{"generatedAt":"2025-12-29T12:23:29.412Z","maxBytes":204800,"entries":[{"path":"app/account/page.tsx","content":"'use client'\n\nimport React, { useState, useEffect } from 'react'\nimport { useSession } from 'next-auth/react'\nimport { useRouter } from 'next/navigation'\nimport Link from 'next/link'\nimport { useUserData } from '@/components/providers/UserDataProvider'\nimport MobileMoreMenu from '@/components/MobileMoreMenu'\nimport PageHeader from '@/components/PageHeader'\n\nexport default function AccountPage() {\n  const { data: session } = useSession()\n  const { userData, profileImage, updateUserData } = useUserData()\n  const [loading, setLoading] = useState(true)\n  const [saveStatus, setSaveStatus] = useState<'idle' | 'saving' | 'saved'>('idle')\n  const [accountData, setAccountData] = useState({\n    fullName: '',\n    email: session?.user?.email || ''\n  })\n  const router = useRouter()\n\n  // Modal states\n  const [showPasswordModal, setShowPasswordModal] = useState(false)\n  const [showDeleteConfirm, setShowDeleteConfirm] = useState(false)\n  const [showExportModal, setShowExportModal] = useState(false)\n  \n  // Password change state\n  const [passwordData, setPasswordData] = useState({\n    currentPassword: '',\n    newPassword: '',\n    confirmPassword: ''\n  })\n  \n  // Password visibility states\n  const [showCurrentPassword, setShowCurrentPassword] = useState(false)\n  const [showNewPassword, setShowNewPassword] = useState(false)\n  const [showConfirmPassword, setShowConfirmPassword] = useState(false)\n  \n  // Delete confirmation state\n  const [deleteConfirmText, setDeleteConfirmText] = useState('')\n  \n  // Loading and feedback states\n  const [isExporting, setIsExporting] = useState(false)\n  const [isDeleting, setIsDeleting] = useState(false)\n\n  useEffect(() => {\n    if (session) {\n      setLoading(false)\n    }\n  }, [session])\n\n  // Load saved data on mount\n  useEffect(() => {\n    const savedAccountData = localStorage.getItem('accountSettings')\n    \n    if (savedAccountData) {\n      try {\n        setAccountData(JSON.parse(savedAccountData))\n      } catch (error) {\n        console.error('Error loading account data:', error)\n      }\n    } else {\n      // Initialize with session data\n      setAccountData({\n        fullName: session?.user?.name || '',\n        email: session?.user?.email || ''\n      })\n    }\n  }, [session])\n\n  // Auto-save when data changes\n  useEffect(() => {\n    if (!accountData.fullName && !accountData.email) return // Don't save empty initial state\n    \n    setSaveStatus('saving')\n    const saveTimer = setTimeout(async () => {\n      try {\n        // TODO: Replace with actual API call to save to database\n        // For now, using localStorage but this should be a proper API call\n        localStorage.setItem('accountSettings', JSON.stringify(accountData))\n        \n        // Simulate API call delay for realistic UX\n        await new Promise(resolve => setTimeout(resolve, 300))\n        \n        setSaveStatus('saved')\n        \n        // Hide saved status after 2 seconds\n        setTimeout(() => {\n          setSaveStatus('idle')\n        }, 2000)\n      } catch (error) {\n        console.error('Error auto-saving account settings:', error)\n        setSaveStatus('idle')\n      }\n    }, 800) // Debounce saves by 800ms for smoother experience\n\n    return () => clearTimeout(saveTimer)\n  }, [accountData]) // Removed twoFactorEnabled since 2FA is no longer used\n\n  return (\n    <div className=\"min-h-screen bg-gray-50\">\n      <PageHeader title=\"Account Settings\" />\n\n      {/* Main Content */}\n      <div className=\"max-w-3xl mx-auto px-4 py-8 pb-24 md:pb-8\">\n        <div className=\"bg-white rounded-lg shadow-sm p-6\">\n          <div className=\"flex items-center justify-between mb-6\">\n            <h2 className=\"text-2xl font-bold text-gray-900\">Account Settings</h2>\n            \n            {/* Save Status Indicator */}\n            <div className=\"flex items-center\">\n              {saveStatus === 'saving' && (\n                <div className=\"flex items-center text-blue-600\">\n                  <div className=\"w-4 h-4 border-2 border-blue-600 border-t-transparent rounded-full animate-spin mr-2\"></div>\n                  <span className=\"text-sm font-medium\">Saving...</span>\n                </div>\n              )}\n              {saveStatus === 'saved' && (\n                <div className=\"flex items-center text-green-600\">\n                  <svg className=\"w-4 h-4 mr-2\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                    <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M5 13l4 4L19 7\" />\n                  </svg>\n                  <span className=\"text-sm font-medium\">Saved</span>\n                </div>\n              )}\n            </div>\n          </div>\n\n          {/* Auto-save Notice */}\n          <div className=\"bg-green-50 border border-green-200 rounded-xl p-4 mb-6\">\n            <div className=\"flex items-center\">\n              <svg className=\"w-5 h-5 text-green-500 mr-3\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M5 13l4 4L19 7\" />\n              </svg>\n              <p className=\"text-green-700 text-sm\">\n                <span className=\"font-medium\">Auto-save enabled:</span> All changes are automatically saved as you type. No save button needed!\n              </p>\n            </div>\n          </div>\n          \n          {/* Account Information */}\n          <div className=\"mb-8\">\n            <h3 className=\"text-lg font-semibold text-gray-900 mb-4\">Account Information</h3>\n            <div className=\"grid grid-cols-1 md:grid-cols-2 gap-6\">\n              <div>\n                <label className=\"block text-sm font-medium text-gray-700 mb-2\">Full Name</label>\n                <input\n                  type=\"text\"\n                  value={accountData.fullName}\n                  onChange={(e) => setAccountData({ ...accountData, fullName: e.target.value })}\n                  className=\"w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-helfi-green focus:border-helfi-green\"\n                  placeholder=\"Enter your full name\"\n                />\n              </div>\n              <div>\n                <label className=\"block text-sm font-medium text-gray-700 mb-2\">Email Address</label>\n                <input\n                  type=\"email\"\n                  value={accountData.email}\n                  onChange={(e) => setAccountData({ ...accountData, email: e.target.value })}\n                  className=\"w-full px-3 py-2 border border-gray-300 rounded-lg bg-gray-50\"\n                  disabled\n                />\n                <p className=\"text-xs text-gray-500 mt-1\">Email cannot be changed</p>\n              </div>\n            </div>\n\n          </div>\n\n          {/* Security Settings */}\n          <div className=\"mb-8\">\n            <h3 className=\"text-lg font-semibold text-gray-900 mb-4\">Security</h3>\n            <div className=\"space-y-4\">\n              <div className=\"p-4 border border-gray-200 rounded-lg\">\n                <div className=\"mb-3\">\n                  <h4 className=\"font-medium text-gray-900\">Password</h4>\n                  <p className=\"text-sm text-gray-600\">Change your account password</p>\n                </div>\n                <button\n                  onClick={() => setShowPasswordModal(true)}\n                  className=\"bg-helfi-green text-white px-4 py-2 rounded-lg hover:bg-helfi-green/90 transition-colors font-medium\"\n                >\n                  Change Password\n                </button>\n              </div>\n\n            </div>\n          </div>\n\n          {/* Account Actions */}\n          <div className=\"mb-8\">\n            <h3 className=\"text-lg font-semibold text-gray-900 mb-4\">Account Actions</h3>\n            <div className=\"space-y-4\">\n              <div className=\"p-4 border border-gray-200 rounded-lg\">\n                <div className=\"mb-3\">\n                  <h4 className=\"font-medium text-gray-900\">Export Data</h4>\n                  <p className=\"text-sm text-gray-600\">Download a copy of your health data</p>\n                </div>\n                <button\n                  onClick={() => setShowExportModal(true)}\n                  className=\"bg-blue-500 text-white px-4 py-2 rounded-lg hover:bg-blue-600 transition-colors font-medium\"\n                >\n                  Export Data\n                </button>\n              </div>\n              <div className=\"p-4 border border-red-200 rounded-lg bg-red-50\">\n                <div className=\"mb-3\">\n                  <h4 className=\"font-medium text-red-900\">Delete Account</h4>\n                  <p className=\"text-sm text-red-700\">Permanently delete your account and all data</p>\n                </div>\n                <button\n                  onClick={() => setShowDeleteConfirm(true)}\n                  className=\"bg-red-500 text-white px-4 py-2 rounded-lg hover:bg-red-600 transition-colors font-medium\"\n                >\n                  Delete Account\n                </button>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n\n      {/* Mobile Bottom Navigation - Inspired by Google, Facebook, Amazon mobile apps */}\n      <nav className=\"md:hidden fixed bottom-0 left-0 right-0 bg-white border-t border-gray-200 px-4 py-2 z-40\">\n        <div className=\"flex items-center justify-around\">\n          \n          {/* Dashboard */}\n          <Link href=\"/dashboard\" className=\"flex flex-col items-center py-2 px-1 min-w-0 flex-1\">\n            <div className=\"text-gray-400\">\n              <svg className=\"w-6 h-6\" fill=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path d=\"M3 13h8V3H3v10zm0 8h8v-6H3v6zm10 0h8V11h-8v10zm0-18v6h8V3h-8z\"/>\n              </svg>\n            </div>\n            <span className=\"text-xs text-gray-400 mt-1 font-medium truncate\">Dashboard</span>\n          </Link>\n\n          {/* Insights (renamed from Health) */}\n          <Link href=\"/health-tracking\" className=\"flex flex-col items-center py-2 px-1 min-w-0 flex-1\">\n            <div className=\"text-gray-400\">\n              <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z\" />\n              </svg>\n            </div>\n            <span className=\"text-xs text-gray-400 mt-1 font-medium truncate\">Insights</span>\n          </Link>\n\n          {/* Food */}\n          <Link href=\"/food\" className=\"flex flex-col items-center py-2 px-1 min-w-0 flex-1\">\n            <div className=\"text-gray-400\">\n              <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10\" />\n              </svg>\n            </div>\n            <span className=\"text-xs text-gray-400 mt-1 font-medium truncate\">Food</span>\n          </Link>\n\n          <MobileMoreMenu />\n\n        </div>\n      </nav>\n      {/* Mobile Bottom Navigation */}\n      <nav className=\"md:hidden fixed bottom-0 left-0 right-0 bg-white dark:bg-gray-800 border-t border-gray-200 dark:border-gray-700 px-4 py-2 z-40\">\n        <div className=\"flex items-center justify-around\">\n          \n          {/* Dashboard */}\n          <Link href=\"/dashboard\" className=\"flex flex-col items-center py-2 px-1 min-w-0 flex-1\">\n            <div className=\"text-gray-400 dark:text-gray-500\">\n              <svg className=\"w-6 h-6\" fill=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path d=\"M3 13h8V3H3v10zm0 8h8v-6H3v6zm10 0h8V11h-8v10zm0-18v6h8V3h-8z\"/>\n              </svg>\n            </div>\n            <span className=\"text-xs text-gray-400 dark:text-gray-500 mt-1 font-medium truncate\">Dashboard</span>\n          </Link>\n\n          {/* Insights */}\n          <Link href=\"/insights\" className=\"flex flex-col items-center py-2 px-1 min-w-0 flex-1\">\n            <div className=\"text-gray-400 dark:text-gray-500\">\n              <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z\" />\n              </svg>\n            </div>\n            <span className=\"text-xs text-gray-400 dark:text-gray-500 mt-1 font-medium truncate\">Insights</span>\n          </Link>\n\n          {/* Food */}\n          <Link href=\"/food\" className=\"flex flex-col items-center py-2 px-1 min-w-0 flex-1\">\n            <div className=\"text-gray-400 dark:text-gray-500\">\n              <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10\" />\n              </svg>\n            </div>\n            <span className=\"text-xs text-gray-400 dark:text-gray-500 mt-1 font-medium truncate\">Food</span>\n          </Link>\n\n          <MobileMoreMenu />\n\n        </div>\n      </nav>\n\n      {/* Password Change Modal */}\n      {showPasswordModal && (\n        <div className=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50\">\n          <div className=\"bg-white rounded-lg p-6 w-full max-w-md mx-4\">\n            <h3 className=\"text-lg font-semibold text-gray-900 mb-4\">Change Password</h3>\n            <div className=\"space-y-4\">\n              <div>\n                <label className=\"block text-sm font-medium text-gray-700 mb-1\">Current Password</label>\n                <div className=\"relative\">\n                  <input\n                    type={showCurrentPassword ? \"text\" : \"password\"}\n                    value={passwordData.currentPassword}\n                    onChange={(e) => setPasswordData({ ...passwordData, currentPassword: e.target.value })}\n                    className=\"w-full px-3 py-2 pr-10 border border-gray-300 rounded-lg focus:ring-helfi-green focus:border-helfi-green\"\n                    placeholder=\"Enter current password\"\n                  />\n                  <button\n                    type=\"button\"\n                    onClick={() => setShowCurrentPassword(!showCurrentPassword)}\n                    className=\"absolute inset-y-0 right-0 flex items-center pr-3 text-gray-400 hover:text-gray-600 transition-colors\"\n                  >\n                    {showCurrentPassword ? (\n                      <svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                        <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.878 9.878L3 3m6.878 6.878L21 21\" />\n                      </svg>\n                    ) : (\n                      <svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                        <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M15 12a3 3 0 11-6 0 3 3 0 016 0z\" />\n                        <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z\" />\n                      </svg>\n                    )}\n                  </button>\n                </div>\n              </div>\n              <div>\n                <label className=\"block text-sm font-medium text-gray-700 mb-1\">New Password</label>\n                <div className=\"relative\">\n                  <input\n                    type={showNewPassword ? \"text\" : \"password\"}\n                    value={passwordData.newPassword}\n                    onChange={(e) => setPasswordData({ ...passwordData, newPassword: e.target.value })}\n                    className=\"w-full px-3 py-2 pr-10 border border-gray-300 rounded-lg focus:ring-helfi-green focus:border-helfi-green\"\n                    placeholder=\"Enter new password\"\n                  />\n                  <button\n                    type=\"button\"\n                    onClick={() => setShowNewPassword(!showNewPassword)}\n                    className=\"absolute inset-y-0 right-0 flex items-center pr-3 text-gray-400 hover:text-gray-600 transition-colors\"\n                  >\n                    {showNewPassword ? (\n                      <svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                        <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.878 9.878L3 3m6.878 6.878L21 21\" />\n                      </svg>\n                    ) : (\n                      <svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                        <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M15 12a3 3 0 11-6 0 3 3 0 016 0z\" />\n                        <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z\" />\n                      </svg>\n                    )}\n                  </button>\n                </div>\n              </div>\n              <div>\n                <label className=\"block text-sm font-medium text-gray-700 mb-1\">Confirm New Password</label>\n                <div className=\"relative\">\n                  <input\n                    type={showConfirmPassword ? \"text\" : \"password\"}\n                    value={passwordData.confirmPassword}\n                    onChange={(e) => setPasswordData({ ...passwordData, confirmPassword: e.target.value })}\n                    className=\"w-full px-3 py-2 pr-10 border border-gray-300 rounded-lg focus:ring-helfi-green focus:border-helfi-green\"\n                    placeholder=\"Confirm new password\"\n                  />\n                  <button\n                    type=\"button\"\n                    onClick={() => setShowConfirmPassword(!showConfirmPassword)}\n                    className=\"absolute inset-y-0 right-0 flex items-center pr-3 text-gray-400 hover:text-gray-600 transition-colors\"\n                  >\n                    {showConfirmPassword ? (\n                      <svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                        <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.878 9.878L3 3m6.878 6.878L21 21\" />\n                      </svg>\n                    ) : (\n                      <svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                        <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M15 12a3 3 0 11-6 0 3 3 0 016 0z\" />\n                        <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z\" />\n                      </svg>\n                    )}\n                  </button>\n                </div>\n              </div>\n            </div>\n            <div className=\"flex justify-end space-x-3 mt-6\">\n              <button\n                onClick={() => {\n                  setShowPasswordModal(false)\n                  setPasswordData({ currentPassword: '', newPassword: '', confirmPassword: '' })\n                }}\n                className=\"px-4 py-2 text-gray-700 border border-gray-300 rounded-lg hover:bg-gray-50\"\n              >\n                Cancel\n              </button>\n              <button\n                onClick={async () => {\n                  // Password change logic here\n                  alert('Password change functionality coming soon!')\n                  setShowPasswordModal(false)\n                  setPasswordData({ currentPassword: '', newPassword: '', confirmPassword: '' })\n                }}\n                className=\"px-4 py-2 bg-helfi-green text-white rounded-lg hover:bg-helfi-green/90\"\n                disabled={!passwordData.currentPassword || !passwordData.newPassword || passwordData.newPassword !== passwordData.confirmPassword}\n              >\n                Change Password\n              </button>\n            </div>\n          </div>\n        </div>\n      )}\n\n      {/* Export Data Modal */}\n      {showExportModal && (\n        <div className=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50\">\n          <div className=\"bg-white rounded-lg p-6 w-full max-w-md mx-4\">\n            <h3 className=\"text-lg font-semibold text-gray-900 mb-4\">Export Your Data</h3>\n            <p className=\"text-gray-600 mb-6\">\n              This will download a JSON file containing all your health data including:\n              ‚Ä¢ Profile information\n              ‚Ä¢ Onboarding responses\n              ‚Ä¢ Food diary entries\n              ‚Ä¢ Health goals and preferences\n            </p>\n            <div className=\"flex justify-end space-x-3\">\n              <button\n                onClick={() => setShowExportModal(false)}\n                className=\"px-4 py-2 text-gray-700 border border-gray-300 rounded-lg hover:bg-gray-50\"\n              >\n                Cancel\n              </button>\n              <button\n                onClick={async () => {\n                  setIsExporting(true)\n                  try {\n                    // Collect all user data\n                    const userData = {\n                      profile: accountData,\n                      exportDate: new Date().toISOString(),\n                      // Add more data sources as needed\n                    }\n                    \n                    // Create and download file\n                    const blob = new Blob([JSON.stringify(userData, null, 2)], { type: 'application/json' })\n                    const url = URL.createObjectURL(blob)\n                    const a = document.createElement('a')\n                    a.href = url\n                    a.download = `helfi-data-export-${new Date().toISOString().split('T')[0]}.json`\n                    document.body.appendChild(a)\n                    a.click()\n                    document.body.removeChild(a)\n                    URL.revokeObjectURL(url)\n                    \n                    setShowExportModal(false)\n                  } catch (error) {\n                    console.error('Export failed:', error)\n                    alert('Export failed. Please try again.')\n                  } finally {\n                    setIsExporting(false)\n                  }\n                }}\n                className=\"px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 disabled:opacity-50\"\n                disabled={isExporting}\n              >\n                {isExporting ? 'Exporting...' : 'Download Data'}\n              </button>\n            </div>\n          </div>\n        </div>\n      )}\n\n      {/* Delete Account Confirmation Modal */}\n      {showDeleteConfirm && (\n        <div className=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50\">\n          <div className=\"bg-white rounded-lg p-6 w-full max-w-md mx-4\">\n            <h3 className=\"text-lg font-semibold text-red-900 mb-4\">Delete Account</h3>\n            <div className=\"mb-4\">\n              <p className=\"text-gray-600 mb-4\">\n                ‚ö†Ô∏è This action is irreversible. All your data will be permanently deleted including:\n              </p>\n              <ul className=\"text-gray-600 text-sm space-y-1 mb-4\">\n                <li>‚Ä¢ Profile information</li>\n                <li>‚Ä¢ Health data and goals</li>\n                <li>‚Ä¢ Food diary entries</li>\n                <li>‚Ä¢ All account settings</li>\n              </ul>\n              <p className=\"text-red-600 font-medium mb-4\">\n                Type \"DELETE\" to confirm account deletion:\n              </p>\n              <input\n                type=\"text\"\n                value={deleteConfirmText}\n                onChange={(e) => setDeleteConfirmText(e.target.value)}\n                className=\"w-full px-3 py-2 border border-red-300 rounded-lg focus:ring-red-500 focus:border-red-500\"\n                placeholder=\"Type DELETE\"\n              />\n            </div>\n            <div className=\"flex justify-end space-x-3\">\n              <button\n                onClick={() => {\n                  setShowDeleteConfirm(false)\n                  setDeleteConfirmText('')\n                }}\n                className=\"px-4 py-2 text-gray-700 border border-gray-300 rounded-lg hover:bg-gray-50\"\n              >\n                Cancel\n              </button>\n              <button\n                onClick={async () => {\n                  if (deleteConfirmText === 'DELETE') {\n                    setIsDeleting(true)\n                    try {\n                      const response = await fetch('/api/account/delete', {\n                        method: 'POST',\n                        headers: {\n                          'Content-Type': 'application/json',\n                        },\n                      })\n\n                      if (!response.ok) {\n                        const error = await response.json()\n                        throw new Error(error.message || 'Failed to delete account')\n                      }\n\n                      // Account deleted successfully - sign out and redirect\n                      setShowDeleteConfirm(false)\n                      setDeleteConfirmText('')\n                      \n                      // Show success message briefly, then sign out and redirect\n                      alert('Your account has been permanently deleted. You will be signed out now.')\n                      \n                      // Sign out and redirect to homepage\n                      // Clear session and redirect\n                      window.location.href = '/api/auth/signout?callbackUrl=/&message=Account deleted successfully'\n                    } catch (error: any) {\n                      console.error('Deletion failed:', error)\n                      alert(error.message || 'Account deletion failed. Please try again.')\n                    } finally {\n                      setIsDeleting(false)\n                    }\n                  }\n                }}\n                className=\"px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 disabled:opacity-50\"\n                disabled={deleteConfirmText !== 'DELETE' || isDeleting}\n              >\n                {isDeleting ? 'Deleting...' : 'Delete Account'}\n              </button>\n            </div>\n          </div>\n        </div>\n      )}\n    </div>\n  )\n} ","truncated":false,"size":27307},{"path":"app/admin-panel/page.tsx","content":"'use client'\n\nimport React, { useState, useEffect, useRef } from 'react'\nimport Image from 'next/image'\nimport { useRouter } from 'next/navigation'\n\nexport default function AdminPanel() {\n  const router = useRouter()\n  const [isAuthenticated, setIsAuthenticated] = useState(false)\n  const [email, setEmail] = useState('')\n  const [password, setPassword] = useState('')\n  const [otp, setOtp] = useState('')\n  const [error, setError] = useState('')\n  const [loading, setLoading] = useState(false)\n  const [showPassword, setShowPassword] = useState(false)\n  const [adminToken, setAdminToken] = useState('')\n  const [adminUser, setAdminUser] = useState<any>(null)\n  const [totpSetupUrl, setTotpSetupUrl] = useState<string | null>(null)\n  const [totpQrData, setTotpQrData] = useState<string | null>(null)\n  const [needsOtp, setNeedsOtp] = useState(false)\n  const [useQrLogin, setUseQrLogin] = useState(true)\n  const [qrLoginToken, setQrLoginToken] = useState<string | null>(null)\n  const [qrLoginUrl, setQrLoginUrl] = useState<string | null>(null)\n  const [qrLoginImage, setQrLoginImage] = useState<string | null>(null)\n  const [qrLoginStatus, setQrLoginStatus] = useState<'idle' | 'loading' | 'pending' | 'approved'>('idle')\n  const [qrLoginError, setQrLoginError] = useState('')\n  const qrLoginIntervalRef = useRef<NodeJS.Timeout | null>(null)\n  \n  // Analytics data states\n  const [analyticsData, setAnalyticsData] = useState<any[]>([])\n  const [analyticsSummary, setAnalyticsSummary] = useState<any>(null)\n  const [aiInsights, setAiInsights] = useState<string>('')\n  const [activeTab, setActiveTab] = useState('overview')\n  const [loadingInsights, setLoadingInsights] = useState(false)\n  const [visionUsage, setVisionUsage] = useState<any>(null)\n  const [visionRecent, setVisionRecent] = useState<any[]>([])\n  const [visionUsageRange, setVisionUsageRange] = useState(7)\n  const [visionUsageUserFilter, setVisionUsageUserFilter] = useState('')\n  const [visionUsageLoading, setVisionUsageLoading] = useState(false)\n  const [visionUsageError, setVisionUsageError] = useState('')\n\n  // Food analysis cost testing (admin)\n  const [foodCostSimRange, setFoodCostSimRange] = useState(7)\n  const [foodCostSim, setFoodCostSim] = useState<any>(null)\n  const [foodCostSimLoading, setFoodCostSimLoading] = useState(false)\n  const [foodCostSimError, setFoodCostSimError] = useState('')\n  const [foodServerUsageRange, setFoodServerUsageRange] = useState(30)\n  const [foodServerUsage, setFoodServerUsage] = useState<any>(null)\n  const [foodServerUsageLoading, setFoodServerUsageLoading] = useState(false)\n  const [foodServerUsageError, setFoodServerUsageError] = useState('')\n  const [serverCallUsageRange, setServerCallUsageRange] = useState(30)\n  const [serverCallUsage, setServerCallUsage] = useState<any>(null)\n  const [serverCallUsageLoading, setServerCallUsageLoading] = useState(false)\n  const [serverCallUsageError, setServerCallUsageError] = useState('')\n  const [vercelWebhookTestLoading, setVercelWebhookTestLoading] = useState(false)\n  const [foodCostEstimatorUsers, setFoodCostEstimatorUsers] = useState(1000)\n  const [foodCostEstimatorAnalysesPerUser, setFoodCostEstimatorAnalysesPerUser] = useState(1)\n  const [foodCostEstimatorCallsPerAnalysis, setFoodCostEstimatorCallsPerAnalysis] = useState(3)\n  const [foodCostEstimatorCostPer1kCalls, setFoodCostEstimatorCostPer1kCalls] = useState(0.00146)\n  const [foodEstimatorAutoCalls, setFoodEstimatorAutoCalls] = useState(true)\n  const [foodBenchmarkImageUrl, setFoodBenchmarkImageUrl] = useState('')\n  const [foodBenchmarkModels, setFoodBenchmarkModels] = useState<Record<string, boolean>>({\n    'gpt-4o': true,\n    'gpt-5.2': true,\n    'gpt-5-mini': false,\n    'gpt-5.2-pro': false,\n  })\n  const [foodBenchmarkResult, setFoodBenchmarkResult] = useState<any>(null)\n  const [foodBenchmarkLoading, setFoodBenchmarkLoading] = useState(false)\n  const [foodBenchmarkError, setFoodBenchmarkError] = useState('')\n\n  // Additional admin data states\n  const [waitlistData, setWaitlistData] = useState<any[]>([])\n  const [partnerOutreachData, setPartnerOutreachData] = useState<any[]>([])\n  const [userStats, setUserStats] = useState<any>(null)\n  const [isLoadingWaitlist, setIsLoadingWaitlist] = useState(false)\n  const [isLoadingPartnerOutreach, setIsLoadingPartnerOutreach] = useState(false)\n  const [isLoadingUsers, setIsLoadingUsers] = useState(false)\n  \n  // User management states\n  const [managedUsers, setManagedUsers] = useState<any[]>([])\n  const [userSearch, setUserSearch] = useState('')\n  const [userFilter, setUserFilter] = useState('all')\n  const [currentPage, setCurrentPage] = useState(1)\n  const [totalPages, setTotalPages] = useState(1)\n  const [isLoadingManagement, setIsLoadingManagement] = useState(false)\n  const [actionInFlight, setActionInFlight] = useState<Record<string, boolean>>({})\n  const actionInFlightRef = useRef<Record<string, boolean>>({})\n\n  // Email functionality states\n  const [selectedEmails, setSelectedEmails] = useState<string[]>([])\n  const [showCustomEmailInterface, setShowCustomEmailInterface] = useState(false)\n  const [customEmailSubject, setCustomEmailSubject] = useState('')\n  const [customEmailMessage, setCustomEmailMessage] = useState('')\n  const [isComposingEmail, setIsComposingEmail] = useState(false)\n\n  // Partner outreach email states\n  const [selectedPartnerEmails, setSelectedPartnerEmails] = useState<string[]>([])\n  const [showPartnerEmailInterface, setShowPartnerEmailInterface] = useState(false)\n  const [partnerEmailSubject, setPartnerEmailSubject] = useState('')\n  const [partnerEmailMessage, setPartnerEmailMessage] = useState('')\n  const [isComposingPartnerEmail, setIsComposingPartnerEmail] = useState(false)\n\n  // User Management Email states\n  const [selectedUserEmails, setSelectedUserEmails] = useState<string[]>([])\n  const [showUserEmailInterface, setShowUserEmailInterface] = useState(false)\n  const [userEmailSubject, setUserEmailSubject] = useState('')\n  const [userEmailMessage, setUserEmailMessage] = useState('')\n  const [isComposingUserEmail, setIsComposingUserEmail] = useState(false)\n  const [emailTemplate, setEmailTemplate] = useState('custom')\n\n  // Template Management states\n  const [emailTemplates, setEmailTemplates] = useState<any[]>([])\n  const [isLoadingTemplates, setIsLoadingTemplates] = useState(false)\n  const [showTemplateForm, setShowTemplateForm] = useState(false)\n  const [editingTemplate, setEditingTemplate] = useState<any>(null)\n  const [templateName, setTemplateName] = useState('')\n  const [templateCategory, setTemplateCategory] = useState('MARKETING')\n  const [templateSubject, setTemplateSubject] = useState('')\n  const [templateContent, setTemplateContent] = useState('')\n  const [isSubmittingTemplate, setIsSubmittingTemplate] = useState(false)\n\n  // Email testing states\n  const [showEmailTest, setShowEmailTest] = useState(false)\n  const [testEmail, setTestEmail] = useState('')\n  const [isTestingEmail, setIsTestingEmail] = useState(false)\n  const [emailTestResult, setEmailTestResult] = useState<any>(null)\n\n  // Support ticket states\n  const [supportTickets, setSupportTickets] = useState<any[]>([])\n  const [isLoadingTickets, setIsLoadingTickets] = useState(false)\n  const [ticketFilter, setTicketFilter] = useState('all')\n  const [ticketsError, setTicketsError] = useState('')\n  const [selectedTicketIds, setSelectedTicketIds] = useState<string[]>([])\n  const [isDeletingTickets, setIsDeletingTickets] = useState(false)\n  const [selectedTicket, setSelectedTicket] = useState<any>(null)\n  const [showTicketModal, setShowTicketModal] = useState(false)\n  const [ticketResponse, setTicketResponse] = useState('')\n  const [isRespondingToTicket, setIsRespondingToTicket] = useState(false)\n\n  // Affiliate program admin states\n  const [affiliateApplications, setAffiliateApplications] = useState<any[]>([])\n  const [affiliateStatusFilter, setAffiliateStatusFilter] = useState('PENDING_REVIEW')\n  const [affiliateLoading, setAffiliateLoading] = useState(false)\n  const [affiliateError, setAffiliateError] = useState('')\n  const [affiliateActionLoading, setAffiliateActionLoading] = useState<Record<string, boolean>>({})\n  const [payoutCurrency, setPayoutCurrency] = useState('usd')\n  const [payoutMinThreshold, setPayoutMinThreshold] = useState(5000)\n  const [payoutDryRun, setPayoutDryRun] = useState(true)\n  const [payoutLoading, setPayoutLoading] = useState(false)\n  const [payoutError, setPayoutError] = useState('')\n  const [payoutResult, setPayoutResult] = useState<any>(null)\n\n  // Admin management states\n  const [showCreateAdminModal, setShowCreateAdminModal] = useState(false)\n  const [showPasswordModal, setShowPasswordModal] = useState(false)\n  const [newAdminEmail, setNewAdminEmail] = useState('')\n  const [newAdminName, setNewAdminName] = useState('')\n  const [newAdminPassword, setNewAdminPassword] = useState('')\n  const [newAdminRole, setNewAdminRole] = useState('ADMIN')\n  const [currentPassword, setCurrentPassword] = useState('')\n  const [newPassword, setNewPassword] = useState('')\n  const [confirmPassword, setConfirmPassword] = useState('')\n  const [adminList, setAdminList] = useState<any[]>([])\n  const [isLoadingAdmins, setIsLoadingAdmins] = useState(false)\n\n  // QR Code and Push Notification states\n  const [qrCodeData, setQrCodeData] = useState<string | null>(null)\n  const [qrCodeUrl, setQrCodeUrl] = useState<string | null>(null)\n  const [isGeneratingQR, setIsGeneratingQR] = useState(false)\n  type PushNotificationState = { subscribed: boolean; loading: boolean; lastUpdated: string | null }\n  const [pushNotificationStatus, setPushNotificationStatus] = useState<PushNotificationState>({\n    subscribed: false,\n    loading: false,\n    lastUpdated: null\n  })\n  const [pushLogs, setPushLogs] = useState<Array<{createdAt: string; event: string; userEmail: string; status: string; info?: string}>>([])\n  const [mobileMenuOpen, setMobileMenuOpen] = useState(false)\n  const [securityStatus, setSecurityStatus] = useState<Array<{ id: string; label: string; status: 'set' | 'missing' }>>([])\n  const [securityStatusLoading, setSecurityStatusLoading] = useState(false)\n  const [securityStatusError, setSecurityStatusError] = useState('')\n\n  // Check for URL hash to set active tab and load data\n  useEffect(() => {\n    const token = sessionStorage.getItem('adminToken') || localStorage.getItem('adminToken')\n    const user = sessionStorage.getItem('adminUser') || localStorage.getItem('adminUser')\n    \n    if (token && user) {\n      sessionStorage.setItem('adminToken', token)\n      sessionStorage.setItem('adminUser', user)\n      setAdminToken(token)\n      setAdminUser(JSON.parse(user))\n      setIsAuthenticated(true)\n      loadAnalyticsData()\n      loadWaitlistData(token)\n      loadUserStats(token)\n      \n      // Check for URL hash or query to set active tab\n      const checkHashAndLoadData = () => {\n        const queryTab = new URLSearchParams(window.location.search).get('tab')\n\n... [truncated] ...\n\n                          <th className=\"text-left px-3 py-2\">Event</th>\n                          <th className=\"text-left px-3 py-2\">Status</th>\n                          <th className=\"text-left px-3 py-2\">Info</th>\n                        </tr>\n                      </thead>\n                      <tbody>\n                        {pushLogs.map((l, i) => (\n                          <tr key={i} className=\"border-t\">\n                            <td className=\"px-3 py-2 text-gray-600\">{new Date(l.createdAt).toLocaleString()}</td>\n                            <td className=\"px-3 py-2\">{l.event}</td>\n                            <td className=\"px-3 py-2\">{l.status}</td>\n                            <td className=\"px-3 py-2 text-gray-500 truncate max-w-[200px]\">{l.info}</td>\n                          </tr>\n                        ))}\n                      </tbody>\n                    </table>\n                  </div>\n                </div>\n              )}\n\n              <div className=\"mt-4 p-4 bg-blue-50 border border-blue-200 rounded-lg\">\n                <p className=\"text-sm text-blue-800\">\n                  <strong>Note:</strong> On iPhone, web push only works when opened from the Home Screen app icon (PWA).\n                  Add to Home Screen and then enable notifications here.\n                </p>\n              </div>\n            </div>\n\n            {/* Vercel Spend Webhook Test */}\n            <div className=\"bg-white rounded-lg shadow p-6\">\n              <h3 className=\"text-lg font-semibold text-gray-900 mb-2\">üì® Vercel Spend Webhook</h3>\n              <p className=\"text-sm text-gray-600 mb-4\">\n                Send a test webhook to confirm the spend alert email is working.\n              </p>\n              <button\n                onClick={sendVercelWebhookTest}\n                disabled={vercelWebhookTestLoading}\n                className=\"bg-emerald-500 text-white px-4 py-2 rounded-lg hover:bg-emerald-600 transition-colors disabled:opacity-50 disabled:cursor-not-allowed\"\n              >\n                {vercelWebhookTestLoading ? 'Sending...' : 'Send Test Webhook'}\n              </button>\n            </div>\n          </div>\n        )}\n\n        {showPasswordModal && (\n          <div className=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50\">\n            <div className=\"bg-white rounded-lg shadow-xl max-w-md w-full mx-4\">\n              <div className=\"px-6 py-4 border-b border-gray-200 flex items-center justify-between\">\n                <h3 className=\"text-lg font-semibold text-gray-900\">Change Admin Password</h3>\n                <button\n                  onClick={() => setShowPasswordModal(false)}\n                  className=\"text-gray-400 hover:text-gray-600\"\n                  aria-label=\"Close\"\n                >\n                  <svg className=\"w-5 h-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                    <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M6 18L18 6M6 6l12 12\" />\n                  </svg>\n                </button>\n              </div>\n              <div className=\"px-6 py-4 space-y-4\">\n                <div>\n                  <label className=\"block text-sm font-medium text-gray-700 mb-2\">\n                    Current Password\n                  </label>\n                  <input\n                    type=\"password\"\n                    value={currentPassword}\n                    onChange={(e) => setCurrentPassword(e.target.value)}\n                    className=\"w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-emerald-500 focus:border-emerald-500\"\n                    placeholder=\"Enter current password\"\n                  />\n                </div>\n                <div>\n                  <label className=\"block text-sm font-medium text-gray-700 mb-2\">\n                    New Password\n                  </label>\n                  <input\n                    type=\"password\"\n                    value={newPassword}\n                    onChange={(e) => setNewPassword(e.target.value)}\n                    className=\"w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-emerald-500 focus:border-emerald-500\"\n                    placeholder=\"Enter new password\"\n                  />\n                </div>\n                <div>\n                  <label className=\"block text-sm font-medium text-gray-700 mb-2\">\n                    Confirm New Password\n                  </label>\n                  <input\n                    type=\"password\"\n                    value={confirmPassword}\n                    onChange={(e) => setConfirmPassword(e.target.value)}\n                    className=\"w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-emerald-500 focus:border-emerald-500\"\n                    placeholder=\"Confirm new password\"\n                  />\n                </div>\n              </div>\n              <div className=\"px-6 py-4 border-t border-gray-200 flex justify-end gap-3\">\n                <button\n                  onClick={() => setShowPasswordModal(false)}\n                  className=\"px-4 py-2 border border-gray-300 text-gray-700 rounded-lg hover:bg-gray-50\"\n                >\n                  Cancel\n                </button>\n                <button\n                  onClick={changePassword}\n                  className=\"px-4 py-2 bg-emerald-500 text-white rounded-lg hover:bg-emerald-600\"\n                >\n                  Update Password\n                </button>\n              </div>\n            </div>\n          </div>\n        )}\n      </div>\n    </div>\n  )\n}\n","truncated":true,"size":278425},{"path":"app/admin-panel/qr-login/page.tsx","content":"'use client'\n\nimport React, { Suspense, useEffect, useState } from 'react'\nimport { useSearchParams } from 'next/navigation'\n\nexport const dynamic = 'force-dynamic'\n\nfunction QRLoginContent() {\n  const searchParams = useSearchParams()\n  const tokenFromUrl = (searchParams.get('token') || '').trim()\n  const [status, setStatus] = useState<'idle' | 'approving' | 'approved' | 'needs-login' | 'error'>('idle')\n  const [error, setError] = useState('')\n  const [email, setEmail] = useState('')\n  const [password, setPassword] = useState('')\n  const [otp, setOtp] = useState('')\n  const [loading, setLoading] = useState(false)\n  const [needsOtp, setNeedsOtp] = useState(false)\n  const [totpSetupUrl, setTotpSetupUrl] = useState<string | null>(null)\n  const [totpQrData, setTotpQrData] = useState<string | null>(null)\n  const [showPassword, setShowPassword] = useState(false)\n\n  const approveLogin = async (adminToken: string) => {\n    if (!tokenFromUrl) return\n    setStatus('approving')\n    setError('')\n    try {\n      const response = await fetch('/api/admin/qr-login/approve', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          Authorization: `Bearer ${adminToken}`\n        },\n        body: JSON.stringify({ token: tokenFromUrl })\n      })\n\n      const data = await response.json().catch(() => ({}))\n      if (!response.ok) {\n        if (response.status === 401) {\n          sessionStorage.removeItem('adminToken')\n          sessionStorage.removeItem('adminUser')\n          try {\n            localStorage.removeItem('adminToken')\n            localStorage.removeItem('adminUser')\n          } catch (storageError) {\n            console.warn('Unable to clear saved admin token', storageError)\n          }\n          setStatus('needs-login')\n          return\n        }\n        setStatus('error')\n        setError(data?.error || 'Unable to approve login. Please try again.')\n        return\n      }\n\n      setStatus('approved')\n    } catch (err) {\n      console.error('QR approve error:', err)\n      setStatus('error')\n      setError('Unable to approve login. Please try again.')\n    }\n  }\n\n  useEffect(() => {\n    if (!tokenFromUrl) {\n      setStatus('error')\n      setError('Missing login token. Please scan the QR code from your desktop.')\n      return\n    }\n\n    const existingToken =\n      sessionStorage.getItem('adminToken') ||\n      (typeof window !== 'undefined' ? localStorage.getItem('adminToken') : null)\n    if (existingToken) {\n      void approveLogin(existingToken)\n    } else {\n      setStatus('needs-login')\n    }\n  }, [tokenFromUrl])\n\n  const handleLogin = async (e: React.FormEvent) => {\n    e.preventDefault()\n    setLoading(true)\n    setError('')\n    setTotpSetupUrl(null)\n    setTotpQrData(null)\n\n    try {\n      const response = await fetch('/api/admin/auth', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          email: email.trim(),\n          password: password.trim(),\n          otp: otp.trim() || undefined,\n        }),\n      })\n\n      const data = await response.json().catch(() => ({}))\n\n      if (data?.setupRequired && data?.otpauthUrl) {\n        setNeedsOtp(true)\n        setError('')\n        setTotpSetupUrl(data.otpauthUrl)\n        try {\n          const QRCode = (await import('qrcode')).default\n          const qrImageData = await QRCode.toDataURL(data.otpauthUrl, {\n            width: 220,\n            margin: 1,\n          })\n          setTotpQrData(qrImageData)\n        } catch (qrError) {\n          console.error('QR setup generation failed:', qrError)\n          setError('Unable to render the setup code. Please refresh and try again.')\n        }\n        setLoading(false)\n        return\n      }\n\n      if (!response.ok) {\n        if (data?.code === 'OTP_REQUIRED') {\n          setNeedsOtp(true)\n          setError('Enter your 6-digit authenticator code to continue.')\n          setLoading(false)\n          return\n        }\n        setError(data?.error || 'Sign-in failed. Please try again.')\n        setLoading(false)\n        return\n      }\n\n      if (!data?.token || !data?.admin) {\n        setError('Sign-in failed. Please try again.')\n        setLoading(false)\n        return\n      }\n\n      sessionStorage.setItem('adminToken', data.token)\n      sessionStorage.setItem('adminUser', JSON.stringify(data.admin))\n      try {\n        localStorage.setItem('adminToken', data.token)\n        localStorage.setItem('adminUser', JSON.stringify(data.admin))\n      } catch (storageError) {\n        console.warn('Unable to persist admin token locally', storageError)\n      }\n      setOtp('')\n      setNeedsOtp(false)\n      setTotpSetupUrl(null)\n      setTotpQrData(null)\n      await approveLogin(data.token)\n      setLoading(false)\n    } catch (loginError) {\n      console.error('Admin login error:', loginError)\n      setError('Sign-in failed. Please try again.')\n      setLoading(false)\n    }\n  }\n\n  return (\n    <div className=\"min-h-screen bg-gray-50 flex items-center justify-center p-4\">\n      <div className=\"max-w-md w-full bg-white rounded-lg shadow-lg p-6\">\n        <h1 className=\"text-2xl font-bold text-center mb-2\">Approve Admin Login</h1>\n        <p className=\"text-sm text-center text-gray-600 mb-6\">\n          Opened from the QR code on your desktop.\n        </p>\n\n        {status === 'approved' && (\n          <div className=\"text-center py-6\">\n            <p className=\"text-lg font-semibold text-gray-800\">Login approved.</p>\n            <p className=\"text-sm text-gray-600 mt-2\">You can return to your desktop now.</p>\n          </div>\n        )}\n\n        {status === 'approving' && (\n          <div className=\"text-center py-6\">\n            <div className=\"inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-gray-900\"></div>\n            <p className=\"mt-3 text-sm text-gray-600\">Approving login...</p>\n          </div>\n        )}\n\n        {status === 'error' && (\n          <div className=\"bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-lg text-sm text-center\">\n            {error}\n          </div>\n        )}\n\n        {status === 'needs-login' && (\n          <form onSubmit={handleLogin} className=\"space-y-6\">\n            <div className=\"bg-gray-50 border border-gray-200 rounded-lg p-4 text-center text-sm text-gray-700\">\n              Sign in to approve this desktop login.\n            </div>\n            <div>\n              <label htmlFor=\"email\" className=\"block text-sm font-medium text-gray-700 mb-2\">\n                Admin Email\n              </label>\n              <input\n                type=\"email\"\n                id=\"email\"\n                value={email}\n                onChange={(e) => setEmail(e.target.value)}\n                className=\"w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-emerald-500 focus:border-emerald-500\"\n                placeholder=\"Enter admin email\"\n                required\n              />\n            </div>\n            <div>\n              <label htmlFor=\"password\" className=\"block text-sm font-medium text-gray-700 mb-2\">\n                Admin Password\n              </label>\n              <div className=\"relative\">\n                <input\n                  type={showPassword ? 'text' : 'password'}\n                  id=\"password\"\n                  value={password}\n                  onChange={(e) => setPassword(e.target.value)}\n                  className=\"w-full px-4 py-3 pr-12 border border-gray-300 rounded-lg focus:ring-2 focus:ring-emerald-500 focus:border-emerald-500\"\n                  placeholder=\"Enter admin password\"\n                  required\n                />\n                <button\n                  type=\"button\"\n                  onClick={() => setShowPassword(!showPassword)}\n                  className=\"absolute inset-y-0 right-0 flex items-center pr-3 text-gray-400 hover:text-gray-600 transition-colors\"\n                >\n                  {showPassword ? (\n                    <svg className=\"w-5 h-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                      <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.878 9.878L3 3m6.878 6.878L21 21\" />\n                    </svg>\n                  ) : (\n                    <svg className=\"w-5 h-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                      <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M15 12a3 3 0 11-6 0 3 3 0 016 0z\" />\n                      <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z\" />\n                    </svg>\n                  )}\n                </button>\n              </div>\n            </div>\n\n            {totpSetupUrl && (\n              <div className=\"bg-emerald-50 border border-emerald-200 rounded-lg p-4 text-center\">\n                <p className=\"text-sm text-emerald-900 font-medium mb-3\">\n                  Scan this setup code with your authenticator app.\n                </p>\n                {totpQrData ? (\n                  <img src={totpQrData} alt=\"Authenticator setup QR\" className=\"mx-auto border border-emerald-200 rounded-lg\" />\n                ) : (\n                  <p className=\"text-xs text-emerald-700\">Loading setup code...</p>\n                )}\n                <p className=\"text-xs text-emerald-700 mt-3\">\n                  After scanning, enter the 6-digit code below to finish setup.\n                </p>\n              </div>\n            )}\n\n            {(needsOtp || totpSetupUrl) && (\n              <div>\n                <label htmlFor=\"otp\" className=\"block text-sm font-medium text-gray-700 mb-2\">\n                  Authenticator Code\n                </label>\n                <input\n                  type=\"text\"\n                  id=\"otp\"\n                  value={otp}\n                  onChange={(e) => setOtp(e.target.value)}\n                  className=\"w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-emerald-500 focus:border-emerald-500\"\n                  placeholder=\"Enter 6-digit code\"\n                  inputMode=\"numeric\"\n                  autoComplete=\"one-time-code\"\n                />\n              </div>\n            )}\n\n            {error && (\n              <div className=\"bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-lg text-sm\">\n                {error}\n              </div>\n            )}\n\n            <button\n              type=\"submit\"\n              disabled={loading}\n              className=\"w-full bg-emerald-500 text-white py-3 px-4 rounded-lg hover:bg-emerald-600 disabled:opacity-50 disabled:cursor-not-allowed transition-colors font-medium\"\n            >\n              {loading ? 'Signing in...' : 'Approve Login'}\n            </button>\n          </form>\n        )}\n      </div>\n    </div>\n  )\n}\n\nexport default function QRLoginPage() {\n  return (\n    <Suspense fallback={\n      <div className=\"min-h-screen bg-gray-50 flex items-center justify-center\">\n        <div className=\"text-center\">\n          <div className=\"inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-gray-900\"></div>\n          <p className=\"mt-2 text-sm text-gray-600\">Loading...</p>\n        </div>\n      </div>\n    }>\n      <QRLoginContent />\n    </Suspense>\n  )\n}\n","truncated":false,"size":11497},{"path":"app/admin-panel/tickets/[id]/page.tsx","content":"'use client'\n\nimport React, { useState, useEffect } from 'react'\nimport { useParams, useRouter } from 'next/navigation'\nimport Image from 'next/image'\n\ninterface TicketResponse {\n  id: string\n  message: string\n  isAdminResponse: boolean\n  createdAt: string\n  admin?: {\n    name: string\n    email: string\n  }\n}\n\ninterface SupportTicket {\n  id: string\n  subject: string\n  message: string\n  userEmail: string\n  userName: string\n  status: string\n  priority: string\n  category: string\n  createdAt: string\n  updatedAt: string\n  responses: TicketResponse[]\n}\n\nexport default function TicketPage() {\n  const params = useParams()\n  const router = useRouter()\n  const ticketId = params.id as string\n  \n  const [ticket, setTicket] = useState<SupportTicket | null>(null)\n  const [isLoading, setIsLoading] = useState(true)\n  const [error, setError] = useState('')\n  const [isAuthenticated, setIsAuthenticated] = useState(false)\n  const [expandedResponses, setExpandedResponses] = useState<Set<string>>(new Set())\n  const [newResponse, setNewResponse] = useState('')\n  const [isSendingResponse, setIsSendingResponse] = useState(false)\n\n  // Load expanded state from localStorage\n  useEffect(() => {\n    if (typeof window !== 'undefined' && ticketId) {\n      const savedState = localStorage.getItem(`ticket-${ticketId}-expanded`)\n      if (savedState) {\n        try {\n          const expandedIds = JSON.parse(savedState)\n          setExpandedResponses(new Set(expandedIds))\n        } catch (error) {\n          console.error('Failed to parse saved expanded state:', error)\n        }\n      }\n    }\n  }, [ticketId])\n\n  // Save expanded state to localStorage whenever it changes\n  useEffect(() => {\n    if (typeof window !== 'undefined' && ticketId) {\n      const expandedIds = Array.from(expandedResponses)\n      if (expandedIds.length > 0) {\n        localStorage.setItem(`ticket-${ticketId}-expanded`, JSON.stringify(expandedIds))\n      } else {\n        // Remove from localStorage if no responses are expanded\n        localStorage.removeItem(`ticket-${ticketId}-expanded`)\n      }\n    }\n  }, [expandedResponses, ticketId])\n\n  // Check authentication\n  useEffect(() => {\n    const token = sessionStorage.getItem('adminToken')\n    if (!token) {\n      router.push('/admin-panel')\n      return\n    }\n    setIsAuthenticated(true)\n    loadTicketData()\n  }, [ticketId, router])\n\n  const loadTicketData = async () => {\n    try {\n      setIsLoading(true)\n      const response = await fetch(`/api/admin/tickets?action=get_ticket&ticketId=${ticketId}`, {\n        headers: {\n          'Authorization': `Bearer ${sessionStorage.getItem('adminToken')}`\n        }\n      })\n      \n      if (!response.ok) {\n        throw new Error('Failed to load ticket data')\n      }\n      \n      const data = await response.json()\n      setTicket(data.ticket)\n      \n      // Fix: Only set initial expanded state if we don't already have responses in state\n      // This prevents loadTicketData from overriding user's collapse preferences\n      if (data.ticket.responses && data.ticket.responses.length > 0) {\n        // Check if we already have expanded state (either from localStorage or previous load)\n        const savedState = localStorage.getItem(`ticket-${ticketId}-expanded`)\n        const hasExistingState = expandedResponses.size > 0 || savedState\n        \n        if (!hasExistingState) {\n          // Only expand all by default on first load with no saved state\n          console.log('First load - expanding all responses by default')\n          const allResponseIds = new Set<string>(data.ticket.responses.map((r: TicketResponse) => r.id))\n          setExpandedResponses(allResponseIds)\n        } else {\n          console.log('Preserving existing expanded state from localStorage or previous load')\n        }\n      }\n      \n      // Pre-fill response with greeting template\n      if (data.ticket && !newResponse) {\n        let customerName = 'there'\n        if (data.ticket.userName && data.ticket.userName.trim()) {\n          if (data.ticket.userName.includes('@')) {\n            customerName = data.ticket.userName.split('@')[0]\n          } else {\n            customerName = data.ticket.userName\n          }\n          customerName = customerName.charAt(0).toUpperCase() + customerName.slice(1).toLowerCase()\n        }\n        \n        const greeting = `Hi ${customerName},\\n\\n`\n        const signature = `\\n\\nWarmest Regards,\\nHelfi Support Team`\n        setNewResponse(greeting + signature)\n      }\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to load ticket')\n    } finally {\n      setIsLoading(false)\n    }\n  }\n\n  const toggleResponseExpansion = (responseId: string) => {\n    const newExpanded = new Set(expandedResponses)\n    if (newExpanded.has(responseId)) {\n      newExpanded.delete(responseId)\n    } else {\n      newExpanded.add(responseId)\n    }\n    setExpandedResponses(newExpanded)\n    \n    // Save to localStorage for persistence\n    if (ticket?.id) {\n      const storageKey = `ticket-${ticket.id}-expanded`\n      localStorage.setItem(storageKey, JSON.stringify(Array.from(newExpanded)))\n    }\n  }\n\n  const handleStatusChange = async (newStatus: string) => {\n    try {\n      const response = await fetch('/api/admin/tickets', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${sessionStorage.getItem('adminToken')}`\n        },\n        body: JSON.stringify({\n          action: 'update_status',\n          ticketId: ticket?.id,\n          status: newStatus\n        })\n      })\n      \n      if (response.ok) {\n        setTicket(prev => prev ? { ...prev, status: newStatus } : null)\n      }\n    } catch (err) {\n      console.error('Failed to update status:', err)\n    }\n  }\n\n  const handleSendResponse = async () => {\n    if (!newResponse.trim() || !ticket) return\n    \n    setIsSendingResponse(true)\n    try {\n      const response = await fetch('/api/admin/tickets', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${sessionStorage.getItem('adminToken')}`\n        },\n        body: JSON.stringify({\n          action: 'add_response',\n          ticketId: ticket.id,\n          message: newResponse.trim()\n        })\n      })\n      \n      if (response.ok) {\n        // Reload ticket data to get updated responses\n        await loadTicketData()\n        setNewResponse('')\n      }\n    } catch (err) {\n      console.error('Failed to send response:', err)\n    } finally {\n      setIsSendingResponse(false)\n    }\n  }\n\n  const getStatusColor = (status: string) => {\n    switch (status) {\n      case 'OPEN': return 'bg-green-100 text-green-800 border-green-200'\n      case 'IN_PROGRESS': return 'bg-yellow-100 text-yellow-800 border-yellow-200'\n      case 'AWAITING_RESPONSE': return 'bg-blue-100 text-blue-800 border-blue-200'\n      case 'RESPONDED': return 'bg-purple-100 text-purple-800 border-purple-200'\n      case 'RESOLVED': return 'bg-gray-100 text-gray-800 border-gray-200'\n      case 'CLOSED': return 'bg-red-100 text-red-800 border-red-200'\n      default: return 'bg-gray-100 text-gray-800 border-gray-200'\n    }\n  }\n\n  const getPriorityColor = (priority: string) => {\n    switch (priority) {\n      case 'LOW': return 'bg-gray-100 text-gray-800 border-gray-200'\n      case 'MEDIUM': return 'bg-blue-100 text-blue-800 border-blue-200'\n      case 'HIGH': return 'bg-orange-100 text-orange-800 border-orange-200'\n      case 'URGENT': return 'bg-red-100 text-red-800 border-red-200'\n      default: return 'bg-gray-100 text-gray-800 border-gray-200'\n    }\n  }\n\n  const formatDate = (dateString: string) => {\n    return new Date(dateString).toLocaleString('en-US', {\n      year: 'numeric',\n      month: 'short',\n      day: 'numeric',\n      hour: '2-digit',\n      minute: '2-digit'\n    })\n  }\n\n  if (!isAuthenticated) {\n    return null\n  }\n\n  if (isLoading) {\n    return (\n      <div className=\"min-h-screen bg-gray-50 flex items-center justify-center\">\n        <div className=\"flex items-center space-x-3\">\n          <div className=\"animate-spin rounded-full h-8 w-8 border-b-2 border-emerald-500\"></div>\n          <span className=\"text-gray-600\">Loading ticket...</span>\n        </div>\n      </div>\n    )\n  }\n\n  if (error || !ticket) {\n    return (\n      <div className=\"min-h-screen bg-gray-50 flex items-center justify-center\">\n        <div className=\"text-center\">\n          <div className=\"bg-red-50 border border-red-200 rounded-lg p-6 max-w-md\">\n            <h2 className=\"text-lg font-semibold text-red-800 mb-2\">Error Loading Ticket</h2>\n            <p className=\"text-red-600 mb-4\">{error || 'Ticket not found'}</p>\n            <button\n              onClick={() => router.push('/admin-panel')}\n              className=\"bg-red-500 text-white px-4 py-2 rounded-lg hover:bg-red-600 transition-colors\"\n            >\n              Back to Admin Panel\n            </button>\n          </div>\n        </div>\n      </div>\n    )\n  }\n\n  return (\n    <div className=\"min-h-screen bg-gray-50\">\n      {/* Header */}\n      <div className=\"bg-white border-b border-gray-200 px-6 py-4\">\n        <div className=\"flex justify-between items-center\">\n          <div className=\"flex items-center space-x-4\">\n            <button\n              onClick={() => {\n                // Use URL hash to indicate which tab should be active\n                router.push('/admin-panel#tickets')\n              }}\n              className=\"flex items-center space-x-2 text-gray-600 hover:text-gray-800 transition-colors\"\n            >\n              <svg className=\"w-5 h-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M10 19l-7-7m0 0l7-7m-7 7h18\" />\n              </svg>\n              <span>Back to Support Tickets</span>\n            </button>\n            <div className=\"h-6 w-px bg-gray-300\"></div>\n            <div className=\"flex items-center space-x-3\">\n              <Image\n                src=\"/mobile-assets/LOGOS/helfi-01-01.png\"\n                alt=\"Helfi Logo\"\n                width={32}\n                height={32}\n              />\n              <div>\n                <h1 className=\"text-xl font-bold text-gray-900\">Support Ticket #{ticket.id.slice(-8)}</h1>\n                <p className=\"text-sm text-gray-600\">{ticket.subject}</p>\n              </div>\n            </div>\n          </div>\n          <div className=\"flex items-center space-x-3\">\n            <span className={`px-3 py-1 rounded-full text-sm font-medium border ${getStatusColor(ticket.status)}`}>\n              {ticket.status.replace('_', ' ')}\n            </span>\n            <span className={`px-3 py-1 rounded-full text-sm font-medium border ${getPriorityColor(ticket.priority)}`}>\n              {ticket.priority}\n            </span>\n          </div>\n        </div>\n      </div>\n\n      <div className=\"max-w-7xl mx-auto px-6 py-8\">\n        <div className=\"grid grid-cols-1 lg:grid-cols-3 gap-8\">\n          {/* Main Content */}\n          <div className=\"lg:col-span-2 space-y-6\">\n            {/* Conversation Thread */}\n            <div className=\"bg-white rounded-lg shadow-sm border border-gray-200\">\n              <div className=\"px-6 py-4 border-b border-gray-200\">\n                <h2 className=\"text-lg font-semibold text-gray-900\">üí¨ Conversation</h2>\n                <p className=\"text-sm text-gray-600 mt-1\">Latest responses appear first</p>\n              </div>\n              \n              <div className=\"p-6 space-y-4\">\n                {/* Response Form - At Top */}\n                <div className=\"bg-emerald-50 border border-emerald-200 rounded-lg p-4\">\n                  <h3 className=\"text-sm font-medium text-emerald-900 mb-3\">üì§ Send New Response</h3>\n                  <textarea\n                    value={newResponse}\n                    onChange={(e) => setNewResponse(e.target.value)}\n                    rows={6}\n                    className=\"w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-emerald-500 focus:border-emerald-500 resize-none\"\n                    placeholder=\"Type your response to the customer...\"\n                  />\n                  <div className=\"flex justify-end space-x-3 mt-3\">\n                    <button\n                      onClick={() => setNewResponse('')}\n                      className=\"px-4 py-2 text-gray-600 hover:text-gray-800 transition-colors\"\n                    >\n                      Clear\n                    </button>\n                    <button\n                      onClick={handleSendResponse}\n                      disabled={isSendingResponse || !newResponse.trim()}\n                      className=\"px-6 py-2 bg-emerald-500 text-white rounded-lg hover:bg-emerald-600 transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center space-x-2\"\n                    >\n                      {isSendingResponse ? (\n                        <>\n                          <div className=\"animate-spin rounded-full h-4 w-4 border-b-2 border-white\"></div>\n                          <span>Sending...</span>\n                        </>\n                      ) : (\n                        <>\n                          <svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                            <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M12 19l9 2-9-18-9 18 9-2zm0 0v-8\" />\n                          </svg>\n                          <span>Send Response</span>\n                        </>\n                      )}\n                    </button>\n                  </div>\n                </div>\n\n                {/* Responses - Latest First */}\n                {ticket.responses && ticket.responses.length > 0 && (\n                  <div className=\"space-y-4\">\n                    {[...ticket.responses].reverse().map((response) => (\n                      <div\n                        key={response.id}\n                        className={`border rounded-lg overflow-hidden ${\n                          response.isAdminResponse \n                            ? 'border-blue-200 bg-blue-50' \n                            : 'border-gray-200 bg-gray-50'\n                        }`}\n                      >\n                        <div \n                          className=\"px-4 py-3 cursor-pointer hover:bg-opacity-80 transition-colors\"\n                          onClick={() => toggleResponseExpansion(response.id)}\n                        >\n                          <div className=\"flex justify-between items-center\">\n                            <div className=\"flex items-center space-x-3\">\n                              <div className={`w-8 h-8 rounded-full flex items-center justify-center text-white font-medium ${\n                                response.isAdminResponse ? 'bg-blue-500' : 'bg-gray-500'\n                              }`}>\n                                {response.isAdminResponse ? 'üõ°Ô∏è' : 'üë§'}\n                              </div>\n                              <div>\n                                <div className=\"font-medium text-gray-900\">\n                                  {response.isAdminResponse \n                                    ? `${response.admin?.name || 'Admin'} (Support Team)`\n                                    : `${ticket.userName || 'Customer'}`}\n                                </div>\n                                <div className=\"text-sm text-gray-600\">\n                                  {formatDate(response.createdAt)}\n                                </div>\n                              </div>\n                            </div>\n                            <div className=\"flex items-center space-x-2\">\n                              <span className={`px-2 py-1 text-xs font-medium rounded ${\n                                response.isAdminResponse \n                                  ? 'bg-blue-100 text-blue-800' \n                                  : 'bg-gray-100 text-gray-800'\n                              }`}>\n                                {response.isAdminResponse ? 'Admin Reply' : 'Customer'}\n                              </span>\n                              <svg \n                                className={`w-4 h-4 text-gray-400 transition-transform ${\n                                  expandedResponses.has(response.id) ? 'rotate-180' : ''\n                                }`} \n                                fill=\"none\" \n                                stroke=\"currentColor\" \n                                viewBox=\"0 0 24 24\"\n                              >\n                                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M19 9l-7 7-7-7\" />\n                              </svg>\n                            </div>\n                          </div>\n                        </div>\n                        \n                        {expandedResponses.has(response.id) && (\n                          <div className=\"px-4 pb-4 border-t border-gray-200 bg-white\">\n                            <div className=\"pt-3\">\n                              <p className=\"text-gray-700 whitespace-pre-wrap leading-relaxed\">\n                                {response.message}\n                              </p>\n                            </div>\n                          </div>\n                        )}\n                      </div>\n                    ))}\n                  </div>\n                )}\n\n                {/* Original Message - At Bottom */}\n                <div className=\"border border-orange-200 bg-orange-50 rounded-lg p-4\">\n                  <div className=\"flex items-center space-x-2 mb-3\">\n                    <svg className=\"w-5 h-5 text-orange-600\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                      <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z\" />\n                    </svg>\n                    <h3 className=\"text-sm font-medium text-orange-900\">Original Message</h3>\n                    <span className=\"text-xs text-orange-600\">({formatDate(ticket.createdAt)})</span>\n                  </div>\n                  <p className=\"text-gray-700 whitespace-pre-wrap leading-relaxed\">\n                    {ticket.message}\n                  </p>\n                </div>\n              </div>\n            </div>\n          </div>\n\n          {/* Sidebar */}\n          <div className=\"space-y-6\">\n            {/* Customer Info */}\n            <div className=\"bg-white rounded-lg shadow-sm border border-gray-200\">\n              <div className=\"px-6 py-4 border-b border-gray-200\">\n                <h3 className=\"text-lg font-semibold text-gray-900\">üë§ Customer Information</h3>\n              </div>\n              <div className=\"p-6 space-y-4\">\n                <div className=\"flex items-center space-x-3\">\n                  <div className=\"w-12 h-12 bg-emerald-100 rounded-full flex items-center justify-center\">\n                    <span className=\"text-emerald-600 font-semibold text-lg\">\n                      {ticket.userName ? ticket.userName.charAt(0).toUpperCase() : ticket.userEmail.charAt(0).toUpperCase()}\n                    </span>\n                  </div>\n                  <div>\n                    <div className=\"font-medium text-gray-900\">\n                      {ticket.userName || 'Unknown User'}\n                    </div>\n                    <div className=\"text-sm text-gray-600\">\n                      {ticket.userEmail}\n                    </div>\n                  </div>\n                </div>\n                \n                <div className=\"pt-4 border-t border-gray-200\">\n                  <div className=\"space-y-3\">\n                    <div className=\"flex justify-between\">\n                      <span className=\"text-sm text-gray-600\">Category:</span>\n                      <span className=\"text-sm font-medium text-gray-900\">{ticket.category}</span>\n                    </div>\n                    <div className=\"flex justify-between\">\n                      <span className=\"text-sm text-gray-600\">Created:</span>\n                      <span className=\"text-sm font-medium text-gray-900\">{formatDate(ticket.createdAt)}</span>\n                    </div>\n                    <div className=\"flex justify-between\">\n                      <span className=\"text-sm text-gray-600\">Last Update:</span>\n                      <span className=\"text-sm font-medium text-gray-900\">{formatDate(ticket.updatedAt)}</span>\n                    </div>\n                  </div>\n                </div>\n              </div>\n            </div>\n\n            {/* Ticket Management */}\n            <div className=\"bg-white rounded-lg shadow-sm border border-gray-200\">\n              <div className=\"px-6 py-4 border-b border-gray-200\">\n                <h3 className=\"text-lg font-semibold text-gray-900\">‚öôÔ∏è Ticket Management</h3>\n              </div>\n              <div className=\"p-6 space-y-4\">\n                <div>\n                  <label className=\"block text-sm font-medium text-gray-700 mb-2\">\n                    Status\n                  </label>\n                  <select\n                    value={ticket.status}\n                    onChange={(e) => handleStatusChange(e.target.value)}\n                    className=\"w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-emerald-500 focus:border-emerald-500\"\n                  >\n                    <option value=\"OPEN\">Open</option>\n                    <option value=\"IN_PROGRESS\">In Progress</option>\n                    <option value=\"AWAITING_RESPONSE\">Awaiting Response</option>\n                    <option value=\"RESPONDED\">Responded</option>\n                    <option value=\"RESOLVED\">Resolved</option>\n                    <option value=\"CLOSED\">Closed</option>\n                  </select>\n                </div>\n                \n                <div>\n                  <label className=\"block text-sm font-medium text-gray-700 mb-2\">\n                    Priority\n                  </label>\n                  <div className={`px-3 py-2 rounded-lg border ${getPriorityColor(ticket.priority)}`}>\n                    {ticket.priority}\n                  </div>\n                </div>\n                \n                <div className=\"pt-4 border-t border-gray-200\">\n                  <button\n                    onClick={() => {\n                      if (confirm(`Are you sure you want to permanently delete this ticket? This action cannot be undone.`)) {\n                        // Handle delete logic here\n                        console.log('Delete ticket:', ticket.id)\n                      }\n                    }}\n                    className=\"w-full bg-red-500 text-white px-4 py-2 rounded-lg hover:bg-red-600 transition-colors\"\n                  >\n                    üóëÔ∏è Delete Ticket\n                  </button>\n                </div>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  )\n} ","truncated":false,"size":23131},{"path":"app/admin-panel/user/[userId]/page.tsx","content":"'use client'\n\nimport React, { useCallback, useEffect, useMemo, useState } from 'react'\nimport { useParams, useRouter } from 'next/navigation'\n\ntype AdminUser = {\n  id: string\n  email: string\n  name?: string | null\n  createdAt: string\n  dailyAnalysisCredits?: number | null\n  dailyAnalysisUsed?: number | null\n  additionalCredits?: number | null\n  totalAvailableCredits?: number | null\n  totalAnalysisCount?: number | null\n  dailyFoodAnalysisUsed?: number | null\n  dailyFoodReanalysisUsed?: number | null\n  dailyInteractionAnalysisUsed?: number | null\n  monthlyMedicalImageAnalysisUsed?: number | null\n  monthlySymptomAnalysisUsed?: number | null\n  monthlyInsightsGenerationUsed?: number | null\n  lastAnalysisResetDate?: string | null\n  subscription?: {\n    plan?: string | null\n    monthlyPriceCents?: number | null\n    startDate?: string | null\n    endDate?: string | null\n  } | null\n}\n\nexport default function AdminUserPage() {\n  const router = useRouter()\n  const params = useParams()\n  const userId = params.userId as string\n  const [adminToken, setAdminToken] = useState('')\n  const [user, setUser] = useState<AdminUser | null>(null)\n  const [loading, setLoading] = useState(true)\n  const [error, setError] = useState('')\n  const [actionInFlight, setActionInFlight] = useState<Record<string, boolean>>({})\n\n  useEffect(() => {\n    const storedToken = sessionStorage.getItem('adminToken') || ''\n    setAdminToken(storedToken)\n  }, [])\n\n  const loadUser = useCallback(async () => {\n    if (!adminToken || !userId) return\n    setLoading(true)\n    setError('')\n    try {\n      const params = new URLSearchParams({\n        userId,\n        page: '1',\n        limit: '1',\n      })\n      const response = await fetch(`/api/admin/user-management?${params.toString()}`, {\n        headers: { Authorization: `Bearer ${adminToken}` },\n      })\n      if (response.ok) {\n        const result = await response.json()\n        setUser(result.users?.[0] || null)\n        if (!result.users?.length) {\n          setError('User not found. Try returning to the users list and selecting again.')\n        }\n      } else if (response.status === 401) {\n        setError('Admin login is required to view this user.')\n      } else {\n        setError('Unable to load this user right now.')\n      }\n    } catch (err) {\n      console.error('Failed to load user:', err)\n      setError('Unable to load this user right now.')\n    } finally {\n      setLoading(false)\n    }\n  }, [adminToken, userId])\n\n  useEffect(() => {\n    if (adminToken) {\n      loadUser()\n    } else {\n      setLoading(false)\n    }\n  }, [adminToken, loadUser])\n\n  const handleUserAction = async (action: string, data?: any) => {\n    if (!user) return\n    const key = `${action}:${user.id}`\n    if (actionInFlight[key]) return\n    setActionInFlight((prev) => ({ ...prev, [key]: true }))\n    try {\n      const response = await fetch('/api/admin/user-management', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          Authorization: `Bearer ${adminToken}`,\n        },\n        body: JSON.stringify({ action, userId: user.id, data }),\n      })\n      const result = await response.json()\n      if (response.ok) {\n        await loadUser()\n        if (action === 'refund_latest_payment') {\n          const amountCents = typeof result?.refundedAmountCents === 'number' ? result.refundedAmountCents : null\n          const currency = typeof result?.currency === 'string' ? result.currency.toUpperCase() : 'AUD'\n          const amountText = amountCents != null ? `${currency} ${(amountCents / 100).toFixed(2)}` : 'the payment'\n          alert(`Refund started for ${amountText}. Access and credits will be removed automatically.`)\n        } else {\n          const successMessage = result?.message || `User ${action} completed successfully`\n          alert(successMessage)\n        }\n      } else {\n        const errorMessage = result.error || 'Action failed. Please try again.'\n        alert(`Action failed: ${errorMessage}`)\n      }\n    } catch (err) {\n      console.error('Failed to run user action:', err)\n      alert('Action failed. Please try again.')\n    } finally {\n      setActionInFlight((prev) => {\n        const next = { ...prev }\n        delete next[key]\n        return next\n      })\n    }\n  }\n\n  const planLabel = useMemo(() => {\n    if (!user?.subscription?.plan || user.subscription.plan !== 'PREMIUM') {\n      return 'No Subscription'\n    }\n    const price = user.subscription.monthlyPriceCents || 0\n    if (user.subscription.endDate) {\n      const endDate = new Date(user.subscription.endDate)\n      const startDate = new Date(user.subscription.startDate || user.createdAt)\n      const totalDays = Math.ceil((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24))\n      const credits = Math.floor(price * 0.5)\n      if (totalDays > 90) return `Permanent (${credits} credits/month)`\n      return `${totalDays}-Day Access (${credits} credits)`\n    }\n    if (price === 1000) return '$10/month (700 credits)'\n    if (price === 2000) return '$20/month (1,400 credits)'\n    if (price === 3000) return '$30/month (2,100 credits)'\n    if (price === 5000) return '$50/month (3,500 credits)'\n    return `$${Math.round(price / 100)}/month`\n  }, [user])\n\n  const accessLabel = useMemo(() => {\n    if (!user?.subscription) return 'No Subscription'\n    if (user.subscription.endDate) {\n      const endDate = new Date(user.subscription.endDate)\n      return endDate.getFullYear() > 2050\n        ? 'Permanent Access'\n        : `Expires ${endDate.toLocaleDateString()}`\n    }\n    return 'Active Premium Subscription'\n  }, [user])\n\n  const nextRenewal = useMemo(() => {\n    if (!user?.subscription?.startDate || user.subscription.endDate) return null\n    const startDate = new Date(user.subscription.startDate)\n    const now = new Date()\n    const startYear = startDate.getUTCFullYear()\n    const startMonth = startDate.getUTCMonth()\n    const startDay = startDate.getUTCDate()\n    const currentYear = now.getUTCFullYear()\n    const currentMonth = now.getUTCMonth()\n    const currentDay = now.getUTCDate()\n    let monthsSinceStart = (currentYear - startYear) * 12 + (currentMonth - startMonth)\n    if (currentDay < startDay) monthsSinceStart--\n    const nextRenewalDate = new Date(Date.UTC(startYear, startMonth + monthsSinceStart + 1, startDay, 0, 0, 0, 0))\n    return nextRenewalDate.toLocaleDateString()\n  }, [user])\n\n  if (!adminToken && !loading) {\n    return (\n      <div className=\"min-h-screen bg-slate-50 flex items-center justify-center p-6\">\n        <div className=\"bg-white border border-slate-200 rounded-2xl p-8 shadow-sm text-center max-w-lg\">\n          <h1 className=\"text-xl font-semibold text-slate-900 mb-2\">Admin login required</h1>\n          <p className=\"text-slate-600 mb-6\">\n            Please sign in to the admin panel before managing user accounts.\n          </p>\n          <button\n            onClick={() => router.push('/admin-panel')}\n            className=\"bg-emerald-600 text-white px-5 py-2 rounded-lg hover:bg-emerald-700 transition-colors\"\n          >\n            Go to Admin Login\n          </button>\n        </div>\n      </div>\n    )\n  }\n\n  return (\n    <div className=\"min-h-screen bg-slate-50\">\n      <div className=\"max-w-6xl mx-auto px-6 py-8\">\n        <div className=\"flex flex-wrap items-center justify-between gap-4\">\n          <button\n            onClick={() => router.push('/admin-panel?tab=management')}\n            className=\"text-sm text-slate-600 hover:text-slate-900 transition-colors flex items-center gap-2\"\n          >\n            <span className=\"text-lg\">‚Üê</span>\n            Back to Users\n          </button>\n          <button\n            onClick={() => loadUser()}\n            className=\"bg-white border border-slate-200 text-slate-700 px-4 py-2 rounded-lg hover:border-slate-300 hover:text-slate-900 transition-colors\"\n          >\n            Refresh\n          </button>\n        </div>\n\n        {loading ? (\n          <div className=\"mt-10 text-slate-500\">Loading user details‚Ä¶</div>\n        ) : error ? (\n          <div className=\"mt-10 bg-white border border-rose-200 text-rose-700 rounded-xl p-6\">\n            {error}\n          </div>\n        ) : user ? (\n          <>\n            <div className=\"mt-6 bg-white border border-slate-200 rounded-2xl shadow-sm p-6\">\n              <div className=\"flex flex-wrap items-start justify-between gap-6\">\n                <div>\n                  <h1 className=\"text-2xl font-semibold text-slate-900\">\n                    {user.name || user.email}\n                  </h1>\n                  <p className=\"text-slate-500\">{user.email}</p>\n                </div>\n                <div className=\"flex flex-wrap gap-2\">\n                  <span className={`px-3 py-1 rounded-full text-xs font-semibold ${\n                    user.subscription?.plan === 'PREMIUM' ? 'bg-emerald-100 text-emerald-700' : 'bg-slate-100 text-slate-600'\n                  }`}>\n                    {user.subscription?.plan === 'PREMIUM' ? 'Premium' : 'Free'}\n                  </span>\n                  {user.subscription?.endDate && new Date(user.subscription.endDate).getFullYear() > 2050 && (\n                    <span className=\"px-3 py-1 rounded-full text-xs font-semibold bg-amber-100 text-amber-700\">\n                      Permanent\n                    </span>\n                  )}\n                  {user.subscription?.plan === 'PREMIUM' && !user.subscription?.endDate && (\n                    <span className=\"px-3 py-1 rounded-full text-xs font-semibold bg-blue-100 text-blue-700\">\n                      Paid\n                    </span>\n                  )}\n                </div>\n              </div>\n\n              <div className=\"mt-6 grid gap-4 md:grid-cols-4\">\n                <div className=\"bg-slate-50 rounded-xl p-4\">\n                  <div className=\"text-xs text-slate-500\">Plan</div>\n                  <div className=\"text-sm font-semibold text-slate-900\">{planLabel}</div>\n                </div>\n                <div className=\"bg-slate-50 rounded-xl p-4\">\n                  <div className=\"text-xs text-slate-500\">Access</div>\n                  <div className=\"text-sm font-semibold text-slate-900\">{accessLabel}</div>\n                </div>\n                <div className=\"bg-slate-50 rounded-xl p-4\">\n                  <div className=\"text-xs text-slate-500\">Member Since</div>\n                  <div className=\"text-sm font-semibold text-slate-900\">\n                    {new Date(user.createdAt).toLocaleDateString()}\n                  </div>\n                </div>\n                <div className=\"bg-slate-50 rounded-xl p-4\">\n                  <div className=\"text-xs text-slate-500\">Next Renewal</div>\n                  <div className=\"text-sm font-semibold text-slate-900\">\n                    {nextRenewal || '‚Äî'}\n                  </div>\n                </div>\n              </div>\n            </div>\n\n            <div className=\"mt-6 grid gap-6 lg:grid-cols-3\">\n              <div className=\"lg:col-span-2 space-y-6\">\n                <div className=\"bg-white border border-slate-200 rounded-2xl shadow-sm p-6\">\n                  <div className=\"flex items-center justify-between mb-4\">\n                    <h2 className=\"text-lg font-semibold text-slate-900\">Credits & Usage</h2>\n                    <span className=\"text-xs text-slate-500\">Total available credits</span>\n                  </div>\n                  <div className=\"flex items-baseline gap-2 mb-6\">\n                    <div className=\"text-3xl font-semibold text-emerald-600\">\n                      {user.totalAvailableCredits !== undefined\n                        ? user.totalAvailableCredits\n                        : (user.additionalCredits || 0)}\n                    </div>\n                    <div className=\"text-sm text-slate-500\">credits</div>\n                  </div>\n                  <div className=\"grid gap-4 md:grid-cols-3\">\n                    <div className=\"bg-slate-50 rounded-xl p-4\">\n                      <div className=\"text-xs text-slate-500\">Daily usage</div>\n                      <div className=\"text-sm font-semibold text-slate-900\">\n                        {user.dailyAnalysisUsed || 0}/{user.dailyAnalysisCredits || 3}\n                      </div>\n                    </div>\n                    <div className=\"bg-slate-50 rounded-xl p-4\">\n                      <div className=\"text-xs text-slate-500\">Total analyses</div>\n                      <div className=\"text-sm font-semibold text-slate-900\">{user.totalAnalysisCount || 0}</div>\n                    </div>\n                    <div className=\"bg-slate-50 rounded-xl p-4\">\n                      <div className=\"text-xs text-slate-500\">Last reset</div>\n                      <div className=\"text-sm font-semibold text-slate-900\">\n                        {user.lastAnalysisResetDate\n                          ? new Date(user.lastAnalysisResetDate).toLocaleDateString()\n                          : '‚Äî'}\n                      </div>\n                    </div>\n                  </div>\n\n                  <div className=\"mt-6\">\n                    <div className=\"text-xs text-slate-500 mb-3\">Monthly feature usage</div>\n                    <div className=\"grid gap-3 md:grid-cols-2 text-sm\">\n                      <div className=\"flex justify-between bg-slate-50 rounded-lg px-3 py-2\">\n                        <span>Food analysis</span>\n                        <span className=\"font-semibold\">{user.dailyFoodAnalysisUsed || 0}</span>\n                      </div>\n                      <div className=\"flex justify-between bg-slate-50 rounded-lg px-3 py-2\">\n                        <span>Food reanalysis</span>\n                        <span className=\"font-semibold\">{user.dailyFoodReanalysisUsed || 0}</span>\n                      </div>\n                      <div className=\"flex justify-between bg-slate-50 rounded-lg px-3 py-2\">\n                        <span>Medical image</span>\n                        <span className=\"font-semibold\">{user.monthlyMedicalImageAnalysisUsed || 0}</span>\n                      </div>\n                      <div className=\"flex justify-between bg-slate-50 rounded-lg px-3 py-2\">\n                        <span>Interaction analysis</span>\n                        <span className=\"font-semibold\">{user.dailyInteractionAnalysisUsed || 0}</span>\n                      </div>\n                      <div className=\"flex justify-between bg-slate-50 rounded-lg px-3 py-2\">\n                        <span>Symptom analysis</span>\n                        <span className=\"font-semibold\">{user.monthlySymptomAnalysisUsed || 0}</span>\n                      </div>\n                      <div className=\"flex justify-between bg-slate-50 rounded-lg px-3 py-2\">\n                        <span>Insights generation</span>\n                        <span className=\"font-semibold\">{user.monthlyInsightsGenerationUsed || 0}</span>\n                      </div>\n                    </div>\n                  </div>\n\n                  <div className=\"mt-6 flex flex-wrap gap-2\">\n                    <button\n                      onClick={() => {\n                        const credits = prompt('Enter number of credits to add:')\n                        if (credits && !isNaN(parseInt(credits)) && parseInt(credits) > 0) {\n                          handleUserAction('add_credits', { creditAmount: parseInt(credits) })\n                        }\n                      }}\n                      className=\"bg-emerald-500 text-white px-4 py-2 rounded-lg text-sm hover:bg-emerald-600 transition-colors\"\n                    >\n                      Add credits\n                    </button>\n                    <button\n                      onClick={() => {\n                        const credits = prompt('Enter number of credits to remove:')\n                        if (credits && !isNaN(parseInt(credits)) && parseInt(credits) > 0) {\n                          if (confirm(`Are you sure you want to remove ${credits} credits?`)) {\n                            handleUserAction('remove_credits', { creditAmount: parseInt(credits) })\n                          }\n                        }\n                      }}\n                      className=\"bg-rose-500 text-white px-4 py-2 rounded-lg text-sm hover:bg-rose-600 transition-colors\"\n                    >\n                      Remove credits\n                    </button>\n                    <button\n                      onClick={() => {\n                        if (confirm('Reset daily quota for this user?')) {\n                          handleUserAction('reset_daily_quota')\n                        }\n                      }}\n                      className=\"bg-slate-900 text-white px-4 py-2 rounded-lg text-sm hover:bg-slate-800 transition-colors\"\n                    >\n                      Reset daily quota\n                    </button>\n                  </div>\n                </div>\n\n                <div className=\"bg-white border border-slate-200 rounded-2xl shadow-sm p-6\">\n                  <h2 className=\"text-lg font-semibold text-slate-900 mb-4\">Grant subscription access</h2>\n                  <div className=\"grid gap-3 md:grid-cols-4\">\n                    <button\n                      onClick={() => handleUserAction('grant_subscription', { tier: '10' })}\n                      className=\"bg-emerald-100 text-emerald-700 px-4 py-3 rounded-xl text-sm font-semibold hover:bg-emerald-200 transition-colors\"\n                    >\n                      $10/month\n                      <div className=\"text-xs font-normal\">700 credits</div>\n                    </button>\n                    <button\n                      onClick={() => handleUserAction('grant_subscription', { tier: '20' })}\n                      className=\"bg-emerald-200 text-emerald-800 px-4 py-3 rounded-xl text-sm font-semibold hover:bg-emerald-300 transition-colors\"\n                    >\n                      $20/month\n                      <div className=\"text-xs font-normal\">1,400 credits</div>\n                    </button>\n                    <button\n                      onClick={() => handleUserAction('grant_subscription', { tier: '30' })}\n                      className=\"bg-emerald-300 text-emerald-900 px-4 py-3 rounded-xl text-sm font-semibold hover:bg-emerald-400 transition-colors\"\n                    >\n                      $30/month\n                      <div className=\"text-xs font-normal\">2,100 credits</div>\n                    </button>\n                    <button\n                      onClick={() => handleUserAction('grant_subscription', { tier: '50' })}\n                      className=\"bg-slate-900 text-white px-4 py-3 rounded-xl text-sm font-semibold hover:bg-slate-800 transition-colors\"\n                    >\n                      $50/month\n                      <div className=\"text-xs font-normal text-slate-200\">3,500 credits</div>\n                    </button>\n                  </div>\n\n                  <div className=\"mt-6\">\n                    <h3 className=\"text-sm font-semibold text-slate-700 mb-3\">Temporary access</h3>\n                    <div className=\"grid gap-3 md:grid-cols-2\">\n                      <button\n                        onClick={() => handleUserAction('grant_trial', { trialDays: 7 })}\n                        className=\"bg-blue-100 text-blue-700 px-4 py-3 rounded-xl text-sm font-semibold hover:bg-blue-200 transition-colors\"\n                      >\n                        7-day premium\n                        <div className=\"text-xs font-normal\">250 credits</div>\n                      </button>\n                      <button\n                        onClick={() => handleUserAction('grant_trial', { trialDays: 30 })}\n                        className=\"bg-blue-100 text-blue-700 px-4 py-3 rounded-xl text-sm font-semibold hover:bg-blue-200 transition-colors\"\n                      >\n                        30-day premium\n                        <div className=\"text-xs font-normal\">1,400 credits</div>\n                      </button>\n                    </div>\n                  </div>\n\n                  <div className=\"mt-6\">\n                    <h3 className=\"text-sm font-semibold text-slate-700 mb-3\">Quick credit packages</h3>\n                    <div className=\"grid gap-3 md:grid-cols-3\">\n                      <button\n                        onClick={() => handleUserAction('add_credits', { creditPackage: '250' })}\n                        className=\"bg-purple-100 text-purple-700 px-4 py-3 rounded-xl text-sm font-semibold hover:bg-purple-200 transition-colors\"\n                      >\n                        250 credits\n                        <div className=\"text-xs font-normal\">$5</div>\n                      </button>\n                      <button\n                        onClick={() => handleUserAction('add_credits', { creditPackage: '500' })}\n                        className=\"bg-purple-100 text-purple-700 px-4 py-3 rounded-xl text-sm font-semibold hover:bg-purple-200 transition-colors\"\n                      >\n                        500 credits\n                        <div className=\"text-xs font-normal\">$10</div>\n                      </button>\n                      <button\n                        onClick={() => handleUserAction('add_credits', { creditPackage: '1000' })}\n                        className=\"bg-purple-100 text-purple-700 px-4 py-3 rounded-xl text-sm font-semibold hover:bg-purple-200 transition-colors\"\n                      >\n                        1,000 credits\n                        <div className=\"text-xs font-normal\">$20</div>\n                      </button>\n                    </div>\n                  </div>\n                </div>\n              </div>\n\n              <div className=\"space-y-6\">\n                <div className=\"bg-white border border-slate-200 rounded-2xl shadow-sm p-6\">\n                  <h2 className=\"text-lg font-semibold text-slate-900 mb-3\">Plan controls</h2>\n                  <div className=\"space-y-3\">\n                    {user.subscription?.plan === 'PREMIUM' ? (\n                      <button\n                        onClick={() => handleUserAction('deactivate')}\n                        className=\"w-full bg-amber-500 text-white px-4 py-2 rounded-lg text-sm hover:bg-amber-600 transition-colors\"\n                      >\n                        Remove subscription\n                      </button>\n                    ) : (\n                      <button\n                        onClick={() => handleUserAction('activate')}\n                        className=\"w-full bg-emerald-600 text-white px-4 py-2 rounded-lg text-sm hover:bg-emerald-700 transition-colors\"\n                      >\n                        Upgrade to premium\n                      </button>\n                    )}\n                    <button\n                      onClick={() => {\n                        if (confirm('Are you sure you want to delete this user? This action cannot be undone.')) {\n                          handleUserAction('delete_user')\n                        }\n                      }}\n                      className=\"w-full bg-rose-600 text-white px-4 py-2 rounded-lg text-sm hover:bg-rose-700 transition-colors\"\n                    >\n                      Delete user\n                    </button>\n                  </div>\n                </div>\n\n                <div className=\"bg-white border border-slate-200 rounded-2xl shadow-sm p-6\">\n                  <h2 className=\"text-lg font-semibold text-slate-900 mb-3\">Refunds</h2>\n                  <p className=\"text-sm text-slate-600 mb-4\">\n                    Refund the most recent payment. Access and credits are removed automatically.\n                  </p>\n                  <button\n                    onClick={() => {\n                      const raw = prompt('Refund amount in dollars (leave blank for full refund):')\n                      if (raw === null) return\n                      const trimmed = raw.trim()\n                      let amountCents: number | null = null\n                      if (trimmed) {\n                        const parsed = Number(trimmed)\n                        if (!Number.isFinite(parsed) || parsed <= 0) {\n                          alert('Please enter a valid amount.')\n                          return\n                        }\n                        amountCents = Math.round(parsed * 100)\n                      }\n                      const amountLabel = amountCents ? `$${(amountCents / 100).toFixed(2)}` : 'the full amount'\n                      if (confirm(`Refund ${amountLabel} from the most recent payment for ${user.email}?`)) {\n                        handleUserAction('refund_latest_payment', { amountCents })\n                      }\n                    }}\n                    className=\"w-full bg-amber-500 text-white px-4 py-2 rounded-lg text-sm hover:bg-amber-600 transition-colors\"\n                  >\n                    Refund latest payment\n                  </button>\n                </div>\n\n                <div className=\"bg-white border border-slate-200 rounded-2xl shadow-sm p-6\">\n                  <h2 className=\"text-lg font-semibold text-slate-900 mb-3\">Account security</h2>\n                  <p className=\"text-sm text-slate-600 mb-4\">\n                    Log this user out everywhere if their device is lost or they can‚Äôt log out.\n                  </p>\n                  <button\n                    onClick={() => {\n                      if (confirm(`Log ${user.email} out of all devices now?`)) {\n                        handleUserAction('revoke_sessions')\n                      }\n                    }}\n                    className=\"w-full bg-slate-900 text-white px-4 py-2 rounded-lg text-sm hover:bg-slate-800 transition-colors\"\n                  >\n                    Log out everywhere\n                  </button>\n                </div>\n              </div>\n            </div>\n          </>\n        ) : null}\n      </div>\n    </div>\n  )\n}\n","truncated":false,"size":25880},{"path":"app/affiliate/apply/page.tsx","content":"'use client'\n\nimport React, { useEffect, useState } from 'react'\nimport Link from 'next/link'\nimport { useSession } from 'next-auth/react'\n\nexport default function AffiliateApplyPage() {\n  const termsVersion = '2025-12-22'\n  const { data: session } = useSession()\n  const [loading, setLoading] = useState(true)\n  const [status, setStatus] = useState<any>(null)\n  const [error, setError] = useState<string | null>(null)\n  const [submitting, setSubmitting] = useState(false)\n  const [name, setName] = useState('')\n  const [website, setWebsite] = useState('')\n  const [primaryChannel, setPrimaryChannel] = useState('')\n  const [primaryChannelOther, setPrimaryChannelOther] = useState('')\n  const [audienceSize, setAudienceSize] = useState('')\n  const [termsAccepted, setTermsAccepted] = useState(false)\n  const [promotionMethod, setPromotionMethod] = useState('')\n  const [notes, setNotes] = useState('')\n\n  const loadStatus = async () => {\n    setLoading(true)\n    setError(null)\n    try {\n      const res = await fetch('/api/affiliate/application', { cache: 'no-store' })\n      const json = await res.json().catch(() => ({}))\n      if (!res.ok) throw new Error(json?.error || 'Failed to load application status')\n      setStatus(json)\n    } catch (e: any) {\n      setError(e?.message || 'Failed to load application status')\n    } finally {\n      setLoading(false)\n    }\n  }\n\n  useEffect(() => {\n    if (!session?.user) return\n    loadStatus()\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [session])\n\n  const submit = async (e: React.FormEvent) => {\n    e.preventDefault()\n    setSubmitting(true)\n    setError(null)\n    try {\n      const res = await fetch('/api/affiliate/apply', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          name,\n          website,\n          primaryChannel,\n          primaryChannelOther,\n          audienceSize,\n          termsAccepted,\n          termsVersion,\n          promotionMethod,\n          notes,\n        }),\n      })\n      const json = await res.json().catch(() => ({}))\n      if (!res.ok) throw new Error(json?.error || 'Application failed')\n      await loadStatus()\n    } catch (e: any) {\n      setError(e?.message || 'Application failed')\n    } finally {\n      setSubmitting(false)\n    }\n  }\n\n  if (!session?.user) {\n    return (\n      <div className=\"min-h-screen p-6\">\n        <div className=\"max-w-2xl mx-auto\">\n          <h1 className=\"text-2xl font-bold text-gray-900\">Affiliate Application</h1>\n          <p className=\"text-gray-600 mt-2\">\n            Please <Link className=\"text-helfi-green underline\" href=\"/auth/signin\">sign in</Link> to apply.\n          </p>\n        </div>\n      </div>\n    )\n  }\n\n  const alreadyAffiliate = !!status?.affiliate\n\n  return (\n    <div className=\"min-h-screen bg-gray-50 p-6\">\n      <div className=\"max-w-2xl mx-auto space-y-6\">\n        <div className=\"flex items-start justify-between gap-4\">\n          <div>\n            <h1 className=\"text-2xl font-bold text-gray-900\">Affiliate Application</h1>\n            <p className=\"text-gray-600 mt-1\">Applications are screened automatically; some require manual review.</p>\n          </div>\n          <Link href=\"/affiliate\" className=\"text-sm text-gray-600 hover:text-gray-900 underline\">\n            Back to portal\n          </Link>\n        </div>\n\n        {loading && <div className=\"bg-white rounded-xl p-6 shadow-sm\">Loading‚Ä¶</div>}\n        {error && <div className=\"bg-white rounded-xl p-6 shadow-sm text-red-600\">{error}</div>}\n\n        {!loading && !error && alreadyAffiliate && (\n          <div className=\"bg-white rounded-xl p-6 shadow-sm\">\n            <h2 className=\"text-lg font-semibold text-gray-900\">You‚Äôre approved</h2>\n            <p className=\"text-gray-600 mt-2\">Your affiliate link is ready.</p>\n            <div className=\"mt-4\">\n              <Link href=\"/affiliate\" className=\"inline-flex items-center px-4 py-2 rounded-lg bg-helfi-green text-white\">\n                Go to Dashboard\n              </Link>\n            </div>\n          </div>\n        )}\n\n        {!loading && !error && !alreadyAffiliate && status?.application && (\n          <div className=\"bg-white rounded-xl p-6 shadow-sm\">\n            <h2 className=\"text-lg font-semibold text-gray-900\">Application Status</h2>\n            <div className=\"mt-2 text-sm text-gray-700\">\n              <div>Status: <span className=\"font-semibold\">{status.application.status}</span></div>\n              <div>Risk: <span className=\"font-semibold\">{status.application.riskLevel || '‚Äî'}</span></div>\n              <div>Recommendation: <span className=\"font-semibold\">{status.application.recommendation || '‚Äî'}</span></div>\n            </div>\n            <p className=\"text-gray-600 mt-3\">{status.application.aiReasoning || 'We‚Äôll review your application and get back to you.'}</p>\n          </div>\n        )}\n\n        {!loading && !error && !alreadyAffiliate && !status?.application && (\n          <form onSubmit={submit} className=\"bg-white rounded-xl p-6 shadow-sm space-y-4\">\n            <div>\n              <label className=\"block text-sm font-medium text-gray-700\">Name</label>\n              <input\n                value={name}\n                onChange={e => setName(e.target.value)}\n                className=\"mt-1 w-full border rounded-lg px-3 py-2\"\n                required\n              />\n            </div>\n            <div>\n              <label className=\"block text-sm font-medium text-gray-700\">Website (optional)</label>\n              <input\n                value={website}\n                onChange={e => setWebsite(e.target.value)}\n                className=\"mt-1 w-full border rounded-lg px-3 py-2\"\n                placeholder=\"https://‚Ä¶\"\n              />\n            </div>\n            <div>\n              <label className=\"block text-sm font-medium text-gray-700\">Primary promotion channel</label>\n              <select\n                value={primaryChannel}\n                onChange={e => {\n                  const next = e.target.value\n                  setPrimaryChannel(next)\n                  if (next !== 'OTHER') setPrimaryChannelOther('')\n                }}\n                className=\"mt-1 w-full border rounded-lg px-3 py-2 bg-white\"\n                required\n              >\n                <option value=\"\" disabled>Select a channel</option>\n                <option value=\"WEBSITE\">Website / Blog</option>\n                <option value=\"YOUTUBE\">YouTube</option>\n                <option value=\"SOCIAL\">Instagram / TikTok / Social</option>\n                <option value=\"NEWSLETTER\">Email Newsletter</option>\n                <option value=\"PODCAST\">Podcast</option>\n                <option value=\"COMMUNITY\">Community / Forum</option>\n                <option value=\"PAID_ADS\">Paid Ads</option>\n                <option value=\"OTHER\">Other</option>\n              </select>\n            </div>\n            {primaryChannel === 'OTHER' && (\n              <div>\n                <label className=\"block text-sm font-medium text-gray-700\">Please specify</label>\n                <input\n                  value={primaryChannelOther}\n                  onChange={e => setPrimaryChannelOther(e.target.value)}\n                  className=\"mt-1 w-full border rounded-lg px-3 py-2\"\n                  placeholder=\"Tell us the channel\"\n                  required\n                  minLength={2}\n                />\n              </div>\n            )}\n            <div>\n              <label className=\"block text-sm font-medium text-gray-700\">Audience size (optional)</label>\n              <select\n                value={audienceSize}\n                onChange={e => setAudienceSize(e.target.value)}\n                className=\"mt-1 w-full border rounded-lg px-3 py-2 bg-white\"\n              >\n                <option value=\"\">Select range</option>\n                <option value=\"UNDER_1K\">Under 1k</option>\n                <option value=\"1K_10K\">1k‚Äì10k</option>\n                <option value=\"10K_50K\">10k‚Äì50k</option>\n                <option value=\"50K_250K\">50k‚Äì250k</option>\n                <option value=\"250K_PLUS\">250k+</option>\n                <option value=\"UNKNOWN\">Prefer not to say</option>\n              </select>\n            </div>\n            <div>\n              <label className=\"block text-sm font-medium text-gray-700\">How will you promote Helfi?</label>\n              <textarea\n                value={promotionMethod}\n                onChange={e => setPromotionMethod(e.target.value)}\n                className=\"mt-1 w-full border rounded-lg px-3 py-2\"\n                rows={5}\n                placeholder=\"Be specific (content plan, audience fit, examples, etc.)\"\n                required\n                minLength={10}\n              />\n            </div>\n            <label className=\"flex items-start gap-3 text-sm text-gray-700\">\n              <input\n                type=\"checkbox\"\n                className=\"mt-1\"\n                checked={termsAccepted}\n                onChange={e => setTermsAccepted(e.target.checked)}\n                required\n              />\n              <span>\n                I agree to the{' '}\n                <Link href=\"/affiliate/terms\" className=\"text-helfi-green underline\">\n                  Affiliate Program Terms\n                </Link>\n                .\n              </span>\n            </label>\n            <div>\n              <label className=\"block text-sm font-medium text-gray-700\">Notes (optional)</label>\n              <textarea value={notes} onChange={e => setNotes(e.target.value)} className=\"mt-1 w-full border rounded-lg px-3 py-2\" rows={3} />\n            </div>\n            <button\n              disabled={submitting}\n              className=\"w-full px-4 py-2 rounded-lg bg-helfi-green text-white disabled:opacity-50\"\n              type=\"submit\"\n            >\n              {submitting ? 'Submitting‚Ä¶' : 'Submit Application'}\n            </button>\n          </form>\n        )}\n      </div>\n    </div>\n  )\n}\n","truncated":false,"size":9986},{"path":"app/affiliate/page.tsx","content":"'use client'\n\nimport React, { useEffect, useMemo, useState } from 'react'\nimport Link from 'next/link'\nimport { useSession } from 'next-auth/react'\n\ntype AffiliateMeResponse =\n  | { ok: true; affiliate: null }\n  | {\n      ok: true\n      affiliate: {\n        id: string\n        code: string\n        status: 'ACTIVE' | 'SUSPENDED'\n        stripeConnectAccountId: string | null\n        stripeConnectDetailsSubmitted: boolean\n        stripeConnectChargesEnabled: boolean\n        stripeConnectPayoutsEnabled: boolean\n        stripeConnectOnboardedAt: string | null\n        createdAt: string\n      }\n      referralLink: string\n      stats: {\n        clicks: number\n        uniqueVisitors: number\n        conversionsByType: Record<string, number>\n        commissionTotalsByStatus: Record<string, number>\n        payableNowCents: number\n      }\n      events: Array<{\n        occurredAt: string\n        type: string\n        currency: string\n        amountGrossCents: number\n        stripeFeeCents: number\n        amountNetCents: number\n        commission: null | { status: string; commissionCents: number; payableAt: string; paidAt: string | null }\n      }>\n    }\n\nfunction formatMoney(cents: number, currency: string) {\n  const amount = cents / 100\n  try {\n    return new Intl.NumberFormat('en-AU', { style: 'currency', currency: currency.toUpperCase() }).format(amount)\n  } catch {\n    return `${amount.toFixed(2)} ${currency.toUpperCase()}`\n  }\n}\n\nexport default function AffiliateDashboardPage() {\n  const { data: session } = useSession()\n  const [loading, setLoading] = useState(true)\n  const [data, setData] = useState<AffiliateMeResponse | null>(null)\n  const [error, setError] = useState<string | null>(null)\n  const [connectLoading, setConnectLoading] = useState(false)\n\n  const fullReferralUrl = useMemo(() => {\n    if (!data || !('referralLink' in data)) return ''\n    if (typeof window === 'undefined') return data.referralLink\n    return `${window.location.origin}${data.referralLink}`\n  }, [data])\n\n  useEffect(() => {\n    if (!session?.user) return\n    const load = async () => {\n      setLoading(true)\n      setError(null)\n      try {\n        const res = await fetch('/api/affiliate/me', { cache: 'no-store' })\n        const json = (await res.json().catch(() => ({}))) as AffiliateMeResponse\n        if (!res.ok) throw new Error((json as any)?.error || 'Failed to load affiliate data')\n        setData(json)\n      } catch (e: any) {\n        setError(e?.message || 'Failed to load affiliate data')\n      } finally {\n        setLoading(false)\n      }\n    }\n    load()\n  }, [session])\n\n  const startConnectOnboarding = async () => {\n    try {\n      setConnectLoading(true)\n      const res = await fetch('/api/affiliate/connect/onboard', { method: 'POST' })\n      const json = await res.json().catch(() => ({}))\n      if (!res.ok) throw new Error(json?.error || 'Failed to start Stripe Connect onboarding')\n      if (json?.url) window.location.href = json.url\n    } catch (e: any) {\n      alert(e?.message || 'Failed to start Stripe Connect onboarding')\n    } finally {\n      setConnectLoading(false)\n    }\n  }\n\n  const copyLink = async () => {\n    if (!fullReferralUrl) return\n    try {\n      await navigator.clipboard.writeText(fullReferralUrl)\n      alert('Copied referral link')\n    } catch {\n      alert('Could not copy link')\n    }\n  }\n\n  if (!session?.user) {\n    return (\n      <div className=\"min-h-screen p-6\">\n        <div className=\"max-w-3xl mx-auto\">\n          <h1 className=\"text-2xl font-bold text-gray-900\">Affiliate</h1>\n          <p className=\"text-gray-600 mt-2\">\n            Please <Link className=\"text-helfi-green underline\" href=\"/auth/signin\">sign in</Link> to access your affiliate portal.\n          </p>\n        </div>\n      </div>\n    )\n  }\n\n  return (\n    <div className=\"min-h-screen bg-gray-50 p-6\">\n      <div className=\"max-w-5xl mx-auto space-y-6\">\n        <div className=\"flex items-start justify-between gap-4\">\n          <div>\n            <h1 className=\"text-2xl font-bold text-gray-900\">Affiliate Portal</h1>\n            <p className=\"text-gray-600 mt-1\">Track clicks, sales, and commissions (Net-30).</p>\n          </div>\n          <Link href=\"/billing\" className=\"text-sm text-gray-600 hover:text-gray-900 underline\">\n            Billing\n          </Link>\n        </div>\n\n        {loading && <div className=\"bg-white rounded-xl p-6 shadow-sm\">Loading‚Ä¶</div>}\n        {error && <div className=\"bg-white rounded-xl p-6 shadow-sm text-red-600\">{error}</div>}\n\n        {!loading && !error && data && 'affiliate' in data && data.affiliate === null && (\n          <div className=\"bg-white rounded-xl p-6 shadow-sm\">\n            <h2 className=\"text-lg font-semibold text-gray-900\">Not enrolled</h2>\n            <p className=\"text-gray-600 mt-2\">Apply to join the Helfi affiliate program.</p>\n            <div className=\"mt-4\">\n              <Link href=\"/affiliate/apply\" className=\"inline-flex items-center px-4 py-2 rounded-lg bg-helfi-green text-white\">\n                Apply Now\n              </Link>\n            </div>\n          </div>\n        )}\n\n        {!loading && !error && data && 'affiliate' in data && data.affiliate && (\n          <>\n            <div className=\"bg-white rounded-xl p-6 shadow-sm\">\n              <div className=\"flex flex-col md:flex-row md:items-center md:justify-between gap-4\">\n                <div>\n                  <div className=\"text-sm text-gray-500\">Your referral link</div>\n                  <div className=\"mt-1 font-mono text-sm break-all\">{fullReferralUrl}</div>\n                  <div className=\"mt-2 text-xs text-gray-500\">Last-click attribution, 30-day window.</div>\n                </div>\n                <div className=\"flex gap-2\">\n                  <button onClick={copyLink} className=\"px-3 py-2 rounded-lg border text-sm hover:bg-gray-50\">\n                    Copy\n                  </button>\n                  <a href={fullReferralUrl} className=\"px-3 py-2 rounded-lg bg-gray-900 text-white text-sm\" target=\"_blank\" rel=\"noreferrer\">\n                    Open\n                  </a>\n                </div>\n              </div>\n            </div>\n\n            <div className=\"grid grid-cols-1 md:grid-cols-4 gap-4\">\n              <div className=\"bg-white rounded-xl p-4 shadow-sm\">\n                <div className=\"text-xs text-gray-500\">Clicks</div>\n                <div className=\"text-2xl font-semibold\">{data.stats.clicks}</div>\n              </div>\n              <div className=\"bg-white rounded-xl p-4 shadow-sm\">\n                <div className=\"text-xs text-gray-500\">Unique Visitors</div>\n                <div className=\"text-2xl font-semibold\">{data.stats.uniqueVisitors}</div>\n              </div>\n              <div className=\"bg-white rounded-xl p-4 shadow-sm\">\n                <div className=\"text-xs text-gray-500\">Sales</div>\n                <div className=\"text-2xl font-semibold\">\n                  {(data.stats.conversionsByType?.SUBSCRIPTION_INITIAL || 0) + (data.stats.conversionsByType?.TOPUP || 0)}\n                </div>\n              </div>\n              <div className=\"bg-white rounded-xl p-4 shadow-sm\">\n                <div className=\"text-xs text-gray-500\">Payable Now</div>\n                <div className=\"text-2xl font-semibold\">{formatMoney(data.stats.payableNowCents, 'aud')}</div>\n              </div>\n            </div>\n\n            <div className=\"bg-white rounded-xl p-6 shadow-sm\">\n              <h2 className=\"text-lg font-semibold text-gray-900\">Payout Setup (Stripe Connect)</h2>\n              <p className=\"text-gray-600 mt-2\">\n                Payouts are processed monthly on a Net-30 basis once your payable balance reaches $50 USD.\n              </p>\n              <div className=\"mt-4 flex items-center gap-3\">\n                <div className=\"text-sm text-gray-700\">\n                  Status:{' '}\n                  {data.affiliate.stripeConnectPayoutsEnabled ? (\n                    <span className=\"text-helfi-green font-semibold\">Ready</span>\n                  ) : (\n                    <span className=\"text-amber-600 font-semibold\">Action required</span>\n                  )}\n                </div>\n                <button\n                  onClick={startConnectOnboarding}\n                  disabled={connectLoading}\n                  className=\"px-4 py-2 rounded-lg bg-helfi-green text-white disabled:opacity-50\"\n                >\n                  {connectLoading ? 'Opening‚Ä¶' : 'Set Up Payouts'}\n                </button>\n              </div>\n            </div>\n\n            <div className=\"bg-white rounded-xl p-6 shadow-sm\">\n              <h2 className=\"text-lg font-semibold text-gray-900\">Recent Activity</h2>\n              <div className=\"mt-4 overflow-x-auto\">\n                <table className=\"min-w-full text-sm\">\n                  <thead>\n                    <tr className=\"text-left text-gray-500\">\n                      <th className=\"py-2 pr-4\">Date</th>\n                      <th className=\"py-2 pr-4\">Type</th>\n                      <th className=\"py-2 pr-4\">Net</th>\n                      <th className=\"py-2 pr-4\">Commission</th>\n                      <th className=\"py-2 pr-4\">Status</th>\n                    </tr>\n                  </thead>\n                  <tbody>\n                    {data.events.length === 0 && (\n                      <tr>\n                        <td className=\"py-3 text-gray-500\" colSpan={5}>\n                          No conversions yet.\n                        </td>\n                      </tr>\n                    )}\n                    {data.events.map((e, idx) => (\n                      <tr key={`${e.occurredAt}-${idx}`} className=\"border-t\">\n                        <td className=\"py-2 pr-4 whitespace-nowrap\">{new Date(e.occurredAt).toLocaleString()}</td>\n                        <td className=\"py-2 pr-4\">{e.type === 'TOPUP' ? 'Top-up' : 'Subscription (first month)'}</td>\n                        <td className=\"py-2 pr-4\">{formatMoney(e.amountNetCents, e.currency)}</td>\n                        <td className=\"py-2 pr-4\">\n                          {e.commission ? formatMoney(e.commission.commissionCents, e.currency) : '‚Äî'}\n                        </td>\n                        <td className=\"py-2 pr-4\">{e.commission?.status || '‚Äî'}</td>\n                      </tr>\n                    ))}\n                  </tbody>\n                </table>\n              </div>\n            </div>\n          </>\n        )}\n      </div>\n    </div>\n  )\n}\n","truncated":false,"size":10441},{"path":"app/affiliate/terms/page.tsx","content":"'use client'\n\nimport Link from 'next/link'\n\nconst TERMS_VERSION = '2025-12-22'\n\nexport default function AffiliateTermsPage() {\n  return (\n    <div className=\"min-h-screen bg-gray-50 p-6\">\n      <div className=\"max-w-3xl mx-auto space-y-6\">\n        <div>\n          <h1 className=\"text-2xl font-bold text-gray-900\">Affiliate Program Terms</h1>\n          <p className=\"text-sm text-gray-600 mt-1\">Version {TERMS_VERSION}</p>\n        </div>\n\n        <div className=\"bg-white rounded-xl p-6 shadow-sm space-y-4 text-sm text-gray-700\">\n          <div>\n            <h2 className=\"text-base font-semibold text-gray-900\">Attribution</h2>\n            <ul className=\"list-disc pl-5 mt-2 space-y-1\">\n              <li>Last-click attribution with a 30‚Äëday window.</li>\n              <li>Only the final affiliate click before purchase earns a commission.</li>\n            </ul>\n          </div>\n\n          <div>\n            <h2 className=\"text-base font-semibold text-gray-900\">Commissions</h2>\n            <ul className=\"list-disc pl-5 mt-2 space-y-1\">\n              <li>50% of net revenue (after Stripe fees).</li>\n              <li>Subscription: first payment only (no recurring commissions).</li>\n              <li>Top‚Äëups: one‚Äëtime commission per purchase.</li>\n            </ul>\n          </div>\n\n          <div>\n            <h2 className=\"text-base font-semibold text-gray-900\">Payouts</h2>\n            <ul className=\"list-disc pl-5 mt-2 space-y-1\">\n              <li>Net‚Äë30 payout timing (paid 30 days after transaction date).</li>\n              <li>$50 USD minimum payout threshold; balances roll over.</li>\n              <li>Payouts are processed via Stripe Connect.</li>\n            </ul>\n          </div>\n\n          <div>\n            <h2 className=\"text-base font-semibold text-gray-900\">Refunds & Disputes</h2>\n            <ul className=\"list-disc pl-5 mt-2 space-y-1\">\n              <li>Refunds only where required under Australian Consumer Law.</li>\n              <li>Refunded or disputed transactions within 30 days void commission.</li>\n            </ul>\n          </div>\n\n          <div>\n            <h2 className=\"text-base font-semibold text-gray-900\">Promotion Rules</h2>\n            <ul className=\"list-disc pl-5 mt-2 space-y-1\">\n              <li>No spam, misleading claims, or impersonation.</li>\n              <li>No unauthorized coupon code sites or incentive traffic.</li>\n              <li>Affiliates must comply with applicable laws and platform policies.</li>\n            </ul>\n          </div>\n\n          <div>\n            <h2 className=\"text-base font-semibold text-gray-900\">Privacy</h2>\n            <ul className=\"list-disc pl-5 mt-2 space-y-1\">\n              <li>Affiliate reporting is anonymized; no customer PII is shared.</li>\n            </ul>\n          </div>\n        </div>\n\n        <div className=\"flex items-center gap-3\">\n          <Link href=\"/affiliate/apply\" className=\"inline-flex items-center px-4 py-2 rounded-lg bg-helfi-green text-white\">\n            Back to Application\n          </Link>\n          <Link href=\"/affiliate\" className=\"text-sm text-gray-600 hover:text-gray-900 underline\">\n            Affiliate Portal\n          </Link>\n        </div>\n      </div>\n    </div>\n  )\n}\n","truncated":false,"size":3226},{"path":"app/api/account/delete/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\nimport Stripe from 'stripe'\nimport { Prisma } from '@prisma/client'\n\nconst stripe = process.env.STRIPE_SECRET_KEY \n  ? new Stripe(process.env.STRIPE_SECRET_KEY, {\n      apiVersion: '2024-06-20',\n    })\n  : null\n\nfunction isMissingDbObjectError(err: unknown): boolean {\n  const anyErr = err as any\n  const code = anyErr?.code as string | undefined\n  const msg = String(anyErr?.message || '')\n\n  // Prisma known request errors:\n  // - P2021: table does not exist\n  // - P2022: column does not exist\n  if (code === 'P2021' || code === 'P2022') return true\n\n  // Fallback string checks (covers some prisma engines / postgres phrasing)\n  return (\n    /does not exist/i.test(msg) ||\n    /Unknown column/i.test(msg) ||\n    /column .* does not exist/i.test(msg) ||\n    /relation .* does not exist/i.test(msg)\n  )\n}\n\nasync function bestEffort(label: string, fn: () => Promise<unknown>) {\n  try {\n    await fn()\n  } catch (err: any) {\n    // If production DB is behind schema, ignore missing table/column errors so deletion can proceed.\n    if (isMissingDbObjectError(err) || err instanceof Prisma.PrismaClientKnownRequestError) {\n      if (isMissingDbObjectError(err)) {\n        console.warn(`‚ö†Ô∏è Account deletion cleanup skipped (${label}):`, err?.message || err)\n        return\n      }\n    }\n    throw err\n  }\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    const session = await getServerSession(authOptions)\n    \n    if (!session?.user?.email) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const userEmail = session.user.email\n    console.log('üóëÔ∏è Account deletion requested for:', userEmail)\n\n    // IMPORTANT:\n    // Do NOT use `include` here because Prisma will select all scalar User columns by default.\n    // If the DB hasn't been migrated yet for newly added fields (e.g., free credits counters),\n    // selecting the full User row will throw \"column does not exist\". We only select what we need.\n    const user = await prisma.user.findUnique({\n      where: { email: userEmail },\n      select: {\n        id: true,\n        email: true,\n        subscription: {\n          select: {\n            stripeSubscriptionId: true,\n          },\n        },\n      },\n    })\n\n    if (!user) {\n      return NextResponse.json({ error: 'User not found' }, { status: 404 })\n    }\n\n    // Cancel Stripe subscription (and derive customer id from subscription, since we don't store it in DB)\n    let stripeCustomerId: string | null = null\n    if (stripe && user.subscription?.stripeSubscriptionId) {\n      const subId = user.subscription.stripeSubscriptionId\n      try {\n        const sub = await stripe.subscriptions.retrieve(subId)\n        const customer = (sub as any)?.customer\n        stripeCustomerId = typeof customer === 'string' ? customer : (customer?.id ?? null)\n      } catch (error: any) {\n        console.warn('‚ö†Ô∏è Failed to retrieve Stripe subscription (non-blocking):', error?.message || error)\n      }\n\n      try {\n        await stripe.subscriptions.cancel(subId)\n        console.log('‚úÖ Cancelled Stripe subscription:', subId)\n      } catch (error: any) {\n        // Log but don't fail - subscription might already be cancelled\n        console.warn('‚ö†Ô∏è Failed to cancel Stripe subscription (may already be cancelled):', error.message)\n      }\n    }\n\n    // Delete Stripe customer if we could resolve it from the subscription\n    if (stripe && stripeCustomerId) {\n      try {\n        await stripe.customers.del(stripeCustomerId)\n        console.log('‚úÖ Deleted Stripe customer:', stripeCustomerId)\n      } catch (error: any) {\n        // Log but don't fail - customer might already be deleted\n        console.warn('‚ö†Ô∏è Failed to delete Stripe customer (may already be deleted):', error.message)\n      }\n    }\n\n    // Delete all user-related data (cascading deletes will handle most relationships)\n    // But we'll explicitly delete some to be safe and clear\n    \n    // Delete OAuth accounts (Fitbit, Garmin, etc.)\n    await bestEffort('account.deleteMany', () =>\n      prisma.account.deleteMany({\n        where: { userId: user.id },\n      })\n    )\n\n    // Delete sessions\n    await bestEffort('session.deleteMany', () =>\n      prisma.session.deleteMany({\n        where: { userId: user.id },\n      })\n    )\n\n    // Delete verification tokens\n    await bestEffort('verificationToken.deleteMany', () =>\n      prisma.verificationToken.deleteMany({\n        where: { identifier: user.email },\n      })\n    )\n\n    // Delete credit top-ups\n    await bestEffort('creditTopUp.deleteMany', () =>\n      prisma.creditTopUp.deleteMany({\n        where: { userId: user.id },\n      })\n    )\n\n    // Delete subscription (if not already deleted)\n    await bestEffort('subscription.deleteMany', () =>\n      prisma.subscription.deleteMany({\n        where: { userId: user.id },\n      })\n    )\n\n    // Delete all health-related data\n    await bestEffort('healthGoal.deleteMany', () => prisma.healthGoal.deleteMany({ where: { userId: user.id } }))\n    await bestEffort('supplement.deleteMany', () => prisma.supplement.deleteMany({ where: { userId: user.id } }))\n    await bestEffort('medication.deleteMany', () => prisma.medication.deleteMany({ where: { userId: user.id } }))\n    await bestEffort('healthLog.deleteMany', () => prisma.healthLog.deleteMany({ where: { userId: user.id } }))\n    await bestEffort('foodLog.deleteMany', () => prisma.foodLog.deleteMany({ where: { userId: user.id } }))\n    await bestEffort('exerciseLog.deleteMany', () => prisma.exerciseLog.deleteMany({ where: { userId: user.id } }))\n    await bestEffort('exerciseEntry.deleteMany', () => prisma.exerciseEntry.deleteMany({ where: { userId: user.id } }))\n    \n    // Delete AI analysis data\n    await bestEffort('interactionAnalysis.deleteMany', () => prisma.interactionAnalysis.deleteMany({ where: { userId: user.id } }))\n    await bestEffort('symptomAnalysis.deleteMany', () => prisma.symptomAnalysis.deleteMany({ where: { userId: user.id } }))\n    await bestEffort('medicalImageAnalysis.deleteMany', () => prisma.medicalImageAnalysis.deleteMany({ where: { userId: user.id } }))\n    await bestEffort('foodAnalysisFeedback.deleteMany', () => prisma.foodAnalysisFeedback.deleteMany({ where: { userId: user.id } }))\n    \n    // Delete device data\n    await bestEffort('fitbitData.deleteMany', () => prisma.fitbitData.deleteMany({ where: { userId: user.id } }))\n    await bestEffort('garminRequestToken.deleteMany', () => prisma.garminRequestToken.deleteMany({ where: { userId: user.id } }))\n    await bestEffort('garminWebhookLog.deleteMany', () => prisma.garminWebhookLog.deleteMany({ where: { userId: user.id } }))\n    \n    // Delete files (File model uses uploadedById, not userId)\n    await bestEffort('file.deleteMany', () => prisma.file.deleteMany({ where: { uploadedById: user.id } }))\n    \n    // Delete reports\n    await bestEffort('report.deleteMany', () => prisma.report.deleteMany({ where: { userId: user.id } }))\n    await bestEffort('consentRecord.deleteMany', () => prisma.consentRecord.deleteMany({ where: { userId: user.id } }))\n    \n    // Delete affiliate data\n    await bestEffort('affiliateReferral.deleteMany', () => prisma.affiliateReferral.deleteMany({ where: { referredUserId: user.id } }))\n    await bestEffort('affiliateConversion.deleteMany', () => prisma.affiliateConversion.deleteMany({ where: { referredUserId: user.id } }))\n    await bestEffort('affiliateApplication.deleteMany', () => prisma.affiliateApplication.deleteMany({ where: { userId: user.id } }))\n    await bestEffort('affiliate.deleteMany', () => prisma.affiliate.deleteMany({ where: { userId: user.id } }))\n    \n    // Delete support tickets\n    await bestEffort('supportTicket.deleteMany', () => prisma.supportTicket.deleteMany({ where: { userId: user.id } }))\n\n    // Finally, delete the user.\n    // IMPORTANT: Use deleteMany() instead of delete() because delete() returns the deleted User record.\n    // When the DB is behind the Prisma schema (missing columns), returning the full record will throw.\n    const deleted = await prisma.user.deleteMany({\n      where: { id: user.id },\n    })\n    if (!deleted?.count) {\n      return NextResponse.json({ error: 'User not found' }, { status: 404 })\n    }\n\n    console.log('‚úÖ Successfully deleted account and all related data for:', userEmail)\n\n    return NextResponse.json({ \n      success: true, \n      message: 'Account deleted successfully' \n    })\n  } catch (error: any) {\n    console.error('‚ùå Error deleting account:', error)\n    return NextResponse.json({ \n      error: 'Failed to delete account',\n      message: error.message || 'An unexpected error occurred'\n    }, { status: 500 })\n  }\n}\n","truncated":false,"size":8852},{"path":"app/api/admin/affiliates/applications/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\nimport { extractAdminFromHeaders } from '@/lib/admin-auth'\nimport { createUniqueAffiliateCode } from '@/lib/affiliate-code'\n\nexport const runtime = 'nodejs'\nexport const dynamic = 'force-dynamic'\n\nexport async function GET(request: NextRequest) {\n  const authHeader = request.headers.get('authorization')\n  const admin = extractAdminFromHeaders(authHeader)\n  if (!admin) {\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  }\n\n  const url = new URL(request.url)\n  const status = url.searchParams.get('status')?.toUpperCase() || null\n\n  const applications = await prisma.affiliateApplication.findMany({\n    where: status ? { status: status as any } : undefined,\n    orderBy: { createdAt: 'desc' },\n    take: 200,\n    select: {\n      id: true,\n      userId: true,\n      email: true,\n      name: true,\n      website: true,\n      primaryChannel: true,\n      primaryChannelOther: true,\n      audienceSize: true,\n      termsVersion: true,\n      termsAcceptedAt: true,\n      promotionMethod: true,\n      notes: true,\n      ip: true,\n      userAgent: true,\n      country: true,\n      region: true,\n      city: true,\n      riskLevel: true,\n      recommendation: true,\n      aiReasoning: true,\n      status: true,\n      autoApproved: true,\n      reviewedAt: true,\n      reviewedByAdminId: true,\n      createdAt: true,\n    },\n  })\n\n  return NextResponse.json({ ok: true, applications })\n}\n\nexport async function POST(request: NextRequest) {\n  const authHeader = request.headers.get('authorization')\n  const admin = extractAdminFromHeaders(authHeader)\n  if (!admin) {\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  }\n\n  const body = await request.json().catch(() => ({}))\n  const applicationId = String(body?.applicationId || '')\n  const action = String(body?.action || '').toLowerCase()\n  if (!applicationId) return NextResponse.json({ error: 'applicationId is required' }, { status: 400 })\n  if (action !== 'approve' && action !== 'reject') {\n    return NextResponse.json({ error: 'action must be approve or reject' }, { status: 400 })\n  }\n\n  const application = await prisma.affiliateApplication.findUnique({\n    where: { id: applicationId },\n    select: { id: true, userId: true },\n  })\n  if (!application) return NextResponse.json({ error: 'Application not found' }, { status: 404 })\n  if (!application.userId) return NextResponse.json({ error: 'Application missing userId' }, { status: 400 })\n\n  if (action === 'reject') {\n    await prisma.affiliateApplication.update({\n      where: { id: applicationId },\n      data: {\n        status: 'REJECTED',\n        reviewedAt: new Date(),\n        reviewedByAdminId: admin?.adminId || null,\n        autoApproved: false,\n      },\n    })\n    return NextResponse.json({ ok: true, status: 'REJECTED' })\n  }\n\n  const existingAffiliate = await prisma.affiliate.findUnique({\n    where: { userId: application.userId },\n    select: { id: true, code: true, status: true },\n  })\n  if (existingAffiliate) {\n    await prisma.affiliateApplication.update({\n      where: { id: applicationId },\n      data: {\n        status: 'APPROVED',\n        reviewedAt: new Date(),\n        reviewedByAdminId: admin?.adminId || null,\n        autoApproved: false,\n      },\n    })\n    return NextResponse.json({ ok: true, status: 'APPROVED', affiliate: existingAffiliate })\n  }\n\n  const code = await createUniqueAffiliateCode()\n  const affiliate = await prisma.affiliate.create({\n    data: { userId: application.userId, applicationId, code, status: 'ACTIVE' },\n    select: { id: true, code: true, status: true },\n  })\n\n  await prisma.affiliateApplication.update({\n    where: { id: applicationId },\n    data: {\n      status: 'APPROVED',\n      reviewedAt: new Date(),\n      reviewedByAdminId: admin?.adminId || null,\n      autoApproved: false,\n    },\n  })\n\n  return NextResponse.json({ ok: true, status: 'APPROVED', affiliate })\n}\n","truncated":false,"size":3976},{"path":"app/api/admin/affiliates/payout-run/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport Stripe from 'stripe'\nimport { prisma } from '@/lib/prisma'\nimport { extractAdminFromHeaders } from '@/lib/admin-auth'\n\nexport const runtime = 'nodejs'\nexport const dynamic = 'force-dynamic'\n\ntype PayableCommission = {\n  id: string\n  affiliateId: string\n  currency: string\n  commissionCents: number\n  payableAt: Date\n  affiliate: {\n    id: string\n    code: string\n    stripeConnectAccountId: string | null\n    stripeConnectPayoutsEnabled: boolean\n    status: 'ACTIVE' | 'SUSPENDED'\n  }\n}\n\nexport async function POST(request: NextRequest) {\n  const authHeader = request.headers.get('authorization')\n  const admin = extractAdminFromHeaders(authHeader)\n  const schedulerSecret = process.env.SCHEDULER_SECRET\n  const isScheduler = !!(schedulerSecret && authHeader === `Bearer ${schedulerSecret}`)\n  if (!admin && !isScheduler) {\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  }\n\n  const secretKey = process.env.STRIPE_SECRET_KEY\n  if (!secretKey) return NextResponse.json({ error: 'Stripe not configured' }, { status: 500 })\n  const stripe = new Stripe(secretKey, { apiVersion: '2024-06-20' })\n\n  const body = await request.json().catch(() => ({}))\n  const currency = String(body?.currency || 'usd').toLowerCase()\n  const minThresholdCents = Number(body?.minThresholdCents ?? 5000)\n  const dryRun = Boolean(body?.dryRun ?? false)\n\n  const now = new Date()\n\n  const commissions: PayableCommission[] = (await prisma.affiliateCommission.findMany({\n    where: {\n      status: 'PENDING',\n      payableAt: { lte: now },\n      payoutId: null,\n      currency,\n    },\n    select: {\n      id: true,\n      affiliateId: true,\n      currency: true,\n      commissionCents: true,\n      payableAt: true,\n      affiliate: {\n        select: {\n          id: true,\n          code: true,\n          status: true,\n          stripeConnectAccountId: true,\n          stripeConnectPayoutsEnabled: true,\n        },\n      },\n    },\n  })) as any\n\n  const byAffiliate = new Map<\n    string,\n    { affiliate: PayableCommission['affiliate']; commissionIds: string[]; totalCents: number }\n  >()\n  for (const c of commissions) {\n    const existing = byAffiliate.get(c.affiliateId)\n    const total = Number(c.commissionCents || 0)\n    if (!existing) {\n      byAffiliate.set(c.affiliateId, { affiliate: c.affiliate, commissionIds: [c.id], totalCents: total })\n    } else {\n      existing.commissionIds.push(c.id)\n      existing.totalCents += total\n    }\n  }\n\n  const candidates = Array.from(byAffiliate.values())\n    .filter(x => x.totalCents >= minThresholdCents)\n    .map(x => ({\n      affiliateId: x.affiliate.id,\n      code: x.affiliate.code,\n      connectAccountId: x.affiliate.stripeConnectAccountId,\n      payoutsEnabled: x.affiliate.stripeConnectPayoutsEnabled,\n      status: x.affiliate.status,\n      totalCents: x.totalCents,\n      commissionIds: x.commissionIds,\n    }))\n\n  const skipped = candidates.filter(\n    c => !c.connectAccountId || !c.payoutsEnabled || c.status !== 'ACTIVE' || c.totalCents <= 0\n  )\n  const toPay = candidates.filter(\n    c => c.connectAccountId && c.payoutsEnabled && c.status === 'ACTIVE' && c.totalCents > 0\n  )\n\n  if (dryRun) {\n    return NextResponse.json({\n      ok: true,\n      dryRun: true,\n      currency,\n      minThresholdCents,\n      payableAffiliateCount: toPay.length,\n      totalCents: toPay.reduce((sum, x) => sum + x.totalCents, 0),\n      payouts: toPay.map(x => ({\n        affiliateCode: x.code,\n        connectAccountId: x.connectAccountId,\n        amountCents: x.totalCents,\n        commissionCount: x.commissionIds.length,\n      })),\n      skipped: skipped.map(x => ({\n        affiliateCode: x.code,\n        reason: !x.connectAccountId ? 'missing_connect_account' : !x.payoutsEnabled ? 'payouts_not_enabled' : x.status,\n        amountCents: x.totalCents,\n      })),\n    })\n  }\n\n  const run = await prisma.affiliatePayoutRun.create({\n    data: {\n      createdByAdminId: admin?.adminId || null,\n      currency,\n      periodStart: new Date(0),\n      periodEnd: now,\n      runAt: now,\n      status: 'FAILED',\n      totalCents: 0,\n      transferCount: 0,\n      note: 'running',\n    },\n    select: { id: true },\n  })\n\n  const results: Array<{ affiliateCode: string; amountCents: number; transferId: string }> = []\n  const failures: Array<{ affiliateCode: string; reason: string }> = []\n  let totalCents = 0\n\n  for (const payout of toPay) {\n    try {\n      const transfer = await stripe.transfers.create(\n        {\n          amount: payout.totalCents,\n          currency,\n          destination: payout.connectAccountId!,\n          transfer_group: `affiliate_payout_run:${run.id}`,\n          description: `Helfi affiliate payout (${currency.toUpperCase()})`,\n          metadata: {\n            helfi_payout_run_id: run.id,\n            helfi_affiliate_code: payout.code,\n          },\n        },\n        { idempotencyKey: `affiliate_payout_run:${run.id}:affiliate:${payout.affiliateId}` }\n      )\n\n      const created = await prisma.$transaction(async tx => {\n        const payoutRecord = await tx.affiliatePayout.create({\n          data: {\n            payoutRunId: run.id,\n            affiliateId: payout.affiliateId,\n            currency,\n            amountCents: payout.totalCents,\n            stripeTransferId: transfer.id,\n          },\n          select: { id: true },\n        })\n\n        await tx.affiliateCommission.updateMany({\n          where: { id: { in: payout.commissionIds } },\n          data: { status: 'PAID', paidAt: now, payoutId: payoutRecord.id },\n        })\n\n        return payoutRecord\n      })\n\n      results.push({ affiliateCode: payout.code, amountCents: payout.totalCents, transferId: transfer.id })\n      totalCents += payout.totalCents\n      void created\n    } catch (e: any) {\n      failures.push({ affiliateCode: payout.code, reason: e?.message || 'transfer_failed' })\n    }\n  }\n\n  await prisma.affiliatePayoutRun.update({\n    where: { id: run.id },\n    data: {\n      status: failures.length ? 'FAILED' : 'SUCCEEDED',\n      totalCents,\n      transferCount: results.length,\n      note: failures.length ? JSON.stringify(failures.slice(0, 25)) : null,\n    },\n  })\n\n  return NextResponse.json({\n    ok: true,\n    runId: run.id,\n    currency,\n    transferCount: results.length,\n    totalCents,\n    failures,\n  })\n}\n","truncated":false,"size":6334},{"path":"app/api/admin/auth/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\nimport bcrypt from 'bcryptjs'\nimport jwt from 'jsonwebtoken'\nimport { authenticator } from 'otplib'\n\nconst JWT_SECRET = process.env.JWT_SECRET || process.env.NEXTAUTH_SECRET\nauthenticator.options = { window: 1 }\n\nexport async function POST(request: NextRequest) {\n  try {\n    if (!JWT_SECRET) {\n      return NextResponse.json({ error: 'Admin login secret not configured' }, { status: 500 })\n    }\n    const { email, password, otp } = await request.json()\n\n    if (!email || !password) {\n      return NextResponse.json({ error: 'Email and password are required' }, { status: 400 })\n    }\n\n    const normalizedEmail = String(email).trim().toLowerCase()\n\n    // Find admin user by email\n    const adminUser = await prisma.adminUser.findUnique({\n      where: { email: normalizedEmail }\n    })\n\n    if (!adminUser || !adminUser.isActive) {\n      return NextResponse.json({ error: 'Invalid credentials' }, { status: 401 })\n    }\n\n    // Verify password\n    const passwordMatch = await bcrypt.compare(password, adminUser.password)\n    if (!passwordMatch) {\n      return NextResponse.json({ error: 'Invalid credentials' }, { status: 401 })\n    }\n\n    const otpCode = typeof otp === 'string' ? otp.replace(/\\s+/g, '') : ''\n\n    if (adminUser.totpEnabled) {\n      if (!otpCode) {\n        return NextResponse.json({ error: 'Authentication code required', code: 'OTP_REQUIRED' }, { status: 401 })\n      }\n\n      const isValid = authenticator.verify({ token: otpCode, secret: adminUser.totpSecret || '' })\n      if (!isValid) {\n        return NextResponse.json({ error: 'Invalid authentication code', code: 'OTP_INVALID' }, { status: 401 })\n      }\n    } else {\n      let secret = adminUser.totpSecret\n      if (!secret) {\n        secret = authenticator.generateSecret()\n        await prisma.adminUser.update({\n          where: { id: adminUser.id },\n          data: { totpSecret: secret }\n        })\n      }\n\n      if (!otpCode) {\n        const otpauthUrl = authenticator.keyuri(adminUser.email, 'Helfi Admin', secret)\n        return NextResponse.json({\n          setupRequired: true,\n          message: 'Set up your authenticator app to continue.',\n          otpauthUrl\n        })\n      }\n\n      const isValid = authenticator.verify({ token: otpCode, secret })\n      if (!isValid) {\n        return NextResponse.json({ error: 'Invalid authentication code', code: 'OTP_INVALID' }, { status: 401 })\n      }\n\n      await prisma.adminUser.update({\n        where: { id: adminUser.id },\n        data: { totpEnabled: true }\n      })\n    }\n\n    // Update last login\n    await prisma.adminUser.update({\n      where: { id: adminUser.id },\n      data: { lastLogin: new Date() }\n    })\n\n    // Create JWT token\n    const token = jwt.sign(\n      { \n        adminId: adminUser.id, \n        email: adminUser.email, \n        role: adminUser.role \n      },\n      JWT_SECRET,\n      { expiresIn: '24h' }\n    )\n\n    return NextResponse.json({\n      success: true,\n      message: 'Authentication successful',\n      token,\n      admin: {\n        id: adminUser.id,\n        email: adminUser.email,\n        name: adminUser.name,\n        role: adminUser.role\n      }\n    })\n\n  } catch (error) {\n    console.error('Error authenticating admin:', error)\n    return NextResponse.json({ error: 'Authentication failed' }, { status: 500 })\n  }\n} \n","truncated":false,"size":3395},{"path":"app/api/admin/email-templates/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\nimport { extractAdminFromHeaders } from '@/lib/admin-auth'\n\n// GET - Fetch all email templates\nexport async function GET(request: NextRequest) {\n  try {\n    const authHeader = request.headers.get('authorization')\n    const admin = extractAdminFromHeaders(authHeader)\n    if (!admin) {\n      return NextResponse.json({ error: 'Invalid token' }, { status: 401 })\n    }\n\n    // Fetch all active email templates\n    const templates = await prisma.emailTemplate.findMany({\n      where: { isActive: true },\n      orderBy: [\n        { isBuiltIn: 'desc' }, // Built-in templates first\n        { category: 'asc' },\n        { name: 'asc' }\n      ]\n    })\n\n    return NextResponse.json({ templates })\n  } catch (error) {\n    console.error('Error fetching email templates:', error)\n    return NextResponse.json({ error: 'Failed to fetch templates' }, { status: 500 })\n  }\n}\n\n// POST - Create new email template\nexport async function POST(request: NextRequest) {\n  try {\n    const authHeader = request.headers.get('authorization')\n    const admin = extractAdminFromHeaders(authHeader)\n    if (!admin) {\n      return NextResponse.json({ error: 'Invalid token' }, { status: 401 })\n    }\n\n    const { name, category, subject, content } = await request.json()\n\n    if (!name || !subject || !content) {\n      return NextResponse.json({ error: 'Name, subject, and content are required' }, { status: 400 })\n    }\n\n    // Create new template\n    const template = await prisma.emailTemplate.create({\n      data: {\n        name,\n        category: category || 'CUSTOM',\n        subject,\n        content,\n        isBuiltIn: false,\n        createdBy: admin.adminId\n      }\n    })\n\n    return NextResponse.json({ template }, { status: 201 })\n  } catch (error) {\n    console.error('Error creating email template:', error)\n    return NextResponse.json({ error: 'Failed to create template' }, { status: 500 })\n  }\n}\n\n// PUT - Update email template\nexport async function PUT(request: NextRequest) {\n  try {\n    const authHeader = request.headers.get('authorization')\n    const admin = extractAdminFromHeaders(authHeader)\n    if (!admin) {\n      return NextResponse.json({ error: 'Invalid token' }, { status: 401 })\n    }\n\n    const { id, name, category, subject, content } = await request.json()\n\n    if (!id || !name || !subject || !content) {\n      return NextResponse.json({ error: 'ID, name, subject, and content are required' }, { status: 400 })\n    }\n\n    // Update template\n    const template = await prisma.emailTemplate.update({\n      where: { id },\n      data: {\n        name,\n        category: category || 'CUSTOM',\n        subject,\n        content,\n        updatedAt: new Date()\n      }\n    })\n\n    return NextResponse.json({ template })\n  } catch (error) {\n    console.error('Error updating email template:', error)\n    return NextResponse.json({ error: 'Failed to update template' }, { status: 500 })\n  }\n}\n\n// DELETE - Delete email template\nexport async function DELETE(request: NextRequest) {\n  try {\n    const authHeader = request.headers.get('authorization')\n    const admin = extractAdminFromHeaders(authHeader)\n    if (!admin) {\n      return NextResponse.json({ error: 'Invalid token' }, { status: 401 })\n    }\n\n    const url = new URL(request.url)\n    const id = url.searchParams.get('id')\n\n    if (!id) {\n      return NextResponse.json({ error: 'Template ID is required' }, { status: 400 })\n    }\n\n    // Check if template exists and is not built-in\n    const template = await prisma.emailTemplate.findUnique({\n      where: { id }\n    })\n\n    if (!template) {\n      return NextResponse.json({ error: 'Template not found' }, { status: 404 })\n    }\n\n    if (template.isBuiltIn) {\n      return NextResponse.json({ error: 'Cannot delete built-in templates' }, { status: 400 })\n    }\n\n    // Soft delete by marking as inactive\n    await prisma.emailTemplate.update({\n      where: { id },\n      data: { isActive: false }\n    })\n\n    return NextResponse.json({ message: 'Template deleted successfully' })\n  } catch (error) {\n    console.error('Error deleting email template:', error)\n    return NextResponse.json({ error: 'Failed to delete template' }, { status: 500 })\n  }\n} \n","truncated":false,"size":4255},{"path":"app/api/admin/fix-selected-issues/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\n\nexport const runtime = 'nodejs'\nexport const dynamic = 'force-dynamic'\n\nexport async function GET(request: NextRequest) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.email || !session?.user?.id) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const url = new URL(request.url)\n    const raw = (url.searchParams.get('list') || '').split(',')\n    const names = raw.map((s) => s.trim()).filter(Boolean)\n    if (!names.length) {\n      return NextResponse.json({ error: 'No issues provided' }, { status: 400 })\n    }\n\n    // Upsert special snapshot record for the current user\n    await prisma.healthGoal.deleteMany({ where: { userId: session.user.id, name: '__SELECTED_ISSUES__' } })\n    await prisma.healthGoal.create({\n      data: {\n        userId: session.user.id,\n        name: '__SELECTED_ISSUES__',\n        category: JSON.stringify(names),\n        currentRating: 0,\n      },\n    })\n\n    return NextResponse.json({ ok: true, saved: names })\n  } catch (error) {\n    return NextResponse.json({ error: 'Failed to save' }, { status: 500 })\n  }\n}\n\n\n","truncated":false,"size":1309},{"path":"app/api/admin/fix-unsubscribed/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\nimport { extractAdminFromHeaders } from '@/lib/admin-auth'\n\n/**\n * Admin endpoint to manually mark waitlist entries as unsubscribed\n * This fixes cases where someone unsubscribed before the column existed\n */\nexport async function POST(request: NextRequest) {\n  try {\n    // JWT authentication check\n    const authHeader = request.headers.get('authorization')\n    const admin = extractAdminFromHeaders(authHeader)\n    \n    if (!admin) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const { email } = await request.json()\n\n    if (!email) {\n      return NextResponse.json({ error: 'Email is required' }, { status: 400 })\n    }\n\n    const normalizedEmail = email.trim().toLowerCase()\n\n    // Ensure column exists\n    await prisma.$executeRawUnsafe(`\n      ALTER TABLE \"Waitlist\" \n      ADD COLUMN IF NOT EXISTS \"unsubscribed\" BOOLEAN NOT NULL DEFAULT false\n    `).catch(() => {})\n\n    // Mark as unsubscribed using raw SQL\n    const escapedEmail = normalizedEmail.replace(/'/g, \"''\")\n    await prisma.$executeRawUnsafe(`\n      UPDATE \"Waitlist\" \n      SET unsubscribed = true \n      WHERE LOWER(email) = LOWER('${escapedEmail}')\n    `)\n\n    return NextResponse.json({ \n      success: true,\n      message: `Marked ${normalizedEmail} as unsubscribed`\n    })\n\n  } catch (error: any) {\n    console.error('Error marking as unsubscribed:', error)\n    return NextResponse.json(\n      { error: 'Failed to mark as unsubscribed: ' + (error?.message || 'Unknown error') },\n      { status: 500 }\n    )\n  }\n}\n\n","truncated":false,"size":1630},{"path":"app/api/admin/food-analysis-usage/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\nimport { extractAdminFromHeaders } from '@/lib/admin-auth'\n\nexport const runtime = 'nodejs'\nexport const dynamic = 'force-dynamic'\n\nexport async function GET(request: NextRequest) {\n  try {\n    const authHeader = request.headers.get('authorization')\n    const admin = extractAdminFromHeaders(authHeader)\n    if (!admin) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const url = new URL(request.url)\n    const rangeDaysRaw = url.searchParams.get('rangeDays') || '30'\n    const rangeDays = Math.max(1, Math.min(365, parseInt(rangeDaysRaw, 10) || 30))\n    const since = new Date(Date.now() - rangeDays * 24 * 60 * 60 * 1000)\n\n    const [analysisCount, fallbackCount] = await Promise.all([\n      prisma.aIUsageEvent.count({\n        where: {\n          feature: 'food:analysis',\n          createdAt: { gte: since },\n        },\n      }),\n      prisma.aIUsageEvent.count({\n        where: {\n          feature: 'food:image-analysis-fallback',\n          createdAt: { gte: since },\n        },\n      }),\n    ])\n\n    const estimatedCallsPerAnalysis = 3\n    const estimatedTotalServerCalls = analysisCount * estimatedCallsPerAnalysis\n\n    return NextResponse.json({\n      rangeDays,\n      analysisCount,\n      fallbackCount,\n      estimatedCallsPerAnalysis,\n      estimatedTotalServerCalls,\n      note: 'Estimate assumes 1 analysis call + 1 save + 1 refresh per food analysis.',\n    })\n  } catch (error) {\n    console.error('[admin food-analysis-usage] error', error)\n    return NextResponse.json({ error: 'Failed to load food analysis usage' }, { status: 500 })\n  }\n}\n","truncated":false,"size":1690},{"path":"app/api/admin/food-analyzer-model/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { extractAdminFromHeaders } from '@/lib/admin-auth'\nimport { prisma } from '@/lib/prisma'\n\nexport const runtime = 'nodejs'\nexport const dynamic = 'force-dynamic'\n\nconst FOOD_MODEL_GOAL_NAME = '__FOOD_ANALYZER_MODEL__'\nconst DEFAULT_MODEL = (process.env.OPENAI_FOOD_MODEL || 'gpt-5.2').trim()\nconst ALLOWED_MODELS = new Set(['gpt-4o', 'gpt-5.2'])\n\nconst normalizeEmail = (raw: string) => raw.trim().toLowerCase()\n\nconst parseModelFromGoalCategory = (category: unknown): string | null => {\n  if (typeof category !== 'string' || !category.trim()) return null\n  try {\n    const parsed = JSON.parse(category)\n    const model = typeof parsed?.model === 'string' ? parsed.model.trim() : ''\n    return model || null\n  } catch {\n    return null\n  }\n}\n\nexport async function GET(req: NextRequest) {\n  try {\n    const authHeader = req.headers.get('authorization')\n    const admin = extractAdminFromHeaders(authHeader)\n    if (!admin) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const { searchParams } = new URL(req.url)\n    const userEmailRaw = searchParams.get('userEmail') || ''\n    const userEmail = userEmailRaw ? normalizeEmail(userEmailRaw) : ''\n    if (!userEmail) return NextResponse.json({ error: 'Missing userEmail' }, { status: 400 })\n\n    const user = await prisma.user.findUnique({\n      where: { email: userEmail },\n      select: { id: true, email: true },\n    })\n    if (!user) return NextResponse.json({ error: 'User not found' }, { status: 404 })\n\n    const goal = await prisma.healthGoal.findFirst({\n      where: { userId: user.id, name: FOOD_MODEL_GOAL_NAME },\n      select: { id: true, category: true, updatedAt: true },\n    })\n    const override = goal ? parseModelFromGoalCategory(goal.category) : null\n    const overrideModel = override && ALLOWED_MODELS.has(override) ? override : null\n\n    return NextResponse.json({\n      success: true,\n      userEmail: user.email,\n      defaultModel: DEFAULT_MODEL,\n      overrideModel,\n      effectiveModel: overrideModel || DEFAULT_MODEL,\n      allowedModels: Array.from(ALLOWED_MODELS),\n      updatedAt: goal?.updatedAt?.toISOString?.() || null,\n    })\n  } catch (err) {\n    console.error('[admin food-analyzer-model] GET error', err)\n    return NextResponse.json({ error: 'Failed to load food analyzer model' }, { status: 500 })\n  }\n}\n\nexport async function POST(req: NextRequest) {\n  try {\n    const authHeader = req.headers.get('authorization')\n    const admin = extractAdminFromHeaders(authHeader)\n    if (!admin) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const body = await req.json().catch(() => ({} as any))\n    const userEmailRaw = typeof body?.userEmail === 'string' ? body.userEmail : ''\n    const userEmail = userEmailRaw ? normalizeEmail(userEmailRaw) : ''\n    const modelRaw = typeof body?.model === 'string' ? body.model.trim() : ''\n    const model = modelRaw === '' || modelRaw === 'default' ? null : modelRaw\n\n    if (!userEmail) return NextResponse.json({ error: 'Missing userEmail' }, { status: 400 })\n    if (model !== null && !ALLOWED_MODELS.has(model)) {\n      return NextResponse.json({ error: `Unsupported model: ${model}` }, { status: 400 })\n    }\n\n    const user = await prisma.user.findUnique({\n      where: { email: userEmail },\n      select: { id: true, email: true },\n    })\n    if (!user) return NextResponse.json({ error: 'User not found' }, { status: 404 })\n\n    const existing = await prisma.healthGoal.findFirst({\n      where: { userId: user.id, name: FOOD_MODEL_GOAL_NAME },\n      select: { id: true },\n    })\n\n    if (model === null) {\n      if (existing?.id) {\n        await prisma.healthGoal.delete({ where: { id: existing.id } })\n      }\n      return NextResponse.json({\n        success: true,\n        userEmail: user.email,\n        defaultModel: DEFAULT_MODEL,\n        overrideModel: null,\n        effectiveModel: DEFAULT_MODEL,\n      })\n    }\n\n    const payload = JSON.stringify({ model })\n    if (existing?.id) {\n      await prisma.healthGoal.update({\n        where: { id: existing.id },\n        data: { category: payload, currentRating: 0 },\n      })\n    } else {\n      await prisma.healthGoal.create({\n        data: {\n          userId: user.id,\n          name: FOOD_MODEL_GOAL_NAME,\n          category: payload,\n          currentRating: 0,\n        },\n      })\n    }\n\n    return NextResponse.json({\n      success: true,\n      userEmail: user.email,\n      defaultModel: DEFAULT_MODEL,\n      overrideModel: model,\n      effectiveModel: model,\n    })\n  } catch (err) {\n    console.error('[admin food-analyzer-model] POST error', err)\n    return NextResponse.json({ error: 'Failed to update food analyzer model' }, { status: 500 })\n  }\n}\n","truncated":false,"size":4783},{"path":"app/api/admin/food-benchmark/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { extractAdminFromHeaders } from '@/lib/admin-auth'\nimport OpenAI from 'openai'\nimport { chatCompletionWithCost } from '@/lib/metered-openai'\nimport { openaiCostCentsForTokens, costCentsForTokens } from '@/lib/cost-meter'\n\nexport const runtime = 'nodejs'\nexport const dynamic = 'force-dynamic'\n\nconst getOpenAIClient = (): OpenAI | null => {\n  if (!process.env.OPENAI_API_KEY) return null\n  return new OpenAI({ apiKey: process.env.OPENAI_API_KEY })\n}\n\nconst isSafeImageUrl = (url: string) => /^https?:\\/\\//i.test(url) && url.length < 2000\n\nconst buildBenchmarkMessages = (imageUrl: string) => {\n  return [\n    {\n      role: 'user',\n      content: [\n        {\n          type: 'text',\n          text:\n            'Analyze this food image.\\n' +\n            '- Return short, plain ingredient names (no \"several components:\" prefixes).\\n' +\n            '- For sliced produce (e.g., avocado slices), treat as a portion (grams or fraction of whole), NOT \"pieces\".\\n' +\n            '- Be conservative when uncertain and mark guesses.\\n' +\n            'Return ONLY a JSON block with shape:\\n' +\n            '{\"items\":[{\"name\":\"string\",\"brand\":null,\"serving_size\":\"string\",\"servings\":1,\"calories\":0,\"protein_g\":0,\"carbs_g\":0,\"fat_g\":0,\"fiber_g\":0,\"sugar_g\":0,\"isGuess\":false}],\"total\":{\"calories\":0,\"protein_g\":0,\"carbs_g\":0,\"fat_g\":0,\"fiber_g\":0,\"sugar_g\":0}}',\n        },\n        { type: 'image_url', image_url: { url: imageUrl, detail: 'high' } },\n      ],\n    },\n  ]\n}\n\nexport async function POST(req: NextRequest) {\n  try {\n    const authHeader = req.headers.get('authorization')\n    const admin = extractAdminFromHeaders(authHeader)\n    if (!admin) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const body = await req.json().catch(() => ({} as any))\n    const imageUrl = typeof body?.imageUrl === 'string' ? body.imageUrl.trim() : ''\n    const models = Array.isArray(body?.models) ? body.models : []\n    const modelList =\n      models.length > 0\n        ? models.filter((m: any) => typeof m === 'string' && m.trim().length > 0).slice(0, 3)\n        : ['gpt-4o', 'gpt-5.2']\n\n    if (!imageUrl || !isSafeImageUrl(imageUrl)) {\n      return NextResponse.json({ error: 'Provide a public https:// imageUrl' }, { status: 400 })\n    }\n\n    const openai = getOpenAIClient()\n    if (!openai) return NextResponse.json({ error: 'OpenAI not configured' }, { status: 500 })\n\n    const messages = buildBenchmarkMessages(imageUrl)\n\n    const results: any[] = []\n    for (const model of modelList) {\n      const isGpt5Family = model.toLowerCase().includes('gpt-5')\n      const out = await chatCompletionWithCost(openai, {\n        model,\n        messages,\n        ...(isGpt5Family ? { max_completion_tokens: 700 } : { max_tokens: 700 }),\n        temperature: 0,\n      } as any)\n      const text = out.completion.choices?.[0]?.message?.content?.trim?.() || ''\n      const vendorCostCents = openaiCostCentsForTokens(model, {\n        promptTokens: out.promptTokens,\n        completionTokens: out.completionTokens,\n      })\n      const billedCostCents = costCentsForTokens(model, {\n        promptTokens: out.promptTokens,\n        completionTokens: out.completionTokens,\n      })\n      results.push({\n        model,\n        promptTokens: out.promptTokens,\n        completionTokens: out.completionTokens,\n        vendorCostCents,\n        billedCostCents,\n        outputPreview: text.slice(0, 1200),\n      })\n    }\n\n    return NextResponse.json({\n      success: true,\n      imageUrl,\n      results,\n      note:\n        'Benchmark prompt is simplified vs the live analyzer. Use this to compare relative cost/token usage and qualitative output.',\n    })\n  } catch (err: any) {\n    console.error('[admin food-benchmark] error', err)\n    return NextResponse.json({ error: err?.message || 'Benchmark failed' }, { status: 500 })\n  }\n}\n","truncated":false,"size":3904},{"path":"app/api/admin/food-cost-sim/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\nimport { extractAdminFromHeaders } from '@/lib/admin-auth'\nimport { costCentsForTokens, openaiCostCentsForTokens } from '@/lib/cost-meter'\n\nexport const runtime = 'nodejs'\nexport const dynamic = 'force-dynamic'\n\nconst parseRangeDays = (raw: string | null): number => {\n  const n = Number(raw)\n  if (!Number.isFinite(n) || n <= 0) return 7\n  return Math.min(365, Math.max(1, Math.floor(n)))\n}\n\nconst avg = (nums: number[]) => {\n  if (!nums.length) return 0\n  return nums.reduce((a, b) => a + b, 0) / nums.length\n}\n\nexport async function GET(req: NextRequest) {\n  try {\n    const authHeader = req.headers.get('authorization')\n    const admin = extractAdminFromHeaders(authHeader)\n    if (!admin) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const { searchParams } = new URL(req.url)\n    const rangeDays = parseRangeDays(searchParams.get('rangeDays'))\n\n    const now = new Date()\n    const start = new Date(now.getTime() - rangeDays * 24 * 60 * 60 * 1000)\n\n    // Prefer the per-image usage logs (avoid double-counting the later aggregate \"food:analysis\" event).\n    const rows = await prisma.aIUsageEvent.findMany({\n      where: {\n        createdAt: { gte: start, lte: now },\n        success: true,\n        endpoint: '/api/analyze-food',\n        OR: [{ feature: 'food:image-analysis' }, { feature: 'food:image-reanalysis' }],\n      },\n      select: {\n        model: true,\n        promptTokens: true,\n        completionTokens: true,\n        totalTokens: true,\n        costCents: true,\n      },\n      orderBy: { createdAt: 'desc' },\n      take: 500,\n    })\n\n    const promptTokens = rows.map((r) => Number(r.promptTokens || 0)).filter((n) => n > 0)\n    const completionTokens = rows.map((r) => Number(r.completionTokens || 0)).filter((n) => n >= 0)\n    const totalTokens = rows\n      .map((r) => Number(r.totalTokens || (Number(r.promptTokens || 0) + Number(r.completionTokens || 0))))\n      .filter((n) => n > 0)\n    const billedCostCents = rows.map((r) => Number(r.costCents || 0)).filter((n) => n >= 0)\n\n    const avgPrompt = Math.round(avg(promptTokens))\n    const avgCompletion = Math.round(avg(completionTokens))\n    const avgTotal = Math.round(avg(totalTokens))\n    const avgBilled = Math.round(avg(billedCostCents))\n\n    const simulate = (model: string) => {\n      const vendor = openaiCostCentsForTokens(model, { promptTokens: avgPrompt, completionTokens: avgCompletion })\n      const billed = costCentsForTokens(model, { promptTokens: avgPrompt, completionTokens: avgCompletion })\n      const analysesPer1400 = avgTotal > 0 ? Math.floor(1400 / Math.max(1, billed)) : 0\n      return {\n        model,\n        vendorCostCents: vendor,\n        billedCostCents: billed,\n        analysesPer1400Credits: analysesPer1400,\n      }\n    }\n\n    // Models to compare (you can add/remove in the UI)\n    const simulations = [\n      simulate('gpt-4o'),\n      simulate('gpt-5.2'),\n      simulate('gpt-5-mini'),\n      simulate('gpt-5.2-pro'),\n    ]\n\n    return NextResponse.json({\n      success: true,\n      rangeDays,\n      samples: rows.length,\n      averages: {\n        promptTokens: avgPrompt,\n        completionTokens: avgCompletion,\n        totalTokens: avgTotal,\n        billedCostCents: avgBilled,\n      },\n      simulations,\n      notes: {\n        interpretation:\n          'Simulated costs assume token usage stays the same when switching models. Real token usage and accuracy may change; use the benchmark tool for head-to-head tests.',\n        credits: 'Helfi credits are cents. 1400 credits is the current $20/month plan mapping.',\n        sampling: 'This is based on up to 500 recent food:image-* events within the selected range.',\n      },\n    })\n  } catch (err) {\n    console.error('[admin food-cost-sim] error', err)\n    return NextResponse.json({ error: 'Failed to compute food cost simulation' }, { status: 500 })\n  }\n}\n","truncated":false,"size":3965},{"path":"app/api/admin/init-templates/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { PrismaClient } from '@prisma/client'\nimport { extractAdminFromHeaders } from '@/lib/admin-auth'\n\nconst prisma = new PrismaClient()\n\nexport async function POST(request: NextRequest) {\n  try {\n    const authHeader = request.headers.get('authorization')\n    const admin = extractAdminFromHeaders(authHeader)\n    if (!admin) {\n      return NextResponse.json({ error: 'Invalid token' }, { status: 401 })\n    }\n\n    // Use raw SQL to create table and insert templates\n    await prisma.$executeRaw`\n      CREATE TABLE IF NOT EXISTS \"EmailTemplate\" (\n        \"id\" TEXT NOT NULL,\n        \"name\" TEXT NOT NULL,\n        \"category\" TEXT NOT NULL DEFAULT 'MARKETING',\n        \"subject\" TEXT NOT NULL,\n        \"content\" TEXT NOT NULL,\n        \"isActive\" BOOLEAN NOT NULL DEFAULT true,\n        \"isBuiltIn\" BOOLEAN NOT NULL DEFAULT false,\n        \"createdBy\" TEXT,\n        \"createdAt\" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,\n        \"updatedAt\" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,\n        \n        CONSTRAINT \"EmailTemplate_pkey\" PRIMARY KEY (\"id\")\n      );\n    `\n\n    // Check if templates already exist\n    const count = await prisma.$queryRaw`SELECT COUNT(*) as count FROM \"EmailTemplate\"` as any[]\n    const templateCount = parseInt(count[0]?.count || '0')\n    \n    if (templateCount > 0) {\n      return NextResponse.json({ \n        message: 'Templates already initialized',\n        count: templateCount \n      })\n    }\n\n    // Insert built-in templates using raw SQL\n    const templateId1 = 'tmpl_' + Math.random().toString(36).substring(2)\n    const templateId2 = 'tmpl_' + Math.random().toString(36).substring(2)\n    const templateId3 = 'tmpl_' + Math.random().toString(36).substring(2)\n    const templateId4 = 'tmpl_' + Math.random().toString(36).substring(2)\n    const templateId5 = 'tmpl_' + Math.random().toString(36).substring(2)\n\n    await prisma.$executeRaw`\n      INSERT INTO \"EmailTemplate\" (\"id\", \"name\", \"category\", \"subject\", \"content\", \"isBuiltIn\", \"createdBy\") VALUES\n      (${templateId1}, 'Welcome Email', 'ONBOARDING', 'üéâ Welcome to Helfi - Your AI Health Journey Begins!', \n       'Hi {name},\\n\\nWelcome to the Helfi community! We''re thrilled to have you on board.\\n\\nüöÄ Getting Started:\\n‚Ä¢ Complete your health profile for personalized insights\\n‚Ä¢ Start logging your meals with AI-powered analysis\\n‚Ä¢ Set your health goals and track your progress\\n‚Ä¢ Explore our medication interaction checker\\n\\nüí° Pro Tip: The more you use Helfi, the smarter your AI health coach becomes!\\n\\nNeed help getting started? Just reply to this email or contact our support team.\\n\\nBest regards,\\nThe Helfi Team', \n       true, ${admin.adminId}),\n      (${templateId2}, 'Premium Upgrade', 'MARKETING', 'üî• Unlock Your Full Health Potential with Helfi Premium',\n       'Hi {name},\\n\\nReady to supercharge your health journey? Helfi Premium gives you everything you need:\\n\\n‚ú® Premium Benefits:\\n‚Ä¢ 30 AI food analyses per day (vs 3 on free)\\n‚Ä¢ 30 medical image analyses per day\\n‚Ä¢ Advanced medication interaction checking\\n‚Ä¢ Priority customer support\\n‚Ä¢ Early access to new features\\n\\nüéØ Special Offer: Get 14 days free when you upgrade today!\\n\\n[Upgrade to Premium - helfi.ai/billing]\\n\\nYour health deserves the best tools. Let''s make it happen!\\n\\nBest regards,\\nThe Helfi Team',\n       true, ${admin.adminId}),\n      (${templateId3}, 'Re-engagement', 'RETENTION', 'üåü Your Health Journey Awaits - Come Back to Helfi!',\n       'Hi {name},\\n\\nWe miss you at Helfi! Your health journey is important, and we''re here to support you every step of the way.\\n\\nüéØ Quick Health Check:\\n‚Ä¢ Log today''s meals in under 2 minutes\\n‚Ä¢ Check if your medications interact safely\\n‚Ä¢ Review your progress toward your health goals\\n\\nüí™ Remember: Small daily actions lead to big health transformations.\\n\\nReady to continue your journey? We''re excited to see your progress!\\n\\n[Continue Your Journey - helfi.ai]\\n\\nBest regards,\\nThe Helfi Team',\n       true, ${admin.adminId}),\n      (${templateId4}, 'Feature Announcement', 'ANNOUNCEMENTS', 'üÜï Exciting New Features Just Dropped at Helfi!',\n       'Hi {name},\\n\\nBig news! We''ve just released some amazing new features that will take your health journey to the next level:\\n\\nüî• What''s New:\\n‚Ä¢ Enhanced AI food analysis with better accuracy\\n‚Ä¢ New medical image analysis for skin conditions\\n‚Ä¢ Improved medication interaction database\\n‚Ä¢ Faster mobile app performance\\n‚Ä¢ Smart health insights dashboard\\n\\n‚ú® Ready to explore? Log in to your Helfi account and discover these powerful new tools.\\n\\n[Explore New Features - helfi.ai]\\n\\nYour feedback helps us build better health tools. Let us know what you think!\\n\\nBest regards,\\nThe Helfi Team',\n       true, ${admin.adminId}),\n      (${templateId5}, 'Support Follow-up', 'SUPPORT', 'ü§ù Following Up - How Can We Help You Better?',\n       'Hi {name},\\n\\nHope you''re doing well! We wanted to follow up and see how your experience with Helfi has been going.\\n\\nü§î We''d love to know:\\n‚Ä¢ Are you finding the features helpful?\\n‚Ä¢ Is there anything confusing or frustrating?\\n‚Ä¢ What would make Helfi even better for you?\\n\\nüí¨ Your feedback matters! Just reply to this email with your thoughts - our team reads every response personally.\\n\\nüÜò Need immediate help? Contact us at support@helfi.ai\\n\\nThank you for being part of the Helfi community!\\n\\nBest regards,\\nThe Helfi Team',\n       true, ${admin.adminId})\n    `\n\n    return NextResponse.json({ \n      message: 'Email templates initialized successfully!',\n      created: 5,\n      templates: ['Welcome Email', 'Premium Upgrade', 'Re-engagement', 'Feature Announcement', 'Support Follow-up']\n    })\n  } catch (error) {\n    console.error('Error initializing email templates:', error)\n    return NextResponse.json({ \n      error: 'Failed to initialize templates',\n      details: error instanceof Error ? error.message : 'Unknown error'\n    }, { status: 500 })\n  }\n} \n","truncated":false,"size":6059},{"path":"app/api/admin/management/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\nimport { extractAdminFromHeaders } from '@/lib/admin-auth'\nimport bcrypt from 'bcryptjs'\n\nexport async function GET(request: NextRequest) {\n  try {\n    // JWT authentication check\n    const authHeader = request.headers.get('authorization')\n    const admin = extractAdminFromHeaders(authHeader)\n    if (!admin) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    // Only SUPER_ADMIN can view admin list\n    if (admin.role !== 'SUPER_ADMIN') {\n      return NextResponse.json({ error: 'Insufficient permissions' }, { status: 403 })\n    }\n\n    const admins = await prisma.adminUser.findMany({\n      select: {\n        id: true,\n        email: true,\n        name: true,\n        role: true,\n        isActive: true,\n        lastLogin: true,\n        createdAt: true,\n        createdBy: true\n      },\n      orderBy: { createdAt: 'desc' }\n    })\n\n    return NextResponse.json({ admins })\n\n  } catch (error) {\n    console.error('Error fetching admin list:', error)\n    return NextResponse.json({ error: 'Failed to fetch admin list' }, { status: 500 })\n  }\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    // JWT authentication check\n    const authHeader = request.headers.get('authorization')\n    const admin = extractAdminFromHeaders(authHeader)\n    if (!admin) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const { action, email, name, password, role, currentPassword, newPassword } = await request.json()\n\n    switch (action) {\n      case 'create':\n        // Only SUPER_ADMIN can create new admins\n        if (admin.role !== 'SUPER_ADMIN') {\n          return NextResponse.json({ error: 'Insufficient permissions' }, { status: 403 })\n        }\n\n        if (!email || !name || !password || !role) {\n          return NextResponse.json({ error: 'All fields are required' }, { status: 400 })\n        }\n\n        // Check if admin email already exists\n        const existingAdmin = await prisma.adminUser.findUnique({\n          where: { email: email.toLowerCase() }\n        })\n\n        if (existingAdmin) {\n          return NextResponse.json({ error: 'Admin with this email already exists' }, { status: 409 })\n        }\n\n        // Hash the password\n        const saltRounds = 12\n        const hashedPassword = await bcrypt.hash(password, saltRounds)\n\n        // Create new admin\n        const newAdmin = await prisma.adminUser.create({\n          data: {\n            email: email.toLowerCase(),\n            password: hashedPassword,\n            name,\n            role,\n            createdBy: admin.adminId\n          }\n        })\n\n        return NextResponse.json({ \n          success: true, \n          message: 'Admin created successfully',\n          adminId: newAdmin.id \n        })\n\n      case 'change_password':\n        if (!currentPassword || !newPassword) {\n          return NextResponse.json({ error: 'Current and new passwords are required' }, { status: 400 })\n        }\n\n        // Get current admin data\n        const currentAdmin = await prisma.adminUser.findUnique({\n          where: { id: admin.adminId }\n        })\n\n        if (!currentAdmin) {\n          return NextResponse.json({ error: 'Admin not found' }, { status: 404 })\n        }\n\n        // Verify current password\n        const passwordMatch = await bcrypt.compare(currentPassword, currentAdmin.password)\n        if (!passwordMatch) {\n          return NextResponse.json({ error: 'Current password is incorrect' }, { status: 401 })\n        }\n\n        // Hash new password\n        const newHashedPassword = await bcrypt.hash(newPassword, 12)\n\n        // Update password\n        await prisma.adminUser.update({\n          where: { id: admin.adminId },\n          data: { password: newHashedPassword }\n        })\n\n        return NextResponse.json({ \n          success: true, \n          message: 'Password changed successfully' \n        })\n\n      default:\n        return NextResponse.json({ error: 'Invalid action' }, { status: 400 })\n    }\n\n  } catch (error) {\n    console.error('Error in admin management:', error)\n    return NextResponse.json({ error: 'Failed to perform admin action' }, { status: 500 })\n  }\n} ","truncated":false,"size":4253},{"path":"app/api/admin/migrate/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\n\nexport async function POST(request: NextRequest) {\n  try {\n    const { migrationKey } = await request.json()\n\n    // Special migration key to prevent unauthorized table creation\n    if (migrationKey !== 'HelfiMigrate2024!SecureSetup') {\n      return NextResponse.json({ error: 'Invalid migration key' }, { status: 401 })\n    }\n\n    // Create AdminUser table using raw SQL\n    await prisma.$executeRaw`\n      CREATE TABLE IF NOT EXISTS \"AdminUser\" (\n        \"id\" TEXT NOT NULL PRIMARY KEY,\n        \"email\" TEXT NOT NULL UNIQUE,\n        \"password\" TEXT NOT NULL,\n        \"name\" TEXT NOT NULL,\n        \"role\" TEXT NOT NULL DEFAULT 'ADMIN',\n        \"isActive\" BOOLEAN NOT NULL DEFAULT true,\n        \"lastLogin\" TIMESTAMP,\n        \"createdAt\" TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n        \"updatedAt\" TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n        \"createdBy\" TEXT\n      );\n    `\n\n    return NextResponse.json({ \n      success: true, \n      message: 'AdminUser table created successfully' \n    })\n\n  } catch (error) {\n    console.error('Error creating AdminUser table:', error)\n    return NextResponse.json({ \n      error: 'Migration failed',\n      details: error instanceof Error ? error.message : 'Unknown error'\n    }, { status: 500 })\n  }\n} ","truncated":false,"size":1350},{"path":"app/api/admin/partner-outreach/init/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\nimport { extractAdminFromHeaders } from '@/lib/admin-auth'\nimport { partnerOutreachSeed } from '@/lib/partner-outreach-seed'\n\nconst ensureAdmin = (request: NextRequest) => {\n  const authHeader = request.headers.get('authorization')\n  const admin = extractAdminFromHeaders(authHeader)\n  if (!admin) {\n    return null\n  }\n  return admin\n}\n\nconst ensurePartnerOutreachSchema = async () => {\n  await prisma.$executeRawUnsafe(`\n    CREATE TABLE IF NOT EXISTS \"PartnerOutreachContact\" (\n      \"id\" TEXT NOT NULL,\n      \"name\" TEXT NOT NULL,\n      \"email\" TEXT,\n      \"company\" TEXT NOT NULL,\n      \"region\" TEXT,\n      \"notes\" TEXT,\n      \"sourceUrl\" TEXT,\n      \"unsubscribed\" BOOLEAN NOT NULL DEFAULT false,\n      \"createdAt\" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,\n      \"updatedAt\" TIMESTAMP(3) NOT NULL,\n      CONSTRAINT \"PartnerOutreachContact_pkey\" PRIMARY KEY (\"id\")\n    );\n  `)\n  await prisma.$executeRawUnsafe(`\n    CREATE UNIQUE INDEX IF NOT EXISTS \"PartnerOutreachContact_email_key\"\n    ON \"PartnerOutreachContact\"(\"email\");\n  `)\n  await prisma.$executeRawUnsafe(`\n    CREATE INDEX IF NOT EXISTS \"PartnerOutreachContact_company_idx\"\n    ON \"PartnerOutreachContact\"(\"company\");\n  `)\n}\n\nexport async function POST(request: NextRequest) {\n  const admin = ensureAdmin(request)\n  if (!admin) {\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  }\n\n  try {\n    await ensurePartnerOutreachSchema()\n    const data = partnerOutreachSeed.map(entry => ({\n      name: entry.name.trim(),\n      email: entry.email.trim().toLowerCase(),\n      company: entry.company.trim(),\n      region: entry.region ? entry.region.trim() : null,\n      notes: entry.notes ? entry.notes.trim() : null,\n      sourceUrl: entry.sourceUrl ? entry.sourceUrl.trim() : null,\n      unsubscribed: false\n    }))\n\n    const result = await prisma.partnerOutreachContact.createMany({\n      data,\n      skipDuplicates: true\n    })\n\n    return NextResponse.json({ createdCount: result.count })\n  } catch (error: any) {\n    console.error('Error initializing partner outreach contacts:', error)\n    return NextResponse.json({ error: 'Failed to initialize contacts' }, { status: 500 })\n  }\n}\n","truncated":false,"size":2275},{"path":"app/api/admin/partner-outreach/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\nimport { extractAdminFromHeaders } from '@/lib/admin-auth'\n\nconst normalizeEmail = (email?: string | null) => {\n  const trimmed = (email || '').trim().toLowerCase()\n  return trimmed.length > 0 ? trimmed : null\n}\n\nconst ensureAdmin = (request: NextRequest) => {\n  const authHeader = request.headers.get('authorization')\n  const admin = extractAdminFromHeaders(authHeader)\n  if (!admin) {\n    return null\n  }\n  return admin\n}\n\nconst ensurePartnerOutreachSchema = async () => {\n  await prisma.$executeRawUnsafe(`\n    CREATE TABLE IF NOT EXISTS \"PartnerOutreachContact\" (\n      \"id\" TEXT NOT NULL,\n      \"name\" TEXT NOT NULL,\n      \"email\" TEXT,\n      \"company\" TEXT NOT NULL,\n      \"region\" TEXT,\n      \"notes\" TEXT,\n      \"sourceUrl\" TEXT,\n      \"unsubscribed\" BOOLEAN NOT NULL DEFAULT false,\n      \"createdAt\" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,\n      \"updatedAt\" TIMESTAMP(3) NOT NULL,\n      CONSTRAINT \"PartnerOutreachContact_pkey\" PRIMARY KEY (\"id\")\n    );\n  `)\n  await prisma.$executeRawUnsafe(`\n    CREATE UNIQUE INDEX IF NOT EXISTS \"PartnerOutreachContact_email_key\"\n    ON \"PartnerOutreachContact\"(\"email\");\n  `)\n  await prisma.$executeRawUnsafe(`\n    CREATE INDEX IF NOT EXISTS \"PartnerOutreachContact_company_idx\"\n    ON \"PartnerOutreachContact\"(\"company\");\n  `)\n}\n\nexport async function GET(request: NextRequest) {\n  const admin = ensureAdmin(request)\n  if (!admin) {\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  }\n\n  try {\n    await ensurePartnerOutreachSchema()\n    const contacts = await prisma.partnerOutreachContact.findMany({\n      orderBy: [{ company: 'asc' }, { name: 'asc' }]\n    })\n\n    return NextResponse.json({ contacts })\n  } catch (error: any) {\n    console.error('Error fetching partner outreach contacts:', error)\n    return NextResponse.json({ error: 'Failed to fetch contacts' }, { status: 500 })\n  }\n}\n\nexport async function POST(request: NextRequest) {\n  const admin = ensureAdmin(request)\n  if (!admin) {\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  }\n\n  try {\n    await ensurePartnerOutreachSchema()\n    const body = await request.json()\n    const contacts = Array.isArray(body?.contacts) ? body.contacts : [body]\n\n    const normalized = contacts\n      .map((contact: any) => ({\n        name: (contact?.name || '').trim(),\n        email: normalizeEmail(contact?.email),\n        company: (contact?.company || '').trim(),\n        region: contact?.region ? String(contact.region).trim() : null,\n        notes: contact?.notes ? String(contact.notes).trim() : null,\n        sourceUrl: contact?.sourceUrl ? String(contact.sourceUrl).trim() : null,\n        unsubscribed: Boolean(contact?.unsubscribed)\n      }))\n      .filter((contact: any) => contact.name && contact.company)\n\n    if (normalized.length === 0) {\n      return NextResponse.json({ error: 'No valid contacts provided' }, { status: 400 })\n    }\n\n    const result = await prisma.partnerOutreachContact.createMany({\n      data: normalized,\n      skipDuplicates: true\n    })\n\n    return NextResponse.json({ createdCount: result.count })\n  } catch (error: any) {\n    console.error('Error creating partner outreach contacts:', error)\n    return NextResponse.json({ error: 'Failed to create contacts' }, { status: 500 })\n  }\n}\n\nexport async function DELETE(request: NextRequest) {\n  const admin = ensureAdmin(request)\n  if (!admin) {\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  }\n\n  try {\n    const url = new URL(request.url)\n    const id = url.searchParams.get('id')\n\n    if (!id) {\n      return NextResponse.json({ error: 'Contact ID is required' }, { status: 400 })\n    }\n\n    await prisma.partnerOutreachContact.delete({ where: { id } })\n\n    return NextResponse.json({ message: 'Contact deleted' })\n  } catch (error: any) {\n    console.error('Error deleting partner outreach contact:', error)\n    return NextResponse.json({ error: 'Failed to delete contact' }, { status: 500 })\n  }\n}\n","truncated":false,"size":4069},{"path":"app/api/admin/push-logs/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\nimport { extractAdminFromHeaders } from '@/lib/admin-auth'\n\nexport async function GET(req: NextRequest) {\n  try {\n    const authHeader = req.headers.get('authorization')\n    const admin = extractAdminFromHeaders(authHeader)\n    if (!admin) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    await prisma.$executeRawUnsafe(`\n      CREATE TABLE IF NOT EXISTS OwnerPushLog (\n        createdAt TIMESTAMP NOT NULL DEFAULT NOW(),\n        event TEXT,\n        userEmail TEXT,\n        status TEXT,\n        info TEXT\n      )\n    `)\n\n    const rows: Array<{ createdAt: Date; event: string; userEmail: string; status: string; info: string | null }> =\n      await prisma.$queryRawUnsafe(\n        `SELECT createdAt, event, userEmail, status, info\n         FROM OwnerPushLog\n         ORDER BY createdAt DESC\n         LIMIT 50`\n      )\n\n    return NextResponse.json({ logs: rows })\n  } catch (e) {\n    console.error('[ADMIN PUSH LOGS] error', e)\n    return NextResponse.json({ error: 'Failed to fetch logs' }, { status: 500 })\n  }\n}\n\nexport const runtime = 'nodejs'\nexport const dynamic = 'force-dynamic'\n\n","truncated":false,"size":1221},{"path":"app/api/admin/push-subscribe/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\nimport { extractAdminFromHeaders } from '@/lib/admin-auth'\nimport { mergeSubscriptionList, normalizeSubscriptionList } from '@/lib/push-subscriptions'\n\nasync function ensurePushSubscriptionsTable() {\n  await prisma.$executeRawUnsafe(`\n    CREATE TABLE IF NOT EXISTS PushSubscriptions (\n      userId TEXT PRIMARY KEY,\n      subscription JSONB NOT NULL,\n      updatedAt TIMESTAMP NOT NULL DEFAULT NOW()\n    )\n  `)\n  await prisma.$executeRawUnsafe(\n    `ALTER TABLE PushSubscriptions ADD COLUMN IF NOT EXISTS updatedAt TIMESTAMP NOT NULL DEFAULT NOW()`\n  ).catch(() => {})\n}\n\nexport async function POST(req: NextRequest) {\n  try {\n    // Verify admin authentication\n    const authHeader = req.headers.get('authorization')\n    const admin = extractAdminFromHeaders(authHeader)\n    \n    if (!admin) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const adminEmail = admin.email.toLowerCase()\n\n    const { subscription } = await req.json()\n    if (!subscription) {\n      return NextResponse.json({ error: 'Missing subscription' }, { status: 400 })\n    }\n\n    // Find or create User account for admin (push subscriptions use User table)\n    let user = await prisma.user.findUnique({\n      where: { email: adminEmail }\n    })\n\n    if (!user) {\n      // Create a User account for the admin (for push notifications)\n      user = await prisma.user.create({\n        data: {\n          email: adminEmail,\n          name: adminEmail.split('@')[0],\n          emailVerified: new Date() // Auto-verify admin accounts\n        }\n      })\n    }\n\n    // Save push subscription\n    await ensurePushSubscriptionsTable()\n    const rows: Array<{ subscription: any }> = await prisma.$queryRawUnsafe(\n      `SELECT subscription FROM PushSubscriptions WHERE userId = $1`,\n      user.id\n    )\n    const merged = mergeSubscriptionList(rows[0]?.subscription, subscription)\n    if (rows.length) {\n      await prisma.$executeRawUnsafe(\n        `UPDATE PushSubscriptions SET subscription = $2::jsonb, updatedAt = NOW() WHERE userId = $1`,\n        user.id,\n        JSON.stringify(merged)\n      )\n    } else {\n      await prisma.$executeRawUnsafe(\n        `INSERT INTO PushSubscriptions (userId, subscription, updatedAt) VALUES ($1, $2::jsonb, NOW())`,\n        user.id,\n        JSON.stringify(merged)\n      )\n    }\n\n    return NextResponse.json({ success: true, subscriptionCount: merged.length })\n  } catch (e) {\n    console.error('admin push subscribe save error', e)\n    return NextResponse.json({ error: 'Failed to save subscription' }, { status: 500 })\n  }\n}\n\nexport async function GET(req: NextRequest) {\n  try {\n    // Verify admin authentication\n    const authHeader = req.headers.get('authorization')\n    const admin = extractAdminFromHeaders(authHeader)\n    \n    if (!admin) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const adminEmail = admin.email.toLowerCase()\n\n    // Find User account for admin\n    const user = await prisma.user.findUnique({\n      where: { email: adminEmail },\n      select: { id: true }\n    })\n\n    if (!user) {\n      return NextResponse.json({ hasSubscription: false })\n    }\n\n    // Check for push subscription\n    await ensurePushSubscriptionsTable()\n    \n    const rows: Array<{ subscription: any; updatedAt: Date | null }> = await prisma.$queryRawUnsafe(\n      `SELECT subscription, updatedAt FROM PushSubscriptions WHERE userId = $1`,\n      user.id\n    )\n    const subscriptionCount = rows.length ? normalizeSubscriptionList(rows[0].subscription).length : 0\n\n    return NextResponse.json({\n      hasSubscription: subscriptionCount > 0,\n      lastUpdated: rows[0]?.updatedAt ?? null,\n      subscriptionCount\n    })\n  } catch (e) {\n    console.error('admin push status error', e)\n    return NextResponse.json({ error: 'Failed to check status' }, { status: 500 })\n  }\n}\n\nexport async function DELETE(req: NextRequest) {\n  try {\n    // Verify admin authentication\n    const authHeader = req.headers.get('authorization')\n    const admin = extractAdminFromHeaders(authHeader)\n    \n    if (!admin) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const adminEmail = admin.email.toLowerCase()\n\n    // Find User account for admin\n    const user = await prisma.user.findUnique({\n      where: { email: adminEmail },\n      select: { id: true }\n    })\n    if (!user) {\n      return NextResponse.json({ success: true }) // nothing to delete\n    }\n\n    // Ensure table and delete subscription\n    await ensurePushSubscriptionsTable()\n    await prisma.$executeRawUnsafe(\n      `DELETE FROM PushSubscriptions WHERE userId = $1`,\n      user.id\n    )\n\n    return NextResponse.json({ success: true })\n  } catch (e) {\n    console.error('admin push unsubscribe error', e)\n    return NextResponse.json({ error: 'Failed to unsubscribe' }, { status: 500 })\n  }\n}\n","truncated":false,"size":4958},{"path":"app/api/admin/push-test/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { extractAdminFromHeaders } from '@/lib/admin-auth'\nimport { notifyOwner } from '@/lib/owner-notifications'\n\nexport async function POST(req: NextRequest) {\n  try {\n    const authHeader = req.headers.get('authorization')\n    const admin = extractAdminFromHeaders(authHeader)\n    if (!admin) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    await notifyOwner({\n      event: 'signup',\n      userEmail: 'test@helfi.ai',\n      userName: 'Test User',\n    })\n\n    return NextResponse.json({ ok: true })\n  } catch (e: any) {\n    console.error('[ADMIN PUSH TEST] error', e?.stack || e)\n    return NextResponse.json({ error: 'Failed to enqueue test notification' }, { status: 500 })\n  }\n}\n\nexport const runtime = 'nodejs'\nexport const dynamic = 'force-dynamic'\n\n","truncated":false,"size":854},{"path":"app/api/admin/qr-generate/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\nimport { extractAdminFromHeaders } from '@/lib/admin-auth'\nimport jwt from 'jsonwebtoken'\nimport crypto from 'crypto'\n\nconst JWT_SECRET = process.env.JWT_SECRET || process.env.NEXTAUTH_SECRET\n\nasync function resolveAdminInfo(authHeader: string | null) {\n  const admin = extractAdminFromHeaders(authHeader)\n  if (admin) {\n    return { adminId: admin.adminId, email: admin.email.toLowerCase() }\n  }\n  return null\n}\n\n// Ensure QR tokens table exists\nasync function ensureQRTokensTable() {\n  await prisma.$executeRawUnsafe(`\n    CREATE TABLE IF NOT EXISTS QRTokens (\n      token TEXT PRIMARY KEY,\n      adminId TEXT NOT NULL,\n      email TEXT NOT NULL,\n      expiresAt BIGINT NOT NULL,\n      createdAt TIMESTAMP DEFAULT NOW()\n    )\n  `)\n}\n\n// Clean up expired tokens (run on each request to avoid stale data)\nasync function cleanupExpiredTokens() {\n  const now = Date.now()\n  await prisma.$executeRawUnsafe(\n    `DELETE FROM QRTokens WHERE expiresAt < $1`,\n    now\n  )\n}\n\nexport async function GET(request: NextRequest) {\n  try {\n    if (!JWT_SECRET) {\n      return NextResponse.json({ error: 'Admin login secret not configured' }, { status: 500 })\n    }\n    // Verify admin is authenticated (support legacy desktop token)\n    const authHeader = request.headers.get('authorization')\n    console.log('[QR-GEN] Received request with auth header:', authHeader ? 'Bearer ***' : 'none')\n    \n    const adminInfo = await resolveAdminInfo(authHeader)\n    \n    if (!adminInfo) {\n      console.error('[QR-GEN] Failed to resolve admin info')\n      return NextResponse.json({ \n        error: 'Unauthorized - Could not identify admin user. Make sure OWNER_EMAIL is set correctly.' \n      }, { status: 401 })\n    }\n    \n    console.log('[QR-GEN] Resolved admin info:', { adminId: adminInfo.adminId, email: adminInfo.email })\n\n    // Ensure table exists and clean up expired tokens\n    await ensureQRTokensTable()\n    await cleanupExpiredTokens()\n\n    // Generate a unique QR token (valid for 5 minutes)\n    const qrToken = crypto.randomBytes(32).toString('hex')\n    const expiresAt = Date.now() + 5 * 60 * 1000 // 5 minutes\n\n    // Store token in database\n    await prisma.$executeRawUnsafe(\n      `INSERT INTO QRTokens (token, adminId, email, expiresAt) VALUES ($1, $2, $3, $4)`,\n      qrToken,\n      adminInfo.adminId,\n      adminInfo.email,\n      expiresAt\n    )\n\n    // Verify insert (debug)\n    try {\n      const verifyRows: Array<{ token: string }> = await prisma.$queryRawUnsafe(\n        `SELECT token FROM QRTokens WHERE token = $1`,\n        qrToken\n      )\n      console.log('[QR-GEN] Insert verify for token prefix:', qrToken.substring(0, 20), 'found:', verifyRows.length)\n    } catch (e) {\n      console.log('[QR-GEN] Insert verification query failed')\n    }\n\n    // Get app URL from request or environment\n    const origin = request.headers.get('origin') || request.headers.get('host')\n    const protocol = request.headers.get('x-forwarded-proto') || 'https'\n    const baseUrl = process.env.NEXT_PUBLIC_APP_URL || \n                    (origin ? `${protocol}://${origin}` : 'https://helfi.ai')\n    \n    // Return QR code data URL\n    const qrData = {\n      token: qrToken,\n      url: `${baseUrl}/admin-panel/qr-login?token=${qrToken}`,\n      expiresAt\n    }\n\n    return NextResponse.json({ success: true, qrData })\n  } catch (error: any) {\n    console.error('[QR-GEN] Error generating QR code:', error)\n    return NextResponse.json({ \n      error: `Failed to generate QR code: ${error?.message || 'Unknown error'}` \n    }, { status: 500 })\n  }\n}\n\n// Endpoint to verify QR token and get admin info\nexport async function POST(request: NextRequest) {\n  try {\n    if (!JWT_SECRET) {\n      return NextResponse.json({ error: 'Admin login secret not configured' }, { status: 500 })\n    }\n    const body = await request.json()\n    const token = typeof body?.token === 'string' ? body.token.trim() : ''\n\n    console.log('[QR-VERIFY] Received token:', token ? `${token.substring(0, 20)}... (length: ${token.length})` : 'null')\n\n    if (!token) {\n      console.error('[QR-VERIFY] No token provided')\n      return NextResponse.json({ error: 'Token required' }, { status: 400 })\n    }\n\n    // Ensure table exists and clean up expired tokens\n    await ensureQRTokensTable()\n    await cleanupExpiredTokens()\n\n    // Check how many tokens exist in database (for debugging)\n    const allTokens: Array<{ token: string }> = await prisma.$queryRawUnsafe(`SELECT token FROM QRTokens`)\n    console.log('[QR-VERIFY] Total tokens in database:', allTokens.length)\n\n    // Look up token in database with explicit aliases to preserve casing of keys\n    const rows: Array<{ adminId: string; email: string; expiresAt: any }> = await prisma.$queryRawUnsafe(\n      `SELECT adminId AS \"adminId\", email AS \"email\", expiresAt AS \"expiresAt\" FROM QRTokens WHERE token = $1`,\n      token\n    )\n\n    console.log('[QR-VERIFY] Token lookup result:', rows.length > 0 ? 'Found' : 'Not found')\n\n    if (!rows.length) {\n      console.log('[QR-VERIFY] Token not found in database:', token.substring(0, 20))\n      // Log first few tokens in DB for comparison\n      if (allTokens.length > 0) {\n        console.log('[QR-VERIFY] Sample tokens in DB:', allTokens.slice(0, 3).map(t => t.token.substring(0, 20)))\n      }\n      return NextResponse.json({ error: 'Invalid or expired token' }, { status: 401 })\n    }\n\n    const qrData = rows[0]\n    // Normalize BIGINT from Postgres to Number before comparing\n    const expiresAtMs =\n      typeof (qrData as any).expiresAt === 'bigint'\n        ? Number((qrData as any).expiresAt)\n        : Number((qrData as any).expiresAt)\n\n    if (Number.isNaN(expiresAtMs)) {\n      console.error('[QR-VERIFY] Invalid expiresAt value for token prefix:', token.substring(0, 20))\n      return NextResponse.json({ error: 'Invalid or expired token' }, { status: 401 })\n    }\n\n    if (expiresAtMs < Date.now()) {\n      // Delete expired token\n      await prisma.$executeRawUnsafe(`DELETE FROM QRTokens WHERE token = $1`, token)\n      return NextResponse.json({ error: 'Token expired' }, { status: 401 })\n    }\n\n    // Get admin user details\n    const adminUser = await prisma.adminUser.findUnique({\n      where: { id: qrData.adminId },\n      select: {\n        id: true,\n        email: true,\n        name: true,\n        role: true,\n        isActive: true\n      }\n    })\n\n    if (!adminUser || (adminUser as any).isActive === false) {\n      return NextResponse.json({ error: 'Admin user not found or inactive' }, { status: 404 })\n    }\n\n    // Create JWT token for the mobile session\n    const jwtToken = jwt.sign(\n      {\n        adminId: adminUser.id,\n        email: adminUser.email,\n        role: adminUser.role\n      },\n      JWT_SECRET,\n      { expiresIn: '24h' }\n    )\n\n    // Remove QR token (one-time use)\n    await prisma.$executeRawUnsafe(`DELETE FROM QRTokens WHERE token = $1`, token)\n\n    // Update last login (only if AdminUser exists, not for regular User accounts)\n    await prisma.adminUser.update({\n      where: { id: adminUser.id },\n      data: { lastLogin: new Date() }\n    })\n\n    return NextResponse.json({\n      success: true,\n      token: jwtToken,\n      admin: {\n        id: adminUser.id,\n        email: adminUser.email,\n        name: adminUser.name,\n        role: adminUser.role\n      }\n    })\n  } catch (error) {\n    console.error('Error verifying QR token:', error)\n    return NextResponse.json({ error: 'Failed to verify token' }, { status: 500 })\n  }\n}\n","truncated":false,"size":7545},{"path":"app/api/admin/qr-login/approve/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\nimport { extractAdminFromHeaders } from '@/lib/admin-auth'\n\nasync function cleanupExpired() {\n  const now = new Date()\n  await prisma.adminQrLogin.deleteMany({\n    where: { expiresAt: { lt: now } }\n  })\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    const authHeader = request.headers.get('authorization')\n    const admin = extractAdminFromHeaders(authHeader)\n    if (!admin) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const body = await request.json().catch(() => ({}))\n    const token = typeof body?.token === 'string' ? body.token.trim() : ''\n    if (!token) {\n      return NextResponse.json({ error: 'Token required' }, { status: 400 })\n    }\n\n    await cleanupExpired()\n\n    const entry = await prisma.adminQrLogin.findUnique({\n      where: { token }\n    })\n\n    if (!entry) {\n      return NextResponse.json({ error: 'Invalid or expired token' }, { status: 404 })\n    }\n\n    if (!entry.expiresAt || entry.expiresAt.getTime() < Date.now()) {\n      await prisma.adminQrLogin.delete({ where: { token } })\n      return NextResponse.json({ error: 'Token expired' }, { status: 410 })\n    }\n\n    await prisma.adminQrLogin.update({\n      where: { token },\n      data: {\n        status: 'APPROVED',\n        adminId: admin.adminId,\n        email: admin.email.toLowerCase(),\n        approvedAt: new Date()\n      }\n    })\n\n    return NextResponse.json({ success: true })\n  } catch (error: any) {\n    console.error('[ADMIN QR LOGIN] approve error', error)\n    return NextResponse.json({ error: 'Failed to approve QR login' }, { status: 500 })\n  }\n}\n\nexport const runtime = 'nodejs'\nexport const dynamic = 'force-dynamic'\n","truncated":false,"size":1771},{"path":"app/api/admin/qr-login/start/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\nimport crypto from 'crypto'\n\nconst LOGIN_TTL_MS = 5 * 60 * 1000\n\nasync function cleanupExpired() {\n  const now = new Date()\n  await prisma.adminQrLogin.deleteMany({\n    where: { expiresAt: { lt: now } }\n  })\n}\n\nexport async function GET(request: NextRequest) {\n  try {\n    await cleanupExpired()\n\n    const token = crypto.randomBytes(32).toString('hex')\n    const expiresAt = new Date(Date.now() + LOGIN_TTL_MS)\n\n    await prisma.adminQrLogin.create({\n      data: {\n        token,\n        status: 'PENDING',\n        expiresAt\n      }\n    })\n\n    const origin = request.headers.get('origin') || request.headers.get('host')\n    const protocol = request.headers.get('x-forwarded-proto') || 'https'\n    const baseUrl =\n      process.env.NEXT_PUBLIC_APP_URL ||\n      (origin ? `${protocol}://${origin}` : 'https://helfi.ai')\n\n    return NextResponse.json({\n      token,\n      url: `${baseUrl}/admin-panel/qr-login?token=${token}`,\n      expiresAt: expiresAt.getTime()\n    })\n  } catch (error: any) {\n    console.error('[ADMIN QR LOGIN] start error', error)\n    return NextResponse.json({ error: 'Failed to create QR login' }, { status: 500 })\n  }\n}\n\nexport const runtime = 'nodejs'\nexport const dynamic = 'force-dynamic'\n","truncated":false,"size":1310},{"path":"app/api/admin/qr-login/status/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\nimport jwt from 'jsonwebtoken'\n\nconst JWT_SECRET = process.env.JWT_SECRET || process.env.NEXTAUTH_SECRET\n\nasync function cleanupExpired() {\n  const now = new Date()\n  await prisma.adminQrLogin.deleteMany({\n    where: { expiresAt: { lt: now } }\n  })\n}\n\nexport async function GET(request: NextRequest) {\n  try {\n    if (!JWT_SECRET) {\n      return NextResponse.json({ error: 'Admin login secret not configured' }, { status: 500 })\n    }\n    const { searchParams } = new URL(request.url)\n    const token = (searchParams.get('token') || '').trim()\n    if (!token) {\n      return NextResponse.json({ error: 'Token required' }, { status: 400 })\n    }\n\n    await cleanupExpired()\n\n    const entry = await prisma.adminQrLogin.findUnique({\n      where: { token }\n    })\n\n    if (!entry) {\n      return NextResponse.json({ error: 'Invalid or expired token' }, { status: 404 })\n    }\n\n    if (!entry.expiresAt || entry.expiresAt.getTime() < Date.now()) {\n      await prisma.adminQrLogin.delete({ where: { token } })\n      return NextResponse.json({ error: 'Token expired' }, { status: 410 })\n    }\n\n    if (entry.status !== 'APPROVED' || !entry.adminId || !entry.email) {\n      return NextResponse.json({ status: 'PENDING' })\n    }\n\n    const adminUser = await prisma.adminUser.findUnique({\n      where: { id: entry.adminId },\n      select: {\n        id: true,\n        email: true,\n        name: true,\n        role: true,\n        isActive: true\n      }\n    })\n\n    if (!adminUser || adminUser.isActive === false) {\n      await prisma.$executeRawUnsafe(`DELETE FROM \"AdminQrLogin\" WHERE token = $1`, token)\n      return NextResponse.json({ error: 'Admin user not found or inactive' }, { status: 404 })\n    }\n\n    const jwtToken = jwt.sign(\n      {\n        adminId: adminUser.id,\n        email: adminUser.email,\n        role: adminUser.role\n      },\n      JWT_SECRET,\n      { expiresIn: '24h' }\n    )\n\n    await prisma.adminQrLogin.delete({ where: { token } })\n\n    return NextResponse.json({\n      status: 'APPROVED',\n      token: jwtToken,\n      admin: {\n        id: adminUser.id,\n        email: adminUser.email,\n        name: adminUser.name,\n        role: adminUser.role\n      }\n    })\n  } catch (error: any) {\n    console.error('[ADMIN QR LOGIN] status error', error)\n    return NextResponse.json({ error: 'Failed to check QR login status' }, { status: 500 })\n  }\n}\n\nexport const runtime = 'nodejs'\nexport const dynamic = 'force-dynamic'\n","truncated":false,"size":2523},{"path":"app/api/admin/security-status/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { extractAdminFromHeaders } from '@/lib/admin-auth'\n\nconst hasValue = (value?: string | null) => Boolean(value && value.trim().length > 0)\n\nexport async function GET(request: NextRequest) {\n  try {\n    const authHeader = request.headers.get('authorization')\n    const admin = extractAdminFromHeaders(authHeader)\n    if (!admin) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const items = [\n      {\n        id: 'session-secret',\n        label: 'App session secret',\n        status: hasValue(process.env.NEXTAUTH_SECRET) || hasValue(process.env.AUTH_SECRET) ? 'set' : 'missing',\n      },\n      {\n        id: 'admin-secret',\n        label: 'Admin login secret',\n        status: hasValue(process.env.JWT_SECRET) || hasValue(process.env.NEXTAUTH_SECRET) ? 'set' : 'missing',\n      },\n      {\n        id: 'stripe-secret',\n        label: 'Payment secret key',\n        status: hasValue(process.env.STRIPE_SECRET_KEY) ? 'set' : 'missing',\n      },\n      {\n        id: 'stripe-webhook',\n        label: 'Payment webhook secret',\n        status: hasValue(process.env.STRIPE_WEBHOOK_SECRET) ? 'set' : 'missing',\n      },\n      {\n        id: 'openai-key',\n        label: 'AI provider key',\n        status: hasValue(process.env.OPENAI_API_KEY) ? 'set' : 'missing',\n      },\n      {\n        id: 'email-key',\n        label: 'Email sending key',\n        status: hasValue(process.env.RESEND_API_KEY) ? 'set' : 'missing',\n      },\n      {\n        id: 'storage-key',\n        label: 'File storage key',\n        status: hasValue(process.env.BLOB_READ_WRITE_TOKEN) || hasValue(process.env.VERCEL_BLOB_READ_WRITE_TOKEN) ? 'set' : 'missing',\n      },\n      {\n        id: 'encryption-key',\n        label: 'Encryption master key',\n        status: hasValue(process.env.ENCRYPTION_MASTER_KEY) ? 'set' : 'missing',\n      },\n      {\n        id: 'scheduler-secret',\n        label: 'Background job secret',\n        status: hasValue(process.env.SCHEDULER_SECRET) ? 'set' : 'missing',\n      },\n      {\n        id: 'push-key',\n        label: 'Push notification key',\n        status: hasValue(process.env.VAPID_PRIVATE_KEY) ? 'set' : 'missing',\n      },\n    ]\n\n    return NextResponse.json({ items })\n  } catch (error) {\n    console.error('Security status error:', error)\n    return NextResponse.json({ error: 'Failed to load security status' }, { status: 500 })\n  }\n}\n","truncated":false,"size":2436},{"path":"app/api/admin/send-emails/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { Resend } from 'resend'\nimport { extractAdminFromHeaders } from '@/lib/admin-auth'\nimport { getEmailFooter } from '@/lib/email-footer'\nimport { prisma } from '@/lib/prisma'\n\n// Initialize Resend only when needed to avoid build-time errors\nfunction getResend() {\n  if (!process.env.RESEND_API_KEY) {\n    return null\n  }\n  return new Resend(process.env.RESEND_API_KEY)\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    // JWT authentication check (with temporary token support)\n    const authHeader = request.headers.get('authorization')\n    const admin = extractAdminFromHeaders(authHeader)\n    \n    // Allow temporary admin token during transition\n    if (!admin) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const { emails, subject, message, waitlistData, emailType, reasonText } = await request.json()\n\n    if (!emails || !Array.isArray(emails) || emails.length === 0) {\n      return NextResponse.json({ error: 'No recipients provided' }, { status: 400 })\n    }\n\n    if (!subject.trim() || !message.trim()) {\n      return NextResponse.json({ error: 'Subject and message are required' }, { status: 400 })\n    }\n\n    // Check if Resend API key is configured\n    if (!process.env.RESEND_API_KEY) {\n      return NextResponse.json({ error: 'Email service not configured' }, { status: 500 })\n    }\n    \n    const results = []\n    \n    for (const email of emails) {\n      try {\n        // Check if email is unsubscribed\n        const waitlistEntry = await prisma.waitlist.findUnique({\n          where: { email: email.toLowerCase() }\n        })\n        \n        if (waitlistEntry?.unsubscribed) {\n          results.push({\n            email,\n            status: 'skipped',\n            reason: 'Email address has unsubscribed from marketing emails'\n          })\n          console.log(`‚è≠Ô∏è [EMAIL SKIPPED] ${email} has unsubscribed`)\n          continue\n        }\n        \n        // Find the corresponding waitlist entry to get the name\n        const recipient = waitlistData?.find((entry: any) => entry.email === email)\n        const name = recipient?.name || 'there'\n        const company = recipient?.company || ''\n        const region = recipient?.region || ''\n        const notes = recipient?.notes || ''\n        \n        // Personalize the message\n        const personalizedMessage = message\n          .replace(/{name}/g, name)\n          .replace(/{company}/g, company)\n          .replace(/{region}/g, region)\n          .replace(/{notes}/g, notes)\n        \n        // Send real email using Resend\n        const resend = getResend()\n        if (!resend) {\n          throw new Error('Resend API key not configured')\n        }\n        \n        const emailResponse = await resend.emails.send({\n          from: 'Helfi Team <support@helfi.ai>',\n          to: email,\n          subject: subject,\n          html: `\n            <div style=\"font-family: 'Segoe UI', Arial, sans-serif; max-width: 600px; margin: 0 auto; color: #333; background: #f8fafc;\">\n              <div style=\"background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; padding: 40px 30px; text-align: center; border-radius: 12px 12px 0 0;\">\n                <h1 style=\"margin: 0; font-size: 32px; font-weight: bold; letter-spacing: -0.5px;\">Helfi</h1>\n                <p style=\"margin: 12px 0 0 0; opacity: 0.95; font-size: 16px;\">Your AI-Powered Health Coach</p>\n              </div>\n              \n              <div style=\"padding: 40px 30px; background: white; border-radius: 0 0 12px 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);\">\n                                 ${personalizedMessage.split('\\n').map((line: string) => \n                   line.trim() ? `<p style=\"margin: 18px 0; line-height: 1.7; font-size: 16px;\">${line}</p>` : '<div style=\"height: 10px;\"></div>'\n                 ).join('')}\n                \n                <div style=\"margin-top: 40px; padding-top: 30px; border-top: 2px solid #e5e7eb; text-align: center;\">\n                  <a href=\"https://helfi.ai\" style=\"display: inline-block; background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; text-decoration: none; padding: 16px 32px; border-radius: 8px; font-weight: 600; font-size: 16px; margin: 10px 0; box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);\">üöÄ Get Started with Helfi</a>\n                </div>\n                \n                ${getEmailFooter({\n                  recipientEmail: email,\n                  emailType: emailType || 'marketing',\n                  reasonText: reasonText || 'You received this email because you joined our waitlist.'\n                })}\n              </div>\n            </div>\n          `\n        })\n        \n        results.push({\n          email,\n          status: 'sent',\n          messageId: emailResponse.data?.id || 'unknown',\n          personalizedMessage\n        })\n        \n        console.log(`‚úÖ [EMAIL SENT] To: ${email}, Subject: ${subject}, ID: ${emailResponse.data?.id}`)\n        \n      } catch (emailError: any) {\n        console.error(`‚ùå Failed to send email to ${email}:`, emailError)\n        results.push({\n          email,\n          status: 'failed',\n          error: emailError.message || 'Unknown error'\n        })\n      }\n    }\n\n    const successCount = results.filter(r => r.status === 'sent').length\n    const failCount = results.filter(r => r.status === 'failed').length\n\n    return NextResponse.json({\n      success: failCount === 0,\n      message: failCount === 0 \n        ? `üéâ Successfully sent ${successCount} emails!` \n        : `üìä Sent ${successCount} emails, ${failCount} failed`,\n      results,\n      summary: {\n        total: emails.length,\n        sent: successCount,\n        failed: failCount\n      }\n    })\n\n  } catch (error: any) {\n    console.error('‚ùå Email sending error:', error)\n    return NextResponse.json(\n      { error: 'Failed to send emails: ' + (error.message || 'Unknown error') },\n      { status: 500 }\n    )\n  }\n} \n","truncated":false,"size":6020},{"path":"app/api/admin/server-call-usage/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\nimport { extractAdminFromHeaders } from '@/lib/admin-auth'\n\nexport const runtime = 'nodejs'\nexport const dynamic = 'force-dynamic'\n\nasync function ensureServerCallLogTable() {\n  await prisma.$executeRawUnsafe(`\n    CREATE TABLE IF NOT EXISTS \"ServerCallLog\" (\n      id TEXT PRIMARY KEY,\n      \"createdAt\" TIMESTAMP NOT NULL DEFAULT NOW(),\n      feature TEXT NOT NULL,\n      endpoint TEXT NOT NULL,\n      kind TEXT NOT NULL\n    )\n  `)\n}\n\nexport async function GET(request: NextRequest) {\n  try {\n    const authHeader = request.headers.get('authorization')\n    const admin = extractAdminFromHeaders(authHeader)\n    if (!admin) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const url = new URL(request.url)\n    const rangeDaysRaw = url.searchParams.get('rangeDays') || '30'\n    const rangeDays = Math.max(1, Math.min(365, parseInt(rangeDaysRaw, 10) || 30))\n    const since = new Date(Date.now() - rangeDays * 24 * 60 * 60 * 1000)\n\n    await ensureServerCallLogTable()\n\n    const rows = await prisma.$queryRawUnsafe<\n      Array<{ feature: string; kind: string; count: number }>\n    >(\n      `SELECT feature, kind, COUNT(*)::int AS count\n       FROM \"ServerCallLog\"\n       WHERE \"createdAt\" >= $1\n       GROUP BY feature, kind`,\n      since\n    )\n\n    const summary: Record<\n      string,\n      { feature: string; analysisCalls: number; totalCalls: number; extraCalls: number; callsPerAnalysis: number | null }\n    > = {}\n\n    for (const row of rows) {\n      const feature = row.feature || 'unknown'\n      if (!summary[feature]) {\n        summary[feature] = {\n          feature,\n          analysisCalls: 0,\n          totalCalls: 0,\n          extraCalls: 0,\n          callsPerAnalysis: null,\n        }\n      }\n      summary[feature].totalCalls += row.count\n      if (row.kind === 'analysis') {\n        summary[feature].analysisCalls += row.count\n      }\n    }\n\n    const features = Object.values(summary)\n      .map((item) => {\n        const analysisCalls = item.analysisCalls\n        const totalCalls = item.totalCalls\n        const extraCalls = Math.max(0, totalCalls - analysisCalls)\n        const callsPerAnalysis = analysisCalls > 0 ? totalCalls / analysisCalls : null\n        return {\n          feature: item.feature,\n          analysisCalls,\n          totalCalls,\n          extraCalls,\n          callsPerAnalysis,\n        }\n      })\n      .sort((a, b) => {\n        if (a.callsPerAnalysis == null && b.callsPerAnalysis == null) return 0\n        if (a.callsPerAnalysis == null) return 1\n        if (b.callsPerAnalysis == null) return -1\n        return b.callsPerAnalysis - a.callsPerAnalysis\n      })\n\n    return NextResponse.json({\n      rangeDays,\n      features,\n      note: 'Calls are tracked when analysis endpoints and credit meters are hit with a feature tag.',\n    })\n  } catch (error) {\n    console.error('[admin server-call-usage] error', error)\n    return NextResponse.json({ error: 'Failed to load server call usage' }, { status: 500 })\n  }\n}\n","truncated":false,"size":3091},{"path":"app/api/admin/setup/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\nimport bcrypt from 'bcryptjs'\n\nexport async function POST(request: NextRequest) {\n  try {\n    // Special setup authentication - only allow if no admin users exist\n    const existingAdmins = await prisma.adminUser.count()\n    if (existingAdmins > 0) {\n      return NextResponse.json({ error: 'Admin users already exist. Setup not allowed.' }, { status: 403 })\n    }\n\n    const { email, password, name, setupKey } = await request.json()\n\n    // Special setup key to prevent unauthorized admin creation\n    if (setupKey !== 'HelfiAdminSetup2024!') {\n      return NextResponse.json({ error: 'Invalid setup key' }, { status: 401 })\n    }\n\n    if (!email || !password || !name) {\n      return NextResponse.json({ error: 'Email, password, and name are required' }, { status: 400 })\n    }\n\n    // Hash the password\n    const saltRounds = 12\n    const hashedPassword = await bcrypt.hash(password, saltRounds)\n\n    // Create the first admin user\n    const adminUser = await prisma.adminUser.create({\n      data: {\n        email,\n        password: hashedPassword,\n        name,\n        role: 'SUPER_ADMIN'\n      }\n    })\n\n    return NextResponse.json({ \n      success: true, \n      message: 'First admin user created successfully',\n      adminId: adminUser.id \n    })\n\n  } catch (error) {\n    console.error('Error creating admin user:', error)\n    return NextResponse.json({ error: 'Failed to create admin user' }, { status: 500 })\n  }\n} ","truncated":false,"size":1521},{"path":"app/api/admin/stripe/ensure-webhooks/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport Stripe from 'stripe'\nimport { extractAdminFromHeaders } from '@/lib/admin-auth'\n\nexport const runtime = 'nodejs'\nexport const dynamic = 'force-dynamic'\n\nconst REQUIRED_EVENTS = [\n  'checkout.session.completed',\n  'invoice.paid',\n  'charge.refunded',\n  'charge.dispute.created',\n  'account.updated',\n  'customer.subscription.created',\n  'customer.subscription.updated',\n  'customer.subscription.deleted',\n] as const\n\nfunction getBaseUrl(): string | null {\n  const base =\n    process.env.PUBLIC_BASE_URL ||\n    process.env.NEXTAUTH_URL ||\n    (process.env.VERCEL_URL ? `https://${process.env.VERCEL_URL}` : '') ||\n    process.env.NEXT_PUBLIC_APP_URL ||\n    ''\n\n  const normalized = base.trim().replace(/\\/+$/, '')\n  if (!normalized) return null\n  if (!/^https?:\\/\\//i.test(normalized)) return `https://${normalized}`\n  return normalized\n}\n\nfunction unionEvents(\n  existing: Stripe.WebhookEndpointUpdateParams.EnabledEvent[] | string[],\n  required: readonly string[]\n): Stripe.WebhookEndpointUpdateParams.EnabledEvent[] {\n  const set = new Set<string>(existing || [])\n  for (const e of required) set.add(e)\n  return Array.from(set).sort() as Stripe.WebhookEndpointUpdateParams.EnabledEvent[]\n}\n\nexport async function POST(request: NextRequest) {\n  const authHeader = request.headers.get('authorization')\n  const admin = extractAdminFromHeaders(authHeader)\n  if (!admin) {\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  }\n\n  const secretKey = process.env.STRIPE_SECRET_KEY\n  if (!secretKey) return NextResponse.json({ error: 'Stripe not configured' }, { status: 500 })\n\n  const stripe = new Stripe(secretKey, { apiVersion: '2024-06-20' })\n\n  const body = await request.json().catch(() => ({}))\n  const baseUrl = getBaseUrl()\n  const defaultWebhookUrl = baseUrl ? `${baseUrl}/api/billing/webhook` : null\n  const webhookUrl = (String(body?.webhookUrl || '').trim() || defaultWebhookUrl || '').trim()\n\n  if (!webhookUrl) {\n    return NextResponse.json(\n      { error: 'Missing webhookUrl and could not infer base URL (set NEXTAUTH_URL or PUBLIC_BASE_URL)' },\n      { status: 400 }\n    )\n  }\n\n  const endpoints = await stripe.webhookEndpoints.list({ limit: 100 })\n  const matches = endpoints.data.filter(e => e.url === webhookUrl)\n\n  if (!matches.length) {\n    return NextResponse.json(\n      {\n        ok: false,\n        error: 'No Stripe webhook endpoint found for this URL',\n        webhookUrl,\n        requiredEvents: REQUIRED_EVENTS,\n        note: 'Create the webhook endpoint in Stripe for this URL, then re-run.',\n      },\n      { status: 404 }\n    )\n  }\n\n  const updated: Array<{ id: string; url: string; beforeCount: number; afterCount: number }> = []\n\n  for (const endpoint of matches) {\n    const before = endpoint.enabled_events || []\n    const after = unionEvents(before, REQUIRED_EVENTS)\n    if (after.length === before.length) {\n      updated.push({ id: endpoint.id, url: endpoint.url, beforeCount: before.length, afterCount: after.length })\n      continue\n    }\n    const res = await stripe.webhookEndpoints.update(endpoint.id, { enabled_events: after })\n    updated.push({\n      id: res.id,\n      url: res.url,\n      beforeCount: before.length,\n      afterCount: res.enabled_events?.length || after.length,\n    })\n  }\n\n  return NextResponse.json({ ok: true, webhookUrl, requiredEvents: REQUIRED_EVENTS, updated })\n}\n","truncated":false,"size":3416},{"path":"app/api/admin/test-email/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { Resend } from 'resend'\nimport { extractAdminFromHeaders } from '@/lib/admin-auth'\nimport { getEmailFooter } from '@/lib/email-footer'\n\nexport async function POST(request: NextRequest) {\n  try {\n    // Verify admin token\n    const authHeader = request.headers.get('authorization')\n    const admin = extractAdminFromHeaders(authHeader)\n    if (!admin) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const { testEmail } = await request.json()\n    \n    if (!testEmail) {\n      return NextResponse.json({ error: 'Test email address required' }, { status: 400 })\n    }\n\n    // Check environment configuration\n    const resendApiKey = process.env.RESEND_API_KEY\n    if (!resendApiKey) {\n      return NextResponse.json({ \n        error: 'RESEND_API_KEY not configured',\n        details: 'Email service is not properly configured on the server'\n      }, { status: 500 })\n    }\n\n    console.log(`üß™ [EMAIL TEST] Starting test to: ${testEmail}`)\n    console.log(`üîë [EMAIL TEST] API Key configured: ${resendApiKey.substring(0, 10)}...`)\n\n    try {\n      const resend = new Resend(resendApiKey)\n      \n      const emailResponse = await resend.emails.send({\n        from: 'Helfi Team <support@helfi.ai>',\n        to: testEmail,\n        subject: 'üß™ Helfi Email Test - ' + new Date().toLocaleString(),\n        html: `\n          <div style=\"font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px;\">\n            <h2 style=\"color: #10b981;\">üß™ Helfi Email Test</h2>\n            <p>This is a test email to verify your email delivery system is working properly.</p>\n            \n            <div style=\"background: #f0f9ff; padding: 15px; border-radius: 8px; margin: 20px 0;\">\n              <h3 style=\"margin: 0 0 10px 0; color: #0369a1;\">Test Details:</h3>\n              <ul style=\"margin: 0; padding-left: 20px;\">\n                <li><strong>Sent At:</strong> ${new Date().toISOString()}</li>\n                <li><strong>From:</strong> Helfi Team &lt;support@helfi.ai&gt;</li>\n                <li><strong>To:</strong> ${testEmail}</li>\n                <li><strong>Service:</strong> Resend Email API</li>\n              </ul>\n            </div>\n            \n            <p>If you received this email, your email delivery system is working correctly! ‚úÖ</p>\n            \n            ${getEmailFooter({ recipientEmail: testEmail, emailType: 'admin', reasonText: 'This is an automated test email from the Helfi admin panel.' })}\n          </div>\n        `\n      })\n\n      const messageId = emailResponse.data?.id\n      const success = emailResponse.error === null || emailResponse.error === undefined\n\n      console.log(`üìß [EMAIL TEST] Resend Response:`, {\n        success,\n        messageId,\n        error: emailResponse.error\n      })\n\n      if (success && messageId) {\n        console.log(`‚úÖ [EMAIL TEST] Successfully sent to ${testEmail} with ID: ${messageId}`)\n        \n        return NextResponse.json({\n          success: true,\n          message: 'Test email sent successfully!',\n          details: {\n            messageId,\n            recipient: testEmail,\n            timestamp: new Date().toISOString(),\n            resendResponse: emailResponse.data\n          }\n        })\n      } else {\n        console.error(`‚ùå [EMAIL TEST] Failed to send:`, emailResponse.error)\n        \n        return NextResponse.json({\n          success: false,\n          error: 'Failed to send test email',\n          details: {\n            resendError: emailResponse.error,\n            recipient: testEmail,\n            timestamp: new Date().toISOString()\n          }\n        }, { status: 500 })\n      }\n\n    } catch (resendError: any) {\n      console.error(`‚ùå [EMAIL TEST] Resend API Error:`, resendError)\n      \n      return NextResponse.json({\n        success: false,\n        error: 'Resend API Error',\n        details: {\n          errorMessage: resendError.message,\n          errorName: resendError.name,\n          recipient: testEmail,\n          timestamp: new Date().toISOString()\n        }\n      }, { status: 500 })\n    }\n\n  } catch (error: any) {\n    console.error('‚ùå [EMAIL TEST] General Error:', error)\n    return NextResponse.json({\n      success: false,\n      error: 'Test failed',\n      details: error.message\n    }, { status: 500 })\n  }\n} \n","truncated":false,"size":4368},{"path":"app/api/admin/tickets/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { extractAdminFromHeaders } from '@/lib/admin-auth'\nimport { Resend } from 'resend'\nimport { getEmailFooter } from '@/lib/email-footer'\nimport { prisma } from '@/lib/prisma'\nimport { processSupportTicketAutoReply } from '@/lib/support-automation'\n\n// Check if database tables exist and create them if needed\nasync function ensureDatabaseSchema() {\n  try {\n    // Try to query the SupportTicket table to see if it exists\n    await prisma.supportTicket.findFirst()\n    return { success: true, message: 'Database schema is ready' }\n  } catch (error: any) {\n    console.log('üîß Database schema needs to be created...')\n    \n    // If the table doesn't exist, we'll return a helpful message\n    if (error.code === 'P2021' || error.message.includes('does not exist')) {\n      return { \n        success: false, \n        needsSchema: true,\n        message: 'Database schema needs to be deployed. Please run: npx prisma db push'\n      }\n    }\n    \n    return { success: false, message: 'Database connection error: ' + error.message }\n  }\n}\n\nexport async function GET(request: NextRequest) {\n  try {\n    // JWT authentication check\n    const authHeader = request.headers.get('authorization')\n    const admin = extractAdminFromHeaders(authHeader)\n    \n    if (!admin) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    // Check database schema first\n    const schemaCheck = await ensureDatabaseSchema()\n    if (!schemaCheck.success && schemaCheck.needsSchema) {\n      return NextResponse.json({\n        tickets: [],\n        pagination: {\n          currentPage: 1,\n          totalPages: 1,\n          totalTickets: 0,\n          hasNext: false,\n          hasPrev: false\n        },\n        schemaStatus: {\n          ready: false,\n          message: schemaCheck.message,\n          action: 'Please deploy database schema first'\n        }\n      })\n    }\n\n    const { searchParams } = new URL(request.url)\n    const action = searchParams.get('action')\n    const ticketId = searchParams.get('ticketId')\n    \n    // Handle single ticket retrieval\n    if (action === 'get_ticket' && ticketId) {\n      const ticket = await prisma.supportTicket.findUnique({\n        where: { id: ticketId },\n        include: {\n          user: {\n            select: {\n              email: true,\n              name: true\n            }\n          },\n          responses: {\n            orderBy: { createdAt: 'asc' },\n            include: {\n              admin: {\n                select: {\n                  name: true,\n                  email: true\n                }\n              }\n            }\n          }\n        }\n      })\n      \n      if (!ticket) {\n        return NextResponse.json({ error: 'Ticket not found' }, { status: 404 })\n      }\n      \n      return NextResponse.json({ ticket })\n    }\n    \n    // Default: Get tickets with pagination\n    const rawStatus = String(searchParams.get('status') || 'all').trim()\n    const normalizedStatus = rawStatus.toUpperCase()\n    const allowedStatuses = new Set([\n      'OPEN',\n      'IN_PROGRESS',\n      'AWAITING_RESPONSE',\n      'RESPONDED',\n      'RESOLVED',\n      'CLOSED',\n    ])\n    const status = normalizedStatus === 'ALL' || normalizedStatus === 'ALL TICKETS' || !normalizedStatus\n      ? 'all'\n      : allowedStatuses.has(normalizedStatus)\n        ? normalizedStatus\n        : 'all'\n    const page = parseInt(searchParams.get('page') || '1')\n    const limit = parseInt(searchParams.get('limit') || '20')\n    const skip = (page - 1) * limit\n\n    // Build filter conditions\n    let whereClause: any = {}\n    if (status !== 'all') {\n      whereClause.status = status\n    }\n\n    // Get tickets with pagination\n    const tickets = await prisma.supportTicket.findMany({\n      where: whereClause,\n      orderBy: { createdAt: 'desc' },\n      skip,\n      take: limit,\n      include: {\n        user: {\n          select: {\n            email: true,\n            name: true\n          }\n        },\n        responses: {\n          orderBy: { createdAt: 'asc' },\n          include: {\n            admin: {\n              select: {\n                name: true,\n                email: true\n              }\n            }\n          }\n        }\n      }\n    })\n\n    // Get total count for pagination\n    const totalTickets = await prisma.supportTicket.count({\n      where: whereClause\n    })\n\n    return NextResponse.json({\n      tickets,\n      pagination: {\n        currentPage: page,\n        totalPages: Math.ceil(totalTickets / limit),\n        totalTickets,\n        hasNext: page * limit < totalTickets,\n        hasPrev: page > 1\n      },\n      schemaStatus: {\n        ready: true,\n        message: 'Database schema is ready'\n      }\n    })\n\n  } catch (error: any) {\n    console.error('‚ùå Error fetching tickets:', error)\n    return NextResponse.json(\n      { \n        error: 'Failed to fetch tickets: ' + error.message,\n        schemaStatus: {\n          ready: false,\n          message: 'Database error occurred'\n        }\n      },\n      { status: 500 }\n    )\n  }\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    // Check database schema first\n    const schemaCheck = await ensureDatabaseSchema()\n    if (!schemaCheck.success && schemaCheck.needsSchema) {\n      return NextResponse.json({\n        success: false,\n        error: 'Database schema not ready',\n        message: schemaCheck.message\n      }, { status: 503 })\n    }\n\n    const { action, ticketId, ...data } = await request.json()\n\n    if (action !== 'create') {\n      const authHeader = request.headers.get('authorization')\n      const admin = extractAdminFromHeaders(authHeader)\n      if (!admin) {\n        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n      }\n    }\n\n    switch (action) {\n      case 'create':\n        // Create a new ticket (manual creation from admin)\n        const newTicket = await prisma.supportTicket.create({\n          data: {\n            subject: data.subject,\n            message: data.message,\n            userEmail: data.userEmail,\n            userName: data.userName,\n            status: 'OPEN',\n            priority: data.priority || 'MEDIUM',\n            category: data.category || 'GENERAL'\n          },\n          include: {\n            user: {\n              select: {\n                email: true,\n                name: true\n              }\n            },\n            responses: true\n          }\n        })\n\n        // Send email notification to support team\n        try {\n          if (process.env.RESEND_API_KEY) {\n            const resend = new Resend(process.env.RESEND_API_KEY)\n            \n            await resend.emails.send({\n              from: 'Helfi Team <support@helfi.ai>',\n              to: 'support@helfi.ai',\n              subject: `üé´ New Support Ticket: ${newTicket.subject}`,\n              html: `\n                <div style=\"font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px;\">\n                  <h2 style=\"color: #10b981;\">üé´ New Support Ticket Created</h2>\n                  \n                  <div style=\"background: #f9fafb; padding: 20px; border-radius: 8px; margin: 20px 0;\">\n                    <h3 style=\"margin: 0 0 15px 0; color: #374151;\">Ticket Details:</h3>\n                    <p><strong>Ticket ID:</strong> ${newTicket.id}</p>\n                    <p><strong>Subject:</strong> ${newTicket.subject}</p>\n                    <p><strong>Category:</strong> ${newTicket.category}</p>\n                    <p><strong>Priority:</strong> ${newTicket.priority}</p>\n                    <p><strong>Status:</strong> ${newTicket.status}</p>\n                    <p><strong>Created:</strong> ${new Date(newTicket.createdAt).toLocaleString()}</p>\n                  </div>\n\n                  <div style=\"background: #fef2f2; padding: 20px; border-radius: 8px; margin: 20px 0;\">\n                    <h3 style=\"margin: 0 0 15px 0; color: #374151;\">Customer Information:</h3>\n                    <p><strong>Name:</strong> ${newTicket.userName || 'Not provided'}</p>\n                    <p><strong>Email:</strong> ${newTicket.userEmail}</p>\n                  </div>\n\n                  <div style=\"background: #fff; border: 1px solid #e5e7eb; padding: 20px; border-radius: 8px; margin: 20px 0;\">\n                    <h3 style=\"margin: 0 0 15px 0; color: #374151;\">Message:</h3>\n                    <p style=\"line-height: 1.6; white-space: pre-wrap;\">${newTicket.message}</p>\n                  </div>\n\n                  <div style=\"text-align: center; margin: 30px 0;\">\n                    <a href=\"https://helfi.ai/admin-panel\" \n                       style=\"background: #10b981; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; display: inline-block;\">\n                      View in Admin Panel\n                    </a>\n                  </div>\n\n                  ${getEmailFooter({ recipientEmail: 'support@helfi.ai', emailType: 'support', reasonText: 'This is an automated notification from the Helfi support system.' })}\n                </div>\n              `\n            })\n            console.log(`üìß [TICKET ALERT] Email notification sent for ticket ${newTicket.id}`)\n          }\n        } catch (emailError) {\n          console.error('üìß [TICKET ALERT] Failed to send email notification:', emailError)\n          // Don't fail the ticket creation if email fails\n        }\n\n        try {\n          await processSupportTicketAutoReply({\n            ticketId: newTicket.id,\n            latestUserMessage: newTicket.message,\n            source: 'web_ticket',\n          })\n        } catch (aiError) {\n          console.error('ü§ñ [SUPPORT AI] Failed to auto-reply:', aiError)\n        }\n\n        return NextResponse.json({ ticket: newTicket })\n\n      case 'update_status':\n        const updatedTicket = await prisma.supportTicket.update({\n          where: { id: ticketId },\n          data: { status: data.status },\n          include: {\n            user: {\n              select: {\n                email: true,\n                name: true\n              }\n            },\n            responses: {\n              include: {\n                admin: {\n                  select: {\n                    name: true,\n                    email: true\n                  }\n                }\n              }\n            }\n          }\n        })\n        return NextResponse.json({ ticket: updatedTicket })\n\n      case 'add_response':\n        // Add admin response to ticket\n        const response = await prisma.ticketResponse.create({\n          data: {\n            ticketId: ticketId,\n            message: data.message,\n            isAdminResponse: true,\n            adminId: null  // Set to null instead of fake ID to avoid foreign key constraint\n          }\n        })\n\n        // Update ticket status if needed\n        await prisma.supportTicket.update({\n          where: { id: ticketId },\n          data: { \n            status: 'RESPONDED',\n            updatedAt: new Date()\n          }\n        })\n\n        // Send email response to user (if configured)\n        try {\n          // Get ticket information for email sending\n          const ticket = await prisma.supportTicket.findUnique({\n            where: { id: ticketId },\n            select: {\n              subject: true,\n              userEmail: true,\n              userName: true,\n              createdAt: true\n            }\n          })\n\n          if (process.env.RESEND_API_KEY && ticket) {\n            const resend = new Resend(process.env.RESEND_API_KEY)\n            \n            await resend.emails.send({\n              from: 'Helfi Team <support@helfi.ai>',\n              to: ticket.userEmail,\n              subject: `Re: ${ticket.subject}`,\n              html: `\n                <div style=\"font-family: 'Segoe UI', Arial, sans-serif; max-width: 600px; margin: 0 auto; color: #333; background: #f8fafc;\">\n                  <div style=\"background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; padding: 40px 30px; text-align: center; border-radius: 12px 12px 0 0;\">\n                    <h1 style=\"margin: 0; font-size: 32px; font-weight: bold; letter-spacing: -0.5px;\">Helfi</h1>\n                    <p style=\"margin: 12px 0 0 0; opacity: 0.95; font-size: 16px;\">Support Team Response</p>\n                  </div>\n                  \n                  <div style=\"padding: 40px 30px; background: white; border-radius: 0 0 12px 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);\">\n                    <h2 style=\"margin: 0 0 20px 0; color: #374151; font-size: 24px;\">üì¨ Response to Your Support Request</h2>\n                    \n                    <div style=\"background: #f0f9ff; border: 1px solid #0ea5e9; border-radius: 8px; padding: 16px; margin: 20px 0;\">\n                      <p style=\"margin: 0; color: #0c4a6e; font-size: 14px;\">\n                        <strong>üìã Regarding:</strong> ${ticket.subject}\n                      </p>\n                    </div>\n                    \n                    <div style=\"background: #f9fafb; border-radius: 8px; padding: 20px; margin: 30px 0;\">\n                      <h3 style=\"margin: 0 0 15px 0; color: #374151;\">üí¨ Our Response:</h3>\n                      <div style=\"line-height: 1.7; font-size: 16px; color: #4b5563; white-space: pre-wrap;\">${data.message}</div>\n                    </div>\n                    \n                    <div style=\"background: #ecfdf5; border: 1px solid #10b981; border-radius: 8px; padding: 16px; margin: 30px 0;\">\n                      <p style=\"margin: 0; color: #065f46; font-size: 14px;\">\n                        <strong>üí° Need More Help?</strong> Simply reply to this email and we'll continue the conversation!\n                      </p>\n                    </div>\n                    \n                    <div style=\"margin-top: 40px; padding-top: 30px; border-top: 1px solid #e5e7eb; font-size: 14px; color: #6b7280; text-align: center;\">\n                      <p style=\"margin: 0 0 16px 0; font-size: 16px; color: #374151;\"><strong>Best regards,<br>Helfi Support Team</strong></p>\n                      <p style=\"margin: 20px 0 0 0; font-size: 14px;\">\n                        <a href=\"https://helfi.ai\" style=\"color: #10b981; text-decoration: none; font-weight: 500;\">üåê helfi.ai</a> | \n                        <a href=\"mailto:support@helfi.ai\" style=\"color: #10b981; text-decoration: none; font-weight: 500;\">üìß support@helfi.ai</a>\n                      </p>\n                    </div>\n                  </div>\n                </div>\n              `\n            })\n            \n            console.log(`‚úÖ [SUPPORT RESPONSE] Email sent to ${ticket.userEmail} for ticket ${ticketId}`)\n          } else {\n            console.log(`‚ö†Ô∏è [SUPPORT RESPONSE] Email not sent - RESEND_API_KEY: ${!!process.env.RESEND_API_KEY}, Ticket found: ${!!ticket}`)\n          }\n        } catch (emailError) {\n          console.error(`‚ùå [SUPPORT RESPONSE] Failed to send email for ticket ${ticketId}:`, emailError)\n          // Don't fail the API response if email fails - the response is still saved\n        }\n\n        return NextResponse.json({ response })\n\n      case 'delete':\n        // Delete a ticket and all its responses\n        await prisma.ticketResponse.deleteMany({\n          where: { ticketId: ticketId }\n        })\n        \n        const deletedTicket = await prisma.supportTicket.delete({\n          where: { id: ticketId }\n        })\n        \n        return NextResponse.json({ \n          success: true, \n          message: 'Ticket deleted successfully',\n          deletedTicket \n        })\n\n      default:\n        return NextResponse.json({ error: 'Invalid action' }, { status: 400 })\n    }\n\n  } catch (error: any) {\n    console.error('‚ùå Error handling ticket action:', error)\n    return NextResponse.json(\n      { error: 'Failed to process ticket action: ' + error.message },\n      { status: 500 }\n    )\n  }\n} \n","truncated":false,"size":15884},{"path":"app/api/admin/user-management/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\nimport { extractAdminFromHeaders } from '@/lib/admin-auth'\nimport { CreditManager } from '@/lib/credit-system'\nimport { revokeUserSessions } from '@/lib/session-revocation'\nimport Stripe from 'stripe'\n\nconst stripe = new Stripe(process.env.STRIPE_SECRET_KEY || '', { apiVersion: '2024-06-20' })\n\nexport async function GET(request: NextRequest) {\n  try {\n    // JWT authentication check\n    const authHeader = request.headers.get('authorization')\n    const admin = extractAdminFromHeaders(authHeader)\n    \n    if (!admin) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const { searchParams } = new URL(request.url)\n    const search = searchParams.get('search') || ''\n    const userId = searchParams.get('userId')\n    const status = searchParams.get('status') || 'all'\n    const plan = searchParams.get('plan') || 'all'\n    const page = parseInt(searchParams.get('page') || '1')\n    const limit = parseInt(searchParams.get('limit') || '20')\n\n    // Build filter conditions\n    const where: any = {}\n    \n    if (userId) {\n      where.id = userId\n    } else if (search) {\n      where.OR = [\n        { email: { contains: search, mode: 'insensitive' } },\n        { name: { contains: search, mode: 'insensitive' } }\n      ]\n    }\n\n    if (!userId && plan !== 'all') {\n      if (plan === 'premium') {\n        where.subscription = {\n          plan: 'PREMIUM'\n        }\n      } else if (plan === 'non-subscribed') {\n        where.subscription = null\n      }\n    }\n\n    // Get total count for pagination\n    let totalUsers = 0\n    try {\n      totalUsers = await prisma.user.count({ where })\n    } catch (e) {\n      console.error('User count failed, returning 0:', e)\n      totalUsers = 0\n    }\n\n    // Get users with pagination\n    const users = await prisma.user.findMany({\n      where,\n      select: {\n        id: true,\n        email: true,\n        name: true,\n        createdAt: true,\n        gender: true,\n        dailyAnalysisCredits: true,\n        dailyAnalysisUsed: true,\n        additionalCredits: true,\n        totalAnalysisCount: true,\n        dailyFoodAnalysisUsed: true,\n        dailyFoodReanalysisUsed: true,\n        dailyMedicalAnalysisUsed: true,\n        dailyInteractionAnalysisUsed: true,\n        lastAnalysisResetDate: true,\n        monthlyInsightsGenerationUsed: true,\n        monthlyMedicalImageAnalysisUsed: true,\n        monthlySymptomAnalysisUsed: true,\n        subscription: { select: { plan: true, monthlyPriceCents: true, endDate: true, startDate: true } },\n        creditTopUps: {\n          where: {\n            expiresAt: { gt: new Date() }\n          },\n          select: {\n            amountCents: true,\n            usedCents: true,\n            expiresAt: true\n          }\n        },\n        _count: {\n          select: {\n            healthGoals: true,\n            supplements: true,\n            medications: true,\n            foodLogs: true,\n            exerciseLogs: true\n          }\n        }\n      },\n      orderBy: { createdAt: 'desc' },\n      skip: (page - 1) * limit,\n      take: limit\n    })\n    \n    // Calculate total available credits from CreditTopUp records + non-expiring additional credits\n    const usersWithCredits = users.map(user => {\n      const now = new Date()\n      const topUpAvailable = user.creditTopUps\n        .filter(topUp => topUp.expiresAt > now)\n        .reduce((sum, topUp) => sum + Math.max(0, topUp.amountCents - topUp.usedCents), 0)\n      const additionalAvailable = Math.max(0, user.additionalCredits || 0)\n      const availableCredits = topUpAvailable + additionalAvailable\n      \n      return {\n        ...user,\n        totalAvailableCredits: availableCredits, // Total in cents (which equals credits)\n        additionalAvailableCredits: additionalAvailable,\n        topUpAvailableCredits: topUpAvailable,\n      }\n    })\n\n    return NextResponse.json({\n      users: usersWithCredits,\n      pagination: {\n        page,\n        limit,\n        total: totalUsers,\n        pages: Math.ceil(totalUsers / limit)\n      }\n    })\n\n  } catch (error) {\n    console.error('Error fetching users:', error)\n    return NextResponse.json({ error: 'Failed to fetch users' }, { status: 500 })\n  }\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    // JWT authentication check\n    const authHeader = request.headers.get('authorization')\n    const admin = extractAdminFromHeaders(authHeader)\n    \n    if (!admin) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const body = await request.json()\n    const { action, userId, data } = body\n\n    switch (action) {\n      case 'sync_stripe_subscription': {\n        const targetEmail = data?.email?.toLowerCase()\n        if (!targetEmail) {\n          return NextResponse.json({ error: 'Email required' }, { status: 400 })\n        }\n\n        // Find user\n        const user = await prisma.user.findUnique({ where: { email: targetEmail } })\n        if (!user) {\n          return NextResponse.json({ error: 'User not found' }, { status: 404 })\n        }\n\n        // Lookup Stripe customer and active subscription\n        if (!process.env.STRIPE_SECRET_KEY) {\n          return NextResponse.json({ error: 'Stripe not configured' }, { status: 500 })\n        }\n\n        const customers = await stripe.customers.list({ email: targetEmail, limit: 1 })\n        if (!customers.data.length) {\n          return NextResponse.json({ error: 'Stripe customer not found' }, { status: 404 })\n        }\n        const customer = customers.data[0]\n        const subs = await stripe.subscriptions.list({ customer: customer.id, status: 'all', limit: 1 })\n        if (!subs.data.length) {\n          return NextResponse.json({ error: 'Stripe subscription not found' }, { status: 404 })\n        }\n        const sub = subs.data[0]\n        const amountCents = sub.items.data[0]?.price?.unit_amount || 0\n        const currentPeriodStart = sub.current_period_start ? new Date(sub.current_period_start * 1000) : new Date()\n        const currentPeriodEnd = sub.current_period_end ? new Date(sub.current_period_end * 1000) : null\n\n        // Update subscription to Stripe details (auto-add column if missing)\n        const upsertSubscription = async () => {\n          await prisma.subscription.upsert({\n            where: { userId: user.id },\n            update: {\n              plan: 'PREMIUM',\n              monthlyPriceCents: amountCents,\n              stripeSubscriptionId: sub.id,\n              startDate: currentPeriodStart,\n              endDate: currentPeriodEnd\n            } as any,\n            create: {\n              userId: user.id,\n              plan: 'PREMIUM',\n              monthlyPriceCents: amountCents,\n              stripeSubscriptionId: sub.id,\n              startDate: currentPeriodStart,\n              endDate: currentPeriodEnd\n            } as any\n          })\n        }\n\n        try {\n          await upsertSubscription()\n        } catch (err: any) {\n          const msg = err?.message || ''\n          if (msg.includes('stripeSubscriptionId')) {\n            // Add column if missing (defensive for older DBs)\n            await prisma.$executeRawUnsafe(\n              'ALTER TABLE \\\"Subscription\\\" ADD COLUMN IF NOT EXISTS \\\"stripeSubscriptionId\\\" TEXT'\n            )\n            await upsertSubscription()\n          } else {\n            throw err\n          }\n        }\n\n        // Reset wallet/monthly counters to align with Stripe period start\n        await prisma.user.update({\n          where: { id: user.id },\n          data: {\n            walletMonthlyUsedCents: 0,\n            walletMonthlyResetAt: currentPeriodStart,\n            monthlySymptomAnalysisUsed: 0,\n            monthlyFoodAnalysisUsed: 0,\n            monthlyMedicalImageAnalysisUsed: 0,\n            monthlyInteractionAnalysisUsed: 0,\n            monthlyInsightsGenerationUsed: 0,\n          } as any\n        })\n\n        return NextResponse.json({\n          success: true,\n          userId: user.id,\n          stripeSubscriptionId: sub.id,\n          startDate: currentPeriodStart,\n          endDate: currentPeriodEnd,\n          amountCents\n        })\n      }\n\n      case 'activate':\n        // Create or update subscription to PREMIUM (defaults to $20 tier)\n        await prisma.subscription.upsert({\n          where: { userId },\n          update: { \n            plan: 'PREMIUM',\n            monthlyPriceCents: 2000 // Default to $20 tier\n          },\n          create: { \n            userId, \n            plan: 'PREMIUM',\n            monthlyPriceCents: 2000\n          }\n        })\n        // Update daily credits for premium\n        await prisma.user.update({\n          where: { id: userId },\n          data: { dailyAnalysisCredits: 30 }\n        })\n        break\n\n      case 'revoke_sessions': {\n        const revokedAt = await revokeUserSessions(userId)\n        if (!revokedAt) {\n          return NextResponse.json({ error: 'Failed to revoke sessions' }, { status: 500 })\n        }\n        return NextResponse.json({\n          success: true,\n          message: 'User sessions revoked. They will be logged out on their next request.',\n          revokedAt,\n        })\n      }\n\n      case 'grant_subscription':\n        // Grant subscription with specific tier ($10, $20, $30, or $50)\n        const tier = data?.tier // '10', '20', '30', or '50'\n        const priceCentsMap: Record<string, number> = {\n          '10': 1000,\n          '20': 2000,\n          '30': 3000,\n          '50': 5000\n        }\n        const priceCents = priceCentsMap[tier || '20'] || 2000\n        \n        // Check if subscription already exists and if tier is changing\n        const existingSub = await prisma.subscription.findUnique({\n          where: { userId }\n        })\n        \n        // If tier is changing, reset startDate to start new billing cycle\n        const shouldResetStartDate = existingSub && existingSub.monthlyPriceCents !== priceCents\n        \n        const newStartDate = shouldResetStartDate || !existingSub ? new Date() : existingSub.startDate\n        \n        await prisma.subscription.upsert({\n          where: { userId },\n          update: { \n            plan: 'PREMIUM',\n            monthlyPriceCents: priceCents,\n            // Reset startDate if tier changed or if subscription didn't exist\n            startDate: newStartDate\n          },\n          create: { \n            userId, \n            plan: 'PREMIUM',\n            monthlyPriceCents: priceCents,\n            startDate: newStartDate\n          }\n        })\n        \n        // Reset monthly counters and wallet when starting new subscription cycle\n        if (shouldResetStartDate || !existingSub) {\n          await prisma.user.update({\n            where: { id: userId },\n            data: {\n              dailyAnalysisCredits: 30,\n              walletMonthlyUsedCents: 0,\n              walletMonthlyResetAt: newStartDate,\n              monthlySymptomAnalysisUsed: 0,\n              monthlyFoodAnalysisUsed: 0,\n              monthlyMedicalImageAnalysisUsed: 0,\n              monthlyInteractionAnalysisUsed: 0,\n              monthlyInsightsGenerationUsed: 0,\n            } as any\n          })\n        } else {\n          // Just update daily credits if not resetting\n          await prisma.user.update({\n            where: { id: userId },\n            data: { dailyAnalysisCredits: 30 }\n          })\n        }\n        break\n\n      case 'deactivate':\n        // Remove subscription (delete subscription record)\n        await prisma.subscription.delete({\n          where: { userId }\n        }).catch(() => {\n          // Ignore if subscription doesn't exist\n        })\n        break\n\n      case 'grant_free_access':\n        // Grant permanent PREMIUM subscription (admin-only) - defaults to $20 tier\n        const endDate = new Date()\n        endDate.setFullYear(endDate.getFullYear() + 100) // 100 years = permanent\n        \n        await prisma.subscription.upsert({\n          where: { userId },\n          update: { \n            plan: 'PREMIUM',\n            endDate: endDate,\n            monthlyPriceCents: 2000 // Default to $20 tier\n          },\n          create: { \n            userId, \n            plan: 'PREMIUM',\n            endDate: endDate,\n            monthlyPriceCents: 2000\n          }\n        })\n        break\n\n      case 'grant_trial':\n        // Grant temporary PREMIUM subscription (admin-only)\n        const trialDays = data?.trialDays || 30\n        const trialEndDate = new Date()\n        trialEndDate.setDate(trialEndDate.getDate() + trialDays)\n        \n        // For 7-day trials, grant 250 credits ($5 tier = 500 cents, 50% = 250 credits)\n        // For 30-day trials, grant 1,000 credits ($20 tier = 2000 cents, 50% = 1,000 credits)\n        const monthlyPriceCents = trialDays === 7 ? 500 : 2000\n        \n        await prisma.subscription.upsert({\n          where: { userId },\n          update: { \n            plan: 'PREMIUM',\n            endDate: trialEndDate,\n            monthlyPriceCents: monthlyPriceCents\n          },\n          create: { \n            userId, \n            plan: 'PREMIUM',\n            endDate: trialEndDate,\n            monthlyPriceCents: monthlyPriceCents\n          }\n        })\n        break\n\n      case 'update_profile':\n        // Update user profile information\n        await prisma.user.update({\n          where: { id: userId },\n          data: {\n            name: data.name,\n            email: data.email,\n            gender: data.gender,\n            weight: data.weight,\n            height: data.height\n          }\n        })\n        break\n\n      case 'delete_user':\n        // Delete user and all related data (cascading)\n        await prisma.user.delete({\n          where: { id: userId }\n        })\n        break\n\n      case 'add_credits':\n        // Add credits using wallet-based system (CreditTopUp)\n        // Credits = cents (1 credit = 1 cent). Admin grants should reflect immediately in the meter,\n        // so we store them as non-expiring additionalCredits.\n        const creditPackage = data?.creditPackage // e.g., '250', '500', '1000'\n        const creditAmount = data?.creditAmount // Direct credit amount\n        \n        let centsAmount = 0\n        \n        if (creditPackage) {\n          // Credit packages: 250, 500, or 1000 credits (1 credit = 1 cent)\n          const packageMap: Record<string, number> = {\n            '250': 250,    // 250 credits = 250 cents\n            '500': 500,    // 500 credits = 500 cents\n            '1000': 1000   // 1000 credits = 1000 cents\n          }\n          \n          centsAmount = packageMap[creditPackage]\n          if (!centsAmount) {\n            return NextResponse.json({ error: 'Invalid credit package. Use: 250, 500, or 1000' }, { status: 400 })\n          }\n        } else if (creditAmount && creditAmount > 0) {\n          // Direct credit amount (credits = cents)\n          centsAmount = creditAmount\n        } else {\n          return NextResponse.json({ error: 'Invalid credit amount or package. Provide creditPackage (250/500/1000) or creditAmount (number)' }, { status: 400 })\n        }\n        \n        // Store as non-expiring additionalCredits so the meter and consumption see it immediately.\n        await prisma.user.update({\n          where: { id: userId },\n          data: {\n            additionalCredits: {\n              increment: centsAmount,\n            },\n          },\n        })\n        break\n\n      case 'remove_credits':\n        // Remove credits by creating a negative top-up or marking existing top-ups as used\n        const removeAmount = data?.creditAmount || 0\n        if (removeAmount <= 0) {\n          return NextResponse.json({ error: 'Invalid credit amount to remove' }, { status: 400 })\n        }\n        \n        // Get all non-expired, unused top-ups\n        const now = new Date()\n        const topUps = await prisma.creditTopUp.findMany({\n          where: {\n            userId,\n            expiresAt: { gt: now }\n          },\n          orderBy: { expiresAt: 'asc' } // FIFO - oldest first\n        })\n        \n        let remainingToRemove = removeAmount\n        for (const topUp of topUps) {\n          if (remainingToRemove <= 0) break\n          \n          const available = topUp.amountCents - topUp.usedCents\n          if (available > 0) {\n            const toRemove = Math.min(remainingToRemove, available)\n            await prisma.creditTopUp.update({\n              where: { id: topUp.id },\n              data: {\n                usedCents: topUp.usedCents + toRemove\n              }\n            })\n            remainingToRemove -= toRemove\n          }\n        }\n        \n        if (remainingToRemove > 0) {\n          return NextResponse.json({ \n            error: `Only ${removeAmount - remainingToRemove} credits were available to remove. ${remainingToRemove} credits could not be removed.`,\n            partial: true \n          }, { status: 200 }) // Still return 200 since some credits were removed\n        }\n        break\n\n      case 'refund_latest_payment': {\n        if (!process.env.STRIPE_SECRET_KEY) {\n          return NextResponse.json({ error: 'Stripe not configured' }, { status: 500 })\n        }\n        const user = await prisma.user.findUnique({\n          where: { id: userId },\n          select: { email: true },\n        })\n        if (!user?.email) {\n          return NextResponse.json({ error: 'User email not found' }, { status: 404 })\n        }\n\n        const customers = await stripe.customers.list({ email: user.email.toLowerCase(), limit: 1 })\n        if (!customers.data.length) {\n          return NextResponse.json({ error: 'Stripe customer not found' }, { status: 404 })\n        }\n        const customer = customers.data[0]\n        const charges = await stripe.charges.list({ customer: customer.id, limit: 10 })\n        const charge = charges.data.find(\n          (c) => c.paid && c.status === 'succeeded' && (c.amount - c.amount_refunded) > 0\n        )\n        if (!charge) {\n          return NextResponse.json({ error: 'No refundable payments found' }, { status: 404 })\n        }\n\n        const remaining = charge.amount - charge.amount_refunded\n        const requestedAmount = data?.amountCents ? Number(data.amountCents) : null\n        if (requestedAmount != null && (Number.isNaN(requestedAmount) || requestedAmount <= 0)) {\n          return NextResponse.json({ error: 'Invalid refund amount' }, { status: 400 })\n        }\n        if (requestedAmount != null && requestedAmount > remaining) {\n          return NextResponse.json({ error: 'Refund amount exceeds remaining balance' }, { status: 400 })\n        }\n\n        const refund = await stripe.refunds.create({\n          charge: charge.id,\n          ...(requestedAmount ? { amount: requestedAmount } : {}),\n        })\n\n        return NextResponse.json({\n          success: true,\n          refundId: refund.id,\n          refundedAmountCents: refund.amount,\n          currency: refund.currency,\n          chargeId: charge.id,\n          remainingAmountCents: Math.max(0, remaining - refund.amount),\n        })\n      }\n\n      case 'reset_daily_quota':\n        // Reset daily analysis quota using new credit system\n        await CreditManager.resetDailyQuota(userId)\n        break\n\n      case 'view_credit_usage':\n        // Get detailed credit usage information using new credit system\n        const creditUsage = await CreditManager.getCreditUsage(userId)\n        return NextResponse.json({ success: true, creditUsage })\n\n      default:\n        return NextResponse.json({ error: 'Invalid action' }, { status: 400 })\n    }\n\n    return NextResponse.json({ success: true, message: `User ${action} completed successfully` })\n\n  } catch (error) {\n    console.error('Error managing user:', error)\n    const errorMessage = error instanceof Error ? error.message : 'Failed to manage user'\n    return NextResponse.json({ error: errorMessage }, { status: 500 })\n  }\n} \n","truncated":false,"size":19875},{"path":"app/api/admin/users/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\nimport { extractAdminFromHeaders } from '@/lib/admin-auth'\n\n// This API route uses dynamic headers and should not be statically generated\nexport const runtime = 'nodejs'\nexport const dynamic = 'force-dynamic'\n\nexport async function GET(request: NextRequest) {\n  try {\n    // JWT authentication check\n    const authHeader = request.headers.get('authorization')\n    const admin = extractAdminFromHeaders(authHeader)\n    \n    if (!admin) {\n      return NextResponse.json(\n        { error: 'Unauthorized' },\n        { status: 401 }\n      )\n    }\n\n    // Get user statistics\n    const totalUsers = await prisma.user.count()\n    \n    const usersWithProfiles = await prisma.user.count({\n      where: {\n        OR: [\n          { name: { not: null } },\n          { gender: { not: null } },\n          { weight: { not: null } },\n          { height: { not: null } }\n        ]\n      }\n    })\n\n    const usersWithGoals = await prisma.user.count({\n      where: {\n        healthGoals: {\n          some: {}\n        }\n      }\n    })\n\n    const usersWithSupplements = await prisma.user.count({\n      where: {\n        supplements: {\n          some: {}\n        }\n      }\n    })\n\n    const usersWithMedications = await prisma.user.count({\n      where: {\n        medications: {\n          some: {}\n        }\n      }\n    })\n\n    const usersWithFoodLogs = await prisma.user.count({\n      where: {\n        foodLogs: {\n          some: {}\n        }\n      }\n    })\n\n    // Get recent signups (last 30 days)\n    const thirtyDaysAgo = new Date()\n    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30)\n    \n    const recentSignups = await prisma.user.count({\n      where: {\n        createdAt: {\n          gte: thirtyDaysAgo\n        }\n      }\n    })\n\n    // Get users by gender breakdown\n    const genderStats = await prisma.user.groupBy({\n      by: ['gender'],\n      _count: {\n        gender: true\n      }\n    })\n\n    // Get recent users (last 10)\n    const recentUsers = await prisma.user.findMany({\n      orderBy: { createdAt: 'desc' },\n      take: 10,\n      select: {\n        id: true,\n        email: true,\n        name: true,\n        createdAt: true,\n        gender: true,\n        _count: {\n          select: {\n            healthGoals: true,\n            supplements: true,\n            medications: true,\n            foodLogs: true\n          }\n        }\n      }\n    })\n\n    // Device interest counts (from user.data JSON field category if present)\n    // Count from hidden HealthGoal records storing device interest\n    const deviceApple = await prisma.healthGoal.count({ where: { name: '__DEVICE_INTEREST__', category: { contains: '\"appleWatch\":true' } } })\n    const deviceFitbit = await prisma.healthGoal.count({ where: { name: '__DEVICE_INTEREST__', category: { contains: '\"fitbit\":true' } } })\n    const deviceGarmin = await prisma.healthGoal.count({ where: { name: '__DEVICE_INTEREST__', category: { contains: '\"garmin\":true' } } })\n    const deviceSamsung = await prisma.healthGoal.count({ where: { name: '__DEVICE_INTEREST__', category: { contains: '\"samsung\":true' } } })\n    const deviceGoogleFit = await prisma.healthGoal.count({ where: { name: '__DEVICE_INTEREST__', category: { contains: '\"googleFit\":true' } } })\n    const deviceOura = await prisma.healthGoal.count({ where: { name: '__DEVICE_INTEREST__', category: { contains: '\"oura\":true' } } })\n    const devicePolar = await prisma.healthGoal.count({ where: { name: '__DEVICE_INTEREST__', category: { contains: '\"polar\":true' } } })\n\n    const stats = {\n      totalUsers,\n      usersWithProfiles,\n      usersWithGoals,\n      usersWithSupplements,\n      usersWithMedications,\n      usersWithFoodLogs,\n      recentSignups,\n      genderStats,\n      recentUsers,\n      completionRate: totalUsers > 0 ? Math.round((usersWithProfiles / totalUsers) * 100) : 0,\n      deviceInterest: {\n        appleWatch: deviceApple,\n        fitbit: deviceFitbit,\n        garmin: deviceGarmin,\n        samsung: deviceSamsung,\n        googleFit: deviceGoogleFit,\n        oura: deviceOura,\n        polar: devicePolar\n      }\n    }\n\n    return NextResponse.json(stats)\n\n  } catch (error) {\n    console.error('Error fetching user stats:', error)\n    return NextResponse.json(\n      { error: 'Failed to fetch user stats' },\n      { status: 500 }\n    )\n  }\n} \n","truncated":false,"size":4364},{"path":"app/api/admin/vercel-spend-test/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { extractAdminFromHeaders } from '@/lib/admin-auth'\nimport { sendVercelSpendAlertEmail } from '@/lib/admin-alerts'\n\nexport const runtime = 'nodejs'\nexport const dynamic = 'force-dynamic'\n\nfunction resolveBaseUrl(): string {\n  let base =\n    process.env.PUBLIC_BASE_URL ||\n    (process.env.VERCEL_URL ? `https://${process.env.VERCEL_URL}` : '') ||\n    process.env.NEXT_PUBLIC_APP_URL ||\n    ''\n  base = (base || '').trim()\n  if (base && !/^https?:\\/\\//i.test(base)) {\n    base = `https://${base}`\n  }\n  return base.replace(/\\/+$/, '')\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    const authHeader = request.headers.get('authorization')\n    const admin = extractAdminFromHeaders(authHeader)\n    if (!admin) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const secret = (process.env.VERCEL_SPEND_WEBHOOK_SECRET || '').trim()\n    if (!secret) {\n      return NextResponse.json({ error: 'Webhook secret not configured' }, { status: 400 })\n    }\n\n    const payload = {\n      test: true,\n      source: 'admin-panel',\n      sentAt: new Date().toISOString(),\n    }\n\n    const baseUrl = resolveBaseUrl()\n    if (!baseUrl) {\n      await sendVercelSpendAlertEmail({ payload })\n      return NextResponse.json({\n        ok: true,\n        delivered: 'email',\n        note: 'Base URL not configured; sent direct email instead.',\n      })\n    }\n\n    const webhookUrl = `${baseUrl}/api/vercel/spend-webhook?secret=${encodeURIComponent(secret)}`\n    const res = await fetch(webhookUrl, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(payload),\n    })\n\n    if (!res.ok) {\n      const text = await res.text().catch(() => '')\n      return NextResponse.json(\n        { error: 'Webhook test failed', status: res.status, detail: text },\n        { status: 500 }\n      )\n    }\n\n    return NextResponse.json({ ok: true, delivered: 'webhook', url: webhookUrl })\n  } catch (error) {\n    console.error('[admin vercel-spend-test] error', error)\n    return NextResponse.json({ error: 'Failed to send test webhook' }, { status: 500 })\n  }\n}\n","truncated":false,"size":2189},{"path":"app/api/admin/vision-usage/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { extractAdminFromHeaders } from '@/lib/admin-auth'\nimport { prisma } from '@/lib/prisma'\nimport { computeCostCentsFromTokens, fetchOpenAIUsageTotals } from '@/lib/openai-billing'\n\nexport const runtime = 'nodejs'\nexport const dynamic = 'force-dynamic'\n\nconst num = (value: any) => {\n  const n = Number(value)\n  return Number.isFinite(n) ? n : 0\n}\n\nconst safeModel = (model?: string | null) => (model && model.trim()) || 'gpt-4o'\n\nexport async function GET(req: NextRequest) {\n  try {\n    const authHeader = req.headers.get('authorization')\n    const admin = extractAdminFromHeaders(authHeader)\n    if (!admin) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const url = new URL(req.url)\n    const rangeRaw = url.searchParams.get('rangeDays')\n    const preset = url.searchParams.get('preset') // today|7|30|mtd\n    const userFilter = url.searchParams.get('user')\n\n    let rangeDays = 30\n    if (preset === 'today') rangeDays = 1\n    else if (preset === '7') rangeDays = 7\n    else if (preset === '30') rangeDays = 30\n    else if (preset === 'mtd') rangeDays = 60 // mtd handled separately\n    else if (rangeRaw) {\n      const parsed = Number(rangeRaw)\n      if (Number.isFinite(parsed) && parsed > 0) rangeDays = parsed\n    }\n\n    const now = new Date()\n    const from = new Date(now.getTime() - rangeDays * 24 * 60 * 60 * 1000)\n    const monthStart = new Date(now.getFullYear(), now.getMonth(), 1)\n    const rangeStart = preset === 'mtd' ? monthStart : from\n    const rangeStartStr = rangeStart.toISOString().slice(0, 10)\n    const todayStr = now.toISOString().slice(0, 10)\n    const monthStartStr = monthStart.toISOString().slice(0, 10)\n\n    const where: any = {\n      createdAt: { gte: rangeStart },\n    }\n    if (userFilter) {\n      where.OR = [\n        { userId: userFilter },\n        { userLabel: { contains: userFilter, mode: 'insensitive' } },\n      ]\n    }\n    // Avoid double-counting Food Analyzer usage:\n    // `/api/analyze-food` logs a per-request `food:image-*` or `food:text-*` event AND an\n    // aggregate `food:analysis` event with the same tokens, which inflates totals.\n    // The per-request events are the canonical ones for usage reporting.\n    where.NOT = [{ feature: 'food:analysis' }]\n\n    const [\n      rangeAggregates,\n      monthAggregates,\n      recent,\n      featureGroups,\n      featureModelGroups,\n      userModelGroups,\n      userFeatureGroups,\n      trendModelRaw,\n      billingRange,\n      billingMtd,\n    ] = await Promise.all([\n      prisma.aIUsageEvent.aggregate({\n        where,\n        _count: { _all: true },\n        _sum: { promptTokens: true, completionTokens: true, totalTokens: true },\n      }),\n      prisma.aIUsageEvent.aggregate({\n        where: {\n          ...(userFilter ? { OR: where.OR } : {}),\n          createdAt: { gte: monthStart },\n        },\n        _sum: { promptTokens: true, completionTokens: true, totalTokens: true },\n      }),\n      prisma.aIUsageEvent.findMany({\n        where,\n        orderBy: { createdAt: 'desc' },\n        take: 100,\n      }),\n      prisma.aIUsageEvent.groupBy({\n        by: ['feature'],\n        where,\n        _count: { _all: true },\n        _sum: { promptTokens: true, completionTokens: true, totalTokens: true },\n        _max: { imageWidth: true, imageHeight: true },\n      }),\n      prisma.aIUsageEvent.groupBy({\n        by: ['feature', 'model'],\n        where,\n        _count: { _all: true },\n        _sum: { promptTokens: true, completionTokens: true },\n      }),\n      prisma.aIUsageEvent.groupBy({\n        by: ['userId', 'userLabel', 'model'],\n        where,\n        _count: { _all: true },\n        _sum: { promptTokens: true, completionTokens: true },\n      }),\n      prisma.aIUsageEvent.groupBy({\n        by: ['userId', 'userLabel', 'feature'],\n        where,\n        _count: { _all: true },\n      }),\n      prisma.$queryRawUnsafe<\n        { day: string; model: string | null; prompttokens: number; completiontokens: number; calls: bigint }[]\n      >(\n        `SELECT TO_CHAR(\"createdAt\"::date, 'YYYY-MM-DD') as day,\n                COALESCE(\"model\", 'unknown') as model,\n                SUM(\"promptTokens\") as prompttokens,\n                SUM(\"completionTokens\") as completiontokens,\n                COUNT(*) as calls\n         FROM \"AIUsageEvent\"\n         WHERE \"createdAt\" >= $1${userFilter ? ' AND (\"userId\" = $2 OR \"userLabel\" ILIKE $3)' : ''}\n         GROUP BY 1, 2\n         ORDER BY 1, 2`,\n        rangeStart,\n        ...(userFilter ? [userFilter, `%${userFilter}%`] as any : []),\n      ),\n      fetchOpenAIUsageTotals({ startDate: rangeStartStr, endDate: todayStr }),\n      fetchOpenAIUsageTotals({ startDate: monthStartStr, endDate: todayStr }),\n    ])\n\n    const featureSummary: Record<string, any> = {}\n    featureGroups.forEach((fg) => {\n      featureSummary[fg.feature] = {\n        count: fg._count?._all || 0,\n        costCents: 0,\n        promptTokens: fg._sum?.promptTokens || 0,\n        completionTokens: fg._sum?.completionTokens || 0,\n        tokens: fg._sum?.totalTokens || 0,\n        maxWidth: fg._max?.imageWidth || null,\n        maxHeight: fg._max?.imageHeight || null,\n        models: {},\n        costSource: 'openai_ratecard',\n      }\n    })\n\n    featureModelGroups.forEach((fm) => {\n      const feature = fm.feature || 'unknown'\n      const promptTokens = num(fm._sum?.promptTokens)\n      const completionTokens = num(fm._sum?.completionTokens)\n      const modelCost = computeCostCentsFromTokens(safeModel(fm.model), promptTokens, completionTokens)\n      if (!featureSummary[feature]) {\n        featureSummary[feature] = {\n          count: num(fm._count?._all || 0),\n          costCents: modelCost,\n          promptTokens,\n          completionTokens,\n          tokens: promptTokens + completionTokens,\n          models: {},\n          maxWidth: null,\n          maxHeight: null,\n          costSource: 'openai_ratecard',\n        }\n      } else {\n        featureSummary[feature].costCents += modelCost\n      }\n      featureSummary[feature].models[fm.model] = {\n        count: num(fm._count?._all || 0),\n        promptTokens,\n        completionTokens,\n        costCents: modelCost,\n      }\n    })\n\n    Object.keys(featureSummary).forEach((key) => {\n      const f = featureSummary[key]\n      f.tokens = num(f.promptTokens) + num(f.completionTokens)\n    })\n\n    const userSummary: Record<string, any> = {}\n    userModelGroups.forEach((um) => {\n      const key = um.userId || um.userLabel || 'guest'\n      const label = um.userLabel || um.userId || 'guest'\n      if (!userSummary[key]) {\n        userSummary[key] = {\n          label,\n          count: 0,\n          costCents: 0,\n          promptTokens: 0,\n          completionTokens: 0,\n          tokens: 0,\n          features: {},\n        }\n      }\n      const promptTokens = num(um._sum?.promptTokens)\n      const completionTokens = num(um._sum?.completionTokens)\n      const modelCost = computeCostCentsFromTokens(safeModel(um.model), promptTokens, completionTokens)\n      userSummary[key].count += num(um._count?._all || 0)\n      userSummary[key].promptTokens += promptTokens\n      userSummary[key].completionTokens += completionTokens\n      userSummary[key].tokens = userSummary[key].promptTokens + userSummary[key].completionTokens\n      userSummary[key].costCents += modelCost\n    })\n\n    userFeatureGroups.forEach((uf) => {\n      const key = uf.userId || uf.userLabel || 'guest'\n      if (!userSummary[key]) {\n        userSummary[key] = {\n          label: uf.userLabel || uf.userId || 'guest',\n          count: 0,\n          costCents: 0,\n          promptTokens: 0,\n          completionTokens: 0,\n          tokens: 0,\n          features: {},\n        }\n      }\n      userSummary[key].features = userSummary[key].features || {}\n      userSummary[key].features[uf.feature] = (userSummary[key].features[uf.feature] || 0) + num(uf._count?._all || 0)\n    })\n\n    const trendByDay: Record<string, { costCents: number; calls: number }> = {}\n    ;(trendModelRaw || []).forEach((row) => {\n      const cost = computeCostCentsFromTokens(\n        safeModel((row as any).model),\n        num((row as any).prompttokens),\n        num((row as any).completiontokens),\n      )\n      if (!trendByDay[row.day]) {\n        trendByDay[row.day] = { costCents: 0, calls: 0 }\n      }\n      trendByDay[row.day].costCents += cost\n      trendByDay[row.day].calls += Number(row.calls || 0)\n    })\n\n    const trend = Object.entries(trendByDay)\n      .map(([day, val]) => ({\n        day,\n        costCents: val.costCents,\n        calls: val.calls,\n      }))\n      .sort((a, b) => a.day.localeCompare(b.day))\n\n    // Spike detection: compare latest day vs previous day\n    let spikeAlert: any = null\n    if (trend.length >= 2) {\n      const last = trend[trend.length - 1]\n      const prev = trend[trend.length - 2]\n      if (prev.costCents > 0 && last.costCents > prev.costCents * 1.4) {\n        spikeAlert = {\n          todayCostCents: last.costCents,\n          yesterdayCostCents: prev.costCents,\n          increasePct: ((last.costCents - prev.costCents) / prev.costCents) * 100,\n        }\n      }\n    }\n\n    const recentMapped = recent.map((r) => {\n      const costCents = computeCostCentsFromTokens(safeModel(r.model), num(r.promptTokens), num(r.completionTokens))\n      return {\n        ...r,\n        costUsd: costCents / 100,\n        tokens: Number(r.totalTokens || (Number(r.promptTokens || 0) + Number(r.completionTokens || 0))),\n        timestampIso: r.createdAt.toISOString(),\n        expensive: costCents > 1000, // > $10\n      }\n    })\n\n    const costFromLogsCents = Object.values(featureSummary).reduce((acc, f: any) => acc + num(f.costCents), 0)\n\n    const totals = {\n      totalCalls: rangeAggregates._count?._all || 0,\n      totalPromptTokens: rangeAggregates._sum?.promptTokens || 0,\n      totalCompletionTokens: rangeAggregates._sum?.completionTokens || 0,\n      totalTokens: rangeAggregates._sum?.totalTokens || 0,\n      monthPromptTokens: monthAggregates._sum?.promptTokens || 0,\n      monthCompletionTokens: monthAggregates._sum?.completionTokens || 0,\n      monthTotalTokens: monthAggregates._sum?.totalTokens || 0,\n      rangeCostCentsFromLogs: costFromLogsCents,\n    }\n\n    const tokenSource = billingRange.tokenTotals ? 'openai_usage' : 'app_logs'\n    const altKeys = Object.keys(process.env || {}).filter(\n      (key) => key !== 'OPENAI_API_KEY' && key.toUpperCase().includes('OPENAI_API_KEY') && process.env[key],\n    )\n\n    return NextResponse.json({\n      success: true,\n      rangeDays,\n      rangeStart: rangeStartStr,\n      rangeEnd: todayStr,\n      totalCalls: totals.totalCalls,\n      totalCostCents: billingRange.totalUsageCents ?? costFromLogsCents,\n      features: Object.keys(featureSummary).length,\n      featureSummary,\n      userSummary,\n      trend,\n      recent: recentMapped,\n      totals,\n      spikeAlert,\n      billing: {\n        range: billingRange,\n        monthToDate: billingMtd,\n      },\n      sources: {\n        billing: billingRange.source,\n        billingFallback: billingRange.usingFallback || billingMtd.usingFallback,\n        tokens: tokenSource,\n        logsCostCents: costFromLogsCents,\n      },\n      keyStatus: {\n        hasKey: !!process.env.OPENAI_API_KEY,\n        altKeys,\n        baseUrl: process.env.OPENAI_BASE_URL || 'https://api.openai.com',\n      },\n    })\n  } catch (err) {\n    console.error('[admin vision-usage] error', err)\n    return NextResponse.json({ error: 'Failed to load vision usage' }, { status: 500 })\n  }\n}\n","truncated":false,"size":11531},{"path":"app/api/affiliate/application/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\nimport { getAffiliateUser } from '@/lib/affiliate-auth'\n\nexport const runtime = 'nodejs'\nexport const dynamic = 'force-dynamic'\n\nexport async function GET(request: NextRequest) {\n  const user = await getAffiliateUser(request)\n  if (!user?.email) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n\n  const affiliate = await prisma.affiliate.findUnique({\n    where: { userId: user.id },\n    select: {\n      id: true,\n      code: true,\n      status: true,\n      stripeConnectAccountId: true,\n      stripeConnectDetailsSubmitted: true,\n      stripeConnectChargesEnabled: true,\n      stripeConnectPayoutsEnabled: true,\n    },\n  })\n\n  const application = await prisma.affiliateApplication.findFirst({\n    where: { userId: user.id },\n    orderBy: { createdAt: 'desc' },\n    select: {\n      id: true,\n      status: true,\n      autoApproved: true,\n      riskLevel: true,\n      recommendation: true,\n      primaryChannel: true,\n      primaryChannelOther: true,\n      audienceSize: true,\n      termsVersion: true,\n      termsAcceptedAt: true,\n      createdAt: true,\n      reviewedAt: true,\n      aiReasoning: true,\n    },\n  })\n\n  return NextResponse.json({ ok: true, affiliate, application })\n}\n","truncated":false,"size":1297},{"path":"app/api/affiliate/apply/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\nimport { screenAffiliateApplication } from '@/lib/affiliate-screening'\nimport { notifyAdminAffiliateManualReview } from '@/lib/affiliate-admin-email'\nimport { createUniqueAffiliateCode } from '@/lib/affiliate-code'\nimport { getAffiliateUser } from '@/lib/affiliate-auth'\n\nexport const runtime = 'nodejs'\nexport const dynamic = 'force-dynamic'\n\nconst AFFILIATE_TERMS_VERSION = '2025-12-22'\n\nfunction getClientIp(request: NextRequest): string | null {\n  const header = request.headers.get('x-forwarded-for')\n  if (!header) return null\n  const first = header.split(',')[0]?.trim()\n  return first || null\n}\n\nexport async function POST(request: NextRequest) {\n  const user = await getAffiliateUser(request)\n  const email = user?.email?.toLowerCase()\n  if (!email || !user?.id) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n\n  const body = await request.json().catch(() => ({}))\n  const name = String(body?.name || '').trim()\n  const website = body?.website ? String(body.website).trim() : null\n  const primaryChannel = String(body?.primaryChannel || '').trim()\n  const primaryChannelOther = body?.primaryChannelOther ? String(body.primaryChannelOther).trim() : null\n  const audienceSize = body?.audienceSize ? String(body.audienceSize).trim() : null\n  const termsAccepted = Boolean(body?.termsAccepted)\n  const termsVersion = String(body?.termsVersion || '').trim()\n  const promotionMethod = String(body?.promotionMethod || '').trim()\n  const notes = body?.notes ? String(body.notes).trim() : null\n\n  if (!name || name.length < 2) return NextResponse.json({ error: 'Name is required' }, { status: 400 })\n  if (!termsAccepted || termsVersion !== AFFILIATE_TERMS_VERSION) {\n    return NextResponse.json({ error: 'You must accept the affiliate terms to apply' }, { status: 400 })\n  }\n  if (!primaryChannel) {\n    return NextResponse.json({ error: 'Primary promotion channel is required' }, { status: 400 })\n  }\n  const allowedChannels = new Set([\n    'WEBSITE',\n    'YOUTUBE',\n    'SOCIAL',\n    'NEWSLETTER',\n    'PODCAST',\n    'COMMUNITY',\n    'PAID_ADS',\n    'OTHER',\n  ])\n  if (!allowedChannels.has(primaryChannel)) {\n    return NextResponse.json({ error: 'Invalid promotion channel' }, { status: 400 })\n  }\n  if (primaryChannel === 'OTHER') {\n    if (!primaryChannelOther || primaryChannelOther.length < 2) {\n      return NextResponse.json({ error: 'Please specify the other channel' }, { status: 400 })\n    }\n  }\n  const allowedAudienceSizes = new Set([\n    'UNDER_1K',\n    '1K_10K',\n    '10K_50K',\n    '50K_250K',\n    '250K_PLUS',\n    'UNKNOWN',\n  ])\n  if (audienceSize && !allowedAudienceSizes.has(audienceSize)) {\n    return NextResponse.json({ error: 'Invalid audience size' }, { status: 400 })\n  }\n  if (!promotionMethod || promotionMethod.length < 10) {\n    return NextResponse.json({ error: 'Promotion method must be at least 10 characters' }, { status: 400 })\n  }\n\n  const existingAffiliate = await prisma.affiliate.findFirst({\n    where: { user: { email } },\n    select: { id: true, code: true, status: true },\n  })\n  if (existingAffiliate) {\n    return NextResponse.json({ ok: true, alreadyAffiliate: true, affiliate: existingAffiliate })\n  }\n\n  const ip = getClientIp(request)\n  const userAgent = request.headers.get('user-agent')\n  const country = request.headers.get('cf-ipcountry') || null\n  const region = request.headers.get('x-vercel-ip-country-region') || null\n  const city = request.headers.get('x-vercel-ip-city') || null\n\n  const application = await prisma.affiliateApplication.create({\n    data: {\n      userId: user.id,\n      email,\n      name,\n      website,\n      primaryChannel,\n      primaryChannelOther,\n      audienceSize,\n      termsVersion,\n      termsAcceptedAt: new Date(),\n      promotionMethod,\n      notes,\n      ip,\n      userAgent,\n      country,\n      region,\n      city,\n    },\n    select: { id: true },\n  })\n\n  const screening = await screenAffiliateApplication({\n    email,\n    name,\n    website,\n    primaryChannel,\n    primaryChannelOther,\n    audienceSize,\n    promotionMethod,\n    notes,\n    ip,\n    userAgent,\n    country,\n    region,\n    city,\n  })\n\n  const isLowAutoApprove = screening.riskLevel === 'LOW' && screening.recommendedAction === 'AUTO_APPROVE'\n\n  await prisma.affiliateApplication.update({\n    where: { id: application.id },\n    data: {\n      riskLevel: screening.riskLevel,\n      recommendation: screening.recommendedAction,\n      aiReasoning: screening.reasoning,\n      aiRawJson: screening.raw ?? null,\n      status: isLowAutoApprove ? 'APPROVED' : 'PENDING_REVIEW',\n      autoApproved: isLowAutoApprove,\n      reviewedAt: isLowAutoApprove ? new Date() : null,\n    },\n  })\n\n  if (!isLowAutoApprove && (screening.riskLevel === 'MEDIUM' || screening.riskLevel === 'HIGH')) {\n    const ownerEmail = process.env.OWNER_EMAIL\n    if (ownerEmail) {\n      notifyAdminAffiliateManualReview({\n        toEmail: ownerEmail,\n        applicationId: application.id,\n        applicantEmail: email,\n        applicantName: name,\n        riskLevel: screening.riskLevel,\n        reasoning: screening.reasoning,\n      }).catch(() => {})\n    }\n  }\n\n  if (!isLowAutoApprove) {\n    return NextResponse.json({\n      ok: true,\n      status: 'PENDING_REVIEW',\n      applicationId: application.id,\n      screening: {\n        riskLevel: screening.riskLevel,\n        recommendedAction: screening.recommendedAction,\n      },\n    })\n  }\n\n  const code = await createUniqueAffiliateCode()\n  const affiliate = await prisma.affiliate.create({\n    data: {\n      userId: user.id,\n      applicationId: application.id,\n      code,\n      status: 'ACTIVE',\n    },\n    select: { id: true, code: true, status: true },\n  })\n\n  return NextResponse.json({\n    ok: true,\n    status: 'APPROVED',\n    affiliate,\n  })\n}\n","truncated":false,"size":5847},{"path":"app/api/affiliate/connect/onboard/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport Stripe from 'stripe'\nimport { prisma } from '@/lib/prisma'\nimport { getAffiliateUser } from '@/lib/affiliate-auth'\n\nexport const runtime = 'nodejs'\nexport const dynamic = 'force-dynamic'\n\nexport async function POST(request: NextRequest) {\n  const user = await getAffiliateUser(request)\n  if (!user?.email) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n\n  const secretKey = process.env.STRIPE_SECRET_KEY\n  if (!secretKey) return NextResponse.json({ error: 'Stripe not configured' }, { status: 500 })\n  const stripe = new Stripe(secretKey, { apiVersion: '2024-06-20' })\n\n  const affiliate = await prisma.affiliate.findUnique({\n    where: { userId: user.id },\n    select: { id: true, status: true, stripeConnectAccountId: true },\n  })\n  if (!affiliate || affiliate.status !== 'ACTIVE') {\n    return NextResponse.json({ error: 'Not an active affiliate' }, { status: 403 })\n  }\n\n  const origin = new URL(request.url).origin\n  const returnUrl = `${origin}/affiliate`\n\n  let accountId = affiliate.stripeConnectAccountId\n  if (!accountId) {\n    const account = await stripe.accounts.create({\n      type: 'express',\n      country: 'AU',\n      email: user.email,\n      capabilities: { transfers: { requested: true } },\n      metadata: { helfi_affiliate_id: affiliate.id },\n    })\n    accountId = account.id\n    await prisma.affiliate.update({\n      where: { id: affiliate.id },\n      data: { stripeConnectAccountId: accountId },\n    })\n  }\n\n  const accountLink = await stripe.accountLinks.create({\n    account: accountId,\n    refresh_url: `${returnUrl}?connect=refresh`,\n    return_url: `${returnUrl}?connect=return`,\n    type: 'account_onboarding',\n  })\n\n  return NextResponse.json({ url: accountLink.url })\n}\n","truncated":false,"size":1787},{"path":"app/api/affiliate/me/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\nimport { getAffiliateUser } from '@/lib/affiliate-auth'\n\nexport const runtime = 'nodejs'\nexport const dynamic = 'force-dynamic'\n\nexport async function GET(request: NextRequest) {\n  const user = await getAffiliateUser(request)\n  if (!user?.email) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n\n  const affiliate = await prisma.affiliate.findUnique({\n    where: { userId: user.id },\n    select: {\n      id: true,\n      code: true,\n      status: true,\n      stripeConnectAccountId: true,\n      stripeConnectDetailsSubmitted: true,\n      stripeConnectChargesEnabled: true,\n      stripeConnectPayoutsEnabled: true,\n      stripeConnectOnboardedAt: true,\n      createdAt: true,\n    },\n  })\n  if (!affiliate) return NextResponse.json({ ok: true, affiliate: null })\n\n  const [clickCount, uniqueVisitors, conversionCounts, sums] = await Promise.all([\n    prisma.affiliateClick.count({ where: { affiliateId: affiliate.id } }),\n    prisma.affiliateClick.findMany({\n      where: { affiliateId: affiliate.id },\n      distinct: ['visitorId'],\n      select: { visitorId: true },\n    }),\n    prisma.affiliateConversion.groupBy({\n      by: ['type'],\n      where: { affiliateId: affiliate.id },\n      _count: { _all: true },\n    }),\n    prisma.affiliateCommission.groupBy({\n      by: ['status'],\n      where: { affiliateId: affiliate.id },\n      _sum: { commissionCents: true },\n    }),\n  ])\n\n  const now = new Date()\n  const payableSum = await prisma.affiliateCommission.aggregate({\n    where: { affiliateId: affiliate.id, status: 'PENDING', payableAt: { lte: now } },\n    _sum: { commissionCents: true },\n  })\n\n  const conversions = await prisma.affiliateConversion.findMany({\n    where: { affiliateId: affiliate.id },\n    orderBy: { occurredAt: 'desc' },\n    take: 50,\n    select: {\n      occurredAt: true,\n      type: true,\n      currency: true,\n      amountGrossCents: true,\n      stripeFeeCents: true,\n      amountNetCents: true,\n      commission: { select: { status: true, commissionCents: true, payableAt: true, paidAt: true } },\n    },\n  })\n\n  const stats = {\n    clicks: clickCount,\n    uniqueVisitors: uniqueVisitors.length,\n    conversionsByType: conversionCounts.reduce(\n      (acc: Record<string, number>, row: any) => {\n        acc[row.type] = row._count._all\n        return acc\n      },\n      {} as Record<string, number>\n    ),\n    commissionTotalsByStatus: sums.reduce(\n      (acc: Record<string, number>, row: any) => {\n        acc[row.status] = Number(row._sum.commissionCents || 0)\n        return acc\n      },\n      {} as Record<string, number>\n    ),\n    payableNowCents: Number(payableSum._sum.commissionCents || 0),\n  }\n\n  return NextResponse.json({\n    ok: true,\n    affiliate,\n    referralLink: `/r/${affiliate.code}`,\n    stats,\n    events: conversions.map(c => ({\n      occurredAt: c.occurredAt,\n      type: c.type,\n      currency: c.currency,\n      amountGrossCents: c.amountGrossCents,\n      stripeFeeCents: c.stripeFeeCents,\n      amountNetCents: c.amountNetCents,\n      commission: c.commission,\n    })),\n  })\n}\n","truncated":false,"size":3142},{"path":"app/api/ai-meal-recommendation/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { getToken } from 'next-auth/jwt'\nimport OpenAI from 'openai'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\nimport { CreditManager } from '@/lib/credit-system'\nimport { runChatCompletionWithLogging } from '@/lib/ai-usage-logger'\nimport { calculateDailyTargets } from '@/lib/daily-targets'\nimport { estimateTokensFromText, openaiCostCentsForTokens } from '@/lib/cost-meter'\nimport {\n  AI_MEAL_RECOMMENDATION_CREDITS,\n  AI_MEAL_RECOMMENDATION_GOAL_NAME,\n  AI_MEAL_RECOMMENDATION_HISTORY_LIMIT,\n  AI_MEAL_RECOMMENDATION_STORAGE_VERSION,\n  MealCategory,\n  normalizeMealCategory,\n} from '@/lib/ai-meal-recommendation'\n\nexport const dynamic = 'force-dynamic'\nexport const revalidate = 0\n\ntype MacroTotals = {\n  calories: number | null\n  protein_g: number | null\n  carbs_g: number | null\n  fat_g: number | null\n  fiber_g: number | null\n  sugar_g: number | null\n}\n\ntype RecommendedItem = {\n  id?: string\n  name: string\n  serving_size?: string | null\n  calories?: number | null\n  protein_g?: number | null\n  carbs_g?: number | null\n  fat_g?: number | null\n  fiber_g?: number | null\n  sugar_g?: number | null\n  servings: number\n}\n\ntype RecommendedMealRecord = {\n  id: string\n  createdAt: string\n  date: string\n  category: MealCategory\n  mealName: string\n  tags: string[]\n  why: string\n  recipe?: {\n    servings?: number | null\n    prepMinutes?: number | null\n    cookMinutes?: number | null\n    steps: string[]\n  } | null\n  items: RecommendedItem[]\n  totals: MacroTotals\n}\n\ntype StoredState = {\n  version: number\n  history: RecommendedMealRecord[]\n  seenExplainAt?: string | null\n  committedIds?: string[] | null\n}\n\nconst DATE_RE = /^\\d{4}-\\d{2}-\\d{2}$/\n\nconst clamp = (n: number, min: number, max: number) => Math.min(max, Math.max(min, n))\n\nconst round3 = (n: number) => Math.round(n * 1000) / 1000\n\nconst macroOrZero = (v: any) => (typeof v === 'number' && Number.isFinite(v) ? v : 0)\n\nconst computeTotalsFromItems = (items: RecommendedItem[]): MacroTotals => {\n  const total = { calories: 0, protein_g: 0, carbs_g: 0, fat_g: 0, fiber_g: 0, sugar_g: 0 }\n  for (const item of items) {\n    const servings = typeof item.servings === 'number' && Number.isFinite(item.servings) ? item.servings : 0\n    total.calories += macroOrZero(item.calories) * servings\n    total.protein_g += macroOrZero(item.protein_g) * servings\n    total.carbs_g += macroOrZero(item.carbs_g) * servings\n    total.fat_g += macroOrZero(item.fat_g) * servings\n    total.fiber_g += macroOrZero(item.fiber_g) * servings\n    total.sugar_g += macroOrZero(item.sugar_g) * servings\n  }\n  return {\n    calories: Math.round(total.calories),\n    protein_g: round3(total.protein_g),\n    carbs_g: round3(total.carbs_g),\n    fat_g: round3(total.fat_g),\n    fiber_g: round3(total.fiber_g),\n    sugar_g: round3(total.sugar_g),\n  }\n}\n\nfunction parseJsonRelaxed(raw: string): any | null {\n  try {\n    return JSON.parse(raw)\n  } catch {\n    try {\n      const trimmed = String(raw || '').trim()\n      const fenced = trimmed.replace(/^```(?:json)?/i, '').replace(/```$/i, '').trim()\n      const keysQuoted = fenced.replace(/([{,]\\s*)([A-Za-z0-9_]+)\\s*:/g, '$1\"$2\":')\n      const doubleQuoted = keysQuoted.replace(/'/g, '\"')\n      const noTrailingCommas = doubleQuoted.replace(/,\\s*([}\\]])/g, '$1')\n      return JSON.parse(noTrailingCommas)\n    } catch {\n      return null\n    }\n  }\n}\n\nconst MEAL_NAME_STOPWORDS = new Set(\n  [\n    'ai',\n    'recommended',\n    'meal',\n    'breakfast',\n    'lunch',\n    'dinner',\n    'snack',\n    'snacks',\n    'other',\n    'with',\n    'and',\n    'or',\n    'the',\n    'a',\n    'an',\n    'of',\n    'in',\n    'on',\n    'over',\n    'to',\n    'for',\n    'style',\n    'bowl',\n    'salad',\n    'plate',\n    'wrap',\n    'sandwich',\n    'stir',\n    'fry',\n    'stirfry',\n    'stir-fry',\n    'grilled',\n    'baked',\n    'roasted',\n    'steamed',\n    'sauteed',\n    'saut√©ed',\n    'seared',\n    'poached',\n    'boiled',\n    'broiled',\n    'pan',\n    'air',\n    'fryer',\n    'slow',\n    'cooked',\n    'quick',\n    'easy',\n    'simple',\n    'healthy',\n    'high',\n    'low',\n    'protein',\n    'carb',\n    'carbs',\n    'fat',\n    'fiber',\n    'fibre',\n    'sugar',\n    'heart',\n    'friendly',\n    'gut',\n    'hormone',\n    'supportive',\n    'support',\n    'anti',\n    'inflammatory',\n    'mediterranean',\n    'italian',\n    'mexican',\n    'asian',\n    'thai',\n    'indian',\n    'greek',\n    'korean',\n    'japanese',\n    'vietnamese',\n  ].map((v) => v.toLowerCase()),\n)\n\nconst MEAL_NAME_FLAVOR_TOKEN_TO_ITEM: Record<\n  string,\n  { name: string; serving_size: string; calories: number; protein_g: number; carbs_g: number; fat_g: number; fiber_g: number; sugar_g: number }\n> = {\n  lemon: { name: 'Lemon juice', serving_size: '1 tsp', calories: 1, protein_g: 0, carbs_g: 0.3, fat_g: 0, fiber_g: 0, sugar_g: 0 },\n  lime: { name: 'Lime juice', serving_size: '1 tsp', calories: 1, protein_g: 0, carbs_g: 0.3, fat_g: 0, fiber_g: 0, sugar_g: 0 },\n  garlic: { name: 'Garlic, raw', serving_size: '1 clove', calories: 4, protein_g: 0.2, carbs_g: 1, fat_g: 0, fiber_g: 0.1, sugar_g: 0 },\n  ginger: { name: 'Ginger, raw', serving_size: '1 tsp', calories: 2, protein_g: 0, carbs_g: 0.4, fat_g: 0, fiber_g: 0, sugar_g: 0 },\n  onion: { name: 'Onion, raw', serving_size: '2 tbsp', calories: 8, protein_g: 0.2, carbs_g: 1.9, fat_g: 0, fiber_g: 0.3, sugar_g: 0.8 },\n  parsley: { name: 'Parsley', serving_size: '1 tbsp', calories: 1, protein_g: 0.1, carbs_g: 0.2, fat_g: 0, fiber_g: 0.1, sugar_g: 0 },\n  basil: { name: 'Basil', serving_size: '1 tbsp', calories: 1, protein_g: 0.1, carbs_g: 0.1, fat_g: 0, fiber_g: 0.1, sugar_g: 0 },\n  oregano: { name: 'Oregano', serving_size: '1 tsp', calories: 3, protein_g: 0.1, carbs_g: 0.7, fat_g: 0.1, fiber_g: 0.4, sugar_g: 0 },\n  cilantro: { name: 'Cilantro', serving_size: '1 tbsp', calories: 1, protein_g: 0.1, carbs_g: 0.1, fat_g: 0, fiber_g: 0.1, sugar_g: 0 },\n  coriander: { name: 'Coriander', serving_size: '1 tsp', calories: 3, protein_g: 0.1, carbs_g: 0.6, fat_g: 0.2, fiber_g: 0.4, sugar_g: 0 },\n  cumin: { name: 'Cumin', serving_size: '1 tsp', calories: 8, protein_g: 0.4, carbs_g: 0.9, fat_g: 0.5, fiber_g: 0.2, sugar_g: 0 },\n  paprika: { name: 'Paprika', serving_size: '1 tsp', calories: 6, protein_g: 0.3, carbs_g: 1.2, fat_g: 0.3, fiber_g: 0.7, sugar_g: 0.4 },\n  turmeric: { name: 'Turmeric', serving_size: '1 tsp', calories: 8, protein_g: 0.2, carbs_g: 1.4, fat_g: 0.2, fiber_g: 0.5, sugar_g: 0.1 },\n  chili: { name: 'Chili flakes', serving_size: '1 tsp', calories: 6, protein_g: 0.2, carbs_g: 1.1, fat_g: 0.3, fiber_g: 0.7, sugar_g: 0.5 },\n  chilli: { name: 'Chili flakes', serving_size: '1 tsp', calories: 6, protein_g: 0.2, carbs_g: 1.1, fat_g: 0.3, fiber_g: 0.7, sugar_g: 0.5 },\n  vinegar: { name: 'Vinegar', serving_size: '1 tbsp', calories: 3, protein_g: 0, carbs_g: 0.1, fat_g: 0, fiber_g: 0, sugar_g: 0 },\n  olive: { name: 'Olive oil', serving_size: '1 tsp', calories: 40, protein_g: 0, carbs_g: 0, fat_g: 4.5, fiber_g: 0, sugar_g: 0 },\n  oil: { name: 'Olive oil', serving_size: '1 tsp', calories: 40, protein_g: 0, carbs_g: 0, fat_g: 4.5, fiber_g: 0, sugar_g: 0 },\n}\n\nconst tokenize = (raw: string) =>\n  String(raw || '')\n    .toLowerCase()\n    .replace(/[^a-z0-9]+/g, ' ')\n    .split(' ')\n    .map((t) => t.trim())\n    .filter(Boolean)\n    .map((t) => (t.endsWith('s') && t.length > 3 ? t.slice(0, -1) : t))\n\nconst buildTokenSetFromItems = (items: RecommendedItem[]) => {\n  const set = new Set<string>()\n  for (const item of items) {\n    for (const t of tokenize(item?.name || '')) set.add(t)\n  }\n  return set\n}\n\nconst inferMealNameFromItems = (category: MealCategory, items: RecommendedItem[]) => {\n  const cleaned = items\n    .map((it) => String(it?.name || '').replace(/\\([^)]*\\)/g, '').trim())\n    .filter(Boolean)\n    .map((name) => name.split(',')[0].trim())\n  if (cleaned.length === 0) return `AI Recommended ${category}`\n\n  const scored = items\n    .map((it, idx) => {\n      const cals = Number(it?.calories || 0)\n      const servings = Number(it?.servings || 0)\n      const score = (Number.isFinite(cals) ? cals : 0) * (Number.isFinite(servings) ? servings : 1)\n      return { idx, score }\n    })\n    .sort((a, b) => b.score - a.score)\n    .map((s) => cleaned[s.idx] || cleaned[0])\n    .filter(Boolean)\n\n  const primary = scored[0] || cleaned[0]\n  const sides = scored.slice(1, 3).filter((v) => v && v.toLowerCase() !== primary.toLowerCase())\n  if (sides.length === 0) return primary\n  if (sides.length === 1) return `${primary} with ${sides[0]}`\n  return `${primary} with ${sides[0]} & ${sides[1]}`\n}\n\nconst applyMealNameConsistency = (category: MealCategory, mealNameRaw: string, itemsRaw: RecommendedItem[]) => {\n  let mealName = String(mealNameRaw || '').trim()\n  let items = Array.isArray(itemsRaw) ? [...itemsRaw] : []\n  const itemTokens = buildTokenSetFromItems(items)\n\n  const unmatchedMeaningful: string[] = []\n  for (const token of tokenize(mealName)) {\n    if (MEAL_NAME_STOPWORDS.has(token)) continue\n    if (itemTokens.has(token)) continue\n    const flavor = MEAL_NAME_FLAVOR_TOKEN_TO_ITEM[token]\n    if (flavor) {\n      // Avoid duplicates (e.g. \"oil\" + \"olive\" both map to Olive oil).\n      const exists = items.some((it) => String(it?.name || '').toLowerCase().includes(flavor.name.toLowerCase()))\n      if (!exists) {\n        items.push({\n          name: flavor.name,\n          serving_size: flavor.serving_size,\n          servings: 1,\n          calories: flavor.calories,\n          protein_g: flavor.protein_g,\n          carbs_g: flavor.carbs_g,\n          fat_g: flavor.fat_g,\n          fiber_g: flavor.fiber_g,\n          sugar_g: flavor.sugar_g,\n        })\n      }\n      continue\n    }\n    // Might be a cooking/style word we missed; track but don‚Äôt immediately reject.\n    if (token.length >= 4) unmatchedMeaningful.push(token)\n  }\n\n  if (!mealName) {\n    mealName = inferMealNameFromItems(category, items)\n  } else if (unmatchedMeaningful.length >= 3) {\n    // If too many meaningful tokens don't map to ingredients, fall back to a deterministic name\n    // derived from the ingredient list to avoid misleading titles.\n    mealName = inferMealNameFromItems(category, items)\n  }\n\n  return { mealName, items }\n}\n\nconst normalizeRecipe = (raw: any) => {\n  if (!raw || typeof raw !== 'object') return null\n  const steps = Array.isArray((raw as any).steps)\n    ? (raw as any).steps\n        .map((s: any) => String(s || '').trim())\n        .filter(Boolean)\n        .slice(0, 12)\n    : []\n  if (steps.length === 0) return null\n  const prepMinutes = Number((raw as any).prepMinutes ?? (raw as any).prep_minutes)\n  const cookMinutes = Number((raw as any).cookMinutes ?? (raw as any).cook_minutes)\n  const servings = Number((raw as any).servings ?? null)\n  return {\n    servings: Number.isFinite(servings) && servings > 0 ? Math.round(servings) : null,\n    prepMinutes: Number.isFinite(prepMinutes) && prepMinutes >= 0 ? Math.round(prepMinutes) : null,\n    cookMinutes: Number.isFinite(cookMinutes) && cookMinutes >= 0 ? Math.round(cookMinutes) : null,\n    steps,\n  }\n}\n\nconst buildFallbackRecipe = (category: MealCategory, items: RecommendedItem[]) => {\n  const names = items.map((it) => String(it?.name || '').trim()).filter(Boolean)\n  const has = (re: RegExp) => names.some((n) => re.test(n.toLowerCase()))\n\n  const mainCooking = (() => {\n    if (has(/\\b(egg|eggs|egg whites)\\b/)) return 'Cook the eggs in a non-stick pan until set.'\n    if (has(/\\b(cod|salmon|tuna|fish|prawn|shrimp)\\b/)) return 'Cook the fish gently (bake, steam, or pan-sear) until it flakes.'\n    if (has(/\\b(chicken|beef|pork|lamb|turkey)\\b/)) return 'Cook the protein through in a pan or oven until done.'\n    if (has(/\\b(tofu|tempeh|edamame)\\b/)) return 'Sear the tofu/tempeh until golden.'\n    return 'Cook the main ingredient using your preferred method until ready.'\n  })()\n\n  const carbCooking = (() => {\n    if (has(/\\b(lentil|lentils|bean|beans|chickpea|chickpeas)\\b/)) return 'Warm the legumes (or cook if needed) and season lightly.'\n    if (has(/\\b(rice|quinoa|oats|pasta|barley)\\b/)) return 'Cook the grains according to the package directions.'\n    return null\n  })()\n\n  const vegCooking = has(/\\b(broccoli|spinach|kale|lettuce|carrot|tomato|cucumber|zucchini|capsicum|pepper|onion|mushroom)\\b/)\n    ? 'Steam or saut√© the vegetables until tender-crisp.'\n    : null\n\n  const seasoning = has(/\\b(lemon|lime|garlic|ginger|turmeric|cumin|paprika|chili|chilli|parsley|basil|oregano|coriander|cilantro|vinegar|oil)\\b/)\n    ? 'Finish with your listed herbs/spices (and lemon/lime if included) to taste.'\n    : 'Season to taste.'\n\n  const steps = [\n    `Prep your ingredients: measure the servings and chop/trim anything that needs it.`,\n    mainCooking,\n    carbCooking,\n    vegCooking,\n    `Combine everything in a bowl/plate and mix gently.`,\n    seasoning,\n  ].filter(Boolean) as string[]\n\n  const base = category === 'breakfast' ? { prepMinutes: 8, cookMinutes: 10 } : category === 'snacks' ? { prepMinutes: 6, cookMinutes: 6 } : { prepMinutes: 10, cookMinutes: 15 }\n  return { servings: 1, ...base, steps: steps.slice(0, 10) }\n}\n\n// Revenue per credit (in USD cents) used to guarantee profit margins.\n// Subscriptions: $20 -> 1400 credits == 1.4286 cents/credit (same across tiers).\n// Top-ups: $5 -> 250 credits == 2.0 cents/credit.\nconst SUB_REVENUE_CENTS_PER_CREDIT = Number(process.env.HELFI_SUB_REVENUE_CENTS_PER_CREDIT || '1.4286') || 1.4286\n// Target margins (profit/revenue):\n// - subscriptions: 60% profit => allow cost <= 40% of revenue\n// - top-ups: 70% profit => allow cost <= 30% of revenue\nconst SUB_TARGET_MARGIN = 0.6\n\n// For a fixed credit price, use the subscription rule as the \"worst case\"\n// (lowest revenue/credit). Meeting subscription margin guarantees top-up margin\n// given top-up revenue/credit is higher than subscription revenue/credit.\nconst MAX_VENDOR_COST_CENTS_FOR_FIXED_CREDITS = Math.floor(\n  AI_MEAL_RECOMMENDATION_CREDITS * SUB_REVENUE_CENTS_PER_CREDIT * (1 - SUB_TARGET_MARGIN),\n)\n\nconst buildTodayIso = () => {\n  const d = new Date()\n  const y = d.getFullYear()\n  const m = String(d.getMonth() + 1).padStart(2, '0')\n  const day = String(d.getDate()).padStart(2, '0')\n  return `${y}-${m}-${day}`\n}\n\nconst truncate = (value: string, maxChars: number) => {\n  const s = String(value || '')\n  if (s.length <= maxChars) return s\n  return `${s.slice(0, Math.max(0, maxChars - 1))}‚Ä¶`\n}\n\nconst safeJsonCompact = (value: any, maxChars: number) => truncate(JSON.stringify(value ?? null), maxChars)\n\nconst extractTotalsFromNutrients = (nutrients: any): MacroTotals => {\n  if (!nutrients || typeof nutrients !== 'object') {\n    return { calories: 0, protein_g: 0, carbs_g: 0, fat_g: 0, fiber_g: 0, sugar_g: 0 }\n  }\n  const calories = Number((nutrients as any)?.calories ?? (nutrients as any)?.Calories ?? 0)\n  const protein = Number((nutrients as any)?.protein ?? (nutrients as any)?.protein_g ?? 0)\n  const carbs = Number((nutrients as any)?.carbs ?? (nutrients as any)?.carbs_g ?? 0)\n  const fat = Number((nutrients as any)?.fat ?? (nutrients as any)?.fat_g ?? 0)\n  const fiber = Number((nutrients as any)?.fiber ?? (nutrients as any)?.fiber_g ?? 0)\n  const sugar = Number((nutrients as any)?.sugar ?? (nutrients as any)?.sugar_g ?? 0)\n  return {\n    calories: Number.isFinite(calories) ? calories : 0,\n    protein_g: Number.isFinite(protein) ? protein : 0,\n    carbs_g: Number.isFinite(carbs) ? carbs : 0,\n    fat_g: Number.isFinite(fat) ? fat : 0,\n    fiber_g: Number.isFinite(fiber) ? fiber : 0,\n    sugar_g: Number.isFinite(sugar) ? sugar : 0,\n  }\n}\n\nconst sumTotals = (rows: MacroTotals[]): MacroTotals => {\n  const total = { calories: 0, protein_g: 0, carbs_g: 0, fat_g: 0, fiber_g: 0, sugar_g: 0 }\n  for (const r of rows) {\n    total.calories += macroOrZero(r.calories)\n    total.protein_g += macroOrZero(r.protein_g)\n    total.carbs_g += macroOrZero(r.carbs_g)\n    total.fat_g += macroOrZero(r.fat_g)\n    total.fiber_g += macroOrZero(r.fiber_g)\n    total.sugar_g += macroOrZero(r.sugar_g)\n  }\n  return {\n    calories: Math.round(total.calories),\n    protein_g: round3(total.protein_g),\n    carbs_g: round3(total.carbs_g),\n    fat_g: round3(total.fat_g),\n    fiber_g: round3(total.fiber_g),\n    sugar_g: round3(total.sugar_g),\n  }\n}\n\nconst subtractTotals = (a: MacroTotals, b: MacroTotals): MacroTotals => ({\n  calories: a.calories !== null && b.calories !== null ? a.calories - b.calories : null,\n  protein_g: a.protein_g !== null && b.protein_g !== null ? round3(a.protein_g - b.protein_g) : null,\n  carbs_g: a.carbs_g !== null && b.carbs_g !== null ? round3(a.carbs_g - b.carbs_g) : null,\n  fat_g: a.fat_g !== null && b.fat_g !== null ? round3(a.fat_g - b.fat_g) : null,\n  fiber_g: a.fiber_g !== null && b.fiber_g !== null ? round3(a.fiber_g - b.fiber_g) : null,\n  sugar_g: a.sugar_g !== null && b.sugar_g !== null ? round3(a.sugar_g - b.sugar_g) : null,\n})\n\nconst getAuthedEmail = async (req: NextRequest): Promise<string | null> => {\n  const session = await getServerSession(authOptions)\n  let userEmail = session?.user?.email ?? null\n  if (!userEmail) {\n    try {\n      const token = await getToken({\n        req,\n        secret: process.env.NEXTAUTH_SECRET || process.env.AUTH_SECRET || 'helfi-secret-key-production-2024',\n      })\n      if (token?.email) userEmail = String(token.email)\n    } catch {}\n  }\n  return userEmail\n}\n\nconst loadStoredState = async (userId: string): Promise<StoredState> => {\n  const stored = await prisma.healthGoal.findFirst({\n    where: { userId, name: AI_MEAL_RECOMMENDATION_GOAL_NAME },\n    select: { category: true },\n  })\n  if (!stored?.category) {\n    return { version: AI_MEAL_RECOMMENDATION_STORAGE_VERSION, history: [], seenExplainAt: null, committedIds: [] }\n  }\n  try {\n    const parsed = JSON.parse(stored.category)\n    if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {\n      const history = Array.isArray((parsed as any).history) ? (parsed as any).history.filter(Boolean) : []\n      const seenExplainAt =\n        typeof (parsed as any).seenExplainAt === 'string' ? (parsed as any).seenExplainAt : null\n      const committedIds = Array.isArray((parsed as any).committedIds)\n        ? (parsed as any).committedIds.map((v: any) => String(v || '').trim()).filter(Boolean)\n        : []\n      return {\n        version: Number((parsed as any).version) || AI_MEAL_RECOMMENDATION_STORAGE_VERSION,\n        history,\n        seenExplainAt,\n        committedIds,\n      }\n    }\n    const history = Array.isArray(parsed) ? parsed.filter(Boolean) : []\n    return { version: AI_MEAL_RECOMMENDATION_STORAGE_VERSION, history, seenExplainAt: null, committedIds: [] }\n  } catch {\n    return { version: AI_MEAL_RECOMMENDATION_STORAGE_VERSION, history: [], seenExplainAt: null, committedIds: [] }\n  }\n}\n\nconst saveStoredState = async (userId: string, state: StoredState) => {\n  const committedIdSet = new Set(\n    Array.isArray(state.committedIds) ? state.committedIds.map((v) => String(v || '').trim()).filter(Boolean) : [],\n  )\n  const trimmedHistory = Array.isArray(state.history)\n    ? state.history\n        .filter(Boolean)\n        // Only persist committed records into the saved history.\n        .filter((h: any) => committedIdSet.has(String(h?.id || '')))\n        .slice(0, AI_MEAL_RECOMMENDATION_HISTORY_LIMIT)\n    : []\n  const payload = JSON.stringify({\n    version: AI_MEAL_RECOMMENDATION_STORAGE_VERSION,\n    history: trimmedHistory,\n    seenExplainAt: state.seenExplainAt || null,\n    committedIds: Array.from(committedIdSet).slice(0, AI_MEAL_RECOMMENDATION_HISTORY_LIMIT),\n  })\n  const existing = await prisma.healthGoal.findFirst({\n    where: { userId, name: AI_MEAL_RECOMMENDATION_GOAL_NAME },\n    select: { id: true },\n  })\n  if (existing?.id) {\n    await prisma.healthGoal.update({ where: { id: existing.id }, data: { category: payload } })\n    return\n  }\n  await prisma.healthGoal.create({\n    data: {\n      userId,\n      name: AI_MEAL_RECOMMENDATION_GOAL_NAME,\n      category: payload,\n      currentRating: 0,\n    },\n  })\n}\n\nconst buildTargetsForUser = async (user: any) => {\n  const profile = (() => {\n    try {\n      const stored = user.healthGoals?.find((g: any) => g?.name === '__PROFILE_INFO_DATA__')\n      const parsed = stored?.category ? JSON.parse(stored.category) : null\n      return parsed && typeof parsed === 'object' ? parsed : {}\n    } catch {\n      return {}\n    }\n  })()\n\n  const primaryGoal = (() => {\n    try {\n      const stored = user.healthGoals?.find((g: any) => g?.name === '__PRIMARY_GOAL__')\n      const parsed = stored?.category ? JSON.parse(stored.category) : null\n      return parsed && typeof parsed === 'object' ? parsed : {}\n    } catch {\n      return {}\n    }\n  })()\n\n  const selectedIssues = (() => {\n    try {\n      const stored = user.healthGoals?.find((g: any) => g?.name === '__SELECTED_ISSUES__')\n      const parsed = stored?.category ? JSON.parse(stored.category) : null\n      return Array.isArray(parsed) ? parsed.map((v: any) => String(v || '')).filter(Boolean) : []\n    } catch {\n      return []\n    }\n  })()\n\n  const healthSituations = (() => {\n    try {\n      const stored = user.healthGoals?.find((g: any) => g?.name === '__HEALTH_SITUATIONS_DATA__')\n      const parsed = stored?.category ? JSON.parse(stored.category) : null\n      return parsed && typeof parsed === 'object' ? parsed : {}\n    } catch {\n      return {}\n    }\n  })()\n\n  const allergySettings = (() => {\n    try {\n      const stored = user.healthGoals?.find((g: any) => g?.name === '__ALLERGIES_DATA__')\n      const parsed = stored?.category ? JSON.parse(stored.category) : null\n      return parsed && typeof parsed === 'object' ? parsed : { allergies: [], diabetesType: '' }\n    } catch {\n      return { allergies: [], diabetesType: '' }\n    }\n  })()\n\n  const dietTypes = (() => {\n    try {\n      const stored = user.healthGoals?.find((g: any) => g?.name === '__DIET_PREFERENCE__')\n      const parsed = stored?.category ? JSON.parse(stored.category) : null\n      if (!parsed || typeof parsed !== 'object') return []\n      const raw = Array.isArray((parsed as any).dietTypes) ? (parsed as any).dietTypes : (parsed as any).dietType\n      if (Array.isArray(raw)) return raw.map((v: any) => String(v || '').trim()).filter(Boolean)\n      if (typeof raw === 'string' && raw.trim()) return [raw.trim()]\n      return []\n    } catch {\n      return []\n    }\n  })()\n\n  const targets = calculateDailyTargets({\n    gender: user.gender ? String(user.gender).toLowerCase() : '',\n    birthdate: typeof profile?.dateOfBirth === 'string' ? profile.dateOfBirth : '',\n    weightKg: typeof user.weight === 'number' ? user.weight : null,\n    heightCm: typeof user.height === 'number' ? user.height : null,\n    exerciseFrequency: typeof user.exerciseFrequency === 'string' ? user.exerciseFrequency : '',\n    dietTypes,\n    goals: selectedIssues,\n    goalChoice: typeof primaryGoal?.goalChoice === 'string' ? primaryGoal.goalChoice : '',\n    goalIntensity:\n      typeof primaryGoal?.goalIntensity === 'string' &&\n      ['mild', 'standard', 'aggressive'].includes(primaryGoal.goalIntensity.toLowerCase())\n        ? (primaryGoal.goalIntensity.toLowerCase() as any)\n        : 'standard',\n    bodyType: user.bodyType ? String(user.bodyType).toLowerCase() : '',\n    diabetesType:\n      typeof allergySettings?.diabetesType === 'string' &&\n      ['type1', 'type2', 'prediabetes'].includes(allergySettings.diabetesType.toLowerCase())\n        ? (allergySettings.diabetesType.toLowerCase() as any)\n        : null,\n    healthSituations: healthSituations as any,\n  })\n\n  return {\n    targets: {\n      calories: targets.calories ?? null,\n      protein_g: targets.protein ?? null,\n      carbs_g: targets.carbs ?? null,\n      fat_g: targets.fat ?? null,\n      fiber_g: typeof targets.fiber === 'number' ? targets.fiber : null,\n      sugar_g: typeof targets.sugarMax === 'number' ? targets.sugarMax : null,\n    } satisfies MacroTotals,\n    profile,\n    primaryGoal,\n    selectedIssues,\n    healthSituations,\n    allergySettings,\n  }\n}\n\nconst loadFoodLogsForDate = async (userId: string, date: string, tzOffsetMin: number) => {\n  const [y, m, d] = date.split('-').map((v) => parseInt(v, 10))\n  const start = new Date(Date.UTC(y, m - 1, d, 0, 0, 0) + tzOffsetMin * 60 * 1000)\n  const end = new Date(start.getTime() + 24 * 60 * 60 * 1000 - 1)\n  const logs = await prisma.foodLog.findMany({\n    where: {\n      userId,\n      OR: [{ localDate: date }, { localDate: null, createdAt: { gte: start, lte: end } }, { createdAt: { gte: start, lte: end } }],\n    },\n    orderBy: { createdAt: 'desc' },\n    select: { id: true, description: true, nutrients: true, meal: true, category: true, localDate: true, createdAt: true },\n  })\n\n  const filtered = logs.filter((log) => {\n    if (log.localDate === date) return true\n    const createdAt = log.createdAt instanceof Date ? log.createdAt : new Date(log.createdAt as any)\n    if (Number.isNaN(createdAt.getTime())) return false\n    const local = new Date(createdAt.getTime() - tzOffsetMin * 60 * 1000)\n    const iso = `${local.getUTCFullYear()}-${String(local.getUTCMonth() + 1).padStart(2, '0')}-${String(local.getUTCDate()).padStart(2, '0')}`\n    return iso === date\n  })\n\n  return filtered\n}\n\nconst normalizeAndValidateItems = (items: any[]): RecommendedItem[] => {\n  const safe: RecommendedItem[] = []\n  for (const raw of Array.isArray(items) ? items : []) {\n    const name = String(raw?.name || '').trim()\n    if (!name) continue\n    const servings = Number(raw?.servings ?? 1)\n    safe.push({\n      id: raw?.id ? String(raw.id) : undefined,\n      name,\n      serving_size: raw?.serving_size ? String(raw.serving_size) : null,\n      calories: Number.isFinite(Number(raw?.calories)) ? Number(raw.calories) : null,\n      protein_g: Number.isFinite(Number(raw?.protein_g)) ? Number(raw.protein_g) : null,\n      carbs_g: Number.isFinite(Number(raw?.carbs_g)) ? Number(raw.carbs_g) : null,\n      fat_g: Number.isFinite(Number(raw?.fat_g)) ? Number(raw.fat_g) : null,\n      fiber_g: Number.isFinite(Number(raw?.fiber_g)) ? Number(raw.fiber_g) : null,\n      sugar_g: Number.isFinite(Number(raw?.sugar_g)) ? Number(raw.sugar_g) : null,\n      servings: Number.isFinite(servings) ? clamp(servings, 0, 20) : 1,\n    })\n  }\n  return safe\n}\n\nconst scaleToFitCalories = (items: RecommendedItem[], caloriesCap: number | null) => {\n  if (!Number.isFinite(Number(caloriesCap)) || !caloriesCap || caloriesCap <= 0) return items\n  const totals = computeTotalsFromItems(items)\n  const totalCalories = Number(totals.calories || 0)\n  if (!Number.isFinite(totalCalories) || totalCalories <= 0) return items\n  if (totalCalories <= caloriesCap) return items\n\n  const factor = clamp(caloriesCap / totalCalories, 0.15, 1)\n  return items.map((it) => ({ ...it, servings: round3(clamp((Number(it.servings) || 0) * factor, 0, 20)) }))\n}\n\nconst filterCommittedHistory = (state: StoredState) => {\n  const committedIdSet = new Set(\n    Array.isArray(state.committedIds) ? state.committedIds.map((v) => String(v || '').trim()).filter(Boolean) : [],\n  )\n  if (committedIdSet.size === 0) return []\n  return (state.history || []).filter((h: any) => h && committedIdSet.has(String(h?.id || '')))\n}\n\nexport async function GET(req: NextRequest) {\n  const userEmail = await getAuthedEmail(req)\n  if (!userEmail) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n\n  const { searchParams } = new URL(req.url)\n  const date = (searchParams.get('date') || buildTodayIso()).trim()\n  const category = normalizeMealCategory(searchParams.get('category'))\n  const tzOffsetMin = Number(searchParams.get('tz') || '0')\n\n  if (!DATE_RE.test(date)) {\n    return NextResponse.json({ error: 'Invalid date' }, { status: 400 })\n  }\n\n  const user = await prisma.user.findUnique({\n    where: { email: userEmail },\n    include: { healthGoals: true, supplements: true, medications: true },\n  })\n  if (!user) return NextResponse.json({ error: 'User not found' }, { status: 404 })\n\n  const storedState = await loadStoredState(user.id)\n  const historyAll = filterCommittedHistory(storedState)\n    .filter((h) => h && typeof h === 'object')\n    .sort((a: any, b: any) => Number(new Date(b.createdAt).getTime()) - Number(new Date(a.createdAt).getTime()))\n\n  const { targets } = await buildTargetsForUser(user as any)\n  const logs = await loadFoodLogsForDate(user.id, date, Number.isFinite(tzOffsetMin) ? tzOffsetMin : 0)\n  const used = sumTotals(logs.map((l) => extractTotalsFromNutrients(l.nutrients)))\n  const remaining = subtractTotals(targets, used)\n\n  // Return full history, but leave filtering to client.\n  return NextResponse.json({\n    costCredits: AI_MEAL_RECOMMENDATION_CREDITS,\n    context: { targets, used, remaining },\n    history: historyAll,\n    seenExplain: Boolean(storedState.seenExplainAt) || historyAll.length > 0,\n    category,\n  })\n}\n\nexport async function PUT(req: NextRequest) {\n  const userEmail = await getAuthedEmail(req)\n  if (!userEmail) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n\n  const user = await prisma.user.findUnique({\n    where: { email: userEmail },\n    select: { id: true },\n  })\n  if (!user) return NextResponse.json({ error: 'User not found' }, { status: 404 })\n\n  // Optional: persist a recommendation into history after the user explicitly saves it.\n  // (Generated meals are otherwise treated as drafts and are not stored in history.)\n  const body = await req.json().catch(() => null)\n  if (body && typeof body === 'object' && (body as any).action === 'commit') {\n    const rawRec = (body as any).recommendation\n    if (!rawRec || typeof rawRec !== 'object') {\n      return NextResponse.json({ error: 'Missing recommendation' }, { status: 400 })\n    }\n\n    const category = normalizeMealCategory((rawRec as any).category)\n    const date = typeof (rawRec as any).date === 'string' ? String((rawRec as any).date).trim() : buildTodayIso()\n    if (!DATE_RE.test(date)) {\n      return NextResponse.json({ error: 'Invalid date' }, { status: 400 })\n    }\n\n    const state = await loadStoredState(user.id)\n    const historyAll = filterCommittedHistory(state)\n      .filter((h) => h && typeof h === 'object')\n      .sort((a: any, b: any) => Number(new Date(b.createdAt).getTime()) - Number(new Date(a.createdAt).getTime()))\n\n    const itemsInitial = normalizeAndValidateItems((rawRec as any).items)\n    if (!itemsInitial || itemsInitial.length === 0) {\n      return NextResponse.json({ error: 'Invalid items' }, { status: 400 })\n    }\n\n    const mealNameRaw = typeof (rawRec as any).mealName === 'string' ? String((rawRec as any).mealName).trim() : ''\n    const { mealName: safeMealName, items: itemsWithNameFixes } = applyMealNameConsistency(category, mealNameRaw, itemsInitial)\n    const recipe = normalizeRecipe((rawRec as any).recipe) || buildFallbackRecipe(category, itemsWithNameFixes)\n    const totals = computeTotalsFromItems(itemsWithNameFixes)\n\n    const id =\n      typeof (rawRec as any).id === 'string' && String((rawRec as any).id).trim()\n        ? String((rawRec as any).id).trim()\n        : `air-${Date.now()}-${Math.random().toString(16).slice(2)}`\n    const createdAt =\n      typeof (rawRec as any).createdAt === 'string' && !Number.isNaN(new Date((rawRec as any).createdAt).getTime())\n        ? String((rawRec as any).createdAt)\n        : new Date().toISOString()\n\n    const tags = Array.isArray((rawRec as any).tags)\n      ? (rawRec as any).tags.map((t: any) => String(t || '').trim()).filter(Boolean).slice(0, 12)\n      : []\n    const why = typeof (rawRec as any).why === 'string' ? String((rawRec as any).why).trim() : ''\n\n    const record: RecommendedMealRecord = {\n      id,\n      createdAt,\n      date,\n      category,\n      mealName: safeMealName || `AI Recommended ${category}`,\n      tags,\n      why,\n      recipe,\n      items: itemsWithNameFixes,\n      totals,\n    }\n\n    const nextHistory = [record, ...historyAll.filter((h: any) => String(h?.id || '') !== id)].slice(\n      0,\n      AI_MEAL_RECOMMENDATION_HISTORY_LIMIT,\n    )\n    const committedIds = Array.from(\n      new Set([id, ...(Array.isArray(state.committedIds) ? state.committedIds : [])].map((v) => String(v || '').trim()).filter(Boolean)),\n    ).slice(0, AI_MEAL_RECOMMENDATION_HISTORY_LIMIT)\n    try {\n      await saveStoredState(user.id, {\n        ...state,\n        history: nextHistory,\n        seenExplainAt: state.seenExplainAt || new Date().toISOString(),\n        committedIds,\n      })\n    } catch (e) {\n      console.warn('[ai-meal-recommendation] failed to persist committed history (non-fatal)', e)\n    }\n\n    return NextResponse.json({ ok: true, history: nextHistory })\n  }\n\n  const state = await loadStoredState(user.id)\n  if (state.seenExplainAt) {\n    return NextResponse.json({ ok: true, seenExplainAt: state.seenExplainAt })\n  }\n  const nowIso = new Date().toISOString()\n  try {\n    await saveStoredState(user.id, { ...state, seenExplainAt: nowIso })\n  } catch (e) {\n    console.warn('[ai-meal-recommendation] failed to mark explain as seen (non-fatal)', e)\n  }\n  return NextResponse.json({ ok: true, seenExplainAt: nowIso })\n}\n\nexport async function POST(req: NextRequest) {\n  const userEmail = await getAuthedEmail(req)\n  if (!userEmail) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n\n  const body = await req.json().catch(() => ({}))\n  const date = typeof body?.date === 'string' ? body.date.trim() : buildTodayIso()\n  const category = normalizeMealCategory(body?.category)\n  const tzOffsetMin = Number(body?.tz || '0')\n\n  if (!DATE_RE.test(date)) {\n    return NextResponse.json({ error: 'Invalid date' }, { status: 400 })\n  }\n\n  const user = await prisma.user.findUnique({\n    where: { email: userEmail },\n    include: { healthGoals: true, supplements: true, medications: true, subscription: true },\n  })\n  if (!user) return NextResponse.json({ error: 'User not found' }, { status: 404 })\n\n  const cm = new CreditManager(user.id)\n  const wallet = await cm.getWalletStatus()\n  if (wallet.totalAvailableCents < AI_MEAL_RECOMMENDATION_CREDITS) {\n    return NextResponse.json({ error: 'Insufficient credits' }, { status: 402 })\n  }\n\n  // Model selection mirrors the Food Analyzer override (optional).\n  let model = (process.env.OPENAI_FOOD_MODEL || 'gpt-4o').trim() || 'gpt-4o'\n  try {\n    const goal = await prisma.healthGoal.findFirst({\n      where: { userId: user.id, name: '__FOOD_ANALYZER_MODEL__' },\n      select: { category: true },\n    })\n    if (goal?.category) {\n      const parsed = JSON.parse(goal.category)\n      const override = typeof parsed?.model === 'string' ? parsed.model.trim() : ''\n      if (override === 'gpt-4o' || override === 'gpt-5.2') {\n        model = override\n      }\n    }\n  } catch {}\n\n  const { targets, profile, primaryGoal, selectedIssues, healthSituations, allergySettings } = await buildTargetsForUser(user as any)\n  const logs = await loadFoodLogsForDate(user.id, date, Number.isFinite(tzOffsetMin) ? tzOffsetMin : 0)\n  const used = sumTotals(logs.map((l) => extractTotalsFromNutrients(l.nutrients)))\n  const remaining = subtractTotals(targets, used)\n\n  const storedState = await loadStoredState(user.id)\n  const historyAll = filterCommittedHistory(storedState)\n    .filter((h) => h && typeof h === 'object')\n    .sort((a: any, b: any) => Number(new Date(b.createdAt).getTime()) - Number(new Date(a.createdAt).getTime()))\n\n  const recentSameCategory = historyAll.filter((h: any) => normalizeMealCategory(h?.category) === category).slice(0, 10)\n  const recentNames = recentSameCategory.map((h: any) => String(h?.mealName || '').trim()).filter(Boolean)\n  const recentIngredientHints = recentSameCategory\n    .flatMap((h: any) => (Array.isArray(h?.items) ? h.items.slice(0, 6) : []))\n    .map((it: any) => String(it?.name || '').trim())\n    .filter(Boolean)\n    .slice(0, 24)\n\n  const todaysDescriptions = logs\n    .map((l) => String(l.description || '').split('\\n')[0].trim())\n    .filter(Boolean)\n    .slice(0, 8)\n\n  const supplements = Array.isArray((user as any)?.supplements) ? (user as any).supplements : []\n  const medications = Array.isArray((user as any)?.medications) ? (user as any).medications : []\n\n  const allergies = Array.isArray((allergySettings as any)?.allergies) ? (allergySettings as any).allergies : []\n  const diabetesType = typeof (allergySettings as any)?.diabetesType === 'string' ? (allergySettings as any).diabetesType : ''\n\n  const caloriesCap = typeof remaining.calories === 'number' && Number.isFinite(remaining.calories) ? Math.max(0, remaining.calories) : null\n\n  const system = [\n    'You are Helfi‚Äôs AI meal recommender.',\n    'Return JSON only. No markdown. No extra text.',\n    'Do NOT make medical claims. Use informational wording only.',\n    'Respect allergies/intolerances and avoid excluded foods.',\n    'Respect remaining calories/macros: stay within remaining if possible; if very tight, recommend a smaller/snack-style meal.',\n    'Avoid repeating meals; rotate away from recent names/ingredients when possible.',\n    'The meal name must not mention ingredients that are missing from the items list (including herbs/spices). If you mention it, include it as an item even if calories are tiny.',\n    '',\n    'Output schema:',\n    '{',\n    '  \"mealName\": string,',\n    '  \"tags\": string[],',\n    '  \"why\": string,',\n    '  \"recipe\": { \"prepMinutes\": number, \"cookMinutes\": number, \"steps\": string[] },',\n    '  \"items\": Array<{',\n    '    \"name\": string,',\n    '    \"serving_size\": string,',\n    '    \"servings\": number,',\n    '    \"calories\": number,',\n    '    \"protein_g\": number,',\n    '    \"carbs_g\": number,',\n    '    \"fat_g\": number,',\n    '    \"fiber_g\": number,',\n    '    \"sugar_g\": number',\n    '  }>',\n    '}',\n  ].join('\\n')\n\n  const buildUserPrompt = (opts: {\n    supplementsLimit: number\n    medicationsLimit: number\n    healthSituationsMaxChars: number\n    todaysFoodsLimit: number\n    recentNamesLimit: number\n    recentIngredientsLimit: number\n  }) => {\n    const supplementsForPrompt = supplements\n      .slice(0, opts.supplementsLimit)\n      .map((s: any) => ({\n        name: truncate(String(s?.name || ''), 64),\n        dosage: truncate(String(s?.dosage || ''), 64),\n        timing: truncate(String(s?.timing || ''), 64),\n        scheduleInfo: truncate(String(s?.scheduleInfo || ''), 64),\n      }))\n\n    const medicationsForPrompt = medications\n      .slice(0, opts.medicationsLimit)\n      .map((m: any) => ({\n        name: truncate(String(m?.name || ''), 64),\n        dosage: truncate(String(m?.dosage || ''), 64),\n        timing: truncate(String(m?.timing || ''), 64),\n        scheduleInfo: truncate(String(m?.scheduleInfo || ''), 64),\n      }))\n\n    const userPrompt = [\n      `Meal type: ${category}`,\n      `Date: ${date}`,\n      '',\n      'User profile (may be partial):',\n    `- gender: ${user.gender ? String(user.gender).toLowerCase() : ''}`,\n    `- weightKg: ${typeof user.weight === 'number' ? user.weight : ''}`,\n    `- heightCm: ${typeof user.height === 'number' ? user.height : ''}`,\n    `- birthdate: ${typeof profile?.dateOfBirth === 'string' ? profile.dateOfBirth : ''}`,\n    `- exerciseFrequency: ${typeof user.exerciseFrequency === 'string' ? user.exerciseFrequency : ''}`,\n    `- exerciseTypes: ${Array.isArray(user.exerciseTypes) ? user.exerciseTypes.join(', ') : ''}`,\n    `- goalChoice: ${typeof primaryGoal?.goalChoice === 'string' ? primaryGoal.goalChoice : ''}`,\n    `- goalIntensity: ${typeof primaryGoal?.goalIntensity === 'string' ? primaryGoal.goalIntensity : ''}`,\n    `- selected goals/concerns: ${Array.isArray(selectedIssues) ? selectedIssues.join(', ') : ''}`,\n      '',\n      'Health situations (free-text):',\n    safeJsonCompact(healthSituations || {}, opts.healthSituationsMaxChars),\n      '',\n      'Allergies/intolerances to avoid:',\n      safeJsonCompact(allergies || [], 240),\n      diabetesType ? `Diabetes: ${diabetesType}` : '',\n      '',\n      'Supplements logged:',\n      safeJsonCompact(supplementsForPrompt, 1400),\n      '',\n      'Medications logged:',\n      safeJsonCompact(medicationsForPrompt, 1400),\n      '',\n      'Daily targets:',\n      safeJsonCompact(targets, 260),\n      'Used so far today:',\n      safeJsonCompact(used, 260),\n      'Remaining for today:',\n      safeJsonCompact(remaining, 260),\n      caloriesCap !== null ? `Hard cap calories for this meal: <= ${Math.max(0, Math.floor(caloriesCap))}` : '',\n      '',\n      'Foods already logged today (avoid repeating):',\n    safeJsonCompact(todaysDescriptions.map((d) => truncate(d, 90)).slice(0, opts.todaysFoodsLimit), 900),\n      '',\n      'Recent AI recommended meal names (avoid repeating):',\n    safeJsonCompact(recentNames.map((n) => truncate(n, 70)).slice(0, opts.recentNamesLimit), 600),\n      'Recent AI recommended ingredient hints (avoid repeating):',\n    safeJsonCompact(recentIngredientHints.map((n) => truncate(n, 48)).slice(0, opts.recentIngredientsLimit), 900),\n      '',\n      'Constraints:',\n      '- Provide 2‚Äì6 ingredients.',\n      '- Use common, realistic foods and portions; keep ingredient list concise.',\n    '- Tags must be short (1‚Äì3 words), informational (e.g., \"Low sugar\", \"High protein\", \"Gut-friendly\").',\n    '- The \"why\" must be 2‚Äì5 sentences in plain English referencing goals and remaining macros.',\n    ]\n    .filter(Boolean)\n    .join('\\n')\n    return userPrompt\n  }\n\n  let userPrompt = buildUserPrompt({\n    supplementsLimit: 18,\n    medicationsLimit: 18,\n    healthSituationsMaxChars: 900,\n    todaysFoodsLimit: 8,\n    recentNamesLimit: 8,\n    recentIngredientsLimit: 24,\n  })\n\n  // Guard rail: keep the prompt within a cost envelope so the fixed credit price\n  // maintains required profit margins. We compute a conservative upper-bound cost\n  // based on prompt length + max output tokens.\n  let maxOutputTokens = 650\n  const estimateVendorCost = () => {\n    const estPromptTokens = estimateTokensFromText(`${system}\\n${userPrompt}`)\n    const estVendorCostCents = openaiCostCentsForTokens(model, {\n      promptTokens: estPromptTokens,\n      completionTokens: maxOutputTokens,\n    })\n    return { estPromptTokens, estVendorCostCents }\n  }\n\n  let estimate = estimateVendorCost()\n  if (MAX_VENDOR_COST_CENTS_FOR_FIXED_CREDITS > 0 && estimate.estVendorCostCents > MAX_VENDOR_COST_CENTS_FOR_FIXED_CREDITS) {\n    // First trim pass: cut verbose fields further.\n    userPrompt = buildUserPrompt({\n      supplementsLimit: 10,\n      medicationsLimit: 10,\n      healthSituationsMaxChars: 500,\n      todaysFoodsLimit: 5,\n      recentNamesLimit: 6,\n      recentIngredientsLimit: 16,\n    })\n    estimate = estimateVendorCost()\n  }\n\n  if (MAX_VENDOR_COST_CENTS_FOR_FIXED_CREDITS > 0 && estimate.estVendorCostCents > MAX_VENDOR_COST_CENTS_FOR_FIXED_CREDITS) {\n    // Second trim pass: reduce output cap (most expensive part for these models).\n    maxOutputTokens = 500\n    estimate = estimateVendorCost()\n  }\n\n  if (MAX_VENDOR_COST_CENTS_FOR_FIXED_CREDITS > 0 && estimate.estVendorCostCents > MAX_VENDOR_COST_CENTS_FOR_FIXED_CREDITS) {\n    console.warn('[ai-meal-recommendation] prompt still too large for fixed credit price; proceeding with strict caps', {\n      estPromptTokens: estimate.estPromptTokens,\n      estVendorCostCents: estimate.estVendorCostCents,\n      maxVendorCostCents: MAX_VENDOR_COST_CENTS_FOR_FIXED_CREDITS,\n      maxOutputTokens,\n    })\n  }\n\n  const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY })\n\n  let content = ''\n  try {\n    const completion = await runChatCompletionWithLogging(\n      openai,\n      {\n        model,\n        temperature: 0.5,\n        ...(model.toLowerCase().includes('gpt-5') ? { max_completion_tokens: maxOutputTokens } : { max_tokens: maxOutputTokens }),\n        messages: [\n          { role: 'system', content: system },\n          { role: 'user', content: userPrompt },\n        ],\n      } as any,\n      {\n        feature: 'food:ai-meal-recommendation',\n        userId: user.id,\n        userLabel: user.email,\n        endpoint: '/api/ai-meal-recommendation',\n      },\n    )\n    const raw = (completion as any)?.choices?.[0]?.message?.content\n    content = typeof raw === 'string' ? raw : Array.isArray(raw) ? raw.map((p: any) => p?.text || '').join('') : ''\n  } catch (err: any) {\n    console.error('[ai-meal-recommendation] LLM call failed', err)\n    return NextResponse.json({ error: 'AI failed' }, { status: 500 })\n  }\n\n  const parsed = parseJsonRelaxed(content)\n  const mealName = typeof parsed?.mealName === 'string' ? parsed.mealName.trim() : ''\n  const tags = Array.isArray(parsed?.tags) ? parsed.tags.map((t: any) => String(t || '').trim()).filter(Boolean).slice(0, 12) : []\n  const why = typeof parsed?.why === 'string' ? parsed.why.trim() : ''\n  const itemsInitial = normalizeAndValidateItems(parsed?.items)\n  if (!itemsInitial || itemsInitial.length === 0) {\n    return NextResponse.json({ error: 'Invalid AI response' }, { status: 502 })\n  }\n\n  const { mealName: safeMealName, items: itemsWithNameFixes } = applyMealNameConsistency(category, mealName, itemsInitial)\n  const recipe = normalizeRecipe(parsed?.recipe) || buildFallbackRecipe(category, itemsWithNameFixes)\n\n  const fitItems = scaleToFitCalories(itemsWithNameFixes, caloriesCap)\n  const totals = computeTotalsFromItems(fitItems)\n\n  // Charge credits only after we have a usable recommendation.\n  const charged = await cm.chargeCents(AI_MEAL_RECOMMENDATION_CREDITS)\n  if (!charged) {\n    return NextResponse.json({ error: 'Insufficient credits' }, { status: 402 })\n  }\n\n  const record: RecommendedMealRecord = {\n    id: `air-${Date.now()}-${Math.random().toString(16).slice(2)}`,\n    createdAt: new Date().toISOString(),\n    date,\n    category,\n    mealName: safeMealName || `AI Recommended ${category}`,\n    tags,\n    why,\n    recipe,\n    items: fitItems,\n    totals,\n  }\n\n  // Draft-only generation: do not persist into history unless the user explicitly saves.\n  if (!storedState.seenExplainAt) {\n    try {\n      await saveStoredState(user.id, { ...storedState, seenExplainAt: new Date().toISOString() })\n    } catch (e) {\n      console.warn('[ai-meal-recommendation] failed to mark explain as seen (non-fatal)', e)\n    }\n  }\n\n  const remainingAfter = subtractTotals(targets, used)\n\n  return NextResponse.json({\n    costCredits: AI_MEAL_RECOMMENDATION_CREDITS,\n    context: { targets, used, remaining: remainingAfter },\n    history: historyAll,\n    seenExplain: true,\n    recommendation: record,\n  })\n}\n","truncated":false,"size":46401},{"path":"app/api/analytics/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport OpenAI from 'openai'\nimport { runChatCompletionWithLogging } from '@/lib/ai-usage-logger'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { extractAdminFromHeaders } from '@/lib/admin-auth'\nimport { prisma } from '@/lib/prisma'\n\n// Initialize OpenAI only when needed to avoid build-time errors\nfunction getOpenAI() {\n  if (!process.env.OPENAI_API_KEY) {\n    return null\n  }\n  return new OpenAI({\n    apiKey: process.env.OPENAI_API_KEY,\n  })\n}\n\nasync function ensureAnalyticsTable() {\n  await prisma.$executeRawUnsafe(`\n    CREATE TABLE IF NOT EXISTS \"AnalyticsEvent\" (\n      id TEXT PRIMARY KEY,\n      \"timestamp\" TIMESTAMPTZ NOT NULL,\n      \"action\" TEXT,\n      \"type\" TEXT,\n      \"userId\" TEXT,\n      payload JSONB NOT NULL\n    )\n  `)\n}\n\nfunction normalizePayload(value: any): any {\n  if (!value) return {}\n  if (typeof value === 'string') {\n    try {\n      return JSON.parse(value)\n    } catch {\n      return { raw: value }\n    }\n  }\n  return value\n}\n\nasync function fetchRecentEvents(limit: number): Promise<any[]> {\n  await ensureAnalyticsTable()\n  const rows = await prisma.$queryRawUnsafe<Array<{ payload: any }>>(\n    `SELECT payload FROM \"AnalyticsEvent\" ORDER BY \"timestamp\" DESC LIMIT $1`,\n    limit\n  )\n  return rows.map((row) => normalizePayload(row.payload))\n}\n\nasync function fetchTotalEvents(): Promise<number> {\n  await ensureAnalyticsTable()\n  const rows = await prisma.$queryRawUnsafe<Array<{ count: any }>>(\n    `SELECT COUNT(*)::int AS count FROM \"AnalyticsEvent\"`\n  )\n  return Number(rows?.[0]?.count ?? 0)\n}\n\nasync function fetchTimeRange(): Promise<{ oldest: string | null; newest: string | null }> {\n  await ensureAnalyticsTable()\n  const rows = await prisma.$queryRawUnsafe<Array<{ oldest: Date | null; newest: Date | null }>>(\n    `SELECT MIN(\"timestamp\") AS oldest, MAX(\"timestamp\") AS newest FROM \"AnalyticsEvent\"`\n  )\n  const oldest = rows?.[0]?.oldest ? new Date(rows[0].oldest).toISOString() : null\n  const newest = rows?.[0]?.newest ? new Date(rows[0].newest).toISOString() : null\n  return { oldest, newest }\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    const authHeader = request.headers.get('authorization')\n    const admin = extractAdminFromHeaders(authHeader)\n    const internalSecret = process.env.SCHEDULER_SECRET || ''\n    const hasInternalSecret = !!internalSecret && authHeader === `Bearer ${internalSecret}`\n    let sessionEmail = ''\n    if (!admin && !hasInternalSecret) {\n      const session = (await getServerSession(authOptions as any)) as { user?: { email?: string } } | null\n      sessionEmail = String(session?.user?.email || '').toLowerCase()\n      if (!sessionEmail) {\n        return NextResponse.json({ success: false, error: 'Unauthorized' }, { status: 401 })\n      }\n    }\n\n    const data = await request.json()\n    if (sessionEmail) {\n      data.userId = sessionEmail\n    }\n    \n    await ensureAnalyticsTable()\n\n    const now = new Date()\n    const eventId = `${now.getTime()}-${Math.random().toString(36).slice(2, 10)}`\n    const analyticsEvent = {\n      ...data,\n      timestamp: now.toISOString(),\n      id: eventId\n    }\n    \n    await prisma.$executeRawUnsafe(\n      `INSERT INTO \"AnalyticsEvent\" (id, \"timestamp\", \"action\", \"type\", \"userId\", payload)\n       VALUES ($1, $2, $3, $4, $5, $6::jsonb)`,\n      analyticsEvent.id,\n      now,\n      analyticsEvent.action ?? null,\n      analyticsEvent.type ?? null,\n      analyticsEvent.userId ?? null,\n      JSON.stringify(analyticsEvent)\n    )\n    \n    console.log('üìä Analytics Event Recorded:', {\n      action: data.action,\n      userId: data.userId,\n      timestamp: analyticsEvent.timestamp\n    })\n    \n    const totalEvents = await fetchTotalEvents()\n    return NextResponse.json({ \n      success: true, \n      message: 'Analytics data recorded',\n      totalEvents\n    })\n    \n  } catch (error) {\n    console.error('Analytics API Error:', error)\n    return NextResponse.json(\n      { success: false, error: 'Failed to record analytics' },\n      { status: 500 }\n    )\n  }\n}\n\nexport async function GET(request: NextRequest) {\n  try {\n    const authHeader = request.headers.get('authorization')\n    const admin = extractAdminFromHeaders(authHeader)\n    if (!admin) {\n      return NextResponse.json({ success: false, error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const url = new URL(request.url)\n    const action = url.searchParams.get('action')\n    \n    if (action === 'insights') {\n      // Lightweight: return recent timing and cache stats + aggregated p50/p95 for first byte\n      const recent = await fetchRecentEvents(200)\n      const events = recent.filter(e => e?.type === 'insights-timing')\n      const timings = events.slice(-50).map(e => ({\n        section: e.section,\n        mode: e.mode,\n        generateMs: e.generateMs,\n        classifyMs: e.classifyMs,\n        rewriteMs: e.rewriteMs,\n        fillMs: e.fillMs,\n        totalMs: e.totalMs,\n        firstByteMs: e.firstByteMs,\n        cache: e.cache,\n        at: e.timestamp,\n      }))\n      const firstBytes = events\n        .map((e: any) => Number(e.firstByteMs))\n        .filter((n: number) => Number.isFinite(n))\n        .sort((a: number, b: number) => a - b)\n      const quantile = (arr: number[], q: number) => {\n        if (!arr.length) return null\n        const pos = (arr.length - 1) * q\n        const base = Math.floor(pos)\n        const rest = pos - base\n        return arr[base + 1] !== undefined ? arr[base] + rest * (arr[base + 1] - arr[base]) : arr[base]\n      }\n      const firstByteMsP50 = quantile(firstBytes, 0.5)\n      const firstByteMsP95 = quantile(firstBytes, 0.95)\n      const cacheHitCount = events.filter((e: any) => e.cache === 'hit').length\n      const cacheMissCount = events.filter((e: any) => e.cache === 'miss').length\n      return NextResponse.json({ success: true, timings, stats: { firstByteMsP50, firstByteMsP95, cacheHitCount, cacheMissCount, totalEvents: events.length } })\n    }\n    \n    if (action === 'summary') {\n      // Return analytics summary\n      const totalEvents = await fetchTotalEvents()\n      const recentEvents = await fetchRecentEvents(100)\n      const timeRange = await fetchTimeRange()\n      const summary = generateSummary(recentEvents, totalEvents, timeRange)\n      return NextResponse.json({ success: true, summary })\n    }\n    \n    // Return raw data (last 100 events)\n    const totalEvents = await fetchTotalEvents()\n    const recentEvents = await fetchRecentEvents(100)\n    return NextResponse.json({ \n      success: true, \n      data: recentEvents,\n      totalEvents \n    })\n    \n  } catch (error) {\n    console.error('Analytics GET Error:', error)\n    return NextResponse.json(\n      { success: false, error: 'Failed to fetch analytics' },\n      { status: 500 }\n    )\n  }\n}\n\nasync function generateInsights(events: any[]) {\n  if (events.length < 10) {\n    return \"Not enough data to generate insights yet. Need at least 10 user interactions.\"\n  }\n  \n  try {\n    // Prepare analytics data for AI analysis\n    const recentEvents = events.slice(-100)\n    const summary = {\n      totalEvents: recentEvents.length,\n      uniqueUsers: Array.from(new Set(recentEvents.map(e => e.userId))).length,\n      topActions: getTopActions(recentEvents),\n      userSettings: getUserSettingsStats(recentEvents),\n      timeDistribution: getTimeDistribution(recentEvents)\n    }\n    \n    const prompt = `\nAnalyze this Helfi health app user analytics data and provide actionable insights for app improvement:\n\n${JSON.stringify(summary, null, 2)}\n\nPlease provide:\n1. Key user behavior patterns\n2. Most/least used features\n3. Specific recommendations to improve user experience\n4. Potential issues or friction points\n5. Suggestions for new features based on usage patterns\n\nKeep response concise but actionable for app developers.\n`\n    \n    const openai = getOpenAI()\n    if (!openai) {\n      return \"OpenAI API key not configured. Cannot generate AI insights.\"\n    }\n    \n    const response: any = await runChatCompletionWithLogging(openai, {\n      model: \"gpt-4o-mini\",\n      messages: [{ role: \"user\", content: prompt }],\n      max_tokens: 800,\n      temperature: 0.3\n    }, { feature: 'admin:analytics-insights' })\n    \n    return response.choices[0]?.message?.content || \"Unable to generate insights\"\n    \n  } catch (error) {\n    console.error('OpenAI Insights Error:', error)\n    return \"Error generating AI insights. Please check OpenAI API configuration.\"\n  }\n}\n\nfunction generateSummary(events: any[], totalEvents: number, timeRange: { oldest: string | null; newest: string | null }) {\n  if (totalEvents === 0) {\n    return { message: \"No analytics data available yet.\" }\n  }\n  \n  const recentEvents = events.slice(-100)\n  \n  return {\n    totalEvents,\n    recentEvents: recentEvents.length,\n    uniqueUsers: Array.from(new Set(recentEvents.map(e => e.userId))).length,\n    topActions: getTopActions(recentEvents),\n    timeRange\n  }\n}\n\nfunction getTopActions(events: any[]) {\n  const actionCounts: { [key: string]: number } = {}\n  events.forEach(event => {\n    actionCounts[event.action] = (actionCounts[event.action] || 0) + 1\n  })\n  \n  return Object.entries(actionCounts)\n    .sort(([,a], [,b]) => b - a)\n    .slice(0, 5)\n    .map(([action, count]) => ({ action, count }))\n}\n\nfunction getUserSettingsStats(events: any[]) {\n  const settingsEvents = events.filter(e => e.action?.includes('settings'))\n  const darkModeUsers = events.filter(e => e.settings?.darkMode).length\n  const notificationUsers = events.filter(e => e.settings?.emailNotifications).length\n  \n  return {\n    settingsChanges: settingsEvents.length,\n    darkModeUsers,\n    notificationUsers\n  }\n}\n\nfunction getTimeDistribution(events: any[]) {\n  const hours: { [key: string]: number } = {}\n  events.forEach(event => {\n    const hour = new Date(event.timestamp).getHours()\n    hours[hour] = (hours[hour] || 0) + 1\n  })\n  \n  return hours\n} \n","truncated":false,"size":9965},{"path":"app/api/analyze-food/route.ts","content":"import { NextRequest, NextResponse } from 'next/server';\n/**\n * IMPORTANT ‚Äì DO NOT CHANGE OUTPUT FORMAT WITHOUT UPDATING UI PARSER\n * The Food Diary UI in `app/food/page.tsx` extracts nutrition via regex from a single line:\n *   Calories: <number>, Protein: <g>, Carbs: <g>, Fat: <g>\n * If you modify prompts or response shapes, ensure this exact line remains present.\n * A server-side fallback below appends this line when missing.\n *\n * ‚ö†Ô∏è GUARD RAIL (GUARD_RAILS.md ¬ß3.9):\n * - Keep discrete item handling aligned with the guard rails:\n *   only set pieces/piecesPerServing when a visible, explicit count is present.\n * - Do NOT change portion sync expectations without explicit user approval.\n */\nimport { getServerSession } from 'next-auth';\nimport { getToken } from 'next-auth/jwt';\nimport { authOptions } from '@/lib/auth';\nimport { prisma } from '@/lib/prisma';\nimport { lookupFoodNutrition, searchFatSecretFoods } from '@/lib/food-data';\nimport { CreditManager, CREDIT_COSTS } from '@/lib/credit-system';\nimport { hasFreeCredits, consumeFreeCredit, type FreeCreditType } from '@/lib/free-credits';\nimport crypto from 'crypto';\nimport { consumeRateLimit } from '@/lib/rate-limit';\nimport { normalizeDiscreteItems, summarizeDiscreteItemsForLog } from '@/lib/food-normalization';\nimport { isSubscriptionActive } from '@/lib/subscription-utils';\nimport { logServerCall } from '@/lib/server-call-tracker';\n\n// Bump this when changing curated nutrition to invalidate old cached images.\nconst CACHE_VERSION = 'v5';\nconst RATE_LIMIT_WINDOW_MS = 60_000; // 1 minute\nconst RATE_LIMIT_MAX_REQUESTS = 3;   // stop runaway loops quickly\nconst STRICT_AI_ONLY_ITEMS = true;\n\n// Guard rail: this route powers the main Food Analyzer. Billing enforcement\n// (BILLING_ENFORCED) must remain true for production unless the user explicitly\n// asks to pause billing. Do not toggle it off as a \"quick fix\" for other bugs.\nimport OpenAI from 'openai';\nimport { chatCompletionWithCost } from '@/lib/metered-openai';\nimport { capMaxTokensToBudget, costCentsEstimateFromText, estimateTokensFromText } from '@/lib/cost-meter';\nimport { logAiUsageEvent, runChatCompletionWithLogging } from '@/lib/ai-usage-logger';\nimport { getImageMetadata } from '@/lib/image-metadata';\nimport { checkMultipleDietCompatibility, normalizeDietTypes } from '@/lib/diets';\n// NOTE: USDA/FatSecret lookup removed from AI analysis - kept only for manual ingredient lookup via /api/food-data\n\n// Best-effort relaxed JSON parsing to handle minor LLM formatting issues\nfunction parseItemsJsonRelaxed(raw: string): any | null {\n  try {\n    return JSON.parse(raw);\n  } catch {\n    try {\n      // 1) Quote unquoted keys after { or ,  2) convert single quotes to double  3) remove trailing commas\n      const keysQuoted = raw.replace(/([{,]\\s*)([A-Za-z0-9_]+)\\s*:/g, '$1\"$2\":');\n      const doubleQuoted = keysQuoted.replace(/'/g, '\"');\n      const noTrailingCommas = doubleQuoted.replace(/,\\s*([}\\]])/g, '$1');\n      return JSON.parse(noTrailingCommas);\n    } catch {\n      return null;\n    }\n  }\n}\n\nconst GEMINI_VISION_MODEL_DEFAULT = 'gemini-2.5-flash';\nconst GEMINI_API_BASE = 'https://generativelanguage.googleapis.com/v1beta/models';\n\nconst extractPromptTextFromMessages = (messages: any[]): string => {\n  if (!Array.isArray(messages)) return '';\n  return messages\n    .map((message) => {\n      const content = (message as any)?.content;\n      if (typeof content === 'string') return content;\n      if (Array.isArray(content)) {\n        return content\n          .map((part: any) => {\n            if (typeof part === 'string') return part;\n            if (typeof part?.text === 'string') return part.text;\n            return '';\n          })\n          .filter(Boolean)\n          .join('\\n');\n      }\n      return '';\n    })\n    .filter(Boolean)\n    .join('\\n')\n    .trim();\n};\n\nconst parseInlineImageData = (dataUrl: string | null) => {\n  if (!dataUrl) return null;\n  const match = dataUrl.match(/^data:([^;]+);base64,(.+)$/);\n  if (!match) return null;\n  return { mimeType: match[1], data: match[2] };\n};\n\nconst parseFeedbackList = (raw: any): string[] => {\n  if (!raw) return [];\n  if (Array.isArray(raw)) {\n    return raw\n      .map((item) => String(item || '').replace(/[\\r\\n]+/g, ' ').trim())\n      .filter(Boolean);\n  }\n  if (typeof raw === 'string') {\n    const trimmed = raw.trim();\n    if (!trimmed) return [];\n    try {\n      const parsed = JSON.parse(trimmed);\n      if (Array.isArray(parsed)) {\n        return parsed\n          .map((item) => String(item || '').replace(/[\\r\\n]+/g, ' ').trim())\n          .filter(Boolean);\n      }\n    } catch {}\n    return trimmed\n      .split(',')\n      .map((item) => String(item || '').replace(/[\\r\\n]+/g, ' ').trim())\n      .filter(Boolean);\n  }\n  return [];\n};\n\nconst sanitizeFeedbackItems = (items: string[], limit = 12): string[] => {\n  return items\n    .map((item) => String(item || '').replace(/[\\r\\n]+/g, ' ').trim())\n    .filter(Boolean)\n    .slice(0, limit);\n};\n\nconst extractGeminiText = (payload: any): string | null => {\n  const parts = payload?.candidates?.[0]?.content?.parts;\n  if (!Array.isArray(parts)) return null;\n  const text = parts\n    .map((part: any) => (typeof part?.text === 'string' ? part.text : ''))\n    .join('')\n    .trim();\n  return text.length ? text : null;\n};\n\nconst runGeminiVisionCompletion = async (opts: {\n  apiKey: string;\n  model: string;\n  promptText: string;\n  imageDataUrl: string;\n  maxOutputTokens: number;\n  temperature?: number;\n  responseMimeType?: string;\n}) => {\n  const { apiKey, model, promptText, imageDataUrl, maxOutputTokens, temperature, responseMimeType } = opts;\n  const inlineData = parseInlineImageData(imageDataUrl);\n  if (!inlineData) {\n    throw new Error('Invalid image data for Gemini');\n  }\n\n  const generationConfig: Record<string, any> = {\n    temperature: typeof temperature === 'number' ? temperature : 0,\n    maxOutputTokens,\n  };\n  if (responseMimeType) {\n    generationConfig.responseMimeType = responseMimeType;\n  }\n\n  const body = {\n    contents: [\n      {\n        role: 'user',\n        parts: [\n          { text: promptText },\n          {\n            inlineData: {\n              data: inlineData.data,\n              mimeType: inlineData.mimeType,\n            },\n          },\n        ],\n      },\n    ],\n    generationConfig,\n  };\n\n  const response = await fetch(`${GEMINI_API_BASE}/${model}:generateContent?key=${apiKey}`, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(body),\n  });\n\n  if (!response.ok) {\n    const text = await response.text();\n    throw new Error(`Gemini API error (${response.status}): ${text}`);\n  }\n\n  const payload = await response.json();\n  const text = extractGeminiText(payload);\n  const promptTokens = estimateTokensFromText(promptText);\n  const completionTokens = estimateTokensFromText(text || '');\n  const costCents = costCentsEstimateFromText(model, promptText, (text || '').length);\n\n  return {\n    completion: {\n      choices: [{ message: { content: text || '' } }],\n      model,\n    },\n    costCents,\n    promptTokens,\n    completionTokens,\n  };\n};\n\nconst computeTotalsFromItems = (items: any[]): any | null => {\n  if (!Array.isArray(items) || items.length === 0) {\n    return null;\n  }\n\n  const totals = items.reduce(\n    (acc, item) => {\n      const servings = Number.isFinite(Number(item?.servings)) ? Number(item.servings) : 1;\n      acc.calories += Number(item?.calories || 0) * servings;\n      acc.protein_g += Number(item?.protein_g || 0) * servings;\n      acc.carbs_g += Number(item?.carbs_g || 0) * servings;\n      acc.fat_g += Number(item?.fat_g || 0) * servings;\n      acc.fiber_g += Number(item?.fiber_g || 0) * servings;\n      acc.sugar_g += Number(item?.sugar_g || 0) * servings;\n      return acc;\n    },\n    {\n      calories: 0,\n      protein_g: 0,\n      carbs_g: 0,\n      fat_g: 0,\n      fiber_g: 0,\n      sugar_g: 0,\n    },\n  );\n\n  const round = (value: number, decimals = 1) => {\n    const factor = Math.pow(10, decimals);\n    return Math.round(value * factor) / factor;\n  };\n\n  return {\n    calories: Math.round(totals.calories),\n    protein_g: round(totals.protein_g),\n    carbs_g: round(totals.carbs_g),\n    fat_g: round(totals.fat_g),\n    fiber_g: totals.fiber_g > 0 ? round(totals.fiber_g) : null,\n    sugar_g: totals.sugar_g > 0 ? round(totals.sugar_g) : null,\n  };\n};\n\nconst stripNutritionFromServingSize = (raw: string) => {\n  return String(raw || '')\n    .replace(/\\([^)]*(calories?|kcal|kilojoules?|kj|protein|carbs?|fat|fibre|fiber|sugar)[^)]*\\)/gi, '')\n    .replace(/\\b\\d+(?:\\.\\d+)?\\s*(kcal|cal|kj)\\b[^,)]*(?:protein|carb|fat|fiber|fibre|sugar)[^,)]*/gi, '')\n    .replace(/\\s+/g, ' ')\n    .trim();\n};\n\nconst parseServingWeight = (servingSize?: string | null): number | null => {\n  if (!servingSize) return null;\n  const raw = String(servingSize);\n  const parseRange = (pattern: RegExp, factor = 1) => {\n    const rangeMatch = raw.match(pattern);\n    if (rangeMatch) {\n      const start = parseFloat(rangeMatch[1]);\n      const end = parseFloat(rangeMatch[2]);\n      if (Number.isFinite(start) && Number.isFinite(end)) {\n        return ((start + end) / 2) * factor;\n      }\n    }\n    return null;\n  };\n  const parseSingle = (pattern: RegExp, factor = 1) => {\n    const match = raw.match(pattern);\n    if (!match) return null;\n    const value = parseFloat(match[1]);\n    return Number.isFinite(value) ? value * factor : null;\n  };\n\n  const gramsRange = parseRange(/(\\d+(?:\\.\\d+)?)\\s*(?:-|to)\\s*(\\d+(?:\\.\\d+)?)\\s*g\\b/i);\n  if (gramsRange) return gramsRange;\n  const gramsMatch = parseSingle(/(\\d+(?:\\.\\d+)?)\\s*g\\b/i);\n  if (gramsMatch) return gramsMatch;\n\n  const mlRange = parseRange(/(\\d+(?:\\.\\d+)?)\\s*(?:-|to)\\s*(\\d+(?:\\.\\d+)?)\\s*ml\\b/i);\n  if (mlRange) return mlRange;\n  const mlMatch = parseSingle(/(\\d+(?:\\.\\d+)?)\\s*ml\\b/i);\n  if (mlMatch) return mlMatch;\n\n  const ozRange = parseRange(/(\\d+(?:\\.\\d+)?)\\s*(?:-|to)\\s*(\\d+(?:\\.\\d+)?)\\s*(?:oz|ounce|ounces)\\b/i, 28.3495);\n  if (ozRange) return ozRange;\n  const ozMatch = parseSingle(/(\\d+(?:\\.\\d+)?)\\s*(?:oz|ounce|ounces)\\b/i, 28.3495);\n  if (ozMatch) return ozMatch;\n\n  const lbRange = parseRange(/(\\d+(?:\\.\\d+)?)\\s*(?:-|to)\\s*(\\d+(?:\\.\\d+)?)\\s*(?:lb|lbs|pound|pounds)\\b/i, 453.592);\n  if (lbRange) return lbRange;\n  const lbMatch = parseSingle(/(\\d+(?:\\.\\d+)?)\\s*(?:lb|lbs|pound|pounds)\\b/i, 453.592);\n  if (lbMatch) return lbMatch;\n\n  return null;\n};\n\nconst sanitizePackagedLabelItems = (items: any[]) => {\n  if (!Array.isArray(items) || items.length === 0) {\n    return { items, needsReview: false, message: '' };\n  }\n  let needsReview = false;\n  let message = '';\n  const cleaned = items.map((item) => {\n    const next = { ...item };\n    if (next?.serving_size) {\n      next.serving_size = stripNutritionFromServingSize(next.serving_size);\n    }\n    const weight =\n      parseServingWeight(next?.serving_size || null) ||\n      (Number.isFinite(Number(next?.customGramsPerServing)) && Number(next.customGramsPerServing) > 0\n        ? Number(next.customGramsPerServing)\n        : null) ||\n      (Number.isFinite(Number(next?.customMlPerServing)) && Number(next.customMlPerServing) > 0\n        ? Number(next.customMlPerServing)\n        : null);\n\n    if (!weight || weight <= 0) return next;\n\n    const safe = (value: any) =>\n      Number.isFinite(Number(value)) && Number(value) > 0 ? Number(value) : 0;\n    const calories = safe(next?.calories);\n    const protein = safe(next?.protein_g);\n    const carbs = safe(next?.carbs_g);\n    const fat = safe(next?.fat_g);\n    const fiber = safe(next?.fiber_g);\n    const macroSum = protein + carbs + fat + fiber;\n    const macroLimit = weight * 1.3 + 2;\n    const calorieLimit = weight * 9.5 + 10;\n    const hasNoNumbers = calories <= 0 && macroSum <= 0;\n    const failsMacro = macroSum > macroLimit;\n    const failsCalories = calories > calorieLimit;\n\n    if (hasNoNumbers || failsMacro || failsCalories) {\n      needsReview = true;\n      message =\n        'We could not read the per serve column clearly. Please retake the label photo and make sure the first column is sharp.';\n      next.labelNeedsReview = true;\n      next.labelNeedsReviewMessage = message;\n      next.calories = null;\n      next.protein_g = null;\n      next.carbs_g = null;\n      next.fat_g = null;\n      next.fiber_g = null;\n      next.sugar_g = null;\n    }\n\n    return next;\n  });\n\n  return { items: cleaned, needsReview, message };\n};\n\nconst parseLabelJsonBlock = (raw: string): any | null => {\n  if (!raw) return null;\n  const match = raw.match(/<LABEL_JSON>([\\s\\S]*?)<\\/LABEL_JSON>/i);\n  const block = match && match[1] ? match[1].trim() : '';\n  if (!block) return null;\n  return parseItemsJsonRelaxed(block);\n};\n\nconst extractLabelPerServingFromImage = async (\n  openai: OpenAI,\n  imageDataUrl: string,\n  model: string,\n) => {\n  const messages: any[] = [\n    {\n      role: 'user',\n      content: [\n        {\n          type: 'text',\n          text:\n            'Read this nutrition label. Use ONLY the first column that says \"Quantity per serving\" (ignore the per-100g column).\\n' +\n            'Return JSON between <LABEL_JSON> and </LABEL_JSON> only with this exact shape:\\n' +\n            '{\"serving_size\":\"string\",\"per_serving\":{\"calories\":0,\"protein_g\":0,\"carbs_g\":0,\"fat_g\":0,\"fiber_g\":0,\"sugar_g\":0}}\\n' +\n            '- If both kJ and Cal are shown, use the Cal value for calories.\\n' +\n            '- If a value is unclear, set it to null (do not guess).\\n' +\n            '- Do NOT use per-100g numbers.',\n        },\n        { type: 'image_url', image_url: { url: imageDataUrl, detail: 'high' } },\n      ],\n    },\n  ];\n\n  const result = await chatCompletionWithCost(openai, {\n    model,\n    messages,\n    max_tokens: 300,\n    temperature: 0,\n  } as any);\n\n  const content = result.completion?.choices?.[0]?.message?.content || '';\n  const parsed = parseLabelJsonBlock(content);\n  return { parsed, costCents: result.costCents };\n};\n\nconst isPlausibleTotal = (total: any): boolean => {\n  if (!total || typeof total !== 'object') return false;\n  const calories = Number((total as any)?.calories);\n  if (!Number.isFinite(calories) || calories <= 0 || calories > 5000) return false;\n  return true;\n};\n\nconst chooseCanonicalTotal = (items: any[] | null | undefined, incomingTotal: any | null | undefined) => {\n  const sumFromItems = computeTotalsFromItems(items || []);\n\n  if (incomingTotal && isPlausibleTotal(incomingTotal)) {\n    if (sumFromItems && isPlausibleTotal(sumFromItems)) {\n      const diff = Math.abs(Number((incomingTotal as any).calories) - Number((sumFromItems as any).calories));\n      const ratio = Number((sumFromItems as any).calories) > 0 ? diff / Number((sumFromItems as any).calories) : 0;\n      if (ratio <= 0.35) {\n        return incomingTotal;\n      }\n    } else {\n      return incomingTotal;\n    }\n  }\n\n  return sumFromItems || incomingTotal || null;\n};\n\nconst EGG_KEYWORDS = ['egg', 'eggs', 'fried egg', 'boiled egg', 'scrambled egg', 'omelette', 'omelet'];\n\nconst enforceEggCountFromAnalysis = (items: any[] | null | undefined, analysis: string | null | undefined) => {\n  if (!items || !Array.isArray(items) || items.length === 0) return items;\n  const text = (analysis || '').toLowerCase();\n  const inferredCount = extractExplicitPieceCount(text, ['egg', 'eggs']);\n  if (!inferredCount || inferredCount < 2) return items;\n\n  const looksLikeEgg = (name: string) => {\n    const lower = name.toLowerCase();\n    return EGG_KEYWORDS.some((k) => lower.includes(k));\n  };\n\n  const next = [...items];\n  const first = { ...next[0] };\n  if (!looksLikeEgg(String(first.name || '')) && !looksLikeEgg(String(first.serving_size || ''))) {\n    return items;\n  }\n\n  const factor = inferredCount / Math.max(Number(first.servings) || 1, 1);\n  const scaleField = (v: any) => (Number.isFinite(Number(v)) ? Math.round(Number(v) * factor * 10) / 10 : null);\n\n  first.serving_size = `${inferredCount} eggs`;\n  first.servings = 1;\n  (first as any).pieces = inferredCount;\n  (first as any).piecesPerServing = inferredCount;\n  first.calories = scaleField(first.calories);\n  first.protein_g = scaleField(first.protein_g);\n  first.carbs_g = scaleField(first.carbs_g);\n  first.fat_g = scaleField(first.fat_g);\n  if (first.fiber_g !== null && first.fiber_g !== undefined) first.fiber_g = scaleField(first.fiber_g);\n  if (first.sugar_g !== null && first.sugar_g !== undefined) first.sugar_g = scaleField(first.sugar_g);\n\n  next[0] = first;\n  return next;\n};\n\n// Quick sanity checks for structured items\nconst summarizeItemsForLog = (items: any[]) =>\n  Array.isArray(items)\n    ? items.slice(0, 6).map((it) => ({\n        name: it?.name,\n        calories: it?.calories,\n        protein_g: it?.protein_g,\n        carbs_g: it?.carbs_g,\n        fat_g: it?.fat_g,\n        isGuess: it?.isGuess === true,\n      }))\n    : [];\n\nconst isRealisticItem = (item: any): boolean => {\n  const cal = Number(item?.calories ?? 0);\n  const protein = Number(item?.protein_g ?? 0);\n  const fat = Number(item?.fat_g ?? 0);\n  const carbs = Number(item?.carbs_g ?? 0);\n  const hasAnyMacro = Number.isFinite(protein) && protein > 0.2 || Number.isFinite(fat) && fat > 0.2 || Number.isFinite(carbs) && carbs > 0.2;\n  const caloriesReasonable = Number.isFinite(cal) && cal > 5 && cal < 2000;\n  return caloriesReasonable && hasAnyMacro;\n};\n\nconst validateStructuredItems = (items: any[]): boolean => {\n  if (!Array.isArray(items) || items.length === 0) return false;\n  const realisticCount = items.filter(isRealisticItem).length;\n  // Accept single realistic item (single-food meal) or multi-item meals with at least two realistic items\n  return realisticCount >= 1;\n};\n\n// Very small heuristic map to seed guessed macros when the AI misses structured items.\nconst estimatedGuessMacrosForName = (nameRaw: string) => {\n  const name = (nameRaw || '').toLowerCase();\n  // Defaults are conservative single-portion estimates.\n  if (name.includes('chicken')) return { calories: 220, protein_g: 32, carbs_g: 0, fat_g: 8 };\n  if (name.includes('beef') || name.includes('steak')) return { calories: 250, protein_g: 30, carbs_g: 0, fat_g: 14 };\n  if (name.includes('pork')) return { calories: 240, protein_g: 27, carbs_g: 0, fat_g: 14 };\n  if (name.includes('salmon') || name.includes('fish')) return { calories: 220, protein_g: 25, carbs_g: 0, fat_g: 13 };\n  if (name.includes('potato')) return { calories: 150, protein_g: 3, carbs_g: 32, fat_g: 3 };\n  if (name.includes('sweet potato')) return { calories: 140, protein_g: 3, carbs_g: 33, fat_g: 0.5 };\n  if (name.includes('peas')) return { calories: 70, protein_g: 4, carbs_g: 12, fat_g: 0.5 };\n  if (name.includes('broccoli')) return { calories: 35, protein_g: 2.5, carbs_g: 7, fat_g: 0.5 };\n  if (name.includes('carrot')) return { calories: 45, protein_g: 1, carbs_g: 10, fat_g: 0.2 };\n  if (name.includes('mushroom')) return { calories: 20, protein_g: 3, carbs_g: 3, fat_g: 0.3 };\n  if (name.includes('rice')) return { calories: 200, protein_g: 4, carbs_g: 44, fat_g: 0.5 };\n  if (name.includes('bread') || name.includes('bun')) return { calories: 150, protein_g: 5, carbs_g: 28, fat_g: 3 };\n  // Fallback generic side.\n  return { calories: 90, protein_g: 2, carbs_g: 12, fat_g: 3 };\n};\n\n// Pull likely components from the AI's prose description to add missing guessed items.\nconst inferComponentsFromAnalysis = (analysis: string | null | undefined): string[] => {\n  if (!analysis) return [];\n  const lower = analysis.toLowerCase();\n  const withIdx = lower.indexOf(' with ');\n  if (withIdx === -1) return [];\n  const afterWith = analysis.slice(withIdx + 6);\n  const firstSentence = afterWith.split(/[.]/)[0] || afterWith;\n  const parts = firstSentence\n    .split(/,| and | & /i)\n    .map((p) => p.trim())\n    .filter((p) => p.length >= 3 && p.split(/\\s+/).length <= 6);\n  const unique: string[] = [];\n  for (const p of parts) {\n    const lowerPart = p.toLowerCase();\n    if (!unique.some((u) => u.toLowerCase() === lowerPart)) {\n      unique.push(p);\n    }\n  }\n  return unique.slice(0, 8);\n};\n\nconst normalizeComponentName = (value: string) =>\n  String(value || '')\n    .toLowerCase()\n    .replace(/[^a-z0-9]+/g, ' ')\n    .replace(/\\s+/g, ' ')\n    .trim();\n\nconst cleanComponentLabel = (value: string) => {\n  return String(value || '')\n    .replace(/^(a|an|one)\\s+/i, '')\n    .replace(/^(small|medium|large)\\s+portion\\s+of\\s+/i, '')\n    .replace(/^portion\\s+of\\s+/i, '')\n    .replace(/^(small|medium|large)\\s+/i, '')\n    .trim();\n};\n\nconst normalizeComponentList = (items: string[]) =>\n  items\n    .map((item) => cleanComponentLabel(item))\n    .filter((item) => item && item.length >= 3);\n\nconst buildComponentBoundSchema = (components: string[]) => ({\n  name: 'food_component_items',\n  schema: {\n    type: 'object',\n    additionalProperties: false,\n    required: ['items', 'total'],\n    properties: {\n      items: {\n        type: 'array',\n        minItems: components.length,\n        maxItems: components.length,\n        uniqueItems: true,\n        items: {\n          type: 'object',\n          additionalProperties: false,\n          required: [\n            'component',\n            'name',\n            'brand',\n            'serving_size',\n            'servings',\n            'calories',\n            'protein_g',\n            'carbs_g',\n            'fat_g',\n            'fiber_g',\n            'sugar_g',\n            'isGuess',\n          ],\n          properties: {\n            component: { type: 'string', enum: components },\n            name: { type: 'string' },\n            brand: { type: ['string', 'null'] },\n            serving_size: { type: 'string' },\n            servings: { type: 'number' },\n            calories: { type: ['number', 'null'] },\n            protein_g: { type: ['number', 'null'] },\n            carbs_g: { type: ['number', 'null'] },\n            fat_g: { type: ['number', 'null'] },\n            fiber_g: { type: ['number', 'null'] },\n            sugar_g: { type: ['number', 'null'] },\n            isGuess: { type: 'boolean' },\n          },\n        },\n      },\n      total: {\n        type: 'object',\n        additionalProperties: false,\n        required: ['calories', 'protein_g', 'carbs_g', 'fat_g', 'fiber_g', 'sugar_g'],\n        properties: {\n          calories: { type: ['number', 'null'] },\n          protein_g: { type: ['number', 'null'] },\n          carbs_g: { type: ['number', 'null'] },\n          fat_g: { type: ['number', 'null'] },\n          fiber_g: { type: ['number', 'null'] },\n          sugar_g: { type: ['number', 'null'] },\n        },\n      },\n    },\n  },\n  strict: true,\n});\n\nconst extractComponentsFromDelimitedText = (raw: string | null | undefined): string[] => {\n  if (!raw) return [];\n  const cleaned = String(raw).replace(/\\s+/g, ' ').trim();\n  if (!cleaned) return [];\n\n  let candidate = cleaned.split(/[.]/)[0] || cleaned;\n  candidate = candidate\n    .replace(/^(?:the\\s+image\\s+shows|this\\s+image\\s+shows|image\\s+shows)\\s+/i, '')\n    .replace(/\\b(each component|components?)\\b.*$/i, '')\n    .trim();\n\n  const hasDelimiters = /,|;|\\s+and\\s+|\\s+&\\s+/i.test(candidate);\n  if (!hasDelimiters) return [];\n\n  const parts = candidate\n    .split(/,|;| and | & /i)\n    .map((part) =>\n      part\n        .replace(/^(?:several\\s+components?|components?|includes?|including)\\s*:?/i, '')\n        .replace(/\\bhere'?s\\b.*$/i, '')\n        .trim(),\n    )\n    .filter((part) => part.length >= 3);\n\n  const mergeSaladComponents = (items: string[]) => {\n    const merged: string[] = [];\n    const veggieHints = [\n      'lettuce','cucumber','tomato','carrot','carrots','onion','pepper','peppers','capsicum','spinach','rocket','arugula','greens','shredded',\n    ];\n    const stopHints = ['portion','sauce','fish','shrimp','prawn','wedges','fries','steak','chicken','pork','rice','potato','tartar'];\n    for (let i = 0; i < items.length; i += 1) {\n      const item = items[i];\n      const lower = item.toLowerCase();\n      if (lower.includes('salad') && lower.includes('with')) {\n        const parts: string[] = [item];\n        let j = i + 1;\n        while (j < items.length) {\n          const next = items[j];\n          const nextLower = next.toLowerCase();\n          if (stopHints.some((h) => nextLower.includes(h))) break;\n          const wordCount = nextLower.split(/\\s+/).filter(Boolean).length;\n          if (wordCount <= 2 || veggieHints.some((h) => nextLower.includes(h))) {\n            parts.push(next);\n            j += 1;\n            continue;\n          }\n          break;\n        }\n        merged.push(parts.join(', '));\n        i = j - 1;\n        continue;\n      }\n      merged.push(item);\n    }\n    return merged;\n  };\n\n  const mergedParts = mergeSaladComponents(parts);\n\n  const filtered = mergedParts.filter((part) => {\n    if (/^component\\s*\\d+$/i.test(part)) return false;\n    return !/nutrition|breakdown|estimated|calories?|protein|carbs?|fat|fiber|fibre|sugar/i.test(part);\n  });\n\n  const unique: string[] = [];\n  for (const part of filtered) {\n    const normalized = normalizeComponentName(part);\n    if (!normalized) continue;\n    if (!unique.some((u) => normalizeComponentName(u) === normalized)) unique.push(part);\n    if (unique.length >= 10) break;\n  }\n  return unique;\n};\n\nconst extractComponentsFromAnalysis = (analysis: string | null | undefined): string[] => {\n  if (!analysis) return [];\n  const cleaned = analysis.replace(/\\s+/g, ' ').trim();\n  if (!cleaned) return [];\n\n  let listText = '';\n  const componentsMatch = cleaned.match(\n    /\\b(?:components?|ingredients?)(?:\\s+list)?\\s*[:\\-]\\s*([^\\n.]+)/i,\n  );\n  if (componentsMatch && componentsMatch[1]) {\n    listText = componentsMatch[1];\n  }\n  if (!listText) {\n    const withMatch = cleaned.match(/\\bwith\\b\\s+([^.\\n]+)/i);\n    if (withMatch && withMatch[1]) listText = withMatch[1];\n  }\n  if (!listText) {\n    const containsMatch = cleaned.match(/\\b(?:contains?|includes?|including|consists\\s+of)\\b\\s+([^.\\n]+)/i);\n    if (containsMatch && containsMatch[1]) listText = containsMatch[1];\n  }\n  if (!listText) {\n    const beforeCalories = cleaned.split(/calories\\s*:/i)[0] || cleaned;\n    const fallback = extractComponentsFromDelimitedText(beforeCalories);\n    return fallback;\n  }\n\n  const parts = listText\n    .split(/,|;| and | & /i)\n    .map((part) =>\n      part\n        .replace(/^(?:several\\s+components?|components?|includes?|including)\\s*:?/i, '')\n        .replace(/\\bhere'?s\\b.*$/i, '')\n        .trim(),\n    )\n    .filter((part) => part.length >= 3);\n\n  const mergeSaladComponents = (items: string[]) => {\n    const merged: string[] = [];\n    const veggieHints = [\n      'lettuce','cucumber','tomato','carrot','carrots','onion','pepper','peppers','capsicum','spinach','rocket','arugula','greens','shredded',\n    ];\n    const stopHints = ['portion','sauce','fish','shrimp','prawn','wedges','fries','steak','chicken','pork','rice','potato','tartar'];\n    for (let i = 0; i < items.length; i += 1) {\n      const item = items[i];\n      const lower = item.toLowerCase();\n      if (lower.includes('salad') && lower.includes('with')) {\n        const parts: string[] = [item];\n        let j = i + 1;\n        while (j < items.length) {\n          const next = items[j];\n          const nextLower = next.toLowerCase();\n          if (stopHints.some((h) => nextLower.includes(h))) break;\n          const wordCount = nextLower.split(/\\s+/).filter(Boolean).length;\n          if (wordCount <= 2 || veggieHints.some((h) => nextLower.includes(h))) {\n            parts.push(next);\n            j += 1;\n            continue;\n          }\n          break;\n        }\n        merged.push(parts.join(', '));\n        i = j - 1;\n        continue;\n      }\n      merged.push(item);\n    }\n    return merged;\n  };\n\n  const mergedParts = mergeSaladComponents(parts);\n\n  const filtered = mergedParts.filter((part) => {\n    if (/^component\\s*\\d+$/i.test(part)) return false;\n    return !/nutrition|breakdown|estimated|calories?|protein|carbs?|fat|fiber|fibre|sugar/i.test(part);\n  });\n  const unique: string[] = [];\n  for (const part of filtered) {\n    const normalized = normalizeComponentName(part);\n    if (!normalized) continue;\n    if (!unique.some((u) => normalizeComponentName(u) === normalized)) unique.push(part);\n    if (unique.length >= 10) break;\n  }\n  return unique;\n};\n\n// Normalize isGuess flag across items\nconst normalizeGuessFlags = (items: any[]): any[] =>\n  Array.isArray(items)\n    ? items.map((item) => ({\n        ...item,\n        isGuess: item?.isGuess === true,\n      }))\n    : [];\n\nconst isSlicedProduceLabel = (text: string): boolean => {\n  const lower = (text || '').toLowerCase()\n  if (!lower.includes('slice')) return false\n  return (\n    lower.includes('avocado') ||\n    lower.includes('cucumber') ||\n    lower.includes('tomato') ||\n    lower.includes('zucchini') ||\n    lower.includes('courgette')\n  )\n}\n\nconst inferSliceCount = (text: string): number | null => {\n  const lower = (text || '').toLowerCase()\n  const match = lower.match(/(\\d+)\\s*(?:thin\\s*)?slice/i)\n  if (!match) return null\n  const n = Number(match[1])\n  return Number.isFinite(n) && n > 0 ? n : null\n}\n\nconst applySlicedProduceSanity = (items: any[]): { items: any[]; changed: boolean } => {\n  if (!Array.isArray(items) || items.length === 0) return { items, changed: false }\n  let changed = false\n  const next = items.map((item) => {\n    if (!item || typeof item !== 'object') return item\n    const name = String(item?.name || '')\n    const serving = String(item?.serving_size || '')\n    const label = `${name} ${serving}`.trim()\n    if (!isSlicedProduceLabel(label)) return item\n\n    // If the model already provided grams/oz/ml, keep it (user can still adjust).\n    const hasExplicitWeight = /\\b(\\d+(?:\\.\\d+)?)\\s*(g|gram|grams|ml|oz|ounce|ounces)\\b/i.test(label)\n    const calories = Number(item?.calories)\n    const fat = Number(item?.fat_g)\n\n    // If this is a guess and the calories/macros are clearly \"whole-food\" sized, clamp to a conservative slice portion.\n    const isGuess = item?.isGuess === true\n    const isEgregious =\n      (!Number.isFinite(calories) || calories <= 0) ? false : calories >= 250 ||\n      (!Number.isFinite(fat) || fat <= 0) ? false : fat >= 25\n\n    if (!isGuess || hasExplicitWeight || !isEgregious) {\n      // Still ensure sliced produce doesn't get treated as discrete pieces.\n      if ((item as any)?.piecesPerServing || (item as any)?.pieces) {\n        const cleaned = { ...item }\n        delete (cleaned as any).piecesPerServing\n        delete (cleaned as any).pieces\n        return cleaned\n      }\n      return item\n    }\n\n    // Conservative estimate: thin slices are ~8g each (very rough).\n    const inferredSlices = inferSliceCount(label)\n    const grams = Math.min(90, Math.max(15, (inferredSlices ? inferredSlices * 8 : 25)))\n\n    // Avocado: ~160 kcal / 100g, fat ~14.7g/100g, carbs ~8.5g/100g, protein ~2g/100g, fiber ~6.7g/100g.\n    // For other sliced produce, the model is rarely egregious; keep only avocado clamp for now.\n    const lowerName = name.toLowerCase()\n    if (!lowerName.includes('avocado')) return item\n\n    const scale = grams / 100\n    const clamped = {\n      ...item,\n      name: 'avocado slices',\n      serving_size: inferredSlices ? `${inferredSlices} thin slices (~${Math.round(grams)}g)` : `thin slices (~${Math.round(grams)}g)`,\n      servings: 1,\n      calories: Math.round(160 * scale),\n      fat_g: Math.round(14.7 * scale * 10) / 10,\n      carbs_g: Math.round(8.5 * scale * 10) / 10,\n      protein_g: Math.round(2.0 * scale * 10) / 10,\n      fiber_g: Math.round(6.7 * scale * 10) / 10,\n      sugar_g: Math.round(0.7 * scale * 10) / 10,\n      isGuess: true,\n      // Ensure the UI defaults the weight editor to a sane value.\n      customGramsPerServing: Math.round(grams * 100) / 100,\n      weightUnit: 'g',\n      weightAmount: Math.round(grams * 100) / 100,\n    }\n    delete (clamped as any).piecesPerServing\n    delete (clamped as any).pieces\n    changed = true\n    return clamped\n  })\n  return { items: next, changed }\n}\n\nconst replaceWordNumbers = (text: string) => {\n  if (!text) return text;\n  const map: Record<string, string> = {\n    one: '1',\n    two: '2',\n    three: '3',\n    four: '4',\n    five: '5',\n    six: '6',\n    seven: '7',\n    eight: '8',\n    nine: '9',\n    ten: '10',\n    eleven: '11',\n    twelve: '12',\n  };\n  return String(text).replace(/\\b(one|two|three|four|five|six|seven|eight|nine|ten|eleven|twelve)\\b/gi, (m) => {\n    const repl = map[m.toLowerCase()];\n    return repl || m;\n  });\n};\n\nconst parseCountFromText = (text: string): number | null => {\n  if (!text) return null;\n  const normalized = replaceWordNumbers(String(text).toLowerCase());\n  const match = normalized.match(/(\\d+(?:\\.\\d+)?)/);\n  if (!match) return null;\n  const n = parseFloat(match[1]);\n  return Number.isFinite(n) && n > 0 ? n : null;\n};\n\nconst DISCRETE_PIECE_KEYWORDS = [\n  'egg',\n  'eggs',\n  'patty',\n  'pattie',\n  'patties',\n  'nugget',\n  'nuggets',\n  'wing',\n  'wings',\n  'drumstick',\n  'drumsticks',\n  'leg',\n  'legs',\n  'slice',\n  'slices',\n  'strip',\n  'strips',\n  'tender',\n  'tenders',\n  'piece',\n  'pieces',\n  'cookie',\n  'cookies',\n  'cracker',\n  'crackers',\n  'biscuit',\n  'biscuits',\n  'sausage',\n  'sausages',\n  'link',\n  'links',\n]\n\nconst hasDiscreteKeyword = (text: string) => {\n  const lower = String(text || '').toLowerCase()\n  return DISCRETE_PIECE_KEYWORDS.some((k) => lower.includes(k))\n}\n\nconst extractExplicitPieceCount = (text: string, keywords: string[] = DISCRETE_PIECE_KEYWORDS): number | null => {\n  if (!text) return null\n  const normalized = replaceWordNumbers(String(text).toLowerCase()).replace(/\\b(a|an)\\b/g, '1')\n  const keywordPattern = keywords.map((k) => k.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')).join('|')\n  const match = normalized.match(\n    new RegExp(`(\\\\d+(?:\\\\.\\\\d+)?)\\\\s*(?:x\\\\s*)?(?:[a-z-]+\\\\s+){0,2}(?:${keywordPattern})\\\\b`),\n  )\n  if (!match) return null\n  const n = parseFloat(match[1])\n  return Number.isFinite(n) && n > 0 ? n : null\n}\n\nconst hasExplicitPieceCount = (text: string, keywords?: string[]): boolean => {\n  const count = extractExplicitPieceCount(text, keywords)\n  return Number.isFinite(count) && Number(count) > 0\n}\n\nconst normalizeDiscreteCounts = (items: any[]): any[] =>\n  Array.isArray(items)\n    ? items.map((item) => ({\n        ...item,\n        name: replaceWordNumbers(item?.name || ''),\n        serving_size: replaceWordNumbers(item?.serving_size || item?.servingSize || ''),\n        isGuess: item?.isGuess === true,\n      }))\n    : [];\n\n// Sometimes the model misreads a weight like \"8 oz cooked (227g)\" as a *count* of 8 pieces,\n// and may even prefix the name with the number. This causes the UI to show nonsense like\n// \"8 roasted chicken\" with Pieces=8. If the serving is clearly weight-based and there are\n// no discrete-unit keywords, we clear pieces metadata and strip accidental leading counts.\nconst fixWeightUnitsMisreadAsPieces = (items: any[]): { items: any[]; changed: boolean } => {\n  if (!Array.isArray(items) || items.length === 0) return { items, changed: false }\n  let changed = false\n\n  const hasWeightUnit = (text: string) => /\\b\\d+(?:\\.\\d+)?\\s*(g|gram|grams|kg|ml|oz|ounce|ounces)\\b/i.test(text || '')\n\n  const fixed = items.map((item) => {\n    if (!item || typeof item !== 'object') return item\n    const next: any = { ...item }\n    const name = String(next?.name || '')\n    const serving = String(next?.serving_size || next?.servingSize || '')\n    const label = `${name} ${serving}`.trim()\n\n    const piecesPerServing =\n      Number.isFinite(Number(next?.piecesPerServing)) && Number(next.piecesPerServing) > 0 ? Number(next.piecesPerServing) : null\n    const pieces =\n      Number.isFinite(Number(next?.pieces)) && Number(next.pieces) > 0 ? Number(next.pieces) : null\n\n    if (!hasWeightUnit(serving)) return next\n    if (hasDiscreteKeyword(label)) return next\n\n    // If the model prefixed the name with a number (often from oz), strip it.\n    if (/^\\s*\\d+\\s+/.test(name)) {\n      next.name = name.replace(/^\\s*\\d+\\s+/, '').trim()\n      changed = true\n    }\n\n    // If pieces metadata exists in a weight-based serving, remove it.\n    if (piecesPerServing || pieces) {\n      delete next.piecesPerServing\n      delete next.pieces\n      changed = true\n    }\n\n    return next\n  })\n\n  return { items: fixed, changed }\n}\n\nconst stripPiecesWithoutExplicitCount = (items: any[]): { items: any[]; changed: boolean } => {\n  if (!Array.isArray(items) || items.length === 0) return { items, changed: false }\n  let changed = false\n\n  const next = items.map((item) => {\n    if (!item || typeof item !== 'object') return item\n    const updated: any = { ...item }\n    const name = String(updated?.name || '')\n    const serving = String(updated?.serving_size || updated?.servingSize || '')\n    const label = replaceWordNumbers(`${name} ${serving}`.trim())\n    const explicitCount = extractExplicitPieceCount(label)\n    const hasPieces =\n      (Number.isFinite(Number(updated?.piecesPerServing)) && Number(updated.piecesPerServing) > 0) ||\n      (Number.isFinite(Number(updated?.pieces)) && Number(updated.pieces) > 0)\n\n    if (!explicitCount && hasPieces) {\n      delete updated.piecesPerServing\n      delete updated.pieces\n      changed = true\n    }\n\n    return updated\n  })\n\n  return { items: next, changed }\n}\n\n// When in packaged mode, try to fill missing/zero macros from FatSecret without overwriting existing values.\nconst enrichPackagedItemsWithFatSecret = async (items: any[]): Promise<{ items: any[]; total: any | null }> => {\n  const enriched: any[] = [];\n  let changed = false;\n\n  for (const item of items) {\n    const next = { ...item };\n    const query = [item.brand, item.name].filter(Boolean).join(' ').trim();\n    const hasMissingMacros =\n      next.calories == null ||\n      next.protein_g == null ||\n      next.carbs_g == null ||\n      next.fat_g == null ||\n      next.fiber_g == null ||\n      next.sugar_g == null ||\n      next.calories === 0;\n\n    if (query && hasMissingMacros) {\n      try {\n        const fsResults = await searchFatSecretFoods(query, { pageSize: 1 });\n        const candidate = fsResults?.[0];\n        if (candidate) {\n          const maybe = (key: keyof typeof candidate, fallback: any) =>\n            candidate[key] !== null && candidate[key] !== undefined ? candidate[key] : fallback;\n\n          if (candidate.serving_size && !next.serving_size) {\n            next.serving_size = candidate.serving_size;\n          }\n          if (next.calories == null || next.calories === 0) next.calories = maybe('calories', next.calories);\n          if (next.protein_g == null) next.protein_g = maybe('protein_g', next.protein_g);\n          if (next.carbs_g == null) next.carbs_g = maybe('carbs_g', next.carbs_g);\n          if (next.fat_g == null) next.fat_g = maybe('fat_g', next.fat_g);\n          if (next.fiber_g == null) next.fiber_g = maybe('fiber_g', next.fiber_g);\n          if (next.sugar_g == null) next.sugar_g = maybe('sugar_g', next.sugar_g);\n          changed = true;\n        }\n      } catch (err) {\n        console.warn('FatSecret enrichment failed (non-fatal)', err);\n      }\n    }\n\n    enriched.push(next);\n  }\n\n  return {\n    items: enriched,\n    total: changed ? computeTotalsFromItems(enriched) : null,\n  };\n};\n\n// Lightweight enrichment for struggling items using FatSecret without overriding decent AI values.\n// Only runs when calories are missing/zero OR all macros are missing/zero.\nconst enrichItemsWithFatSecretIfMissing = async (items: any[]): Promise<{ items: any[]; total: any | null; changed: boolean }> => {\n  if (!Array.isArray(items) || items.length === 0) {\n    return { items, total: null, changed: false };\n  }\n\n  const enriched: any[] = [];\n  let changed = false;\n\n  for (const item of items) {\n    const next = { ...item };\n    const query = [item.brand, item.name].filter(Boolean).join(' ').trim();\n    const calories = Number(item?.calories ?? 0);\n    const protein = Number(item?.protein_g ?? 0);\n    const carbs = Number(item?.carbs_g ?? 0);\n    const fat = Number(item?.fat_g ?? 0);\n    const macrosMissing =\n      (!Number.isFinite(calories) || calories === 0) &&\n      (!Number.isFinite(protein) || protein === 0) &&\n      (!Number.isFinite(carbs) || carbs === 0) &&\n      (!Number.isFinite(fat) || fat === 0);\n    const caloriesMissingOrZero = !Number.isFinite(calories) || calories === 0;\n\n    // Only attempt enrichment when we truly lack data\n    if (!query || (!macrosMissing && !caloriesMissingOrZero)) {\n      enriched.push(next);\n      continue;\n    }\n\n    try {\n      const fsResults = await searchFatSecretFoods(query, { pageSize: 1 });\n      const candidate = fsResults?.[0];\n      if (candidate) {\n        const maybe = (key: keyof typeof candidate, fallback: any) =>\n          candidate[key] !== null && candidate[key] !== undefined ? candidate[key] : fallback;\n\n        if (caloriesMissingOrZero) next.calories = maybe('calories', next.calories);\n        if (!Number.isFinite(protein) || protein === 0) next.protein_g = maybe('protein_g', next.protein_g);\n        if (!Number.isFinite(carbs) || carbs === 0) next.carbs_g = maybe('carbs_g', next.carbs_g);\n        if (!Number.isFinite(fat) || fat === 0) next.fat_g = maybe('fat_g', next.fat_g);\n        if (!next.serving_size && candidate.serving_size) next.serving_size = candidate.serving_size;\n\n        // Do not override non-zero values; only fill missing/zero\n        changed = true;\n      }\n    } catch (err) {\n      console.warn('FatSecret enrichment (missing macros) failed (non-fatal)', err);\n    }\n\n    enriched.push(next);\n  }\n\n  return {\n    items: enriched,\n    total: changed ? computeTotalsFromItems(enriched) : null,\n    changed,\n  };\n};\n\nconst normalizeLookupQuery = (raw: string): string => {\n  const cleaned = replaceWordNumbers(String(raw || ''))\n    .replace(/^\\s*\\d+(?:\\.\\d+)?\\s+/, '')\n    .replace(/[^a-z0-9\\s]+/gi, ' ')\n    .replace(/\\s+/g, ' ')\n    .trim();\n  return cleaned.toLowerCase();\n};\n\nconst scoreLookupNameMatch = (queryNorm: string, candidateName: string): number => {\n  if (!queryNorm) return 0;\n  const nameNorm = normalizeLookupQuery(candidateName);\n  if (!nameNorm) return 0;\n  if (nameNorm === queryNorm) return 100;\n  if (nameNorm.startsWith(queryNorm)) return 80;\n  if (nameNorm.includes(queryNorm)) return 60;\n  const tokens = queryNorm.split(' ').filter(Boolean);\n  if (tokens.length === 0) return 0;\n  const hitCount = tokens.filter((t) => nameNorm.includes(t)).length;\n  return hitCount * 10;\n};\n\nconst getItemWeightInGrams = (item: any): number | null => {\n  const customGrams = Number(item?.customGramsPerServing);\n  if (Number.isFinite(customGrams) && customGrams > 0) return customGrams;\n  const customMl = Number(item?.customMlPerServing);\n  if (Number.isFinite(customMl) && customMl > 0) return customMl;\n  const serving = item?.serving_size || item?.servingSize;\n  const parsed = parseServingWeight(serving);\n  if (Number.isFinite(parsed) && parsed && parsed > 0) return parsed;\n  return null;\n};\n\nconst FRIED_SEAFOOD_KCAL_PER_100G_FLOOR = 180;\nconst ROASTED_CHICKEN_KCAL_PER_100G_FLOOR = 150;\nconst isFriedOrBatteredLabel = (label: string) =>\n  /\\b(fried|battered|breaded|crumbed|tempura|beer\\b)\\b/i.test(label || '');\nconst isSeafoodLabel = (label: string) =>\n  /\\b(fish|fillet|seafood|shrimp|prawn|calamari|squid|scallop|crab|lobster)\\b/i.test(label || '');\nconst isRoastedChickenLabel = (label: string) =>\n  /\\b(chicken|rotisserie)\\b/i.test(label || '') && /\\b(roasted|grilled|baked|rotisserie)\\b/i.test(label || '');\n\nconst applyFriedSeafoodCalorieFloor = (items: any[]): { items: any[]; changed: boolean } => {\n  if (!Array.isArray(items) || items.length === 0) {\n    return { items, changed: false };\n  }\n\n  let changed = false;\n  const nextItems = items.map((item) => {\n    const label = `${item?.name || ''} ${item?.serving_size || ''}`.trim();\n    if (!label) return item;\n    if (!isFriedOrBatteredLabel(label) || !isSeafoodLabel(label)) return item;\n\n    const weight = getItemWeightInGrams(item);\n    if (!Number.isFinite(weight) || !weight || weight <= 0) return item;\n\n    const calories = Number(item?.calories ?? 0);\n    if (!Number.isFinite(calories) || calories <= 0) return item;\n\n    const per100 = (calories / weight) * 100;\n    if (!Number.isFinite(per100) || per100 >= FRIED_SEAFOOD_KCAL_PER_100G_FLOOR) return item;\n\n    const targetCalories = Math.round((weight * FRIED_SEAFOOD_KCAL_PER_100G_FLOOR) / 100);\n    const scale = targetCalories / calories;\n    const scaleMacro = (value: any, decimals = 1) => {\n      const num = Number(value);\n      if (!Number.isFinite(num)) return value;\n      const factor = Math.pow(10, decimals);\n      return Math.round(num * scale * factor) / factor;\n    };\n\n    const next = { ...item };\n    next.calories = targetCalories;\n    if (next.protein_g != null) next.protein_g = scaleMacro(next.protein_g);\n    if (next.carbs_g != null) next.carbs_g = scaleMacro(next.carbs_g);\n    if (next.fat_g != null) next.fat_g = scaleMacro(next.fat_g);\n    if (next.fiber_g != null) next.fiber_g = scaleMacro(next.fiber_g);\n    if (next.sugar_g != null) next.sugar_g = scaleMacro(next.sugar_g);\n    changed = true;\n    return next;\n  });\n\n  return { items: nextItems, changed };\n};\n\nconst applyRoastedChickenCalorieFloor = (items: any[]): { items: any[]; changed: boolean } => {\n  if (!Array.isArray(items) || items.length === 0) {\n    return { items, changed: false };\n  }\n\n  let changed = false;\n  const nextItems = items.map((item) => {\n    const label = `${item?.name || ''} ${item?.serving_size || ''}`.trim();\n    if (!label) return item;\n    if (!isRoastedChickenLabel(label)) return item;\n\n    const weight = getItemWeightInGrams(item);\n    if (!Number.isFinite(weight) || !weight || weight <= 0) return item;\n\n    const calories = Number(item?.calories ?? 0);\n    if (!Number.isFinite(calories) || calories <= 0) return item;\n\n    const per100 = (calories / weight) * 100;\n    if (!Number.isFinite(per100) || per100 >= ROASTED_CHICKEN_KCAL_PER_100G_FLOOR) return item;\n\n    const targetCalories = Math.round((weight * ROASTED_CHICKEN_KCAL_PER_100G_FLOOR) / 100);\n    const scale = targetCalories / calories;\n    const scaleMacro = (value: any, decimals = 1) => {\n      const num = Number(value);\n      if (!Number.isFinite(num)) return value;\n      const factor = Math.pow(10, decimals);\n      return Math.round(num * scale * factor) / factor;\n    };\n\n    const next = { ...item };\n    next.calories = targetCalories;\n    if (next.protein_g != null) next.protein_g = scaleMacro(next.protein_g);\n    if (next.carbs_g != null) next.carbs_g = scaleMacro(next.carbs_g);\n    if (next.fat_g != null) next.fat_g = scaleMacro(next.fat_g);\n    if (next.fiber_g != null) next.fiber_g = scaleMacro(next.fiber_g);\n    if (next.sugar_g != null) next.sugar_g = scaleMacro(next.sugar_g);\n    changed = true;\n    return next;\n  });\n\n  return { items: nextItems, changed };\n};\n\nconst selectDatabaseCandidate = (query: string, candidates: any[], aiPer100?: number | null) => {\n  if (!Array.isArray(candidates) || candidates.length === 0) return null;\n  const queryNorm = normalizeLookupQuery(query);\n  const candidatesWithMetrics: Array<{ candidate: any; weight: number; per100: number; score: number }> = [];\n  for (const candidate of candidates) {\n    const weight = parseServingWeight(candidate?.serving_size || null);\n    if (!weight || weight <= 0 || weight > 5000) continue;\n    const calories = Number(candidate?.calories ?? 0);\n    if (!Number.isFinite(calories) || calories <= 0) continue;\n    const per100 = (calories / weight) * 100;\n    if (!Number.isFinite(per100) || per100 <= 0) continue;\n    const sourceBonus = candidate?.source === 'usda' ? 3 : candidate?.source === 'fatsecret' ? 2 : 1;\n    const score = scoreLookupNameMatch(queryNorm, candidate?.name || '') + sourceBonus;\n    candidatesWithMetrics.push({ candidate, weight, per100, score });\n  }\n  if (candidatesWithMetrics.length === 0) return null;\n\n  const aiPer100Safe = Number.isFinite(Number(aiPer100)) ? Number(aiPer100) : null;\n  let pool = candidatesWithMetrics;\n  if (aiPer100Safe && aiPer100Safe > 0) {\n    const lowerOrNear = candidatesWithMetrics.filter((entry) => entry.per100 <= aiPer100Safe * 1.05);\n    if (lowerOrNear.length > 0) {\n      pool = lowerOrNear;\n    }\n  }\n\n  pool.sort((a, b) => b.score - a.score);\n  return { candidate: pool[0].candidate, weight: pool[0].weight, score: pool[0].score };\n};\n\ntype DbOutlierOptions = {\n  maxItems?: number;\n  outlierRatio?: number;\n  allowIncrease?: boolean;\n  preferSource?: 'usda' | 'fatsecret' | 'auto';\n};\n\n// Database-backed calibration for single foods when AI macros look wildly off vs USDA/FatSecret.\nconst enrichItemsWithDatabaseIfOutlier = async (\n  items: any[],\n  options: DbOutlierOptions = {},\n): Promise<{ items: any[]; total: any | null; changed: boolean }> => {\n  if (!Array.isArray(items) || items.length === 0) {\n    return { items, total: null, changed: false };\n  }\n\n  const maxItemsRaw = Number(options?.maxItems);\n  const maxItems = Number.isFinite(maxItemsRaw) && maxItemsRaw > 0 ? Math.floor(maxItemsRaw) : 1;\n  const outlierRatioRaw = Number(options?.outlierRatio);\n  const OUTLIER_RATIO = Number.isFinite(outlierRatioRaw) && outlierRatioRaw > 0 ? outlierRatioRaw : 0.2;\n  const allowIncrease = options?.allowIncrease === true;\n  let checked = 0;\n  let changed = false;\n  const nextItems = items.map((item) => ({ ...item }));\n\n  const isPreparedFoodName = (name: string) =>\n    /\\b(roast|roasted|rotisserie|fried|grilled|baked|bbq|barbecue|smoked|whole|cooked)\\b/i.test(name || '');\n\n  for (const item of nextItems) {\n    if (checked >= maxItems) break;\n\n    const weight = getItemWeightInGrams(item);\n    if (!weight || weight < 15) continue;\n\n    const calories = Number(item?.calories ?? 0);\n    if (!Number.isFinite(calories) || calories <= 0) continue;\n\n    const query = normalizeLookupQuery(item?.name || '');\n    if (!query) continue;\n\n    checked += 1;\n\n    let dbResults: any[] = [];\n    try {\n      const preferSource =\n        options?.preferSource && options.preferSource !== 'auto'\n          ? options.preferSource\n          : isPreparedFoodName(query)\n          ? 'fatsecret'\n          : 'usda';\n      dbResults = await lookupFoodNutrition(query, {\n        preferSource,\n        maxResults: 3,\n        usdaDataType: 'generic',\n      });\n    } catch (err) {\n      console.warn('Database lookup failed (non-fatal)', err);\n      continue;\n    }\n\n    const aiPer100 = (calories / weight) * 100;\n    const selected = selectDatabaseCandidate(query, dbResults, aiPer100);\n    if (!selected) continue;\n\n    const { candidate, weight: candidateWeight } = selected;\n    const candidateCalories = Number(candidate?.calories ?? 0);\n    if (!Number.isFinite(candidateCalories) || candidateCalories <= 0) continue;\n\n    const dbPer100 = (candidateCalories / candidateWeight) * 100;\n    if (!Number.isFinite(aiPer100) || !Number.isFinite(dbPer100) || dbPer100 <= 0) continue;\n\n    const ratio = Math.abs(aiPer100 - dbPer100) / dbPer100;\n    const dbScaledCalories = Math.round(candidateCalories * (weight / candidateWeight));\n    const calorieDiff = Math.abs(calories - dbScaledCalories);\n    if (ratio < OUTLIER_RATIO && calorieDiff < 180) continue;\n    if (!allowIncrease) {\n      const aiIsGuess = item?.isGuess === true;\n      const aiHigherThanDb = aiPer100 > dbPer100;\n      if (!aiIsGuess && !aiHigherThanDb) continue;\n    }\n\n    const scale = weight / candidateWeight;\n    const scaleMacro = (value: any, decimals = 1) => {\n      const num = Number(value);\n      if (!Number.isFinite(num)) return null;\n      const factor = Math.pow(10, decimals);\n      return Math.round(num * scale * factor) / factor;\n    };\n\n    item.calories = dbScaledCalories;\n    if (candidate?.protein_g !== null && candidate?.protein_g !== undefined) {\n      item.protein_g = scaleMacro(candidate.protein_g);\n    }\n    if (candidate?.carbs_g !== null && candidate?.carbs_g !== undefined) {\n      item.carbs_g = scaleMacro(candidate.carbs_g);\n    }\n    if (candidate?.fat_g !== null && candidate?.fat_g !== undefined) {\n      item.fat_g = scaleMacro(candidate.fat_g);\n    }\n    if (candidate?.fiber_g !== null && candidate?.fiber_g !== undefined) {\n      item.fiber_g = scaleMacro(candidate.fiber_g);\n    }\n    if (candidate?.sugar_g !== null && candidate?.sugar_g !== undefined) {\n      item.sugar_g = scaleMacro(candidate.sugar_g);\n    }\n\n    changed = true;\n  }\n\n  return {\n    items: nextItems,\n    total: changed ? computeTotalsFromItems(nextItems) : null,\n    changed,\n  };\n};\n\n// Optional: decode barcode from label image (OpenAI vision quick pass).\nconst fetchOpenFoodFactsByBarcode = async (barcode: string): Promise<any | null> => {\n  try {\n    if (!barcode || barcode.trim().length < 6) return null;\n    const url = `https://world.openfoodfacts.org/api/v0/product/${encodeURIComponent(barcode)}.json`;\n    const res = await fetch(url, {\n      headers: { 'User-Agent': 'helfi-app/1.0 (support@helfi.ai)' },\n      cache: 'no-store',\n    });\n    if (!res.ok) return null;\n    const data = await res.json();\n    if (data.status !== 1 || !data.product) return null;\n    const p = data.product;\n    const nutr = p.nutriments || {};\n    const servingSize =\n      (p.serving_size && String(p.serving_size).trim()) ||\n      (nutr['serving_size'] && String(nutr['serving_size']).trim()) ||\n      null;\n    const get = (k: string) => {\n      const v = nutr[k];\n      const n = Number(v);\n      return Number.isFinite(n) ? n : null;\n    };\n    const calories = get('energy-kcal_serving') ?? get('energy_serving') ?? get('energy-kcal_100g') ?? get('energy_100g');\n    const protein_g = get('proteins_serving') ?? get('proteins_100g');\n    const carbs_g = get('carbohydrates_serving') ?? get('carbohydrates_100g');\n    const fat_g = get('fat_serving') ?? get('fat_100g');\n    const fiber_g = get('fiber_serving') ?? get('fiber_100g');\n    const sugar_g = get('sugars_serving') ?? get('sugars_100g');\n    return {\n      name: p.product_name || p.brands || 'Packaged item',\n      brand: p.brands || null,\n      serving_size: servingSize,\n      calories,\n      protein_g,\n      carbs_g,\n      fat_g,\n      fiber_g,\n      sugar_g,\n    };\n  } catch (err) {\n    console.warn('OpenFoodFacts barcode lookup failed', err);\n    return null;\n  }\n};\n\n// Heuristic correction for discrete foods where the serving label clearly\n// describes multiple units (e.g. \"3 large eggs\", \"4 slices bacon\") but the\n// calories/macros look like a single unit. This runs **after** we have parsed\n// ITEMS_JSON and before values are sent to the Food Diary UI.\nconst harmonizeDiscretePortionItems = (\n  items: any[],\n  options?: { applyWeightDefaults?: boolean },\n): { items: any[]; total: any | null } => {\n  if (!Array.isArray(items) || items.length === 0) {\n    return { items, total: null };\n  }\n\n  const cloned = items.map((item) => ({ ...item }));\n  const applyWeightDefaults = options?.applyWeightDefaults !== false;\n\n  const containsAny = (text: string, keywords: string[]): boolean => {\n    const lower = text.toLowerCase();\n    return keywords.some((k) => lower.includes(k));\n  };\n\n  const EGG_KEYWORDS = ['egg', 'eggs', 'scrambled egg', 'scrambled eggs', 'omelette', 'omelet'];\n  const BACON_KEYWORDS = ['bacon', 'rasher', 'rashers', 'bacon strip', 'bacon strips'];\n  const PATTY_KEYWORDS = ['patty', 'pattie', 'patties', 'burger patty', 'beef patty'];\n  const CHEESE_KEYWORDS = ['cheese', 'cheddar', 'mozzarella', 'slice of cheese', 'cheese slice'];\n  const DRUMSTICK_KEYWORDS = ['drumstick', 'drumsticks', 'chicken drumstick', 'chicken leg', 'chicken legs'];\n  const DISCRETE_DEFAULTS: Array<{\n    key: string;\n    keywords: string[];\n    gramsPerPiece: number;\n    caloriesPerPiece: number;\n    proteinPerPiece?: number;\n    fatPerPiece?: number;\n    label?: (piecesPerServing: number) => string;\n  }> = [\n    {\n      key: 'patty',\n      keywords: PATTY_KEYWORDS,\n      gramsPerPiece: 115,\n      caloriesPerPiece: 250,\n      proteinPerPiece: 22,\n      fatPerPiece: 18,\n      label: (n) => `${n} patty${n > 1 ? 'ies' : 'y'} (4‚Äì6 oz)`,\n    },\n    {\n      key: 'bacon',\n      keywords: BACON_KEYWORDS,\n      gramsPerPiece: 15,\n      caloriesPerPiece: 45,\n      proteinPerPiece: 3,\n      fatPerPiece: 3.5,\n      label: (n) => `${n} slice${n > 1 ? 's' : ''} bacon`,\n    },\n    {\n      key: 'cheese',\n      keywords: CHEESE_KEYWORDS,\n      gramsPerPiece: 25,\n      caloriesPerPiece: 100,\n      proteinPerPiece: 6,\n      fatPerPiece: 9,\n      label: (n) => `${n} cheese slice${n > 1 ? 's' : ''}`,\n    },\n    {\n      key: 'egg',\n      keywords: EGG_KEYWORDS,\n      gramsPerPiece: 50,\n      caloriesPerPiece: 70,\n      proteinPerPiece: 6,\n      fatPerPiece: 5,\n      label: (n) => `${n} piece${n > 1 ? 's' : ''}`,\n    },\n    {\n      key: 'drumstick',\n      keywords: DRUMSTICK_KEYWORDS,\n      gramsPerPiece: 90,\n      caloriesPerPiece: 180,\n      proteinPerPiece: 13,\n      fatPerPiece: 12,\n      label: (n) => `${n} drumstick${n > 1 ? 's' : ''}`,\n    },\n  ];\n  const WEIGHT_ONLY_DEFAULTS: Array<{\n    keywords: string[];\n    gramsPerPiece: number;\n  }> = [\n    { keywords: ['battered fish', 'fried fish', 'fish fillet', 'fish fingers', 'fish sticks'], gramsPerPiece: 90 },\n    { keywords: ['fried shrimp', 'shrimp', 'prawn', 'prawns'], gramsPerPiece: 30 },\n    { keywords: ['sausage', 'sausages', 'link', 'links'], gramsPerPiece: 75 },\n  ];\n\n  for (const item of cloned) {\n    const name = (item?.name || '') as string;\n    const servingSize = (item?.serving_size || '') as string;\n    const labelSource = replaceWordNumbers(`${name} ${servingSize}`.trim());\n    const explicitCount = extractExplicitPieceCount(labelSource);\n\n    const defaults = DISCRETE_DEFAULTS.find((d) => containsAny(labelSource, d.keywords));\n    const weightDefaults = WEIGHT_ONLY_DEFAULTS.find((d) => containsAny(labelSource, d.keywords));\n    if (!explicitCount) continue;\n    const existingServings =\n      Number.isFinite(Number(item?.servings)) && Number(item.servings) > 0 ? Number(item.servings) : 1;\n\n    const piecesPerServing = explicitCount;\n    const totalPieces = Math.max(1, existingServings * piecesPerServing);\n\n    item.servings = Math.round(existingServings * 1000) / 1000;\n    (item as any).piecesPerServing = piecesPerServing;\n\n    if (applyWeightDefaults) {\n      const perPieceWeight = defaults?.gramsPerPiece ?? weightDefaults?.gramsPerPiece ?? null;\n      if (perPieceWeight && perPieceWeight > 0) {\n        const totalWeight = perPieceWeight * piecesPerServing;\n        const servingWeight = parseServingWeight(item?.serving_size || null);\n        const customWeight = Number(item?.customGramsPerServing);\n        const currentWeight =\n          Number.isFinite(customWeight) && customWeight > 0\n            ? customWeight\n            : Number.isFinite(servingWeight) && servingWeight && servingWeight > 0\n            ? servingWeight\n            : null;\n        if (!currentWeight || currentWeight < totalWeight) {\n          item.customGramsPerServing = totalWeight;\n        }\n      }\n    }\n\n    if (defaults) {\n      // Seed serving_size with a discrete hint when missing so the UI picks up pieces.\n      if (!item.serving_size || String(item.serving_size).trim().length === 0) {\n        const label =\n          defaults.label?.(piecesPerServing) || `${piecesPerServing} piece${piecesPerServing > 1 ? 's' : ''}`;\n        item.serving_size = label;\n      }\n\n      const totalPiecesForMacros = Math.max(totalPieces, piecesPerServing * item.servings);\n      const calories = Number(item?.calories ?? NaN);\n      const protein = Number(item?.protein_g ?? NaN);\n      const fat = Number(item?.fat_g ?? NaN);\n\n      const perPieceCalories =\n        totalPiecesForMacros > 0 && Number.isFinite(calories) ? calories / totalPiecesForMacros : NaN;\n      const perPieceProtein =\n        totalPiecesForMacros > 0 && Number.isFinite(protein) ? protein / totalPiecesForMacros : NaN;\n      const perPieceFat = totalPiecesForMacros > 0 && Number.isFinite(fat) ? fat / totalPiecesForMacros : NaN;\n\n      const caloriesLow = !Number.isFinite(perPieceCalories) || perPieceCalories < defaults.caloriesPerPiece * 0.9;\n      const proteinLow =\n        defaults.proteinPerPiece === undefined ||\n        !Number.isFinite(perPieceProtein) ||\n        perPieceProtein < defaults.proteinPerPiece * 0.9;\n      const fatLow =\n        defaults.fatPerPiece === undefined || !Number.isFinite(perPieceFat) || perPieceFat < defaults.fatPerPiece * 0.9;\n\n      // If the \"total\" looks like it's only for a single piece, prefer scaling the model's numbers\n      // (this keeps photo-specific portion sizes), otherwise fall back to conservative defaults.\n      if (caloriesLow && (proteinLow || fatLow)) {\n        const looksLikePerPieceCalories = Number.isFinite(calories) && calories >= defaults.caloriesPerPiece * 0.6;\n        if (looksLikePerPieceCalories) {\n          const mult = totalPiecesForMacros;\n          if (Number.isFinite(calories)) item.calories = Math.round(calories * mult);\n          const macroFields: Array<keyof typeof item> = ['protein_g', 'carbs_g', 'fat_g', 'fiber_g', 'sugar_g'];\n          for (const field of macroFields) {\n            const v = Number((item as any)?.[field]);\n            if (Number.isFinite(v)) (item as any)[field] = Math.round(v * mult * 10) / 10;\n          }\n        } else {\n          item.calories = Math.round(defaults.caloriesPerPiece * totalPiecesForMacros);\n          if (defaults.proteinPerPiece !== undefined) {\n            item.protein_g = Math.round(defaults.proteinPerPiece * totalPiecesForMacros * 10) / 10;\n          }\n          if (defaults.fatPerPiece !== undefined) {\n            item.fat_g = Math.round(defaults.fatPerPiece * totalPiecesForMacros * 10) / 10;\n          }\n        }\n      }\n\n      if (\n        !item.customGramsPerServing &&\n        (!item.serving_size || !String(item.serving_size).toLowerCase().includes('g'))\n      ) {\n        item.customGramsPerServing = defaults.gramsPerPiece * piecesPerServing;\n      }\n    }\n  }\n\n  const total = computeTotalsFromItems(cloned);\n  return { items: cloned, total };\n};\n\n// Burger-specific heuristics: ensure core components exist and have realistic macros.\nconst ensureBurgerComponents = (items: any[] | null, analysis: string | null | undefined): { items: any[]; total: any | null } => {\n  const base = Array.isArray(items) ? normalizeGuessFlags(items) : [];\n  const text = (analysis || '').toLowerCase();\n  const names = base.map((it) => String(it?.name || '').toLowerCase());\n  const looksLikeBurger =\n    text.includes('burger') ||\n    names.some((n) => n.includes('burger') || n.includes('patty') || n.includes('bun'));\n\n  if (!looksLikeBurger) {\n    return { items: base, total: computeTotalsFromItems(base) };\n  }\n\n  const hasKeyword = (keywords: string[]) =>\n    base.some((it) => {\n      const n = String(it?.name || '').toLowerCase();\n      return keywords.some((k) => n.includes(k));\n    });\n\n  const ensureItem = (keywords: string[], createItem: () => any) => {\n    if (!hasKeyword(keywords)) {\n      base.push({ ...createItem(), isGuess: true });\n    }\n  };\n\n  // Normalize patties to explicit counts only (avoid inferred pieces).\n  base.forEach((it) => {\n    const n = String(it?.name || '').toLowerCase();\n    if (!n.includes('patty')) return;\n\n    const existingServings =\n      Number.isFinite(Number(it.servings)) && Number(it.servings) > 0 ? Number(it.servings) : 1;\n    const labelSource = replaceWordNumbers(`${it?.name || ''} ${it?.serving_size || ''}`.trim());\n    const explicitCount = extractExplicitPieceCount(labelSource);\n\n    it.servings = Math.round(existingServings * 1000) / 1000;\n\n    if (!explicitCount) {\n      delete (it as any).piecesPerServing;\n      delete (it as any).pieces;\n      if (!it.serving_size) {\n        it.serving_size = '115 g';\n      }\n      if (!it.customGramsPerServing) {\n        it.customGramsPerServing = 115;\n      }\n\n      const calories = Number(it.calories ?? NaN);\n      const protein = Number(it.protein_g ?? NaN);\n      const fat = Number(it.fat_g ?? NaN);\n      if (!Number.isFinite(calories) || calories < 200) {\n        it.calories = 250;\n      }\n      if (!Number.isFinite(protein) || protein < 18) {\n        it.protein_g = 22;\n      }\n      if (!Number.isFinite(fat) || fat < 12) {\n        it.fat_g = 18;\n      }\n      return;\n    }\n\n    const piecesPerServing = explicitCount;\n    const totalPieces = Math.max(1, piecesPerServing * existingServings);\n    (it as any).piecesPerServing = piecesPerServing;\n\n    const perPieceCalories =\n      totalPieces > 0 && Number.isFinite(Number(it.calories)) ? Number(it.calories) / totalPieces : 0;\n    const perPieceProtein =\n      totalPieces > 0 && Number.isFinite(Number(it.protein_g)) ? Number(it.protein_g) / totalPieces : 0;\n    const perPieceFat =\n      totalPieces > 0 && Number.isFinite(Number(it.fat_g)) ? Number(it.fat_g) / totalPieces : 0;\n\n    if (!Number.isFinite(perPieceCalories) || perPieceCalories < 200) {\n      it.calories = Math.round(250 * totalPieces);\n    }\n    if (!Number.isFinite(perPieceProtein) || perPieceProtein < 18) {\n      it.protein_g = Math.round(22 * totalPieces * 10) / 10;\n    }\n    if (!Number.isFinite(perPieceFat) || perPieceFat < 12) {\n      it.fat_g = Math.round(18 * totalPieces * 10) / 10;\n    }\n    if (!it.serving_size) {\n      it.serving_size = `${piecesPerServing} patty${piecesPerServing > 1 ? 'ies' : 'y'} (4‚Äì6 oz)`;\n    }\n    if (!it.customGramsPerServing) {\n      it.customGramsPerServing = piecesPerServing * 115;\n    }\n  });\n\n  ensureItem(['patty', 'pattie'], () => ({\n    name: 'Beef patty',\n    brand: null,\n    serving_size: '115 g',\n    servings: 1,\n    calories: 250,\n    protein_g: 22,\n    carbs_g: 0,\n    fat_g: 18,\n    fiber_g: 0,\n    sugar_g: 0,\n    customGramsPerServing: 115,\n  }));\n\n  ensureItem(['bun'], () => ({\n    name: 'Burger bun',\n    brand: null,\n    serving_size: '1 bun',\n    servings: 1,\n    calories: 150,\n    protein_g: 5,\n    carbs_g: 28,\n    fat_g: 3,\n    fiber_g: 1,\n    sugar_g: 3,\n  }));\n\n  ensureItem(['cheese'], () => ({\n    name: 'Cheddar cheese slice',\n    brand: null,\n    serving_size: '25 g',\n    servings: 1,\n    calories: 100,\n    protein_g: 6,\n    carbs_g: 1,\n    fat_g: 9,\n    fiber_g: 0,\n    sugar_g: 0,\n    customGramsPerServing: 25,\n  }));\n\n  ensureItem(['bacon'], () => ({\n    name: 'Bacon slice',\n    brand: null,\n    serving_size: '15 g',\n    servings: 1,\n    calories: 45,\n    protein_g: 3,\n    carbs_g: 0,\n    fat_g: 3.5,\n    fiber_g: 0,\n    sugar_g: 0,\n    customGramsPerServing: 15,\n  }));\n\n  ensureItem(['lettuce'], () => ({\n    name: 'Lettuce',\n    brand: null,\n    serving_size: '10 g',\n    servings: 1,\n    calories: 5,\n    protein_g: 0.5,\n    carbs_g: 1,\n    fat_g: 0,\n    fiber_g: 0.5,\n    sugar_g: 0,\n  }));\n\n  ensureItem(['tomato'], () => ({\n    name: 'Tomato',\n    brand: null,\n    serving_size: '40 g',\n    servings: 1,\n    calories: 10,\n    protein_g: 0.5,\n    carbs_g: 2,\n    fat_g: 0,\n    fiber_g: 0.5,\n    sugar_g: 1.5,\n  }));\n\n  ensureItem(['sauce', 'mayo', 'mayonnaise', 'ketchup', 'mustard'], () => ({\n    name: 'Burger sauce',\n    brand: null,\n    serving_size: '1 tbsp',\n    servings: 1,\n    calories: 100,\n    protein_g: 0,\n    carbs_g: 1,\n    fat_g: 11,\n    fiber_g: 0,\n    sugar_g: 1,\n  }));\n\n  const total = computeTotalsFromItems(base);\n  return { items: base, total };\n};\n\n// Detect when the AI returned a generic single card instead of per-component items\nconst looksLikeSingleGenericItem = (items: any[] | null | undefined): boolean => {\n  if (!Array.isArray(items) || items.length !== 1) return false;\n  const item = items[0] || {};\n  const name = String(item.name || '').trim().toLowerCase();\n  const servingSize = String(item.serving_size || '').trim().toLowerCase();\n  const genericNames = ['meal', 'food', 'entry'];\n  const hasMinimalDetail = !servingSize || servingSize === '1 serving';\n  return genericNames.includes(name) || hasMinimalDetail;\n};\n\nconst looksLikeMultiIngredientSummary = (items: any[] | null | undefined): boolean => {\n  if (!Array.isArray(items) || items.length !== 1) return false;\n  const item = items[0] || {};\n  const label = `${String(item?.name || '')} ${String(item?.serving_size || '')}`.toLowerCase();\n  if (!label.trim()) return false;\n  if (label.includes('components')) return true;\n  const hasListDelimiters = label.includes(',') || label.includes(' and ') || label.includes(' with ');\n  const wordCount = label.split(/\\s+/).filter(Boolean).length;\n  return hasListDelimiters && wordCount >= 6;\n};\n\nconst normalizeSummaryLabel = (value: string): string => {\n  return String(value || '')\n    .toLowerCase()\n    .replace(/[^a-z0-9\\s]+/g, ' ')\n    .replace(/\\s+/g, ' ')\n    .trim();\n};\n\nconst hasSummaryDelimiter = (label: string): boolean => {\n  return /,|\\band\\b|\\bwith\\b|\\bplus\\b|&/.test(label || '');\n};\n\nconst isSubstantiveItem = (item: any): boolean => {\n  const calories = Number(item?.calories ?? 0);\n  if (Number.isFinite(calories) && calories >= 50) return true;\n  const protein = Number(item?.protein_g ?? 0);\n  const carbs = Number(item?.carbs_g ?? 0);\n  const fat = Number(item?.fat_g ?? 0);\n  return (\n    (Number.isFinite(protein) && protein >= 5) ||\n    (Number.isFinite(carbs) && carbs >= 5) ||\n    (Number.isFinite(fat) && fat >= 5)\n  );\n};\n\nconst removeSummaryDuplicateItems = (\n  items: any[],\n): { items: any[]; removed: number } => {\n  if (!Array.isArray(items) || items.length < 2) return { items, removed: 0 };\n  const normalized = items.map((item) => {\n    const name = normalizeSummaryLabel(item?.name || '');\n    const label = normalizeSummaryLabel(`${item?.name || ''} ${item?.serving_size || ''}`);\n    return { item, name, label };\n  });\n  const removeIndices = new Set<number>();\n  normalized.forEach((entry, idx) => {\n    if (!entry.label || !hasSummaryDelimiter(entry.label)) return;\n    let hasSubstantiveMatch = false;\n    for (let j = 0; j < normalized.length; j += 1) {\n      if (j === idx) continue;\n      const other = normalized[j];\n      if (!other.name || other.name.length < 4) continue;\n      if (!entry.label.includes(other.name)) continue;\n      if (isSubstantiveItem(other.item)) {\n        hasSubstantiveMatch = true;\n        break;\n      }\n    }\n    if (hasSubstantiveMatch) {\n      removeIndices.add(idx);\n    }\n  });\n  if (removeIndices.size === 0) return { items, removed: 0 };\n  const filtered = items.filter((_, idx) => !removeIndices.has(idx));\n  return { items: filtered, removed: removeIndices.size };\n};\n\nconst itemsResultIsInvalid = (items: any[] | null | undefined, requireMultiple: boolean): boolean => {\n  if (!Array.isArray(items) || items.length === 0) return true;\n  if (looksLikeSingleGenericItem(items) || looksLikeMultiIngredientSummary(items)) return true;\n  if (requireMultiple && items.length < 2) return true;\n  return false;\n};\n\nconst splitAnalysisIntoComponents = (analysis: string | null | undefined): string[] => {\n  if (!analysis) return [];\n  const cleaned = analysis.replace(/\\s+/g, ' ').trim();\n  if (!cleaned) return [];\n  const parts = cleaned\n    .split(/(?:,| and | with | plus | & )/gi)\n    .map((p) => p.trim())\n    .filter((p) => p.length >= 3);\n  const unique: string[] = [];\n  for (const p of parts) {\n    const lower = p.toLowerCase();\n    if (!unique.some((u) => u.toLowerCase() === lower)) {\n      unique.push(p);\n    }\n    if (unique.length >= 4) break;\n  }\n  return unique;\n};\n\nconst looksLikeNonFoodArtifact = (nameRaw: any): boolean => {\n  const name = String(nameRaw || '').trim();\n  if (!name) return true;\n  if (name.length > 140) return true;\n\n  const lower = name.toLowerCase();\n  // JSON/metadata artifacts accidentally parsed into items\n  if (lower.includes('<items_json') || lower.includes('</items_json')) return true;\n  if (name.includes('{') || name.includes('}') || name.includes('\"')) return true;\n  if (/^\\s*[\\[\\]\\{\\}]+\\s*$/.test(name)) return true;\n  if (/^\\s*[a-z_]+\\s*:\\s*.+$/i.test(name)) return true;\n  if (/^\\s*\"(?:brand|serving_size|servings|calories|protein_g|carbs_g|fat_g|fiber_g|sugar_g)\"\\s*:/i.test(name)) return true;\n  if (/^\\s*(?:brand|serving_size|servings|calories|protein_g|carbs_g|fat_g|fiber_g|sugar_g)\\s*:/i.test(name)) return true;\n  if (/^\\s*\\d+\\s*\"(?:calories|protein|carbs|fat|fiber|sugar)/i.test(name)) return true;\n\n  // Reject lines that are basically just numbers/symbols\n  if (!/[a-z]/i.test(name)) return true;\n\n  return false;\n};\n\nconst sanitizeStructuredItems = (items: any[]): any[] => {\n  if (!Array.isArray(items)) return [];\n  const cleaned = items\n    .filter((it) => it && typeof it === 'object')\n    .map((it) => ({\n      ...it,\n      name: typeof it.name === 'string' ? it.name.trim() : '',\n    }))\n    .filter((it) => it.name && !looksLikeNonFoodArtifact(it.name));\n\n  // Prevent runaway lists from exploding the UI\n  return cleaned.length > 10 ? cleaned.slice(0, 10) : cleaned;\n};\n\nconst buildMultiComponentFallback = (\n  analysis: string | null | undefined,\n  total: any | null | undefined,\n): { items: any[]; total: any | null } => {\n  const baseNames = splitAnalysisIntoComponents(analysis);\n  while (baseNames.length < 2) {\n    baseNames.push(baseNames.length === 0 ? 'Component 1' : `Component ${baseNames.length + 1}`);\n  }\n  const count = baseNames.length;\n  const pick = (key: keyof typeof total) => {\n    const val = total && typeof total[key] === 'number' ? Number(total[key]) : null;\n    return Number.isFinite(val) && val !== null ? Math.max(0, val) / count : null;\n  };\n  const items = baseNames.map((name) => ({\n    name,\n    brand: null,\n    serving_size: '1 serving',\n    servings: 1,\n    // Leave macros blank so the UI does not equal-split totals; mark as guesses.\n    calories: null,\n    protein_g: null,\n    carbs_g: null,\n    fat_g: null,\n    fiber_g: null,\n    sugar_g: null,\n    isGuess: true,\n  }));\n  const synthesizedTotal =\n    total && typeof total === 'object' ? total : computeTotalsFromItems(items) || null;\n  return { items, total: synthesizedTotal };\n};\n\n// Initialize OpenAI client only when API key is available\n// Updated: 2025-06-26 - Ensure environment variable is properly loaded\nconst getOpenAIClient = () => {\n  if (!process.env.OPENAI_API_KEY) {\n    return null;\n  }\n  return new OpenAI({\n    apiKey: process.env.OPENAI_API_KEY,\n  });\n};\n\nexport async function POST(req: NextRequest) {\n  try {\n    console.log('=== FOOD ANALYZER DEBUG START ===');\n    let imageHash: string | null = null;\n    let imageDataUrl: string | null = null;\n    let imageMeta: ReturnType<typeof getImageMetadata> | null = null;\n    let imageBytes: number | null = null;\n    let imageMime: string | null = null;\n    \n    // Check authentication - pass request headers for proper session resolution\n    const session = await getServerSession(authOptions);\n    let userEmail: string | null = session?.user?.email ?? null;\n    let usedTokenFallback = false;\n\n    // Some recent route-handler changes made getServerSession unreliable for this endpoint.\n    // Safeguard the analyzer by grabbing the JWT directly if the normal session lookup fails.\n    if (!userEmail) {\n      try {\n        const token = await getToken({\n          req,\n          secret: process.env.NEXTAUTH_SECRET || process.env.AUTH_SECRET || 'helfi-secret-key-production-2024',\n        });\n        if (token?.email) {\n          userEmail = token.email as string;\n          usedTokenFallback = true;\n        }\n      } catch (tokenError) {\n        console.error('Failed to read JWT token for food analyzer auth:', tokenError);\n      }\n    }\n\n    console.log('Session check:', { hasSession: !!session, hasEmail: !!userEmail, usedTokenFallback });\n    if (!userEmail) {\n      console.error('‚ùå Authentication failed - no valid session');\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n    }\n\n    const normalizedEmail = userEmail.trim().toLowerCase();\n\n    const findOrCreateUser = async (includeRelations: any = { subscription: true }): Promise<any> => {\n      try {\n        const existing = await prisma.user.findUnique({\n          where: { email: normalizedEmail },\n          include: includeRelations,\n        });\n        if (existing) return existing;\n\n        console.warn('‚ö†Ô∏è Food analyzer could not find user record. Auto-creating placeholder record for', normalizedEmail);\n        await prisma.user.create({\n          data: {\n            email: normalizedEmail,\n            name: session?.user?.name || normalizedEmail.split('@')[0],\n            emailVerified: new Date(),\n          },\n        });\n\n        return await prisma.user.findUnique({\n          where: { email: normalizedEmail },\n          include: includeRelations,\n        });\n      } catch (creationError) {\n        console.error('‚ùå Failed to find or create user for food analyzer:', creationError);\n        return null;\n      }\n    };\n\n    // Find user\n    const user = await findOrCreateUser({ subscription: true });\n\n    if (user?.id) {\n      logServerCall({\n        feature: 'foodAnalysis',\n        endpoint: '/api/analyze-food',\n        kind: 'analysis',\n      }).catch((error) => {\n        console.error('‚ùå Failed to log food analysis call:', error);\n      });\n    }\n\n    if (!user) {\n      return NextResponse.json({ error: 'User not found' }, { status: 404 });\n    }\n\n    let allergySettings: { allergies: string[]; diabetesType?: string } = { allergies: [], diabetesType: '' };\n    try {\n      const storedAllergies = await prisma.healthGoal.findFirst({\n        where: { userId: user.id, name: '__ALLERGIES_DATA__' },\n      });\n      if (storedAllergies?.category) {\n        const parsed = JSON.parse(storedAllergies.category);\n        allergySettings = {\n          allergies: Array.isArray(parsed?.allergies)\n            ? parsed.allergies.filter((a: any) => typeof a === 'string' && a.trim().length > 0)\n            : [],\n          diabetesType: typeof parsed?.diabetesType === 'string' ? parsed.diabetesType : '',\n        };\n      }\n    } catch (error) {\n      console.warn('‚ö†Ô∏è Could not load allergy settings for analyzer:', error);\n    }\n\n    let dietTypes: string[] = []\n    try {\n      const storedDiet = await prisma.healthGoal.findFirst({\n        where: { userId: user.id, name: '__DIET_PREFERENCE__' },\n      })\n      if (storedDiet?.category) {\n        const parsed = JSON.parse(storedDiet.category)\n        const raw = Array.isArray(parsed?.dietTypes) ? parsed.dietTypes : parsed?.dietType\n        dietTypes = normalizeDietTypes(raw)\n      }\n    } catch (error) {\n      console.warn('‚ö†Ô∏è Could not load diet preference for analyzer:', error)\n    }\n\n    // We'll check free use, premium, or credits below\n    let creditManager: CreditManager | null = null;\n    \n    // Check if API key is configured\n    if (!process.env.OPENAI_API_KEY) {\n      console.log('‚ùå OpenAI API key not configured');\n      return NextResponse.json(\n        { error: 'OpenAI API key not configured' },\n        { status: 500 }\n      );\n    }\n    \n    console.log('‚úÖ OpenAI API key configured');\n\n    // Quick rate limit to stop accidental loops or repeated triggers\n    const clientIp = (req.headers.get('x-forwarded-for') || '').split(',')[0]?.trim() || 'unknown';\n    const rateKey = user.id ? `user:${user.id}` : `ip:${clientIp}`;\n    const rateCheck = await consumeRateLimit('food-analyzer', rateKey, RATE_LIMIT_MAX_REQUESTS, RATE_LIMIT_WINDOW_MS);\n    if (!rateCheck.allowed) {\n      const retryAfter = Math.max(1, Math.ceil(rateCheck.retryAfterMs / 1000));\n      return NextResponse.json(\n        { error: 'Too many analyses in a short period. Please wait and try again.' },\n        { status: 429, headers: { 'Retry-After': String(retryAfter) } }\n      );\n    }\n\n    const contentType = req.headers.get('content-type');\n    console.log('üìù Content-Type:', contentType);\n    let messages: any[] = [];\n    // Backward-compatible enhancement flags\n    // Default ON for best accuracy\n    let wantStructured = true; // when true, we also return items[] and totals\n    let preferMultiDetect = true; // default ON: detect multiple foods without changing output line\n    let analysisMode: 'auto' | 'packaged' | 'meal' = 'auto';\n    let packagedMode = false;\n    let labelScan = false;\n    let forceFresh = false;\n    let packagedEmphasisBlock = '';\n    let analysisHint = '';\n    let feedbackDown = false;\n    let feedbackReasons: string[] = [];\n    let feedbackMissing = false;\n    let feedbackItems: string[] = [];\n\n    const setAnalysisMode = (modeRaw: any) => {\n      const normalized = String(modeRaw || 'auto').toLowerCase();\n      if (normalized === 'packaged' || normalized === 'meal') {\n        analysisMode = normalized as 'packaged' | 'meal';\n      } else {\n        analysisMode = 'auto';\n      }\n      packagedMode = analysisMode === 'packaged';\n      packagedEmphasisBlock = packagedMode\n        ? `\nPACKAGED MODE SELECTED:\n- Use ONLY the per-serving column from the nutrition label (ignore per-100g values).\n- Always read the first column that lists \"Quantity per serving\" (or similar).\n- Copy the per-serving numbers verbatim (calories, protein, carbs, fat, fiber, sugar) and the printed serving size.\n- If you cannot read the per-serve numbers clearly, set calories/protein/carbs/fat/fiber/sugar to null (do not guess).\n- Do NOT scale from per-100g to per-serving; do NOT \"correct\" the label.\n- Keep serving_size as written on the label and set servings to 1 by default (user will adjust).`\n        : '';\n    };\n\n    let isReanalysis = false;\n    if (contentType?.includes('application/json')) {\n      // Handle text-based food analysis\n      const body = await req.json();\n      const {\n        textDescription,\n        foodType,\n        isReanalysis: reFlag,\n        returnItems,\n        multi,\n        analysisMode: bodyMode,\n        labelScan: labelScanFlag,\n        forceFresh: forceFreshFlag,\n        analysisHint: bodyHint,\n      } = body as any;\n      isReanalysis = !!reFlag;\n      // Default to true unless explicitly disabled\n      wantStructured = returnItems !== undefined ? !!returnItems : true;\n      preferMultiDetect = multi !== undefined ? !!multi : true;\n      setAnalysisMode(bodyMode);\n      labelScan = Boolean(labelScanFlag);\n      forceFresh = Boolean(forceFreshFlag);\n      analysisHint = typeof bodyHint === 'string' ? bodyHint : '';\n      feedbackReasons = parseFeedbackList((body as any)?.feedbackReasons);\n      feedbackDown = Boolean((body as any)?.feedbackDown) || feedbackReasons.length > 0;\n      feedbackMissing =\n        Boolean((body as any)?.feedbackMissing) ||\n        feedbackReasons.some((reason) => /missing ingredients/i.test(String(reason)));\n      feedbackItems = sanitizeFeedbackItems(parseFeedbackList((body as any)?.feedbackItems));\n      console.log('üìù Text analysis mode:', { textDescription, foodType });\n\n      if (!textDescription) {\n        return NextResponse.json(\n          { error: 'No food description provided' },\n          { status: 400 }\n        );\n      }\n\n      const cleanedHint = String(analysisHint || '').trim();\n      const hintBlock =\n        cleanedHint && !packagedMode\n          ? `\\nUSER HINT (optional): ${cleanedHint}\\n- Use this only to disambiguate a tricky item.\\n- Do NOT ignore other foods mentioned in the description.\\n- Do NOT invent items that are not described.\\n`\n          : '';\n      const feedbackBlock = feedbackDown\n        ? `\\nFEEDBACK (user reported issues): ${\n            feedbackReasons.length ? feedbackReasons.join(', ') : 'Thumbs down'\n          }\\n${feedbackMissing ? '- Missing ingredients were reported. Re-check for small sides, sauces, and toppings.\\n' : ''}${\n            feedbackItems.length\n              ? `- Previously detected items (include if described/visible, and add anything missing): ${feedbackItems.join(\n                  ', ',\n                )}.\\n`\n              : ''\n          }- Ensure the final Components line includes every item you list.\\n`\n        : '';\n\n      messages = [\n        {\n          role: \"user\",\n          content: `Analyze this food description and provide accurate nutrition information based on the EXACT portion size specified. Be precise about size differences.${hintBlock}${feedbackBlock}\n\nCRITICAL FOR MEALS WITH MULTIPLE COMPONENTS:\n- If the description mentions multiple distinct foods (e.g., plate with protein, vegetables, grains, salads, soups, stews, sandwiches with multiple fillings, bowls with toppings), you MUST:\n  1. Identify EACH component separately\n  2. Estimate portion size for EACH component accurately\n  3. Calculate nutrition for EACH component individually\n  4. Sum all components to provide TOTAL nutrition values\n  5. List components briefly in your description\n\n- For complex meals, be thorough: don't miss side dishes, condiments, dressings, or toppings mentioned\n- Estimate portions realistically based on the description\n- Only use pieces when a clear count is stated; otherwise use grams/servings (if the count is 1, still write it explicitly, e.g., \"1 egg\")\n- If unsure about a component, estimate conservatively but include it in your totals\n- For mixed dishes (salads, soups, stews), break down the main ingredients and sum them\n\nPACKAGED / BRANDED FOODS (VERY IMPORTANT):\n- First, decide if this describes a packaged or branded product (box, bag, packet, bottle, can, branded rolls/bread/cereal, etc.).\n- If it is packaged and a NUTRITION LABEL is mentioned, treat that label as the SINGLE SOURCE OF TRUTH for calories, protein, carbs, fat, fiber and sugar.\n- Do NOT \"re-estimate\" or adjust the numbers away from the label just because the portion looks small or large ‚Äì copy the label values faithfully.\n- If the description includes both \"Per serving\" and \"Per 100 g\", use the \"Per serving\" values and the serving size wording from the label (e.g. \"1 roll (60g)\").\n- For branded items, put the product brand in the \"brand\" field (e.g. \"Tip Top\", \"Heinz\") and the generic food name in \"name\" (e.g. \"Hot dog roll\").\n- For packets with multiple identical units (e.g. 6 hot dog rolls), nutrition in ITEMS_JSON for EACH ITEM should be PER ONE ROLL by default with \"servings\": 1 (the app will multiply when the user eats more than one).\n- If the text clearly says the person ate multiple units (e.g. \"2 hot dog rolls\"), keep the serving_size as on the label (per 1 roll) and set \"servings\" accordingly (e.g. 2).\n${packagedEmphasisBlock}\n\nKeep your explanation concise (2-3 sentences). After the explanation, include a single line exactly in this format:\nComponents: component 1, component 2, component 3\n- Use plain ingredient names only (no quantities).\n- Include every distinct component you mentioned or can see.\n- Even for a single-item meal, include one component.\n- Do not use placeholders like \"component 1\" in the final output.\nThen include a single nutrition line at the end in this exact format:\n\nCalories: [number], Protein: [g], Carbs: [g], Fat: [g]\n\n[Food name/meal description] ([total portion size])\n\nFood description: ${textDescription}\nFood type: ${foodType}\n\n${preferMultiDetect ? `The description likely contains multiple foods or components - analyze each one carefully, calculate nutrition for each, then sum the totals.\n` : ''}\n\nIMPORTANT: Different sizes have different nutrition values:\n- Large egg: ~70 calories, 6g protein\n- Medium egg: ~55 calories, 5g protein  \n- Small egg: ~45 calories, 4g protein\n\nCRITICAL STRUCTURED OUTPUT RULES:\n- ALWAYS return the ITEMS_JSON block and include fiber_g and sugar_g for each item (do not leave as 0 unless truly 0).\n- Use household measures and add ounce equivalents in parentheses where appropriate (e.g., \"1 cup (8 oz)\").\n- Item \"name\" must be the plain ingredient name only (e.g., \"grilled salmon\", \"white rice\"). Do NOT prefix names with \"several components:\", \"components:\", \"meal:\", etc.\n- Do NOT treat weights as counts: \"8 oz\" means weight, NOT \"8 pieces\". Never prefix an item name with a weight number.\n- Only use pieces when a clear count is stated/visible; otherwise use weight/serving size.\n- For foods like fries, wedges, rice, pasta, and salads: use weight/serving, not pieces.\n- For sliced produce (e.g., avocado slices, tomato slices, cucumber slices): treat it as a PORTION (weight/servings), not a discrete piece count. Prefer a grams estimate or a fraction of the whole food (e.g., \"1/4 avocado\") and set isGuess: true if uncertain.\n- If uncertain about a count, choose a conservative (lower) number and mark isGuess: true.\n\nExamples:\n\"Medium banana (1 whole)\nCalories: 105, Protein: 1g, Carbs: 27g, Fat: 0g\"\n\n\"Grilled chicken breast (6 oz) with brown rice (1 cup) and steamed broccoli (1 cup)\nCalories: 485, Protein: 45g, Carbs: 45g, Fat: 8g\"\n\nPay close attention to portion size words like small, medium, large, or specific measurements. For meals, sum all components. Calculate nutrition accordingly. End your response with the nutrition line exactly once as shown.\n${wantStructured ? `\nAfter your explanation and the one-line totals above, also include a compact JSON block between <ITEMS_JSON> and </ITEMS_JSON> with this exact shape for any detected foods:\n<ITEMS_JSON>{\"items\":[{\"name\":\"string\",\"brand\":\"string or null\",\"serving_size\":\"string (e.g., '1 slice', '2 patties', '40g', '1 cup (8 oz)')\",\"servings\":1,\"calories\":0,\"protein_g\":0,\"carbs_g\":0,\"fat_g\":0,\"fiber_g\":0,\"sugar_g\":0,\"isGuess\":false}],\"total\":{\"calories\":0,\"protein_g\":0,\"carbs_g\":0,\"fat_g\":0,\"fiber_g\":0,\"sugar_g\":0}}</ITEMS_JSON>\n\nCRITICAL REQUIREMENTS:\n- For packaged foods: ALWAYS extract the brand name if visible (e.g., \"Burgen\", \"Heinz\", \"Nestle\"). Set to null if not visible or not applicable.\n- For packaged foods: ALWAYS extract the serving size from the label (e.g., \"1 slice\", \"2 cookies\", \"100g\", \"1 cup\"). This is the DEFAULT serving size per package.\n- Set \"servings\" to 1 as the default (user can adjust this in the UI).\n- For multi-item meals: Create separate items for each distinct food component.\n- Include ONLY components explicitly mentioned in the description. Do NOT invent typical sides/toppings.\n- If you mention a component in the description, it MUST appear in ITEMS_JSON (no exceptions).\n- Set \"isGuess\": true only when the description implies an item but is ambiguous.\n- **Set \"isGuess\": false only for items you can clearly identify with high confidence.**\n- **Only use pieces for discrete items when the count is clearly visible/stated (e.g., \"2 patties\"). Otherwise use grams/serving and leave pieces out.**\n- Do not use \"pieces\" semantics for sliced produce; use portion/grams as described above.\n- Nutrition values should be PER SERVING (not total) for each item.\n- The \"total\" object should sum all items multiplied by their servings.\n` : ''}`\n        }\n      ];\n    } else {\n      // Handle image-based food analysis\n      console.log('üñºÔ∏è Image analysis mode');\n      \n      const formData = await req.formData();\n      const imageFile = formData.get('image') as File;\n      setAnalysisMode(formData.get('analysisMode'));\n      labelScan = String(formData.get('labelScan') || '') === '1';\n      forceFresh = String(formData.get('forceFresh') || '') === '1';\n      analysisHint = String(formData.get('analysisHint') || '');\n      feedbackReasons = parseFeedbackList(formData.get('feedbackReasons'));\n      feedbackDown = String(formData.get('feedbackDown') || '') === '1' || feedbackReasons.length > 0;\n      feedbackMissing =\n        String(formData.get('feedbackMissing') || '') === '1' ||\n        feedbackReasons.some((reason) => /missing ingredients/i.test(String(reason)));\n      feedbackItems = sanitizeFeedbackItems(parseFeedbackList(formData.get('feedbackItems')));\n      \n      console.log('üìä Image file info:', {\n        hasImageFile: !!imageFile,\n        name: imageFile?.name || 'none',\n        type: imageFile?.type || 'none',\n        size: imageFile?.size || 0\n      });\n\n      if (!imageFile) {\n        console.log('‚ùå No image file provided');\n        return NextResponse.json(\n          { error: 'No image file provided' },\n          { status: 400 }\n        );\n      }\n\n      // Convert image to base64\n      console.log('üîÑ Converting image to base64...');\n      const imageBuffer = await imageFile.arrayBuffer();\n      const imageBase64 = Buffer.from(imageBuffer).toString('base64');\n      imageMeta = getImageMetadata(imageBuffer);\n      imageDataUrl = `data:${imageFile.type};base64,${imageBase64}`;\n      const baseHash = crypto.createHash('sha256').update(Buffer.from(imageBuffer)).digest('hex');\n      imageHash = forceFresh ? `${baseHash}-${Date.now()}` : baseHash;\n      imageBytes = imageBuffer.byteLength;\n      imageMime = imageFile.type || null;\n      \n      console.log('‚úÖ Image conversion complete:', {\n        bufferSize: imageBuffer.byteLength,\n        base64Length: imageBase64.length,\n        dataUrlPrefix: imageDataUrl.substring(0, 50) + '...',\n        imageHash\n      });\n\n      // For image analysis, request structured items and multi-detect by default\n      wantStructured = true;\n      preferMultiDetect = true;\n\n      const cleanedHint = String(analysisHint || '').trim();\n      const hintBlock =\n        cleanedHint && !packagedMode\n          ? `\\nUSER HINT (optional): ${cleanedHint}\\n- Use this only to disambiguate a tricky item.\\n- Do NOT ignore other visible foods.\\n- Do NOT invent foods not visible in the photo.\\n`\n          : '';\n      const feedbackBlock = feedbackDown\n        ? `\\nFEEDBACK (user reported issues): ${\n            feedbackReasons.length ? feedbackReasons.join(', ') : 'Thumbs down'\n          }\\n${feedbackMissing ? '- Missing ingredients were reported. Re-check for small sides, sauces, and toppings.\\n' : ''}${\n            feedbackItems.length\n              ? `- Previously detected items (include if visible, and add anything missing): ${feedbackItems.join(', ')}.\\n`\n              : ''\n          }- Ensure the final Components line includes every item you list.\\n`\n        : '';\n\n      messages = [\n        {\n          role: \"user\",\n          content: [\n            {\n              type: \"text\",\n              text: `Analyze this food image and provide accurate nutrition information based on the visible portion size. Be precise about size differences.${hintBlock}${feedbackBlock}\n\nCRITICAL FOR MEALS WITH MULTIPLE COMPONENTS:\n- If the image contains multiple distinct foods (e.g., plate with protein, vegetables, grains, salads, soups, stews, sandwiches with multiple fillings, bowls with toppings), you MUST:\n  1. Identify EACH component separately\n  2. Estimate portion size for EACH component accurately\n  3. Calculate nutrition for EACH component individually\n  4. Sum all components to provide TOTAL nutrition values\n  5. List components briefly in your description\n\n- Only include foods you can actually SEE in the photo. Do NOT assume common sides (e.g., fries) unless they are clearly visible.\n- Estimate portions realistically based on what's visible in the image (only count pieces when the count is clearly visible).\n- If something is unclear, prefer leaving it out OR include a generic label (e.g., \"dipping sauce\") and set isGuess: true.\n- For mixed dishes (salads, soups, stews), break down the main ingredients and sum them\n\nDo NOT infer meal patterns. Only list components supported by visible evidence in the photo.\n\nPORTION CUES:\n- Use plate size, utensil size, and hand-size cues to estimate grams or household measures\n- Do not double count overlapping items; base your estimate on visible evidence\n- Ignore inedible items. Only include a drink if clearly visible as part of the meal\n\nPACKAGED / BRANDED FOODS (VERY IMPORTANT):\n- First, decide if the photo shows a packaged or branded product (box, bag, packet, bottle, can, bread or rolls in a bag, cereal box, etc.).\n- If any NUTRITION LABEL is visible on the front, back or side of the packaging, you MUST treat the label as the PRIMARY source of nutrition values.\n- Mentally zoom in and carefully read the serving size and PER-SERVING values from the label; copy those numbers exactly into the item‚Äôs calories, protein_g, carbs_g, fat_g, fiber_g and sugar_g.\n- If both \"Per serving\" and \"Per 100 g\" are shown, use the \"Per serving\" values and the printed serving size wording (e.g. \"1 roll (60g)\", \"2 crackers (20g)\").\n- Do NOT invent or \"correct\" the label; if the label looks surprising, still trust it over your own visual estimate.\n- Put the brand name from the packaging (e.g. \"Tip Top\", \"Heinz\") into the \"brand\" field and a generic food name into \"name\" (e.g. \"Hot dog roll\", \"Wholemeal bread slice\").\n- For packets with multiple identical units (e.g. 6 hot dog rolls), nutrition in ITEMS_JSON for EACH ITEM should be PER ONE UNIT by default with \"servings\": 1. If the person clearly ate multiple units, keep serving_size as the label‚Äôs per-unit portion and adjust \"servings\" (e.g. 2 rolls eaten -> servings: 2).\n${packagedEmphasisBlock}\n\nCRITICAL STRUCTURED OUTPUT RULES:\n- ALWAYS return the ITEMS_JSON block and include fiber_g and sugar_g for each item (do not leave as 0 unless truly 0).\n- Use household measures and add ounce equivalents in parentheses where appropriate (e.g., \"1 cup (8 oz)\").\n- Item \"name\" must be the plain ingredient name only (e.g., \"grilled salmon\", \"white rice\"). Do NOT prefix names with \"several components:\", \"components:\", \"meal:\", etc.\n- Only use pieces when a clear count is visible/stated; otherwise use grams/serving size.\n- If the count is 1, still write it explicitly (e.g., \"1 egg\").\n- For foods like fries, wedges, rice, pasta, and salads: use weight/serving, not pieces.\n- For sliced produce (e.g., avocado slices, tomato slices, cucumber slices): treat it as a PORTION (weight/servings), not a discrete piece count. Prefer a grams estimate or a fraction of the whole food (e.g., \"1/4 avocado\") and set isGuess: true if uncertain.\n- If uncertain about a count, choose a conservative (lower) number and mark isGuess: true.\n- **CRITICAL: Use REALISTIC nutrition values based on standard food databases (USDA, nutrition labels, etc.). Do NOT underestimate calories or macros.**\n- **Self-check before finalizing:** Sum all item macros and ensure they roughly match the headline Calories/Protein/Carbs/Fat line. If they don‚Äôt, adjust per-item macros (not the total) so the sum is realistic. Burgers with bun + 2 patties + cheese + bacon should land roughly 900‚Äì1100 kcal; a single patty ~200‚Äì300 kcal, cheese slice ~80‚Äì120 kcal, bacon slice ~40‚Äì50 kcal.\n\nREALISTIC NUTRITION REFERENCE VALUES (use these as guidance for accurate analysis):\n\nPROTEINS (cooked unless noted):\n- Chicken breast (6 oz / 170g): ~280 calories, 54g protein, 0g carbs, 6g fat\n- Chicken thigh (3 oz): ~180 calories, 22g protein, 0g carbs, 9g fat\n- Ground beef 80/20 (6 oz cooked): ~400 calories, 30g protein, 0g carbs, 30g fat\n- Ground beef 90/10 (6 oz cooked): ~300 calories, 35g protein, 0g carbs, 15g fat\n- Salmon fillet (6 oz): ~350 calories, 40g protein, 0g carbs, 18g fat\n- Tuna steak (6 oz): ~250 calories, 50g protein, 0g carbs, 2g fat\n- Pork chop (6 oz): ~350 calories, 40g protein, 0g carbs, 18g fat\n- Large egg: ~70 calories, 6g protein, 0.5g carbs, 5g fat\n- Bacon (cooked, 2 slices): ~80 calories, 6g protein, 0g carbs, 7g fat\n- Sausage link (pork, cooked): ~150 calories, 7g protein, 1g carbs, 13g fat\n\nCARBOHYDRATES:\n- White rice (cooked, 1 cup): ~220 calories, 4g protein, 45g carbs, 0.5g fat\n- Brown rice (cooked, 1 cup): ~220 calories, 5g protein, 46g carbs, 2g fat\n- Pasta (cooked, 1 cup): ~220 calories, 8g protein, 43g carbs, 1g fat\n- White bread slice: ~80 calories, 2g protein, 15g carbs, 1g fat\n- Whole wheat bread slice: ~80 calories, 4g protein, 15g carbs, 1g fat\n- Burger bun (sesame): ~150 calories, 5g protein, 28g carbs, 3g fat\n- Potato (medium, baked): ~160 calories, 4g protein, 37g carbs, 0g fat\n- Sweet potato (medium, baked): ~180 calories, 4g protein, 41g carbs, 0g fat\n- Oats (cooked, 1 cup): ~150 calories, 6g protein, 27g carbs, 3g fat\n\nDAIRY:\n- Cheese slice (American/Cheddar): ~100 calories, 6g protein, 1g carbs, 9g fat\n- Mozzarella (1 oz): ~80 calories, 6g protein, 1g carbs, 6g fat\n- Milk whole (1 cup): ~150 calories, 8g protein, 12g carbs, 8g fat\n- Milk 2% (1 cup): ~120 calories, 8g protein, 12g carbs, 5g fat\n- Greek yogurt (1 cup): ~150 calories, 20g protein, 9g carbs, 4g fat\n- Butter (1 tbsp): ~100 calories, 0g protein, 0g carbs, 11g fat\n\nVEGETABLES (cooked unless raw):\n- Broccoli (1 cup): ~55 calories, 4g protein, 11g carbs, 0.5g fat\n- Spinach (1 cup cooked): ~40 calories, 5g protein, 7g carbs, 0g fat\n- Carrots (1 cup): ~50 calories, 1g protein, 12g carbs, 0g fat\n- Green beans (1 cup): ~40 calories, 2g protein, 9g carbs, 0g fat\n- Bell pepper (1 medium): ~30 calories, 1g protein, 7g carbs, 0g fat\n- Tomato (1 medium): ~25 calories, 1g protein, 5g carbs, 0g fat\n- Lettuce (1 cup shredded): ~5 calories, 0.5g protein, 1g carbs, 0g fat\n- Onion (1 medium): ~45 calories, 1g protein, 11g carbs, 0g fat\n\nFRUITS:\n- Medium banana: ~105 calories, 1g protein, 27g carbs, 0.4g fat\n- Apple (medium): ~95 calories, 0.5g protein, 25g carbs, 0.3g fat\n- Orange (medium): ~60 calories, 1g protein, 15g carbs, 0g fat\n- Berries (1 cup mixed): ~80 calories, 1g protein, 20g carbs, 0.5g fat\n- Avocado (1 medium): ~240 calories, 3g protein, 13g carbs, 22g fat\n\nFATS & CONDIMENTS:\n- Olive oil (1 tbsp): ~120 calories, 0g protein, 0g carbs, 14g fat\n- Mayonnaise (1 tbsp): ~100 calories, 0g protein, 0g carbs, 11g fat\n- Salad dressing (2 tbsp): ~120 calories, 0g protein, 2g carbs, 12g fat\n- Ketchup (1 tbsp): ~15 calories, 0g protein, 4g carbs, 0g fat\n- Mustard (1 tbsp): ~5 calories, 0g protein, 1g carbs, 0g fat\n\nCOMMON MEAL COMPONENTS:\n- Pizza slice (cheese, 1/8 of 14\"): ~250 calories, 12g protein, 30g carbs, 10g fat\n- Tortilla wrap (large): ~150 calories, 4g protein, 25g carbs, 4g fat\n- Noodles (ramen, cooked): ~190 calories, 4g protein, 27g carbs, 7g fat\n- Soup (chicken noodle, 1 cup): ~75 calories, 4g protein, 7g carbs, 3g fat\n\n**ACCURACY REQUIREMENTS:**\n- **For burgers: Two beef patties (4-6oz each) should total 400-700 calories for the patties alone. A complete burger with bun + 2 patties + cheese + bacon + condiments should total 900-1100 calories.**\n- A typical burger with bun + 6oz patty + cheese + bacon should total 600-900 calories, NOT 40-50 calories\n- Always cross-check your totals: if a meal looks substantial, the calories should reflect that\n- If your calculated total seems too low, re-check each component's nutrition values\n- Use standard serving sizes and realistic nutrition databases\n- **When counting discrete items (patties, slices, nuggets), use realistic per-item values:**\n  - Beef patty (4oz cooked): 200-300 calories per patty\n  - Cheese slice: 80-120 calories per slice\n  - Bacon slice (cooked): 40-50 calories per slice\n  - If you are unsure and it is not clearly visible, omit it (do not invent it).\n\nOUTPUT REQUIREMENTS:\n- Keep explanation to 2-3 sentences\n- ALWAYS end with a single nutrition line in this exact format:\n\nKeep your explanation concise (2-3 sentences). After the explanation, include a single line exactly in this format:\nComponents: component 1, component 2, component 3\n- Use plain ingredient names only (no quantities).\n- Include every distinct component you mentioned or can see.\n- Even for a single-item meal, include one component.\n- Do not use placeholders like \"component 1\" in the final output.\nThen include a single nutrition line at the end in this exact format:\n\nCalories: [number], Protein: [g], Carbs: [g], Fat: [g]\n\n[Food name/meal description] ([total portion size])\n\n${preferMultiDetect ? `The image likely contains multiple foods or components - analyze each one carefully, calculate nutrition for each, then sum the totals.\n` : ''}\n\nExamples with REALISTIC values:\n\"Medium banana (1 whole)\nCalories: 105, Protein: 1g, Carbs: 27g, Fat: 0g\"\n\n\"Grilled chicken breast (6 oz) with brown rice (1 cup) and steamed broccoli (1 cup)\nCalories: 485, Protein: 45g, Carbs: 45g, Fat: 8g\"\n\n\"Caesar salad with grilled chicken (large)\nCalories: 520, Protein: 35g, Carbs: 18g, Fat: 32g\"\n\n\"Burger with bun, 6oz beef patty, cheese, bacon, lettuce, tomato\nCalories: 780, Protein: 47g, Carbs: 29g, Fat: 49g\"\n\nEstimate portion size carefully from the image and calculate nutrition accordingly using REALISTIC values. For meals, sum all components. End your response with the nutrition line exactly once as shown.\n${wantStructured ? `\nAfter your explanation and the one-line totals above, also include a compact JSON block between <ITEMS_JSON> and </ITEMS_JSON> with this exact shape for any detected foods:\n<ITEMS_JSON>{\"items\":[{\"name\":\"string\",\"brand\":\"string or null\",\"serving_size\":\"string (e.g., '1 slice', '2 patties', '40g', '1 cup (8 oz)')\",\"servings\":1,\"calories\":0,\"protein_g\":0,\"carbs_g\":0,\"fat_g\":0,\"fiber_g\":0,\"sugar_g\":0,\"isGuess\":false}],\"total\":{\"calories\":0,\"protein_g\":0,\"carbs_g\":0,\"fat_g\":0,\"fiber_g\":0,\"sugar_g\":0}}</ITEMS_JSON>\n\nCRITICAL REQUIREMENTS:\n- For packaged foods: ALWAYS extract the brand name if visible (e.g., \"Burgen\", \"Heinz\", \"Nestle\"). Set to null if not visible or not applicable.\n- For packaged foods: ALWAYS extract the serving size from the label (e.g., \"1 slice\", \"2 cookies\", \"100g\", \"1 cup\"). This is the DEFAULT serving size per package.\n- Set \"servings\" to 1 as the default (user can adjust this in the UI).\n- For multi-item meals: Create separate items for each distinct food component.\n- Include ONLY foods/components you can see in the photo. Do NOT add \"typical\" sides.\n- If you mention a component in the description, it MUST appear in ITEMS_JSON (no exceptions).\n- Set \"isGuess\": true only for ambiguous items that are still visible (e.g., an unknown dipping sauce).\n- **Set \"isGuess\": false only for items you can clearly see and identify with high confidence.**\n- **Only use pieces for discrete items when the count is clearly visible/stated (e.g., \"2 patties\"). Otherwise use grams/serving and leave pieces out.**\n- Do not use \"pieces\" semantics for sliced produce; use portion/grams as described above.\n- Nutrition values should be PER SERVING (not total) for each item.\n- The \"total\" object should sum all items multiplied by their servings.\n` : ''}`\n            },\n            {\n              type: \"image_url\",\n              image_url: {\n                url: imageDataUrl,\n                detail: \"high\"\n              }\n            }\n          ]\n        }\n      ];\n    }\n\n    // PREMIUM/CREDITS/FREE USE GATING\n    const currentUser = await findOrCreateUser({ subscription: true, creditTopUps: true });\n    if (!currentUser) {\n      return NextResponse.json({ error: 'User not found' }, { status: 404 });\n    }\n\n    const isPremium = isSubscriptionActive(currentUser.subscription);\n    \n    // Check if user has purchased credits (non-expired)\n    const now = new Date();\n    const hasPurchasedCredits = currentUser.creditTopUps.some(\n      (topUp: any) => topUp.expiresAt > now && (topUp.amountCents - topUp.usedCents) > 0\n    );\n    \n    // Check if user has free credits remaining\n    const hasFreeFoodCredits = await hasFreeCredits(currentUser.id, 'FOOD_ANALYSIS');\n    const hasFreeFoodReanalysisCredits = await hasFreeCredits(currentUser.id, 'FOOD_REANALYSIS');\n    \n    // Billing is now stable again ‚Äì enforce credit checks for Food Analysis.\n    // This controls wallet pre-checks and charges; free credits are consumed first.\n    const BILLING_ENFORCED = true;\n\n    // Allow if: Premium subscription OR has purchased credits OR has free credits remaining\n    let allowViaFreeUse = false;\n    if (!isPremium && !hasPurchasedCredits) {\n      if (isReanalysis) {\n        if (hasFreeFoodReanalysisCredits) {\n          allowViaFreeUse = true;\n        } else if (BILLING_ENFORCED) {\n          return NextResponse.json(\n            { \n              error: 'Payment required',\n              message: 'You\\'ve used all your free food re-analyses. Subscribe to a monthly plan or purchase credits to continue.',\n              requiresPayment: true,\n              exhaustedFreeCredits: true\n            },\n            { status: 402 }\n          );\n        }\n      } else if (hasFreeFoodCredits) {\n        // Has free credits - allow free use\n        allowViaFreeUse = true;\n      } else if (BILLING_ENFORCED) {\n        // No subscription, no credits, and no free credits - require payment\n        return NextResponse.json(\n          { \n            error: 'Payment required',\n            message: 'You\\'ve used all your free food analyses. Subscribe to a monthly plan or purchase credits to continue.',\n            requiresPayment: true,\n            exhaustedFreeCredits: true\n          },\n          { status: 402 }\n        );\n      }\n    }\n\n    const lastReset = currentUser.lastAnalysisResetDate;\n    const shouldReset = !lastReset || (now.getTime() - lastReset.getTime()) > 24*60*60*1000;\n    if (shouldReset) {\n      await prisma.user.update({\n        where: { id: currentUser.id },\n        data: ( {\n          dailyAnalysisUsed: 0,\n          dailyFoodAnalysisUsed: 0,\n          dailyFoodReanalysisUsed: 0,\n          lastAnalysisResetDate: now,\n        } as any )\n      });\n      (currentUser as any).dailyFoodAnalysisUsed = 0 as any;\n      (currentUser as any).dailyFoodReanalysisUsed = 0 as any;\n    }\n\n    // Daily gating removed ‚Äì wallet pre-check happens below (trial still allowed)\n\n    // Get OpenAI client\n    const openai = getOpenAIClient();\n    if (!openai) {\n      console.log('‚ùå Failed to create OpenAI client');\n      return NextResponse.json(\n        { error: 'OpenAI API key not configured' },\n        { status: 500 }\n      );\n    }\n\n    // Main food model selection.\n    // Default is env-controlled; admin can set a per-user override via __FOOD_ANALYZER_MODEL__.\n    // Temperature is set to 0 for maximum consistency between runs on the same meal.\n    const envModelRaw = (process.env.OPENAI_FOOD_MODEL || '').trim()\n    const defaultModel = imageDataUrl ? 'gpt-4o' : (envModelRaw || 'gpt-5.2')\n    let model = defaultModel\n    try {\n      const goal = await prisma.healthGoal.findFirst({\n        where: { userId: currentUser.id, name: '__FOOD_ANALYZER_MODEL__' },\n        select: { category: true },\n      })\n      if (goal?.category) {\n        const parsed = JSON.parse(goal.category)\n        const override = typeof parsed?.model === 'string' ? parsed.model.trim() : ''\n        const isGeminiOverride =\n          override.startsWith('gemini-') && Boolean(imageDataUrl) && !packagedMode && !labelScan\n        if (isGeminiOverride || override === 'gpt-4o' || override === 'gpt-5.2') {\n          model = override\n        }\n      }\n    } catch (e) {\n      console.warn('Food analyzer model override lookup failed (non-fatal):', e)\n    }\n    const useGeminiVision =\n      Boolean(imageDataUrl) && !packagedMode && !labelScan && model.startsWith('gemini-')\n\n    let maxTokens = feedbackDown ? 800 : 600;\n\n    // Wallet pre-check (skip if allowed via free use OR billing checks are disabled)\n    if (BILLING_ENFORCED && !allowViaFreeUse) {\n      const cm = new CreditManager(currentUser.id);\n      const promptText = Array.isArray(messages)\n        ? messages\n            .map((m: any) => {\n              if (!m?.content) return '';\n              if (typeof m.content === 'string') return m.content;\n              if (Array.isArray(m.content)) {\n                return m.content\n                  .map((p: any) => (typeof p?.text === 'string' ? p.text : ''))\n                  .join('\\n');\n              }\n              return '';\n            })\n            .join('\\n')\n        : '';\n      const wallet = await cm.getWalletStatus();\n      const cappedMaxTokens = capMaxTokensToBudget(model, promptText, maxTokens, wallet.totalAvailableCents);\n      if (cappedMaxTokens <= 0) {\n        return NextResponse.json({ error: 'Insufficient credits' }, { status: 402 });\n      }\n      maxTokens = cappedMaxTokens;\n    }\n\n    // Pre-charge a minimal credit immediately upon analysis start (skip for free trial\n    // or when billing checks are disabled)\n    let prechargedCents = 0;\n    if (BILLING_ENFORCED && !allowViaFreeUse) {\n      try {\n        const cm = new CreditManager(currentUser.id);\n        const immediate = CREDIT_COSTS.FOOD_ANALYSIS; // fixed price upfront\n        const okPre = await cm.chargeCents(immediate);\n        if (!okPre) {\n          return NextResponse.json({ error: 'Insufficient credits' }, { status: 402 });\n        }\n        prechargedCents = immediate;\n      } catch (e) {\n        console.warn('Immediate pre-charge failed:', e);\n        return NextResponse.json({ error: 'Billing error' }, { status: 402 });\n      }\n    }\n\n    console.log('ü§ñ Calling food analysis model:', {\n      provider: useGeminiVision ? 'Gemini' : 'OpenAI',\n      model,\n      messageCount: messages.length,\n      hasImageContent: messages[0]?.content && Array.isArray(messages[0].content)\n    });\n\n    const runOpenAICompletion = async (params: any) => chatCompletionWithCost(openai, params);\n\n    const runVisionCompletion = async (params: any) => {\n      if (!useGeminiVision) {\n        return runOpenAICompletion(params);\n      }\n      const apiKey = (process.env.GEMINI_API_KEY || '').trim();\n      if (!apiKey) {\n        console.warn('GEMINI_API_KEY missing; falling back to OpenAI for vision.');\n        return runOpenAICompletion({ ...params, model: 'gpt-4o' });\n      }\n      const promptText = extractPromptTextFromMessages(params.messages || []);\n      const maxOutputTokens = Number(params.max_tokens ?? params.max_completion_tokens ?? maxTokens);\n      return runGeminiVisionCompletion({\n        apiKey,\n        model,\n        promptText,\n        imageDataUrl: imageDataUrl as string,\n        maxOutputTokens,\n        temperature: typeof params.temperature === 'number' ? params.temperature : 0,\n        responseMimeType: params.responseMimeType,\n      });\n    };\n\n    // Call food analysis model (metered)\n    const runCompletion = async (runModel: string) =>\n      runVisionCompletion({\n        model: runModel,\n        messages,\n        ...(runModel.toLowerCase().includes('gpt-5')\n          ? { max_completion_tokens: maxTokens }\n          : { max_tokens: maxTokens }),\n        temperature: 0,\n      } as any);\n\n    const extractAnalysisText = (completion: any): string | null => {\n      const c = completion?.choices?.[0]?.message?.content;\n      if (typeof c === 'string') {\n        const trimmed = c.trim();\n        return trimmed.length ? trimmed : null;\n      }\n      // Defensive: some SDK variants may return segmented content; join text parts.\n      if (Array.isArray(c)) {\n        const joined = c\n          .map((part: any) => (typeof part?.text === 'string' ? part.text : ''))\n          .join('')\n          .trim();\n        return joined.length ? joined : null;\n      }\n      return null;\n    };\n\n    const primary = await runCompletion(model);\n    let response = primary.completion;\n\n    if (imageDataUrl) {\n      logAiUsageEvent({\n        feature: isReanalysis ? 'food:image-reanalysis' : 'food:image-analysis',\n        userId: currentUser.id || null,\n        userLabel: currentUser.email || null,\n        scanId: imageHash ? `food-${imageHash.slice(0, 8)}` : `food-${Date.now()}`,\n        model,\n        promptTokens: primary.promptTokens,\n        completionTokens: primary.completionTokens,\n        costCents: primary.costCents,\n        image: {\n          width: imageMeta?.width ?? null,\n          height: imageMeta?.height ?? null,\n          bytes: imageBytes,\n          mime: imageMime,\n        },\n        endpoint: '/api/analyze-food',\n        success: true,\n      }).catch(() => {});\n    } else {\n      logAiUsageEvent({\n        feature: isReanalysis ? 'food:text-reanalysis' : 'food:text-analysis',\n        userId: currentUser.id || null,\n        userLabel: currentUser.email || null,\n        scanId: `food-${Date.now()}`,\n        model,\n        promptTokens: primary.promptTokens,\n        completionTokens: primary.completionTokens,\n        costCents: primary.costCents,\n        endpoint: '/api/analyze-food',\n        success: true,\n      }).catch(() => {});\n    }\n\n    console.log('üìã Model Response:', {\n      hasResponse: !!response,\n      hasChoices: !!response.choices,\n      choicesLength: response.choices?.length || 0,\n      hasContent: !!response.choices?.[0]?.message?.content\n    });\n\n    let analysis = extractAnalysisText(response);\n    let totalCostCents = primary.costCents;\n\n    // Rare but real: models sometimes return a completion object with no content.\n    // To avoid showing the user a blank \"failed\" screen, retry once and then fall\n    // back to gpt-4o for image analysis if needed.\n    if (!analysis) {\n      try {\n        console.warn('‚ö†Ô∏è Model returned empty content; retrying once...');\n        const retry = await runCompletion(model);\n        totalCostCents += retry.costCents;\n        response = retry.completion;\n        analysis = extractAnalysisText(response);\n      } catch (retryErr) {\n        console.warn('Retry attempt failed (non-fatal):', retryErr);\n      }\n    }\n\n    if (!analysis && imageDataUrl) {\n      if (useGeminiVision) {\n        try {\n          console.warn('‚ö†Ô∏è Empty content after retry; falling back to gpt-4o for image analysis...');\n          const fallback = await runOpenAICompletion({\n            model: 'gpt-4o',\n            messages,\n            max_tokens: maxTokens,\n            temperature: 0,\n          } as any);\n          totalCostCents += fallback.costCents;\n          response = fallback.completion;\n          analysis = extractAnalysisText(response);\n          logAiUsageEvent({\n            feature: 'food:image-analysis-fallback',\n            userId: currentUser.id || null,\n            userLabel: currentUser.email || null,\n            scanId: imageHash ? `food-${imageHash.slice(0, 8)}` : `food-${Date.now()}`,\n            model: 'gpt-4o',\n            promptTokens: fallback.promptTokens,\n            completionTokens: fallback.completionTokens,\n            costCents: fallback.costCents,\n            image: {\n              width: imageMeta?.width ?? null,\n              height: imageMeta?.height ?? null,\n              bytes: imageBytes,\n              mime: imageMime,\n            },\n            endpoint: '/api/analyze-food',\n            success: true,\n          }).catch(() => {});\n        } catch (fallbackErr) {\n          console.warn('gpt-4o fallback attempt failed (non-fatal):', fallbackErr);\n        }\n      } else if (model !== 'gpt-4o') {\n        try {\n          console.warn('‚ö†Ô∏è Empty content after retry; falling back to gpt-4o for image analysis...');\n          const fallback = await runCompletion('gpt-4o');\n          totalCostCents += fallback.costCents;\n          response = fallback.completion;\n          analysis = extractAnalysisText(response);\n          logAiUsageEvent({\n            feature: 'food:image-analysis-fallback',\n            userId: currentUser.id || null,\n            userLabel: currentUser.email || null,\n            scanId: imageHash ? `food-${imageHash.slice(0, 8)}` : `food-${Date.now()}`,\n            model: 'gpt-4o',\n            promptTokens: fallback.promptTokens,\n            completionTokens: fallback.completionTokens,\n            costCents: fallback.costCents,\n            image: {\n              width: imageMeta?.width ?? null,\n              height: imageMeta?.height ?? null,\n              bytes: imageBytes,\n              mime: imageMime,\n            },\n            endpoint: '/api/analyze-food',\n            success: true,\n          }).catch(() => {});\n        } catch (fallbackErr) {\n          console.warn('gpt-4o fallback attempt failed (non-fatal):', fallbackErr);\n        }\n      }\n    }\n\n    if (!analysis) {\n      console.log('‚ùå No analysis received from model');\n      return NextResponse.json(\n        { error: 'No analysis received from model' },\n        { status: 500 }\n      );\n    }\n\n    console.log('‚úÖ Analysis received:', analysis.substring(0, 200) + '...');\n    console.log('‚úÖ Analysis received:', analysis.substring(0, 200) + '...');\n\n    // Server-side safeguard: ensure nutrition line is present so frontend cards render reliably\n    const hasCalories = /calories\\s*[:\\-]?\\s*\\d+/i.test(analysis);\n    const hasProtein = /protein\\s*[:\\-]?\\s*\\d+(?:\\.\\d+)?\\s*g/i.test(analysis);\n    const hasCarbs = /carb(?:ohydrate)?s?\\s*[:\\-]?\\s*\\d+(?:\\.\\d+)?\\s*g/i.test(analysis);\n    const hasFat = /fat\\s*[:\\-]?\\s*\\d+(?:\\.\\d+)?\\s*g/i.test(analysis);\n\n    if (!(hasCalories && hasProtein && hasCarbs && hasFat)) {\n      const fallbackLine = 'Calories: unknown, Protein: unknown, Carbs: unknown, Fat: unknown';\n      analysis = `${analysis}\\n${fallbackLine}`;\n      console.log('‚ÑπÔ∏è Nutrition line missing; appended static fallback to avoid extra AI calls');\n    }\n    \n    // Note: Charging happens after health compatibility check to include all costs\n\n    // Consume free credit if this was a free use\n    if (allowViaFreeUse) {\n      await consumeFreeCredit(currentUser.id, isReanalysis ? 'FOOD_REANALYSIS' : 'FOOD_ANALYSIS');\n    }\n    // Update counters (for all users, not just premium)\n    await prisma.user.update({\n      where: { id: currentUser.id },\n      data: ( isReanalysis ? {\n        dailyFoodReanalysisUsed: { increment: 1 },\n        totalAnalysisCount: { increment: 1 },\n      } : {\n        dailyFoodAnalysisUsed: { increment: 1 },\n        totalFoodAnalysisCount: { increment: 1 },\n        totalAnalysisCount: { increment: 1 },\n        monthlyFoodAnalysisUsed: { increment: 1 },\n      } ) as any\n    });\n    \n    console.log('=== FOOD ANALYZER DEBUG END ===');\n\n    const resp: any = {\n      success: true,\n      analysis: analysis.trim(),\n    };\n    const isImageAnalysis = Boolean(imageDataUrl);\n    let itemsSource: string = 'none';\n    let itemsQuality: 'valid' | 'weak' | 'none' = 'none';\n    let analysisTextForFollowUp = analysis;\n    let listedComponents: string[] = [];\n    let analysisComponents: string[] = [];\n    let analysisLooksMulti = false;\n    let componentsHint = '';\n    let componentsRequirement = '';\n    let componentBoundApplied = false;\n    if (wantStructured) {\n      try {\n        const m = analysis.match(/<ITEMS_JSON>([\\s\\S]*?)<\\/ITEMS_JSON>/i);\n        if (m && m[1]) {\n          // Some model variants wrap the JSON payload in ```json fences even\n          // inside our <ITEMS_JSON>...</ITEMS_JSON> tag. Strip those wrappers\n          // before attempting relaxed JSON parsing so we don't silently drop\n          // otherwise valid ingredient data.\n          const rawBlock = m[1].trim();\n          const cleanedBlock = rawBlock\n            .replace(/```json/gi, '')\n            .replace(/```/g, '')\n            .trim();\n          const parsed = parseItemsJsonRelaxed(cleanedBlock);\n          if (parsed) {\n            const parsedItems = Array.isArray(parsed)\n              ? parsed\n              : Array.isArray((parsed as any).items)\n              ? (parsed as any).items\n              : [];\n            const parsedTotal =\n              !Array.isArray(parsed) && typeof (parsed as any).total === 'object'\n                ? (parsed as any).total\n                : null;\n            if (parsedItems.length > 0) {\n              // Use the parsed items/total directly; do not overwrite them with fallback/default items\n              resp.items = sanitizeStructuredItems(parsedItems);\n              resp.total = parsedTotal || computeTotalsFromItems(resp.items) || null;\n              itemsSource = 'items_json';\n              itemsQuality = validateStructuredItems(resp.items) ? 'valid' : 'weak';\n            }\n          }\n          // Always strip the ITEMS_JSON block to avoid UI artifacts, even if parsing failed\n          resp.analysis = resp.analysis.replace(m[0], '').trim();\n        }\n      } catch (e) {\n        console.warn('ITEMS_JSON handling failed (non-fatal):', e);\n      }\n\n      analysisTextForFollowUp = resp.analysis || analysis;\n      listedComponents = extractComponentsFromAnalysis(analysisTextForFollowUp);\n      analysisComponents = extractComponentsFromDelimitedText(analysisTextForFollowUp);\n      if (listedComponents.length === 0 && analysisComponents.length > 0) {\n        listedComponents = analysisComponents;\n      }\n      listedComponents = normalizeComponentList(listedComponents);\n      analysisComponents = normalizeComponentList(analysisComponents);\n      const feedbackComponents = normalizeComponentList(feedbackItems);\n      if (feedbackComponents.length > 0) {\n        listedComponents = normalizeComponentList([...listedComponents, ...feedbackComponents]);\n        analysisComponents = normalizeComponentList([...analysisComponents, ...feedbackComponents]);\n      }\n      if (\n        listedComponents.length === 0 &&\n        resp.items &&\n        looksLikeMultiIngredientSummary(resp.items)\n      ) {\n        const summaryLabel = `${resp.items?.[0]?.name || ''} ${resp.items?.[0]?.serving_size || ''}`;\n        listedComponents = extractComponentsFromDelimitedText(summaryLabel);\n        listedComponents = normalizeComponentList(listedComponents);\n      }\n      analysisLooksMulti =\n        analysisComponents.length > 1 || (resp.items ? looksLikeMultiIngredientSummary(resp.items) : false);\n      componentsHint =\n        listedComponents.length > 0\n          ? `- Components list (include each as its own item): ${listedComponents.join(', ')}.\\n`\n          : '';\n      const requiredComponentCount = Math.max(listedComponents.length, analysisComponents.length);\n      componentsRequirement =\n        requiredComponentCount > 1 ? `- Return at least ${requiredComponentCount} items.\\n` : '';\n\n      // If the main analysis did not contain a usable ITEMS_JSON block, make a\n      // compact follow-up call whose ONLY job is to produce structured items\n      // so the UI can render editable ingredient cards. This is text-only and\n      // only runs when the first call missed items.\n      if (\n        !isImageAnalysis &&\n        (!resp.items || resp.items.length === 0) &&\n        analysisTextForFollowUp.length > 0\n      ) {\n        try {\n          console.log('‚ÑπÔ∏è No ITEMS_JSON found, running lightweight items extractor (text-only)');\n          const extractor = await chatCompletionWithCost(openai, {\n            model: 'gpt-4o-mini',\n            messages: [\n              {\n                role: 'user',\n                content:\n                  'Convert the nutrition analysis text below into JSON with this exact shape:\\n' +\n                  '{\"items\":[{\"name\":\"string\",\"brand\":null,\"serving_size\":\"string\",\"servings\":1,\"calories\":0,\"protein_g\":0,\"carbs_g\":0,\"fat_g\":0,\"fiber_g\":0,\"sugar_g\":0}],' +\n                  '\"total\":{\"calories\":0,\"protein_g\":0,\"carbs_g\":0,\"fat_g\":0,\"fiber_g\":0,\"sugar_g\":0}}\\n' +\n                  componentsHint +\n                  componentsRequirement +\n                  '- Use realistic per-serving values based on the analysis.\\n' +\n                  '- If unsure about fiber or sugar, set them to 0.\\n' +\n                  '- Respond with JSON only, no backticks.\\n\\n' +\n                  'Analysis text:\\n' +\n                  analysisTextForFollowUp,\n              },\n            ],\n            max_tokens: 360,\n            temperature: 0,\n          } as any);\n          logAiUsageEvent({\n            feature: 'food:items-extractor',\n            userId: currentUser.id || null,\n            userLabel: currentUser.email || null,\n            scanId: imageHash ? `food-${imageHash.slice(0, 8)}` : `food-${Date.now()}`,\n            model: 'gpt-4o-mini',\n            promptTokens: extractor.promptTokens,\n            completionTokens: extractor.completionTokens,\n            costCents: extractor.costCents,\n            endpoint: '/api/analyze-food',\n            success: true,\n          }).catch(() => {});\n          totalCostCents += extractor.costCents;\n          const text = extractor.completion.choices?.[0]?.message?.content?.trim() || '';\n          const cleaned =\n            text\n              .replace(/```json/gi, '')\n              .replace(/```/g, '')\n              .trim() || '';\n          const parsed = cleaned ? parseItemsJsonRelaxed(cleaned) : null;\n          if (parsed) {\n            const items = Array.isArray(parsed)\n              ? parsed\n              : Array.isArray((parsed as any).items)\n              ? (parsed as any).items\n              : [];\n            const total =\n              !Array.isArray(parsed) && typeof (parsed as any).total === 'object'\n                ? (parsed as any).total\n                : null;\n            if (items.length > 0) {\n              resp.items = sanitizeStructuredItems(items);\n              resp.total = total || computeTotalsFromItems(resp.items) || resp.total || null;\n              itemsSource = itemsSource === 'none' ? 'text_extractor' : `${itemsSource}+text_extractor`;\n              itemsQuality = validateStructuredItems(resp.items) ? 'valid' : 'weak';\n              console.log('‚úÖ Structured items extracted via follow-up call:', {\n                itemCount: items.length,\n              });\n              if (listedComponents.length === 0 && looksLikeMultiIngredientSummary(resp.items)) {\n                const summaryLabel = `${resp.items?.[0]?.name || ''} ${resp.items?.[0]?.serving_size || ''}`;\n                listedComponents = extractComponentsFromDelimitedText(summaryLabel);\n                componentsHint =\n                  listedComponents.length > 0\n                    ? `- Components list (include each as its own item): ${listedComponents.join(', ')}.\\n`\n                    : componentsHint;\n                componentsRequirement =\n                  listedComponents.length > 1\n                    ? `- Return at least ${listedComponents.length} items.\\n`\n                    : componentsRequirement;\n              }\n            }\n          }\n        } catch (e) {\n          console.warn('ITEMS_JSON extractor follow-up failed (non-fatal):', e);\n        }\n\n        // If we still have no items, synthesize multiple editable items so cards stay separate.\n        if (!resp.items || resp.items.length === 0) {\n          const caloriesMatch = analysisTextForFollowUp.match(/calories\\s*[:\\-]?\\s*(\\d+)/i);\n          const proteinMatch = analysisTextForFollowUp.match(/protein\\s*[:\\-]?\\s*(\\d+(?:\\.\\d+)?)\\s*g/i);\n          const carbsMatch = analysisTextForFollowUp.match(/carbs?\\s*[:\\-]?\\s*(\\d+(?:\\.\\d+)?)\\s*g/i);\n          const fatMatch = analysisTextForFollowUp.match(/fat\\s*[:\\-]?\\s*(\\d+(?:\\.\\d+)?)\\s*g/i);\n          const baseTotal =\n            resp.total ||\n            computeTotalsFromItems([\n              {\n                calories: caloriesMatch ? Number(caloriesMatch[1]) : null,\n                protein_g: proteinMatch ? Number(proteinMatch[1]) : null,\n                carbs_g: carbsMatch ? Number(carbsMatch[1]) : null,\n                fat_g: fatMatch ? Number(fatMatch[1]) : null,\n                fiber_g: 0,\n                sugar_g: 0,\n              },\n            ]) ||\n            null;\n\n          if (preferMultiDetect && !packagedMode) {\n            if (!STRICT_AI_ONLY_ITEMS) {\n              const fallback = buildMultiComponentFallback(analysisTextForFollowUp, baseTotal);\n              resp.items = fallback.items;\n              resp.total = fallback.total;\n              console.log('‚ÑπÔ∏è Using multi-item fallback to avoid single-card UI');\n            } else {\n              resp.total = baseTotal || resp.total || null;\n              console.warn('‚ö†Ô∏è Strict AI-only mode: no fallback cards created when items are missing.');\n            }\n          } else if (!STRICT_AI_ONLY_ITEMS) {\n            const fallbackItem = {\n              name: 'Meal',\n              brand: null,\n              serving_size: '1 serving',\n              servings: 1,\n              calories: caloriesMatch ? Number(caloriesMatch[1]) : null,\n              protein_g: proteinMatch ? Number(proteinMatch[1]) : null,\n              carbs_g: carbsMatch ? Number(carbsMatch[1]) : null,\n              fat_g: fatMatch ? Number(fatMatch[1]) : null,\n              fiber_g: 0,\n              sugar_g: 0,\n            };\n            resp.items = [fallbackItem];\n            resp.total = baseTotal || computeTotalsFromItems(resp.items) || null;\n            console.log('‚ÑπÔ∏è Using fallback single-item card to keep editor usable (packaged/explicit single)');\n          } else {\n            resp.total = baseTotal || resp.total || null;\n            console.warn('‚ö†Ô∏è Strict AI-only mode: no fallback cards created for packaged/single cases.');\n          }\n        }\n      }\n    }\n\n    // For photo analyses with a clear component list, force a component-bound\n    // vision follow-up so we always return one card per ingredient.\n    if (wantStructured && preferMultiDetect && isImageAnalysis && listedComponents.length > 1) {\n      const needsComponentBound =\n        !resp.items ||\n        resp.items.length === 0 ||\n        looksLikeSingleGenericItem(resp.items) ||\n        looksLikeMultiIngredientSummary(resp.items) ||\n        resp.items.length < listedComponents.length;\n      if (needsComponentBound) {\n        try {\n          console.warn('‚ö†Ô∏è Analyzer: running component-bound vision follow-up.');\n          const componentBoundPrompt =\n            'Return JSON only. Use the component list and output exactly one item per component.\\n' +\n            'You must include ALL components and no extras.\\n' +\n            'Each item name must be the plain ingredient name for that component.\\n' +\n            '- Do NOT default every item to \"100 g\". Use realistic, different portions based on the photo.\\n' +\n            '- Prefer household measures with optional grams in parentheses (e.g., \"1 fillet (150 g)\", \"3/4 cup cooked rice (150 g)\", \"1/4 avocado (50 g)\", \"1/3 cup cucumber slices (40 g)\").\\n' +\n            '- If you cannot estimate grams, use a household portion without grams (e.g., \"1 fillet\", \"1/2 cup\").\\n' +\n            'Component list:\\n' +\n            listedComponents.map((c) => `- ${c}`).join('\\n') +\n            '\\n\\nUse the image as the primary source of truth. Analysis text is supplemental:\\n' +\n            analysisTextForFollowUp;\n          const componentBoundMessages = [\n            {\n              role: 'user',\n              content: [\n                { type: 'text', text: componentBoundPrompt },\n                { type: 'image_url', image_url: { url: imageDataUrl, detail: 'high' } },\n              ],\n            },\n          ];\n\n          let componentBound: any = null;\n          if (useGeminiVision) {\n            componentBound = await runVisionCompletion({\n              model,\n              messages: componentBoundMessages,\n              max_tokens: 420,\n              temperature: 0,\n              responseMimeType: 'application/json',\n            } as any);\n          } else {\n            try {\n              componentBound = await chatCompletionWithCost(openai, {\n                model: 'gpt-4o',\n                response_format: {\n                  type: 'json_schema',\n                  json_schema: buildComponentBoundSchema(listedComponents),\n                } as any,\n                messages: componentBoundMessages,\n                max_tokens: 420,\n                temperature: 0,\n              } as any);\n            } catch (schemaErr) {\n              console.warn('Component-bound schema follow-up failed; retrying with json_object.', schemaErr);\n              componentBound = await chatCompletionWithCost(openai, {\n                model: 'gpt-4o',\n                response_format: { type: 'json_object' } as any,\n                messages: componentBoundMessages,\n                max_tokens: 420,\n                temperature: 0,\n              } as any);\n            }\n          }\n\n          if (componentBound?.completion) {\n            totalCostCents += componentBound.costCents;\n            const text = componentBound.completion.choices?.[0]?.message?.content?.trim() || '';\n            const cleaned = text.replace(/```json/gi, '').replace(/```/g, '').trim();\n            const parsed = cleaned ? parseItemsJsonRelaxed(cleaned) : null;\n            if (parsed) {\n              const items = Array.isArray((parsed as any).items) ? (parsed as any).items : [];\n              const total = typeof (parsed as any).total === 'object' ? (parsed as any).total : null;\n              const normalizedComponents = listedComponents.map((c) => normalizeComponentName(c));\n              const itemsByComponent = items.filter((item: any) => {\n                const key = normalizeComponentName(item?.component || item?.name || '');\n                return key && normalizedComponents.includes(key);\n              });\n              const orderedItems = normalizedComponents\n                .map((comp, idx) => {\n                  const item = itemsByComponent.find(\n                    (candidate: any) =>\n                      normalizeComponentName(candidate?.component || candidate?.name || '') === comp,\n                  );\n                  if (!item) return null;\n                  const next = { ...item };\n                  delete (next as any).component;\n                  if (!next.name) next.name = listedComponents[idx];\n                  return next;\n                })\n                .filter(Boolean) as any[];\n\n              const requireMultiple = listedComponents.length > 1;\n              if (orderedItems.length === listedComponents.length && !itemsResultIsInvalid(orderedItems, requireMultiple)) {\n                resp.items = sanitizeStructuredItems(orderedItems);\n                resp.total = total || computeTotalsFromItems(resp.items) || resp.total || null;\n                itemsSource = itemsSource === 'none' ? 'component_bound' : `${itemsSource}+component_bound`;\n                itemsQuality = validateStructuredItems(resp.items) ? 'valid' : 'weak';\n                componentBoundApplied = true;\n                console.log('‚úÖ Component-bound follow-up produced items:', resp.items.length);\n              }\n            }\n          }\n        } catch (componentErr) {\n          console.warn('Component-bound vision follow-up failed (non-fatal):', componentErr);\n        }\n      }\n    }\n\n    // If we still don't have meaningful per-component items (or only a generic \"Meal\" card)\n    // but the prompt was multi-detect capable, run a lightweight structure-only pass to\n    // force separate components. This keeps the ingredient cards usable when the primary\n    // model skips ITEMS_JSON.\n    const missingFromList =\n      listedComponents.length > 1 &&\n      resp.items &&\n      Array.isArray(resp.items) &&\n      resp.items.length < listedComponents.length;\n    if (\n      wantStructured &&\n      preferMultiDetect &&\n      !componentBoundApplied &&\n      (!resp.items ||\n        resp.items.length === 0 ||\n        looksLikeSingleGenericItem(resp.items) ||\n        looksLikeMultiIngredientSummary(resp.items) ||\n        missingFromList)\n    ) {\n      try {\n        console.warn('‚ö†Ô∏è Analyzer: generic/missing/summary items detected; running multi-item follow-up.');\n        console.log('‚ÑπÔ∏è Enforcing multi-item breakdown via structure-only follow-up');\n        const hintTotal = resp.total || computeTotalsFromItems(resp.items || []) || null;\n        const followUpPrompt =\n          'Split this meal description into separate ingredients/components and return JSON only with this shape:\\n' +\n          '{\"items\":[{\"name\":\"string\",\"brand\":null,\"serving_size\":\"string\",\"servings\":1,\"calories\":0,\"protein_g\":0,\"carbs_g\":0,\"fat_g\":0,\"fiber_g\":0,\"sugar_g\":0}],\"total\":{\"calories\":0,\"protein_g\":0,\"carbs_g\":0,\"fat_g\":0,\"fiber_g\":0,\"sugar_g\":0}}\\n' +\n          componentsHint +\n          componentsRequirement +\n          '- Use realistic per-serving values for EACH component (eggs, bacon, bagel, juice, etc).\\n' +\n          '- Keep servings to 1 by default and use household measures (\"1 slice\", \"1 cup\", \"1 egg\").\\n' +\n          '- Do not collapse everything into a single \"Meal\" item. Return 1 item per distinct component.\\n' +\n          '- Do NOT default every item to \"100 g\". Use different portion sizes based on the photo.\\n' +\n          '- Prefer household measures with optional grams in parentheses.\\n' +\n          (imageDataUrl ? '- Use the image as the primary source of truth; the analysis text is supplemental.\\n' : '') +\n          (hintTotal\n            ? `- Keep totals roughly consistent with Calories ${hintTotal.calories ?? 'unknown'} / Protein ${\n                hintTotal.protein_g ?? 'unknown'\n              }g / Carbs ${hintTotal.carbs_g ?? 'unknown'}g / Fat ${hintTotal.fat_g ?? 'unknown'}g.\\n`\n            : '') +\n          '\\nAnalysis text:\\n' +\n          analysisTextForFollowUp;\n        const followUpModel = imageDataUrl ? (useGeminiVision ? model : 'gpt-4o') : 'gpt-4o-mini';\n        const followUpMessages = imageDataUrl\n          ? [\n              {\n                role: 'user',\n                content: [\n                  { type: 'text', text: followUpPrompt },\n                  { type: 'image_url', image_url: { url: imageDataUrl, detail: 'high' } },\n                ],\n              },\n            ]\n          : [\n              {\n                role: 'user',\n                content: followUpPrompt,\n              },\n            ];\n        const followUp =\n          imageDataUrl && useGeminiVision\n            ? await runVisionCompletion({\n                model: followUpModel,\n                messages: followUpMessages,\n                max_tokens: 360,\n                temperature: 0,\n                responseMimeType: 'application/json',\n              } as any)\n            : await chatCompletionWithCost(openai, {\n                model: followUpModel,\n                response_format: { type: 'json_object' } as any,\n                messages: followUpMessages,\n                max_tokens: 360,\n                temperature: 0,\n              } as any);\n\n        totalCostCents += followUp.costCents;\n        const text = followUp.completion.choices?.[0]?.message?.content?.trim() || '';\n        const cleaned = text.replace(/```json/gi, '').replace(/```/g, '').trim();\n        const parsed = cleaned ? parseItemsJsonRelaxed(cleaned) : null;\n        if (parsed) {\n          const items = Array.isArray(parsed)\n            ? parsed\n            : Array.isArray((parsed as any).items)\n            ? (parsed as any).items\n            : [];\n          const total =\n            !Array.isArray(parsed) && typeof (parsed as any).total === 'object'\n              ? (parsed as any).total\n              : null;\n          const requiresMultiple = listedComponents.length > 1 || analysisLooksMulti;\n          const hasEnoughItems = requiresMultiple ? items.length > 1 : items.length > 0;\n          if (hasEnoughItems && !looksLikeSingleGenericItem(items) && !looksLikeMultiIngredientSummary(items)) {\n            resp.items = sanitizeStructuredItems(items);\n            resp.total = total || computeTotalsFromItems(resp.items) || resp.total || null;\n            const sourceLabel = imageDataUrl ? 'vision_multi_followup' : 'multi_followup';\n            itemsSource = itemsSource === 'none' ? sourceLabel : `${itemsSource}+${sourceLabel}`;\n            itemsQuality = validateStructuredItems(resp.items) ? 'valid' : 'weak';\n            console.log('‚úÖ Multi-item follow-up produced structured items:', items.length);\n          }\n        }\n      } catch (multiErr) {\n        console.warn('Multi-item follow-up failed (non-fatal):', multiErr);\n      }\n    }\n\n    // Final safety net for image analyses: if we still have no usable items,\n    // force a structured follow-up using the image + analysis text.\n    if (\n      wantStructured &&\n      isImageAnalysis &&\n      !packagedMode &&\n      (!resp.items ||\n        resp.items.length === 0 ||\n        looksLikeSingleGenericItem(resp.items) ||\n        looksLikeMultiIngredientSummary(resp.items))\n    ) {\n      try {\n        const forcedComponents = normalizeComponentList(\n          listedComponents.length > 1\n            ? listedComponents\n            : extractComponentsFromDelimitedText(analysisTextForFollowUp),\n        );\n        const requireMultiple = forcedComponents.length > 1 || analysisLooksMulti;\n        const forcedHint =\n          forcedComponents.length > 0\n            ? `- Components list (include each as its own item): ${forcedComponents.join(', ')}.\\n`\n            : '';\n        const forcedRequirement = requireMultiple ? `- Return at least ${Math.max(forcedComponents.length, 2)} items.\\n` : '';\n        const forcedPrompt =\n          'Return JSON only with this shape:\\n' +\n          '{\"items\":[{\"name\":\"string\",\"brand\":null,\"serving_size\":\"string\",\"servings\":1,\"calories\":0,\"protein_g\":0,\"carbs_g\":0,\"fat_g\":0,\"fiber_g\":0,\"sugar_g\":0}],' +\n          '\"total\":{\"calories\":0,\"protein_g\":0,\"carbs_g\":0,\"fat_g\":0,\"fiber_g\":0,\"sugar_g\":0}}\\n' +\n          forcedHint +\n          forcedRequirement +\n          '- Use the image as the primary source of truth.\\n' +\n          '- Do NOT return a single summary item for a multi-ingredient meal.\\n' +\n          '- Use realistic per-serving values for each ingredient.\\n' +\n          '\\nAnalysis text:\\n' +\n          analysisTextForFollowUp;\n        console.warn('‚ö†Ô∏è Analyzer: forcing structured image follow-up (items missing).');\n        const forcedFollowUp = useGeminiVision\n          ? await runVisionCompletion({\n              model,\n              messages: [\n                {\n                  role: 'user',\n                  content: [\n                    { type: 'text', text: forcedPrompt },\n                    { type: 'image_url', image_url: { url: imageDataUrl, detail: 'high' } },\n                  ],\n                },\n              ],\n              max_tokens: 420,\n              temperature: 0,\n              responseMimeType: 'application/json',\n            } as any)\n          : await chatCompletionWithCost(openai, {\n              model: 'gpt-4o',\n              response_format: { type: 'json_object' } as any,\n              messages: [\n                {\n                  role: 'user',\n                  content: [\n                    { type: 'text', text: forcedPrompt },\n                    { type: 'image_url', image_url: { url: imageDataUrl, detail: 'high' } },\n                  ],\n                },\n              ],\n              max_tokens: 420,\n              temperature: 0,\n            } as any);\n\n        totalCostCents += forcedFollowUp.costCents;\n        const text = forcedFollowUp.completion.choices?.[0]?.message?.content?.trim() || '';\n        const cleaned = text.replace(/```json/gi, '').replace(/```/g, '').trim();\n        const parsed = cleaned ? parseItemsJsonRelaxed(cleaned) : null;\n        if (parsed) {\n          const items = Array.isArray(parsed)\n            ? parsed\n            : Array.isArray((parsed as any).items)\n            ? (parsed as any).items\n            : [];\n          const total =\n            !Array.isArray(parsed) && typeof (parsed as any).total === 'object'\n              ? (parsed as any).total\n              : null;\n          if (!itemsResultIsInvalid(items, requireMultiple)) {\n            resp.items = sanitizeStructuredItems(items);\n            resp.total = total || computeTotalsFromItems(resp.items) || resp.total || null;\n            itemsSource = itemsSource === 'none' ? 'forced_image_followup' : `${itemsSource}+forced_image_followup`;\n            itemsQuality = validateStructuredItems(resp.items) ? 'valid' : itemsQuality;\n            console.log('‚úÖ Forced image follow-up produced items:', resp.items.length);\n          }\n        }\n      } catch (forcedErr) {\n        console.warn('Forced image follow-up failed (non-fatal):', forcedErr);\n      }\n    }\n\n    // Absolute last resort: if we still have no usable items, run a text-only\n    // structured extractor so the UI never falls back to a summary-only card.\n    if (\n      wantStructured &&\n      !packagedMode &&\n      analysisTextForFollowUp &&\n      (!resp.items ||\n        resp.items.length === 0 ||\n        looksLikeSingleGenericItem(resp.items) ||\n        looksLikeMultiIngredientSummary(resp.items))\n    ) {\n      try {\n        const fallbackComponents = normalizeComponentList(\n          extractComponentsFromDelimitedText(analysisTextForFollowUp),\n        );\n        const requireMultiple = fallbackComponents.length > 1 || analysisLooksMulti;\n        const fallbackHint =\n          fallbackComponents.length > 0\n            ? `- Components list (include each as its own item): ${fallbackComponents.join(', ')}.\\n`\n            : '';\n        const fallbackRequirement = requireMultiple\n          ? `- Return at least ${Math.max(fallbackComponents.length, 2)} items.\\n`\n          : '';\n        console.warn('‚ö†Ô∏è Analyzer: running final text-only structured fallback.');\n        const fallback = await chatCompletionWithCost(openai, {\n          model: 'gpt-4o-mini',\n          response_format: { type: 'json_object' } as any,\n          messages: [\n            {\n              role: 'user',\n              content:\n                'Return JSON only with this shape:\\n' +\n                '{\"items\":[{\"name\":\"string\",\"brand\":null,\"serving_size\":\"string\",\"servings\":1,\"calories\":0,\"protein_g\":0,\"carbs_g\":0,\"fat_g\":0,\"fiber_g\":0,\"sugar_g\":0}],' +\n                '\"total\":{\"calories\":0,\"protein_g\":0,\"carbs_g\":0,\"fat_g\":0,\"fiber_g\":0,\"sugar_g\":0}}\\n' +\n                fallbackHint +\n                fallbackRequirement +\n                '- Use realistic per-serving values.\\n' +\n                '- Do NOT collapse multiple foods into a single summary item.\\n' +\n                '\\nAnalysis text:\\n' +\n                analysisTextForFollowUp,\n            },\n          ],\n          max_tokens: 360,\n          temperature: 0,\n        } as any);\n\n        totalCostCents += fallback.costCents;\n        const text = fallback.completion.choices?.[0]?.message?.content?.trim() || '';\n        const cleaned = text.replace(/```json/gi, '').replace(/```/g, '').trim();\n        const parsed = cleaned ? parseItemsJsonRelaxed(cleaned) : null;\n        if (parsed) {\n          const items = Array.isArray(parsed)\n            ? parsed\n            : Array.isArray((parsed as any).items)\n            ? (parsed as any).items\n            : [];\n          const total =\n            !Array.isArray(parsed) && typeof (parsed as any).total === 'object'\n              ? (parsed as any).total\n              : null;\n          if (!itemsResultIsInvalid(items, requireMultiple)) {\n            resp.items = sanitizeStructuredItems(items);\n            resp.total = total || computeTotalsFromItems(resp.items) || resp.total || null;\n            itemsSource = itemsSource === 'none' ? 'text_only_fallback' : `${itemsSource}+text_only_fallback`;\n            itemsQuality = validateStructuredItems(resp.items) ? 'valid' : itemsQuality;\n            console.log('‚úÖ Text-only fallback produced items:', resp.items.length);\n          }\n        }\n      } catch (fallbackErr) {\n        console.warn('Text-only fallback failed (non-fatal):', fallbackErr);\n      }\n    }\n\n    // If the analysis text clearly lists components that are missing from ITEMS_JSON,\n    // backfill those components so the user can edit/remove them.\n    if (wantStructured && preferMultiDetect && !componentBoundApplied) {\n      if (listedComponents.length > 0) {\n        const existing = resp.items || [];\n        const existingFiltered = existing.filter(\n          (item: any) =>\n            !looksLikeMultiIngredientSummary([item]) && !looksLikeSingleGenericItem([item]),\n        );\n        const existingLabels: string[] = existingFiltered.map((item: any) =>\n          normalizeComponentName(`${item?.name || ''} ${item?.serving_size || ''}`),\n        );\n        const missingComponents = listedComponents.filter((component) => {\n          const normalized = normalizeComponentName(component);\n          if (!normalized) return false;\n          return !existingLabels.some((label) => label.includes(normalized) || normalized.includes(label));\n        });\n\n        if (missingComponents.length > 0) {\n          try {\n            const followUp = isImageAnalysis\n              ? await chatCompletionWithCost(openai, {\n                  model: 'gpt-4o',\n                  response_format: { type: 'json_object' } as any,\n                  messages: [\n                    {\n                      role: 'user',\n                      content: [\n                        {\n                          type: 'text',\n                          text:\n                            'Return JSON only with this shape:\\n' +\n                            '{\"items\":[{\"name\":\"string\",\"brand\":null,\"serving_size\":\"string\",\"servings\":1,\"calories\":0,\"protein_g\":0,\"carbs_g\":0,\"fat_g\":0,\"fiber_g\":0,\"sugar_g\":0,\"isGuess\":false}],\"total\":{\"calories\":0,\"protein_g\":0,\"carbs_g\":0,\"fat_g\":0,\"fiber_g\":0,\"sugar_g\":0}}\\n' +\n                            `- Include ONLY these components, exactly as listed: ${listedComponents.join(', ')}.\\n` +\n                            '- Do not omit any component. Do not add extras.\\n' +\n                            '- Do not omit small items (radish, cucumber, seaweed, kimchi).\\n' +\n                            '- Keep servings at 1 and use simple serving sizes (\"1 serving\", \"1/4 cup\").\\n' +\n                            '- If uncertain, set isGuess: true and keep macros conservative.\\n' +\n                            '\\nAnalysis text:\\n' +\n                            analysisTextForFollowUp,\n                        },\n                        { type: 'image_url', image_url: { url: imageDataUrl, detail: 'high' } },\n                      ],\n                    },\n                  ],\n                  max_tokens: 360,\n                  temperature: 0,\n                } as any)\n              : await chatCompletionWithCost(openai, {\n                  model: 'gpt-4o-mini',\n                  response_format: { type: 'json_object' } as any,\n                  messages: [\n                    {\n                      role: 'user',\n                      content:\n                        'Return JSON only with this shape:\\n' +\n                        '{\"items\":[{\"name\":\"string\",\"brand\":null,\"serving_size\":\"string\",\"servings\":1,\"calories\":0,\"protein_g\":0,\"carbs_g\":0,\"fat_g\":0,\"fiber_g\":0,\"sugar_g\":0,\"isGuess\":false}],\"total\":{\"calories\":0,\"protein_g\":0,\"carbs_g\":0,\"fat_g\":0,\"fiber_g\":0,\"sugar_g\":0}}\\n' +\n                        `- Include ONLY these components, exactly as listed: ${listedComponents.join(', ')}.\\n` +\n                        '- Do not omit any component. Do not add extras.\\n' +\n                        '- Do not omit small items (radish, cucumber, seaweed, kimchi).\\n' +\n                        '- Keep servings at 1 and use simple serving sizes (\"1 serving\", \"1/4 cup\").\\n' +\n                        '- If uncertain, set isGuess: true and keep macros conservative.\\n' +\n                        '\\nAnalysis text:\\n' +\n                        analysisTextForFollowUp,\n                    },\n                  ],\n                  max_tokens: 360,\n                  temperature: 0,\n                } as any);\n\n            totalCostCents += followUp.costCents;\n            const text = followUp.completion.choices?.[0]?.message?.content?.trim() || '';\n            const cleaned = text.replace(/```json/gi, '').replace(/```/g, '').trim();\n            const parsed = cleaned ? parseItemsJsonRelaxed(cleaned) : null;\n            const followUpItems = parsed\n              ? sanitizeStructuredItems(\n                  Array.isArray(parsed)\n                    ? parsed\n                    : Array.isArray((parsed as any).items)\n                    ? (parsed as any).items\n                    : [],\n                )\n              : [];\n            if (followUpItems.length > 0) {\n              const additions = followUpItems.filter((item: any) => {\n                const normalized = normalizeComponentName(item?.name || '');\n                if (!normalized) return false;\n                return !existingLabels.some((label) => label.includes(normalized) || normalized.includes(label));\n              });\n              const merged =\n                additions.length > 0\n                  ? [\n                      ...existingFiltered,\n                      ...additions.map((item: any) => ({ ...item, isGuess: item?.isGuess === true })),\n                    ]\n                  : followUpItems;\n              resp.items = sanitizeStructuredItems(merged);\n              resp.total = computeTotalsFromItems(resp.items) || resp.total;\n              itemsSource = itemsSource === 'none' ? 'component_backfill' : `${itemsSource}+component_backfill`;\n              itemsQuality = validateStructuredItems(resp.items) ? 'valid' : itemsQuality;\n              console.log('‚úÖ Backfilled missing components from AI-only follow-up:', {\n                missingCount: additions.length,\n              });\n            }\n          } catch (missingErr) {\n            console.warn('Missing component AI follow-up failed (non-fatal):', missingErr);\n          }\n        }\n      }\n    }\n\n    if (resp.items && resp.items.length > 0 && !resp.total) {\n      resp.total = computeTotalsFromItems(resp.items);\n    }\n\n    // Burger-specific enrichment: ensure core components and realistic per-item macros.\n    const burgerEnriched = ensureBurgerComponents(resp.items || [], resp.analysis);\n    resp.items = burgerEnriched.items;\n    resp.total = burgerEnriched.total || resp.total;\n\n    // Intentionally do NOT add inferred ‚Äúplausible‚Äù components from the prose.\n    // This was a major source of hallucinations (e.g., fries or sauces not actually visible).\n\n    // Normalize guess flags, discrete counts (pieces/servings), and convert word numbers to numerals.\n    if (resp.items && Array.isArray(resp.items)) {\n      resp.items = normalizeGuessFlags(resp.items);\n      const discreteNormalized = normalizeDiscreteItems(resp.items, { analysisText: analysis });\n      resp.items = discreteNormalized.items;\n      if (discreteNormalized.changed && (!resp.total || Object.keys(resp.total || {}).length === 0)) {\n        resp.total = computeTotalsFromItems(resp.items);\n      }\n      if (discreteNormalized.debug.length > 0) {\n        console.log('[FOOD_DEBUG] discrete normalization preview', discreteNormalized.debug.slice(0, 4));\n      }\n      resp.items = normalizeDiscreteCounts(resp.items);\n      const weightFix = fixWeightUnitsMisreadAsPieces(resp.items)\n      if (weightFix.changed) {\n        resp.items = weightFix.items\n        resp.total = computeTotalsFromItems(resp.items) || resp.total\n      }\n      if (!resp.total || Object.keys(resp.total || {}).length === 0) {\n        resp.total = computeTotalsFromItems(resp.items);\n      }\n    }\n\n    // Sliced produce sanity: avoid egregious \"whole avocado\" guesses when the item is clearly just slices.\n    if (resp.items && Array.isArray(resp.items) && resp.items.length > 0) {\n      const sanitized = applySlicedProduceSanity(resp.items)\n      resp.items = sanitized.items\n      if (sanitized.changed) {\n        resp.total = computeTotalsFromItems(resp.items) || resp.total\n      }\n    }\n\n    if (packagedMode && labelScan && imageDataUrl && resp.items && resp.items.length > 0) {\n      try {\n        const labelModel = model === 'gpt-5.2' ? model : 'gpt-5.2'\n        const labelResult = await extractLabelPerServingFromImage(openai, imageDataUrl, labelModel)\n        totalCostCents += labelResult.costCents\n        const parsed = labelResult.parsed || {}\n        const perServing = parsed?.per_serving || parsed?.perServing || null\n        const toNumber = (value: any) => {\n          const num = Number(value)\n          return Number.isFinite(num) ? num : null\n        }\n        const hasPerServingValues =\n          perServing &&\n          typeof perServing === 'object' &&\n          Object.values(perServing).some((value) => value !== null && value !== undefined && value !== '');\n        if (hasPerServingValues) {\n          const nextItems = [...resp.items]\n          const targetIndex = 0\n          const next = { ...nextItems[targetIndex] }\n          if (parsed?.serving_size || parsed?.servingSize) {\n            next.serving_size = String(parsed.serving_size || parsed.servingSize || '').trim()\n          }\n          next.calories = toNumber(perServing.calories)\n          next.protein_g = toNumber(perServing.protein_g ?? perServing.protein)\n          next.carbs_g = toNumber(perServing.carbs_g ?? perServing.carbs)\n          next.fat_g = toNumber(perServing.fat_g ?? perServing.fat)\n          next.fiber_g = toNumber(perServing.fiber_g ?? perServing.fiber)\n          next.sugar_g = toNumber(perServing.sugar_g ?? perServing.sugar)\n          nextItems[targetIndex] = next\n          resp.items = nextItems\n          resp.total = computeTotalsFromItems(resp.items) || resp.total\n        } else {\n          const nextItems = resp.items.map((item: any, index: number) =>\n            index === 0\n              ? {\n                  ...item,\n                  labelNeedsReview: true,\n                  labelNeedsReviewMessage:\n                    'We could not read the per serve column clearly. Please retake the label photo.',\n                  calories: null,\n                  protein_g: null,\n                  carbs_g: null,\n                  fat_g: null,\n                  fiber_g: null,\n                  sugar_g: null,\n                }\n              : item,\n          )\n          resp.items = nextItems\n          resp.total = computeTotalsFromItems(resp.items) || resp.total\n        }\n      } catch (labelErr) {\n        console.warn('Label per-serving extraction failed (non-fatal):', labelErr)\n      }\n    }\n\n    // Final safety pass: if the AI has described a discrete portion like\n    // \"3 large eggs\" or \"4 slices of bacon\" but provided calories/macros that\n    // only match a single unit, scale those macros up so that the totals match\n    // the visible serving description. This does not touch the Food Diary UI\n    // or diary loading logic ‚Äì it only corrects the structured items returned\n    // from this API.\n    if (resp.items && Array.isArray(resp.items) && resp.items.length > 0) {\n      const harmonized = harmonizeDiscretePortionItems(resp.items, {\n        applyWeightDefaults: !packagedMode && !labelScan,\n      });\n      resp.items = harmonized.items;\n      if (harmonized.total) {\n        resp.total = harmonized.total;\n      } else if (!resp.total) {\n        resp.total = computeTotalsFromItems(resp.items);\n      }\n    }\n\n    if (!packagedMode && !labelScan && resp.items && Array.isArray(resp.items) && resp.items.length > 0) {\n      const friedFloor = applyFriedSeafoodCalorieFloor(resp.items);\n      const chickenFloor = applyRoastedChickenCalorieFloor(friedFloor.items);\n      if (friedFloor.changed || chickenFloor.changed) {\n        resp.items = chickenFloor.items;\n        resp.total = computeTotalsFromItems(resp.items) || resp.total;\n      }\n    }\n\n    // Egg-specific enforcement: if analysis text says \"two eggs\" (or any number >=2),\n    // force the payload to that count, with pieces/serving_size updated and macros scaled.\n    resp.items = enforceEggCountFromAnalysis(resp.items, analysis);\n    if (resp.items && (!resp.total || !isPlausibleTotal(resp.total))) {\n      resp.total = computeTotalsFromItems(resp.items);\n    }\n    if (resp.items && Array.isArray(resp.items) && resp.items.length > 0) {\n      const strictPieces = stripPiecesWithoutExplicitCount(resp.items);\n      if (strictPieces.changed) {\n        resp.items = strictPieces.items;\n        resp.total = computeTotalsFromItems(resp.items) || resp.total;\n      }\n    }\n\n    // Final safety net for image analyses: never return a single multi-ingredient summary card.\n    // If we can detect multiple components but still only have one item, split into multiple\n    // editable cards (macros left blank) to preserve per-ingredient UX.\n    if (\n      isImageAnalysis &&\n      preferMultiDetect &&\n      !packagedMode &&\n      resp.items &&\n      Array.isArray(resp.items) &&\n      resp.items.length <= 1 &&\n      (analysisLooksMulti || looksLikeMultiIngredientSummary(resp.items))\n    ) {\n      const fallback = buildMultiComponentFallback(analysisTextForFollowUp, resp.total);\n      if (fallback.items.length > 1) {\n        resp.items = fallback.items;\n        if (!resp.total) {\n          resp.total = fallback.total || resp.total || null;\n        }\n        itemsSource = itemsSource === 'none' ? 'component_split' : `${itemsSource}+component_split`;\n        itemsQuality = 'weak';\n        console.warn('‚úÖ Split multi-ingredient summary into separate cards (macros left blank).');\n      }\n    }\n\n    // Enforce multi-item output for meal analyses (non-packaged) so the UI never shows a single card.\n    if (\n      !STRICT_AI_ONLY_ITEMS &&\n      preferMultiDetect &&\n      !packagedMode &&\n      (!resp.items || resp.items.length === 0 || (!validateStructuredItems(resp.items) || looksLikeSingleGenericItem(resp.items)))\n    ) {\n      const fallback = buildMultiComponentFallback(analysis, resp.total);\n      // Mark all fallback items as guesses to avoid presenting them as authoritative\n      resp.items = fallback.items.map((it) => ({ ...it, isGuess: true, calories: null, protein_g: null, carbs_g: null, fat_g: null }));\n      resp.total = fallback.total || resp.total || null;\n      itemsSource = itemsSource === 'none' ? 'multi_fallback' : `${itemsSource}+multi_fallback`;\n      itemsQuality = 'weak';\n      console.warn('‚úÖ Enforced multi-item fallback to prevent single-card UI for meals (macros left blank to avoid equal-split).');\n    }\n\n    // Packaged mode: fill missing macros from FatSecret without overriding existing values.\n    if (packagedMode && !labelScan && resp.items && Array.isArray(resp.items) && resp.items.length > 0) {\n      const enriched = await enrichPackagedItemsWithFatSecret(resp.items);\n      if (enriched.total) {\n        resp.items = enriched.items;\n        resp.total = enriched.total;\n      }\n    }\n\n    // General (non-packaged) enrichment when macros are missing/zero\n    if (!labelScan && resp.items && Array.isArray(resp.items) && resp.items.length > 0) {\n      const needsEnrichment = resp.items.some(\n        (it: any) =>\n          (!Number.isFinite(Number(it?.calories)) || Number(it?.calories) === 0) ||\n          ((!Number.isFinite(Number(it?.protein_g)) || Number(it?.protein_g) === 0) &&\n            (!Number.isFinite(Number(it?.carbs_g)) || Number(it?.carbs_g) === 0) &&\n            (!Number.isFinite(Number(it?.fat_g)) || Number(it?.fat_g) === 0)),\n      );\n      if (needsEnrichment) {\n        const enriched = await enrichItemsWithFatSecretIfMissing(resp.items);\n        if (enriched.changed) {\n          resp.items = enriched.items;\n          resp.total = enriched.total || resp.total || computeTotalsFromItems(enriched.items);\n          itemsSource = `${itemsSource}+fatsecret_enrich`;\n          itemsQuality = validateStructuredItems(resp.items) ? 'valid' : itemsQuality;\n          console.log('‚ÑπÔ∏è Applied FatSecret enrichment for missing macros.');\n        }\n      }\n    }\n\n    if (!labelScan && !packagedMode && resp.items && Array.isArray(resp.items) && resp.items.length > 0) {\n      const calibrated = await enrichItemsWithDatabaseIfOutlier(resp.items, {\n        maxItems: feedbackDown ? Math.min(resp.items.length, 6) : 1,\n        outlierRatio: feedbackDown ? 0.15 : 0.2,\n        allowIncrease: feedbackDown,\n      });\n      if (calibrated.changed) {\n        resp.items = calibrated.items;\n        resp.total = calibrated.total || resp.total || computeTotalsFromItems(calibrated.items);\n        itemsSource = `${itemsSource}+db_calibrate`;\n        itemsQuality = validateStructuredItems(resp.items) ? 'valid' : itemsQuality;\n        console.log('‚ÑπÔ∏è Applied database calibration for outlier macros.');\n      }\n    }\n\n    if (!labelScan && !packagedMode && resp.items && Array.isArray(resp.items) && resp.items.length > 1) {\n      const deduped = removeSummaryDuplicateItems(resp.items);\n      if (deduped.removed > 0) {\n        resp.items = deduped.items;\n        resp.total = computeTotalsFromItems(resp.items) || resp.total;\n        itemsSource = `${itemsSource}+summary_dedupe`;\n        itemsQuality = validateStructuredItems(resp.items) ? 'valid' : itemsQuality;\n        console.log('‚ÑπÔ∏è Removed summary duplicate items.', { removed: deduped.removed });\n      }\n    }\n\n    // Stabilize totals: prefer plausible incoming total when it roughly matches per-item sums; otherwise recompute from items.\n    if (labelScan) {\n      resp.total = computeTotalsFromItems(resp.items) || resp.total;\n    } else {\n      resp.total = chooseCanonicalTotal(resp.items, resp.total);\n    }\n\n    // Consistency repair: if totals are implausibly low for a multi-item meal,\n    // run a stricter vision pass to force realistic per-component macros.\n    if (\n      isImageAnalysis &&\n      !packagedMode &&\n      !labelScan &&\n      resp.items &&\n      Array.isArray(resp.items) &&\n      resp.items.length > 0\n    ) {\n      const totalCalories = Number(resp.total?.calories ?? 0);\n      const componentCount = Math.max(listedComponents.length, resp.items.length);\n      const joinedNames = resp.items\n        .map((item: any) => `${item?.name || ''} ${item?.serving_size || ''}`)\n        .join(' ')\n        .toLowerCase();\n      const hasFriedCue = /\\b(fried|battered|breaded|crumbed|wedge|wedges|fries|chips|tartar)\\b/i.test(joinedNames);\n      const minTotal =\n        componentCount >= 4\n          ? 350\n          : componentCount >= 3\n          ? 250\n          : componentCount >= 2\n          ? 180\n          : 0;\n      const minTotalWithCue = hasFriedCue ? Math.max(minTotal, 300) : minTotal;\n\n      if (Number.isFinite(totalCalories) && totalCalories > 0 && totalCalories < minTotalWithCue) {\n        try {\n          const repairComponents = normalizeComponentList(\n            listedComponents.length > 0\n              ? listedComponents\n              : resp.items.map((item: any) => String(item?.name || '')).filter(Boolean),\n          );\n          const repairHint =\n            repairComponents.length > 0\n              ? `- Components list (include each as its own item): ${repairComponents.join(', ')}.\\n`\n              : '';\n          const repairPrompt =\n            'Return JSON only with this shape:\\n' +\n            '{\"items\":[{\"name\":\"string\",\"brand\":null,\"serving_size\":\"string\",\"servings\":1,\"calories\":0,\"protein_g\":0,\"carbs_g\":0,\"fat_g\":0,\"fiber_g\":0,\"sugar_g\":0}],' +\n            '\"total\":{\"calories\":0,\"protein_g\":0,\"carbs_g\":0,\"fat_g\":0,\"fiber_g\":0,\"sugar_g\":0}}\\n' +\n            repairHint +\n            '- Use the image as the primary source of truth.\\n' +\n            '- Do NOT underestimate calories for fried/battered items.\\n' +\n            '- Use realistic restaurant portion sizes.\\n' +\n            '- Return one item per distinct component.\\n';\n          console.warn('‚ö†Ô∏è Analyzer: totals too low; running consistency repair pass.');\n          const repair = await chatCompletionWithCost(openai, {\n            model: 'gpt-4o',\n            response_format: { type: 'json_object' } as any,\n            messages: [\n              {\n                role: 'user',\n                content: [\n                  { type: 'text', text: repairPrompt },\n                  { type: 'image_url', image_url: { url: imageDataUrl, detail: 'high' } },\n                ],\n              },\n            ],\n            max_tokens: 420,\n            temperature: 0,\n          } as any);\n\n          totalCostCents += repair.costCents;\n          const text = repair.completion.choices?.[0]?.message?.content?.trim() || '';\n          const cleaned = text.replace(/```json/gi, '').replace(/```/g, '').trim();\n          const parsed = cleaned ? parseItemsJsonRelaxed(cleaned) : null;\n          const items = Array.isArray(parsed)\n            ? parsed\n            : Array.isArray((parsed as any)?.items)\n            ? (parsed as any).items\n            : [];\n          const total =\n            !Array.isArray(parsed) && typeof (parsed as any)?.total === 'object'\n              ? (parsed as any).total\n              : null;\n          if (items.length > 0 && !itemsResultIsInvalid(items, componentCount > 1)) {\n            resp.items = sanitizeStructuredItems(items);\n            resp.total = total || computeTotalsFromItems(resp.items) || resp.total;\n            itemsSource = itemsSource === 'none' ? 'consistency_repair' : `${itemsSource}+consistency_repair`;\n            itemsQuality = validateStructuredItems(resp.items) ? 'valid' : itemsQuality;\n            console.log('‚úÖ Consistency repair produced items:', resp.items.length);\n          }\n        } catch (repairErr) {\n          console.warn('Consistency repair failed (non-fatal):', repairErr);\n        }\n      }\n    }\n\n    // Packaged mode: skip secondary OpenAI per-serving extraction to keep one API call per analysis.\n    if (packagedMode && resp.items && Array.isArray(resp.items) && resp.items.length > 0 && imageDataUrl) {\n      console.log('‚ÑπÔ∏è Packaged mode active; secondary per-serving OpenAI call disabled to reduce usage.');\n    }\n\n    // NOTE: USDA/FatSecret database enhancement removed from AI photo analysis flow\n    // These databases are still available via /api/food-data for manual ingredient lookup\n    // The AI analysis works better without database interference - it provides accurate\n    // estimates based on visual analysis and portion sizes, which databases can't match.\n\n    // HEALTH COMPATIBILITY CHECK: advisory-only, uses saved allergies/diabetes settings\n    try {\n      const warnings: string[] = [];\n      const lowerAnalysis = (analysis || (resp as any)?.analysis || resp.total?.description || '').toString().toLowerCase();\n      const itemNames = Array.isArray(resp.items)\n        ? resp.items\n            .map((it: any) => `${it?.name || ''} ${it?.serving_size || ''}`.toLowerCase())\n            .join(' ')\n        : '';\n      const textBlob = `${lowerAnalysis} ${itemNames}`;\n\n      const normalizeAllergy = (val: string) => {\n        const lower = val.toLowerCase();\n        if (lower.includes('peanut')) return 'peanut';\n        if (lower.includes('tree nut')) return 'tree nuts';\n        if (lower.includes('nut')) return 'tree nuts';\n        if (lower.includes('gluten') || lower.includes('celiac') || lower.includes('coeliac') || lower.includes('wheat'))\n          return 'gluten';\n        if (lower.includes('dairy') || lower.includes('milk') || lower.includes('lactose')) return 'dairy';\n        if (lower.includes('egg')) return 'egg';\n        if (lower.includes('shellfish') || lower.includes('shrimp') || lower.includes('prawn')) return 'shellfish';\n        if (lower.includes('fish')) return 'fish';\n        if (lower.includes('soy')) return 'soy';\n        if (lower.includes('sesame')) return 'sesame';\n        if (lower.includes('corn') || lower.includes('maize')) return 'corn';\n        return lower;\n      };\n\n      const allergyKeywordMap: Record<string, string[]> = {\n        peanut: ['peanut', 'groundnut', 'satay', 'peanut butter'],\n        'tree nuts': ['almond', 'walnut', 'cashew', 'pecan', 'pistachio', 'hazelnut', 'macadamia'],\n        gluten: ['gluten', 'wheat', 'barley', 'rye', 'malt', 'semolina', 'spelt'],\n        dairy: ['milk', 'cream', 'cheese', 'butter', 'yogurt', 'ghee', 'custard'],\n        egg: ['egg', 'eggs', 'mayo', 'mayonnaise'],\n        shellfish: ['shrimp', 'prawn', 'crab', 'lobster', 'clam', 'mussel', 'oyster', 'shellfish', 'scallop'],\n        fish: ['fish', 'salmon', 'tuna', 'cod', 'trout', 'anchovy', 'sardine'],\n        soy: ['soy', 'soya', 'edamame', 'tofu', 'tempeh', 'miso', 'soy sauce'],\n        sesame: ['sesame', 'tahini', 'sesame seed'],\n        corn: ['corn', 'maize', 'tortilla', 'polenta', 'cornmeal'],\n        sulfites: ['sulfite', 'sulphite', 'wine', 'dried fruit', 'cider'],\n      };\n\n      const allergiesSelected = Array.isArray(allergySettings.allergies)\n        ? allergySettings.allergies.filter((a) => typeof a === 'string' && a.trim().length > 0)\n        : [];\n\n      allergiesSelected.forEach((allergyRaw: string) => {\n        const canonical = normalizeAllergy(allergyRaw);\n        const keywords = allergyKeywordMap[canonical] || [canonical];\n        const hit = keywords.some((kw) => textBlob.includes(kw.toLowerCase()));\n        if (hit) {\n          warnings.push(`Contains or may contain ${allergyRaw} based on the analysis.`);\n        }\n      });\n\n      const diabetesType = (allergySettings.diabetesType || '').toLowerCase();\n      if (diabetesType) {\n        const sugarRaw =\n          (resp.total as any)?.sugar_g ?? (resp.total as any)?.sugar ?? (resp.total as any)?.sugars_g;\n        const sugar = Number(sugarRaw);\n        const hasSugar = Number.isFinite(sugar);\n        const carbsRaw = (resp.total as any)?.carbs_g ?? (resp.total as any)?.carbohydrates;\n        const carbs = Number(carbsRaw);\n        const hasCarbs = Number.isFinite(carbs);\n        const hasSugaryKeywords = /dessert|cake|cookie|ice cream|juice|soda|sweet|syrup|candy|chocolate/.test(textBlob);\n\n        const thresholds =\n          diabetesType === 'prediabetes'\n            ? { sugar: 28, carbs: 75, label: 'pre-diabetes' }\n            : diabetesType === 'type1'\n            ? { sugar: 22, carbs: 70, label: 'Type 1 diabetes' }\n            : { sugar: 20, carbs: 65, label: 'Type 2 diabetes' };\n\n        if (hasSugar && sugar > thresholds.sugar) {\n          warnings.push(`High sugar for ${thresholds.label}: about ${Math.round(sugar)}g (target ‚â§ ${thresholds.sugar}g per meal).`);\n        } else if (!hasSugar && hasSugaryKeywords) {\n          warnings.push(`High-sugar food spotted; use caution for ${thresholds.label}.`);\n        }\n        if (hasCarbs && carbs > thresholds.carbs) {\n          warnings.push(`High carbs for ${thresholds.label}: about ${Math.round(carbs)}g.`);\n        }\n      }\n\n      resp.healthWarning = warnings.length ? `‚ö†Ô∏è Health warning:\\n- ${warnings.join('\\n- ')}` : null;\n      resp.alternatives = null;\n    } catch (healthError) {\n      console.warn('‚ö†Ô∏è Health compatibility section skipped due to error:', healthError);\n    }\n\n    // DIET CHECK: advisory-only, uses saved diet preference (no extra AI calls)\n    try {\n      const normalizedDietIds = normalizeDietTypes(dietTypes)\n      if (normalizedDietIds.length > 0) {\n        const itemNames = Array.isArray(resp.items)\n          ? resp.items.map((it: any) => `${it?.name || ''} ${it?.serving_size || ''}`.trim()).filter(Boolean)\n          : []\n        const analysisText = (analysis || (resp as any)?.analysis || '').toString()\n        const result = checkMultipleDietCompatibility({\n          dietIds: normalizedDietIds,\n          itemNames,\n          analysisText,\n          totals: (resp as any)?.total || null,\n        })\n\n        const warningsByDiet = result.warningsByDiet || []\n        const suggestions = result.suggestions || []\n\n        ;(resp as any).dietWarning =\n          warningsByDiet.length > 0\n            ? `‚ö†Ô∏è Diet warning:\\n- ${warningsByDiet\n                .map((d) => {\n                  const joined = (d.warnings || []).join(' ')\n                  return `${d.dietLabel}: ${joined}`.trim()\n                })\n                .join('\\n- ')}`\n            : null\n        ;(resp as any).dietAlternatives = suggestions.length > 0 ? `- ${suggestions.join('\\n- ')}` : null\n      } else {\n        ;(resp as any).dietWarning = null\n        ;(resp as any).dietAlternatives = null\n      }\n    } catch (dietError) {\n      console.warn('‚ö†Ô∏è Diet compatibility section skipped due to error:', dietError)\n    }\n\n    // Fixed per-use price is charged upfront; no remainder charge here.\n    // Skip if allowed via free use OR when billing checks are disabled.\n    if (BILLING_ENFORCED && !allowViaFreeUse) {\n      try {\n        const cm = new CreditManager(currentUser.id);\n        const remainder = 0;\n        const ok = await cm.chargeCents(remainder);\n        if (!ok) {\n          return NextResponse.json({ error: 'Insufficient credits' }, { status: 402 });\n        }\n      } catch (e) {\n        console.warn('Wallet charge failed:', e);\n        return NextResponse.json({ error: 'Billing error' }, { status: 402 });\n      }\n    }\n\n    if (packagedMode && Array.isArray(resp.items) && resp.items.length > 0) {\n      const packagedReview = sanitizePackagedLabelItems(resp.items);\n      resp.items = packagedReview.items;\n      if (packagedReview.needsReview) {\n        resp.labelNeedsReview = true;\n        resp.labelReviewMessage = packagedReview.message;\n        resp.total = computeTotalsFromItems(resp.items);\n      }\n    }\n\n    const finalSummary = {\n      itemsSource,\n      itemsQuality,\n      itemCount: Array.isArray(resp.items) ? resp.items.length : 0,\n      totalPreview: resp.total\n        ? {\n            calories: (resp.total as any)?.calories,\n            protein_g: (resp.total as any)?.protein_g,\n            carbs_g: (resp.total as any)?.carbs_g,\n            fat_g: (resp.total as any)?.fat_g,\n          }\n        : null,\n      itemsPreview: summarizeItemsForLog(resp.items || []),\n    };\n    console.log('[FOOD_DEBUG] structured summary', finalSummary);\n\n    const discreteLog = summarizeDiscreteItemsForLog(resp.items || []);\n    if (discreteLog.length > 0) {\n      console.log('[FOOD_DEBUG] discrete items', discreteLog);\n    }\n\n    const analysisId = imageHash ? `food-${imageHash.slice(0, 8)}` : `food-${Date.now()}`;\n\n    // Log AI usage for the main Food Analyzer (fire-and-forget).\n    // Use the primary analysis tokens and the total combined cost (analysis + follow-ups).\n    logAiUsageEvent({\n      feature: 'food:analysis',\n      userId: currentUser.id || null,\n      userLabel: currentUser.email || null,\n      scanId: analysisId,\n      model,\n      promptTokens: primary.promptTokens,\n      completionTokens: primary.completionTokens,\n      costCents: totalCostCents,\n      endpoint: '/api/analyze-food',\n      success: true,\n    }).catch(() => {});\n\n    // Debug: log raw items/total for diagnostics (no PII; limited preview)\n    try {\n      console.log('[FOOD_DEBUG] raw response preview', {\n        itemCount: Array.isArray(resp.items) ? resp.items.length : 0,\n        itemsPreview: Array.isArray(resp.items)\n          ? resp.items.slice(0, 5).map((it: any) => ({\n              name: it?.name,\n              serving_size: it?.serving_size,\n              calories: it?.calories,\n              protein_g: it?.protein_g,\n              carbs_g: it?.carbs_g,\n              fat_g: it?.fat_g,\n              fiber_g: it?.fiber_g,\n              sugar_g: it?.sugar_g,\n              isGuess: it?.isGuess,\n            }))\n          : null,\n        totalPreview: resp.total\n          ? {\n              calories: (resp.total as any)?.calories,\n              protein_g: (resp.total as any)?.protein_g,\n              carbs_g: (resp.total as any)?.carbs_g,\n              fat_g: (resp.total as any)?.fat_g,\n              fiber_g: (resp.total as any)?.fiber_g,\n              sugar_g: (resp.total as any)?.sugar_g,\n            }\n          : null,\n        });\n    } catch (logErr) {\n      console.warn('[FOOD_DEBUG] log error', logErr);\n    }\n\n    resp.analysisId = analysisId;\n    return NextResponse.json(resp);\n\n  } catch (error) {\n    console.error('üí• AI API Error:', error);\n    \n    // Handle specific OpenAI errors\n    if (error instanceof Error) {\n      console.log('üîç Error details:', {\n        message: error.message,\n        name: error.name,\n        stack: error.stack?.substring(0, 200)\n      });\n      \n      if (error.message.includes('insufficient_quota')) {\n        return NextResponse.json(\n          { error: 'OpenAI API quota exceeded. Please check your billing.' },\n          { status: 429 }\n        );\n      }\n      if (error.message.includes('invalid_api_key')) {\n        return NextResponse.json(\n          { error: 'Invalid OpenAI API key. Please check your configuration.' },\n          { status: 401 }\n        );\n      }\n    }\n\n    return NextResponse.json(\n      { error: 'Failed to analyze food' },\n      { status: 500 }\n    );\n  }\n} \n","truncated":false,"size":183559},{"path":"app/api/analyze-interactions/route.ts","content":"import { NextRequest, NextResponse } from 'next/server';\nimport { getServerSession } from 'next-auth';\nimport { authOptions } from '@/lib/auth';\nimport { prisma } from '@/lib/prisma';\nimport { CreditManager, CREDIT_COSTS } from '@/lib/credit-system';\nimport { consumeFreeCredit, hasFreeCredits } from '@/lib/free-credits';\nimport OpenAI from 'openai';\nimport { chatCompletionWithCost } from '@/lib/metered-openai';\nimport { capMaxTokensToBudget } from '@/lib/cost-meter';\nimport { logAIUsage } from '@/lib/ai-usage-logger';\nimport { isSubscriptionActive } from '@/lib/subscription-utils';\nimport { logServerCall } from '@/lib/server-call-tracker';\n\n// Lazily initialize OpenAI to avoid build-time env requirements\nfunction getOpenAIClient() {\n  if (!process.env.OPENAI_API_KEY) {\n    return null;\n  }\n  return new OpenAI({ apiKey: process.env.OPENAI_API_KEY });\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    // Check authentication\n    const session = await getServerSession(authOptions);\n    if (!session?.user?.email) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n    }\n\n    const { supplements, medications, analysisName, reanalysis } = await request.json();\n\n    if (!supplements || !medications) {\n      return NextResponse.json({ error: 'Missing supplements or medications data' }, { status: 400 });\n    }\n\n    // Find user and check credit quota\n    const user = await prisma.user.findUnique({\n      where: { email: session.user.email },\n      include: { subscription: true, creditTopUps: true }\n    });\n\n    if (!user) {\n      return NextResponse.json({ error: 'User not found' }, { status: 404 });\n    }\n\n    logServerCall({\n      feature: 'interactionAnalysis',\n      endpoint: '/api/analyze-interactions',\n      kind: 'analysis',\n    }).catch((error) => {\n      console.error('‚ùå Failed to log interaction analysis call:', error);\n    });\n\n    // PREMIUM/CREDITS/FREE USE GATING\n    const isPremium = isSubscriptionActive(user.subscription);\n    \n    // Check if user has purchased credits (non-expired)\n    const now = new Date();\n    const hasPurchasedCredits = user.creditTopUps.some(\n      (topUp: any) => topUp.expiresAt > now && (topUp.amountCents - topUp.usedCents) > 0\n    );\n    \n    const hasFreeInteractionCredits = await hasFreeCredits(user.id, 'INTERACTION_ANALYSIS');\n    const hasFreeInteractionReanalysis = await hasFreeCredits(user.id, 'INTERACTION_REANALYSIS');\n    \n    // Allow if: Premium subscription OR has purchased credits OR has free credits\n    let allowViaFreeUse = false;\n    if (!isPremium && !hasPurchasedCredits) {\n      if (reanalysis) {\n        if (hasFreeInteractionReanalysis) {\n          allowViaFreeUse = true;\n        } else {\n          return NextResponse.json(\n            {\n              error: 'Payment required',\n              message: 'You\\'ve used all your free interaction re-analyses. Subscribe to a monthly plan or purchase credits to continue.',\n              requiresPayment: true,\n              exhaustedFreeCredits: true,\n            },\n            { status: 402 }\n          );\n        }\n      } else if (hasFreeInteractionCredits) {\n        allowViaFreeUse = true;\n      } else {\n        return NextResponse.json(\n          { \n            error: 'Payment required',\n            message: 'You\\'ve used all your free interaction analyses. Subscribe to a monthly plan or purchase credits to continue.',\n            requiresPayment: true,\n            exhaustedFreeCredits: true,\n          },\n          { status: 402 }\n        );\n      }\n    }\n    // Use optional chaining to avoid type errors if field not present in client types\n    const lastMonthlyReset = (user as any).lastMonthlyResetDate as Date | null;\n    const monthChanged = !lastMonthlyReset || lastMonthlyReset.getUTCFullYear() !== now.getUTCFullYear() || lastMonthlyReset.getUTCMonth() !== now.getUTCMonth();\n    if (monthChanged) {\n      await prisma.user.update({\n        where: { id: user.id },\n        data: { \n          // Cast to any to support add-only schema push in staging\n          ...( { monthlyInteractionAnalysisUsed: 0, lastMonthlyResetDate: now } as any )\n        }\n      });\n      (user as any).monthlyInteractionAnalysisUsed = 0 as any;\n    }\n\n    // Plan/trial gating removed ‚Äì wallet pre-check governs access (trial counters still updated later)\n\n    // Prepare the data for OpenAI analysis\n    const supplementList = (supplements as any[]).map((s: any) => ({\n      name: s.name,\n      dosage: s.dosage,\n      timing: Array.isArray(s.timing) ? s.timing.join(', ') : s.timing,\n      schedule: s.scheduleInfo\n    }));\n\n    const medicationList = (medications as any[]).map((m: any) => ({\n      name: m.name,\n      dosage: m.dosage,\n      timing: Array.isArray(m.timing) ? m.timing.join(', ') : m.timing,\n      schedule: m.scheduleInfo\n    }));\n\n    const prompt = `As a clinical pharmacist, analyze the following supplements and medications for potential interactions:\n\nSUPPLEMENTS:\n${supplementList.map(s => `- ${s.name}: ${s.dosage}, taken ${s.timing}, schedule: ${s.schedule}`).join('\\n')}\n\nMEDICATIONS:\n${medicationList.map(m => `- ${m.name}: ${m.dosage}, taken ${m.timing}, schedule: ${m.schedule}`).join('\\n')}\n\nCRITICAL REQUIREMENT: In your summary, you MUST list ALL supplements and medications by their actual names (e.g., \"Analysis completed for Vitamin E, Magnesium, and Ibuprofen. Overall risk level: medium.\") - do NOT use generic counts like \"5 supplements and 2 medications\".\n\nPlease provide a comprehensive interaction analysis in the following JSON format:\n{\n  \"overallRisk\": \"low|medium|high\",\n  \"interactions\": [\n    {\n      \"substance1\": \"name\",\n      \"substance2\": \"name\",\n      \"severity\": \"low|medium|high\",\n      \"description\": \"detailed explanation of the interaction\",\n      \"recommendation\": \"specific recommendation for the user\",\n      \"timingAdjustment\": \"suggested timing changes if needed\"\n    }\n  ],\n  \"timingOptimization\": {\n    \"morning\": [\"list of substances best taken in morning\"],\n    \"afternoon\": [\"list of substances best taken in afternoon\"],\n    \"evening\": [\"list of substances best taken in evening\"],\n    \"beforeBed\": [\"list of substances best taken before bed\"]\n  },\n  \"generalRecommendations\": [\n    \"general advice for this combination\"\n  ],\n  \"disclaimer\": \"Important medical disclaimer text\"\n}\n\nCRITICAL INSTRUCTIONS:\n1. ONLY include interactions that are MEDIUM or HIGH severity - do not include low/safe interactions\n2. For timing optimization, DO NOT include substances that have HIGH severity interactions with each other\n3. For MEDIUM severity interactions, include timing recommendations but note spacing requirements\n4. Focus on actionable, significant interactions only\n\nFocus on:\n1. Drug-supplement interactions\n2. Supplement-supplement interactions\n3. Timing conflicts that could reduce effectiveness\n4. Absorption interference\n5. Dosage concerns\n6. Any contraindications\n\nBe thorough but not alarmist. Provide actionable recommendations.`;\n\n    const openai = getOpenAIClient();\n    if (!openai) {\n      return NextResponse.json({ error: 'OpenAI API key not configured' }, { status: 500 });\n    }\n\n    const model = reanalysis ? \"gpt-4o-mini\" : \"gpt-4\";\n\n    let maxTokens = 2000;\n    // Wallet pre-check (skip if allowed via free use)\n    if (!allowViaFreeUse) {\n      const cm = new CreditManager(user.id);\n      const wallet = await cm.getWalletStatus();\n      const cappedMaxTokens = capMaxTokensToBudget(model, prompt, maxTokens, wallet.totalAvailableCents);\n      if (cappedMaxTokens <= 0) {\n        return NextResponse.json({ error: 'Insufficient credits' }, { status: 402 });\n      }\n      maxTokens = cappedMaxTokens;\n    }\n\n    // Immediate pre-charge (interaction analysis typical cost = CREDIT_COSTS.INTERACTION_ANALYSIS)\n    let prechargedCents = 0;\n    if (!allowViaFreeUse) {\n      try {\n        const cm = new CreditManager(user.id);\n        const immediate = CREDIT_COSTS.INTERACTION_ANALYSIS;\n        const okPre = await cm.chargeCents(immediate);\n        if (!okPre) {\n          return NextResponse.json({ error: 'Insufficient credits' }, { status: 402 });\n        }\n        prechargedCents = immediate;\n      } catch {\n        return NextResponse.json({ error: 'Billing error' }, { status: 402 });\n      }\n    }\n\n    const wrapped = await chatCompletionWithCost(openai, {\n      model,\n      messages: [\n        {\n          role: \"system\",\n          content: \"You are a clinical pharmacist with expertise in drug-supplement interactions. Provide accurate, evidence-based analysis while being appropriately cautious about medical advice.\"\n        },\n        {\n          role: \"user\",\n          content: prompt\n        }\n      ],\n      temperature: 0.3,\n      max_tokens: maxTokens,\n    } as any);\n\n    const analysisText = wrapped.completion.choices[0].message.content;\n    console.log('OpenAI Response:', analysisText);\n    \n    // Parse the JSON response with improved error handling\n    let analysis;\n    try {\n      if (!analysisText) {\n        throw new Error('Empty response from OpenAI');\n      }\n      \n      // Try to extract JSON from the response if it's wrapped in markdown\n      let jsonText = analysisText.trim();\n      \n      // Handle different markdown formats\n      if (jsonText.includes('```json')) {\n        const jsonMatch = jsonText.match(/```json\\s*\\n([\\s\\S]*?)\\n```/);\n        if (jsonMatch) {\n          jsonText = jsonMatch[1].trim();\n        }\n      } else if (jsonText.includes('```')) {\n        const jsonMatch = jsonText.match(/```\\s*\\n([\\s\\S]*?)\\n```/);\n        if (jsonMatch) {\n          jsonText = jsonMatch[1].trim();\n        }\n      }\n      \n      // Clean up common JSON formatting issues\n      jsonText = jsonText.replace(/^[^{]*({[\\s\\S]*})[^}]*$/, '$1');\n      \n      analysis = JSON.parse(jsonText);\n      \n      // Validate the parsed analysis has required fields\n      if (!analysis.overallRisk || !Array.isArray(analysis.interactions)) {\n        throw new Error('Invalid analysis structure');\n      }\n      \n    } catch (parseError) {\n      console.error('Failed to parse OpenAI response:', parseError);\n      console.error('Raw response:', analysisText);\n      \n      // Instead of showing broken placeholder data, return a proper error\n      return NextResponse.json({ \n        error: 'Analysis parsing failed',\n        details: 'Unable to process the interaction analysis. Please try again.',\n        rawResponse: analysisText?.substring(0, 500) // First 500 chars for debugging\n      }, { status: 500 });\n    }\n\n    // Add metadata\n    analysis.analysisDate = new Date().toISOString();\n    analysis.supplementCount = supplements.length;\n    analysis.medicationCount = medications.length;\n\n    // Generate analysis name if not provided\n    const defaultAnalysisName = analysisName || \n      `Analysis ${new Date().toLocaleDateString()} - ${supplements.length} supplements, ${medications.length} medications`;\n\n    // Save analysis to database\n    const savedAnalysis = await prisma.interactionAnalysis.create({\n      data: {\n        userId: user.id,\n        analysisName: defaultAnalysisName,\n        overallRisk: analysis.overallRisk,\n        supplementCount: supplements.length,\n        medicationCount: medications.length,\n        analysisData: analysis,\n        supplementsAnalyzed: supplements,\n        medicationsAnalyzed: medications,\n      }\n    });\n\n    // Charge wallet and update counters (skip if allowed via free use)\n    if (!allowViaFreeUse) {\n      const cm = new CreditManager(user.id);\n      const remainder = Math.max(0, wrapped.costCents - prechargedCents);\n      const ok = await cm.chargeCents(remainder);\n      if (!ok) {\n        return NextResponse.json({ error: 'Insufficient credits' }, { status: 402 });\n      }\n    }\n\n    // Update counters and consume free credits\n    if (allowViaFreeUse) {\n      await consumeFreeCredit(user.id, reanalysis ? 'INTERACTION_REANALYSIS' : 'INTERACTION_ANALYSIS');\n    }\n    // Update counters (for all users, not just premium)\n    await prisma.user.update({\n      where: { id: user.id },\n      data: ( {\n        monthlyInteractionAnalysisUsed: { increment: 1 },\n        totalInteractionAnalysisCount: { increment: 1 },\n        totalAnalysisCount: { increment: 1 },\n      } as any )\n    });\n\n    // Log AI usage for interaction analysis (fire-and-forget)\n    try {\n      await logAIUsage({\n        context: { feature: 'interactions:analysis', userId: user.id },\n        model,\n        promptTokens: wrapped.promptTokens,\n        completionTokens: wrapped.completionTokens,\n        costCents: wrapped.costCents,\n      });\n    } catch {\n      // Logging should never break the main flow\n    }\n\n    // Fire-and-forget: update insights preview based on new interaction results\n    try { fetch('/api/insights/generate?preview=1', { method: 'POST' }).catch(()=>{}) } catch {}\n    return NextResponse.json({ \n      success: true, \n      analysis,\n      analysisId: savedAnalysis.id\n    });\n\n  } catch (error) {\n    console.error('Error analyzing interactions:', error);\n    return NextResponse.json({ \n      error: 'Failed to analyze interactions',\n      details: error instanceof Error ? error.message : 'Unknown error'\n    }, { status: 500 });\n  }\n} \n","truncated":false,"size":13226},{"path":"app/api/analyze-packaged/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport OpenAI from 'openai'\nimport { runChatCompletionWithLogging } from '@/lib/ai-usage-logger'\nimport { logAiUsageEvent } from '@/lib/ai-usage-logger'\nimport { consumeRateLimit } from '@/lib/rate-limit'\nimport { getImageMetadata } from '@/lib/image-metadata'\nimport { prisma } from '@/lib/prisma'\nimport { CreditManager, CREDIT_COSTS } from '@/lib/credit-system'\nimport { consumeFreeCredit, hasFreeCredits } from '@/lib/free-credits'\nimport { isSubscriptionActive } from '@/lib/subscription-utils'\nimport { logServerCall } from '@/lib/server-call-tracker'\n\nconst RATE_LIMIT_WINDOW_MS = 60_000\nconst RATE_LIMIT_MAX = 3\n\nconst getOpenAIClient = () => {\n  if (!process.env.OPENAI_API_KEY) return null\n  return new OpenAI({ apiKey: process.env.OPENAI_API_KEY })\n}\n\nexport async function POST(req: NextRequest) {\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.email) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n\n  const contentType = req.headers.get('content-type') || ''\n  const openai = getOpenAIClient()\n  if (!openai) return NextResponse.json({ error: 'OpenAI API key not configured' }, { status: 500 })\n\n  const clientIp = (req.headers.get('x-forwarded-for') || '').split(',')[0]?.trim() || 'unknown'\n  const rateKey = (session.user as any)?.id ? `user:${(session.user as any)?.id}` : `ip:${clientIp}`\n  const rateCheck = await consumeRateLimit('analyze-packaged', rateKey, RATE_LIMIT_MAX, RATE_LIMIT_WINDOW_MS)\n  if (!rateCheck.allowed) {\n    const retryAfter = Math.max(1, Math.ceil(rateCheck.retryAfterMs / 1000))\n    return NextResponse.json(\n      { error: 'Too many packaged label analyses. Please wait and try again.' },\n      { status: 429, headers: { 'Retry-After': String(retryAfter) } }\n    )\n  }\n\n  const user = await prisma.user.findUnique({\n    where: { email: session.user.email },\n    include: { subscription: true, creditTopUps: true },\n  })\n  if (!user) return NextResponse.json({ error: 'User not found' }, { status: 404 })\n\n  logServerCall({\n    feature: 'packagedFoodLabel',\n    endpoint: '/api/analyze-packaged',\n    kind: 'analysis',\n  }).catch((error) => {\n    console.error('‚ùå Failed to log packaged label call:', error)\n  })\n\n  const isPremium = isSubscriptionActive(user.subscription)\n  const now = new Date()\n  const hasPurchasedCredits = user.creditTopUps.some(\n    (topUp: any) => topUp.expiresAt > now && (topUp.amountCents - topUp.usedCents) > 0\n  )\n  const hasFreeFoodCredits = await hasFreeCredits(user.id, 'FOOD_ANALYSIS')\n\n  let allowViaFreeUse = false\n  if (!isPremium && !hasPurchasedCredits && hasFreeFoodCredits) {\n    allowViaFreeUse = true\n  } else if (!isPremium && !hasPurchasedCredits && !hasFreeFoodCredits) {\n    return NextResponse.json(\n      {\n        error: 'Payment required',\n        message: 'You\\'ve used all your free food analyses. Subscribe to a monthly plan or purchase credits to continue.',\n        requiresPayment: true,\n        exhaustedFreeCredits: true,\n      },\n      { status: 402 }\n    )\n  }\n\n  let promptText = ''\n  let imageDataUrl: string | null = null\n  let imageMeta: ReturnType<typeof getImageMetadata> | null = null\n  let imageBytes: number | null = null\n  let imageMime: string | null = null\n\n  if (contentType.includes('application/json')) {\n    const { text } = await req.json()\n    if (!text) return NextResponse.json({ error: 'No label text provided' }, { status: 400 })\n    promptText = text\n  } else {\n    const form = await req.formData()\n    const image = form.get('image') as File | null\n    if (!image) return NextResponse.json({ error: 'No image provided' }, { status: 400 })\n    const buf = await image.arrayBuffer()\n    const base64 = Buffer.from(buf).toString('base64')\n    imageDataUrl = `data:${image.type};base64,${base64}`\n    imageMeta = getImageMetadata(buf)\n    imageBytes = buf.byteLength\n    imageMime = image.type || null\n  }\n\n  if (!allowViaFreeUse) {\n    const cm = new CreditManager(user.id)\n    const wallet = await cm.getWalletStatus()\n    if (wallet.totalAvailableCents < CREDIT_COSTS.FOOD_ANALYSIS) {\n      return NextResponse.json({ error: 'Insufficient credits' }, { status: 402 })\n    }\n    const ok = await cm.chargeCents(CREDIT_COSTS.FOOD_ANALYSIS)\n    if (!ok) {\n      return NextResponse.json({ error: 'Insufficient credits' }, { status: 402 })\n    }\n  }\n\n  // Ask the model to extract per-portion nutrition from either text or image\n  const messages: any[] = [\n    imageDataUrl\n      ? {\n          role: 'user',\n          content: [\n            {\n              type: 'text',\n              text:\n                'Read this packaged food nutrition label. Return a JSON block between <NUTR_JSON> and </NUTR_JSON> only, with fields: {\"serving_size\":\"string\",\"per_serving\":{\"calories\":0,\"protein_g\":0,\"carbs_g\":0,\"fat_g\":0,\"fiber_g\":0,\"sugar_g\":0}}. Use numbers; if unknown, use null.'\n            },\n            { type: 'image_url', image_url: { url: imageDataUrl, detail: 'high' } }\n          ]\n        }\n      : {\n          role: 'user',\n          content:\n            'Read this packaged food nutrition label text. Return a JSON block between <NUTR_JSON> and </NUTR_JSON> only, with fields: {\"serving_size\":\"string\",\"per_serving\":{\"calories\":0,\"protein_g\":0,\"carbs_g\":0,\"fat_g\":0,\"fiber_g\":0,\"sugar_g\":0}}. Use numbers; if unknown, use null.\\n\\nLabel text:\\n' +\n            promptText,\n        },\n  ]\n\n  const result: any = await runChatCompletionWithLogging(\n    openai,\n    {\n      model: 'gpt-4o-mini',\n      messages,\n      max_tokens: 400,\n      temperature: 0,\n    },\n    { feature: 'food:analyze-packaged', userId: user.id },\n    imageDataUrl\n      ? {\n          image: {\n            width: imageMeta?.width ?? null,\n            height: imageMeta?.height ?? null,\n            bytes: imageBytes,\n            mime: imageMime,\n          },\n        }\n      : undefined\n  )\n\n  if (imageDataUrl) {\n    logAiUsageEvent({\n      feature: 'food:analyze-packaged',\n      endpoint: '/api/analyze-packaged',\n      userId: user.id,\n      userLabel: user.email || null,\n      scanId: `packaged-${Date.now()}`,\n      model: 'gpt-4o-mini',\n      promptTokens: (result as any)?.promptTokens || 0,\n      completionTokens: (result as any)?.completionTokens || 0,\n      costCents: (result as any)?.costCents || 0,\n      image: {\n        width: imageMeta?.width ?? null,\n        height: imageMeta?.height ?? null,\n        bytes: imageBytes,\n        mime: imageMime,\n      },\n      success: true,\n    }).catch(() => {})\n  } else {\n    logAiUsageEvent({\n      feature: 'food:analyze-packaged',\n      endpoint: '/api/analyze-packaged',\n      userId: user.id,\n      userLabel: user.email || null,\n      scanId: `packaged-${Date.now()}`,\n      model: 'gpt-4o-mini',\n      promptTokens: (result as any)?.promptTokens || 0,\n      completionTokens: (result as any)?.completionTokens || 0,\n      costCents: (result as any)?.costCents || 0,\n      success: true,\n    }).catch(() => {})\n  }\n  const content = result.choices?.[0]?.message?.content || ''\n  const m = content.match(/<NUTR_JSON>([\\s\\S]*?)<\\/NUTR_JSON>/i)\n  let parsed: any = null\n  if (m && m[1]) {\n    try {\n      parsed = JSON.parse(m[1])\n    } catch {}\n  }\n\n  if (allowViaFreeUse) {\n    await consumeFreeCredit(user.id, 'FOOD_ANALYSIS')\n  }\n\n  return NextResponse.json({ success: true, raw: content.trim(), parsed })\n}\n","truncated":false,"size":7472},{"path":"app/api/analyze-supplement-image/route.ts","content":"import { NextRequest, NextResponse } from 'next/server';\nimport { getServerSession } from 'next-auth';\nimport { authOptions } from '@/lib/auth';\nimport OpenAI from 'openai';\nimport { logAiUsageEvent } from '@/lib/ai-usage-logger';\nimport { consumeRateLimit } from '@/lib/rate-limit';\nimport { getImageMetadata } from '@/lib/image-metadata';\nimport { prisma } from '@/lib/prisma';\nimport { CreditManager } from '@/lib/credit-system';\nimport { capMaxTokensToBudget } from '@/lib/cost-meter';\nimport { chatCompletionWithCost } from '@/lib/metered-openai';\n\nconst RATE_LIMIT_WINDOW_MS = 60_000;\nconst RATE_LIMIT_MAX = 3;\n\nfunction getOpenAIClient() {\n  if (!process.env.OPENAI_API_KEY) {\n    return null;\n  }\n  return new OpenAI({ apiKey: process.env.OPENAI_API_KEY });\n}\n\nexport async function POST(req: NextRequest) {\n  try {\n    const session = await getServerSession(authOptions);\n    if (!session?.user?.email) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n    }\n\n    const formData = await req.formData();\n    const imageFile = formData.get('image') as File;\n\n    if (!imageFile) {\n      return NextResponse.json({ error: 'No image provided' }, { status: 400 });\n    }\n\n    const clientIp = (req.headers.get('x-forwarded-for') || '').split(',')[0]?.trim() || 'unknown';\n    const rateCheck = await consumeRateLimit('supplement-image', `ip:${clientIp}`, RATE_LIMIT_MAX, RATE_LIMIT_WINDOW_MS);\n    if (!rateCheck.allowed) {\n      const retryAfter = Math.max(1, Math.ceil(rateCheck.retryAfterMs / 1000));\n      return NextResponse.json(\n        { error: 'Too many supplement image analyses. Please wait and try again.' },\n        { status: 429, headers: { 'Retry-After': String(retryAfter) } }\n      );\n    }\n\n    // Convert image to base64\n    const imageBuffer = await imageFile.arrayBuffer();\n    const imageBase64 = Buffer.from(imageBuffer).toString('base64');\n    const meta = getImageMetadata(imageBuffer);\n    \n    console.log('Analyzing supplement image:', {\n      name: imageFile.name,\n      type: imageFile.type,\n      size: imageFile.size\n    });\n\n    const user = await prisma.user.findUnique({\n      where: { email: session.user.email },\n      include: { subscription: true, creditTopUps: true },\n    });\n    if (!user) {\n      return NextResponse.json({ error: 'User not found' }, { status: 404 });\n    }\n\n    // Analyze image to extract supplement name\n    const openai = getOpenAIClient();\n    if (!openai) {\n      return NextResponse.json({ error: 'OpenAI API key not configured' }, { status: 500 });\n    }\n    const promptText = `Analyze this supplement/medication bottle or package image and extract the main product name. \n\nCRITICAL INSTRUCTIONS:\n1. Look for the PRIMARY product name on the label (e.g., \"Vitamin E\", \"Magnesium\", \"Omega-3\", \"Ibuprofen\")\n2. Ignore brand names, dosage amounts, and marketing text\n3. Return ONLY the supplement/medication name, nothing else\n4. If you can't clearly identify the product name, return \"Unknown Supplement\"\n5. Be specific - if it says \"Vitamin E 400 IU\", return \"Vitamin E\"\n6. If it's a medication, return the generic name if visible\n\nExamples of good responses:\n- \"Vitamin E\"\n- \"Magnesium\"\n- \"Omega-3\"\n- \"Multivitamin\"\n- \"Ibuprofen\"\n- \"Fish Oil\"\n\nReturn only the product name, no explanations or additional text.`;\n\n    const model = \"gpt-4o\";\n    const cm = new CreditManager(user.id);\n    const wallet = await cm.getWalletStatus();\n    const maxTokens = capMaxTokensToBudget(model, promptText, 50, wallet.totalAvailableCents);\n    if (maxTokens <= 0) {\n      return NextResponse.json({ error: 'Insufficient credits' }, { status: 402 });\n    }\n\n    const wrapped = await chatCompletionWithCost(openai, {\n      model,\n      messages: [\n        {\n          role: \"user\",\n          content: [\n            { type: \"text\", text: promptText },\n            {\n              type: \"image_url\",\n              image_url: {\n                url: `data:${imageFile.type};base64,${imageBase64}`,\n                detail: \"high\"\n              }\n            }\n          ]\n        }\n      ],\n      max_tokens: maxTokens,\n      temperature: 0.1\n    } as any);\n\n    const ok = await cm.chargeCents(wrapped.costCents);\n    if (!ok) {\n      return NextResponse.json({ error: 'Insufficient credits' }, { status: 402 });\n    }\n\n    // Persist usage (vision)\n    logAiUsageEvent({\n      feature: 'supplements:image-name',\n      endpoint: '/api/analyze-supplement-image',\n      userId: user.id,\n      userLabel: user.email || (clientIp ? `ip:${clientIp}` : null),\n      scanId: `supplement-${Date.now()}`,\n      model,\n      promptTokens: wrapped.promptTokens,\n      completionTokens: wrapped.completionTokens,\n      costCents: wrapped.costCents,\n      image: {\n        width: meta.width,\n        height: meta.height,\n        bytes: imageBuffer.byteLength,\n        mime: imageFile.type || null\n      },\n      success: true,\n    }).catch(() => {});\n\n    const supplementName = wrapped.completion.choices?.[0]?.message?.content?.trim() || 'Unknown Supplement';\n    \n    console.log('Extracted supplement name:', supplementName);\n\n    return NextResponse.json({\n      success: true,\n      supplementName: supplementName\n    });\n\n  } catch (error) {\n    console.error('Error analyzing supplement image:', error);\n    return NextResponse.json(\n      { error: 'Failed to analyze supplement image', supplementName: 'Analysis Error' },\n      { status: 500 }\n    );\n  }\n} \n","truncated":false,"size":5434},{"path":"app/api/analyze-symptoms/chat/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport OpenAI from 'openai'\nimport { prisma } from '@/lib/prisma'\nimport { CreditManager } from '@/lib/credit-system'\nimport { capMaxTokensToBudget } from '@/lib/cost-meter'\nimport { logAIUsage } from '@/lib/ai-usage-logger'\nimport { chatCompletionWithCost } from '@/lib/metered-openai'\nimport { consumeFreeCredit, hasFreeCredits } from '@/lib/free-credits'\nimport { isSubscriptionActive } from '@/lib/subscription-utils'\n\nfunction getOpenAIClient(): OpenAI | null {\n  if (!process.env.OPENAI_API_KEY) return null\n  return new OpenAI({ apiKey: process.env.OPENAI_API_KEY })\n}\n\nexport async function POST(req: NextRequest) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.email) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const contentType = req.headers.get('content-type') || ''\n    let body: {\n      message?: string\n      symptoms?: string[]\n      duration?: string\n      notes?: string\n      analysisResult?: any\n    } = {}\n    if (contentType.includes('application/json')) {\n      try {\n        body = await req.json()\n      } catch {}\n    }\n\n    const question = String(body?.message || '').trim()\n    if (!question) {\n      return NextResponse.json({ error: 'Message required' }, { status: 400 })\n    }\n\n    const { symptoms = [], duration, notes, analysisResult = {} } = body\n\n    const openai = getOpenAIClient()\n    if (!openai) {\n      return NextResponse.json({ error: 'OpenAI API key not configured' }, { status: 500 })\n    }\n    const user = await prisma.user.findUnique({ where: { email: session.user.email }, include: { subscription: true, creditTopUps: true } })\n    if (!user) {\n      return NextResponse.json({ error: 'User not found' }, { status: 404 })\n    }\n\n    const isPremium = isSubscriptionActive(user.subscription)\n    const now = new Date()\n    const hasPurchasedCredits = user.creditTopUps?.some(\n      (topUp: any) => topUp.expiresAt > now && (topUp.amountCents - topUp.usedCents) > 0\n    )\n    const hasFreeChatCredits = await hasFreeCredits(user.id, 'SYMPTOM_CHAT')\n    const allowViaFreeUse = !isPremium && !hasPurchasedCredits && hasFreeChatCredits\n    if (!isPremium && !hasPurchasedCredits && !hasFreeChatCredits) {\n      return NextResponse.json(\n        {\n          error: 'Payment required',\n          message: 'You\\'ve used all your free symptom chat uses. Subscribe to a monthly plan or purchase credits to continue.',\n          requiresPayment: true,\n          exhaustedFreeCredits: true,\n        },\n        { status: 402 }\n      )\n    }\n\n    // Build system prompt with analysis context\n    const systemPrompt = [\n      'You are a careful, patient-friendly clinical assistant helping users understand their symptom analysis.',\n      'You have access to their recent symptom analysis results. Always include a disclaimer about consulting medical professionals.',\n      '',\n      `Original symptoms: ${symptoms.join(', ')}`,\n      duration ? `Duration: ${duration}` : '',\n      notes ? `User notes: ${notes}` : '',\n      '',\n      analysisResult.summary ? `Analysis summary: ${analysisResult.summary}` : '',\n      analysisResult.possibleCauses?.length\n        ? `Likely causes:\\n${analysisResult.possibleCauses.map((c: any) => `- ${c.name} (${c.confidence}): ${c.whyLikely}`).join('\\n')}`\n        : '',\n      analysisResult.redFlags?.length ? `Red flags:\\n${analysisResult.redFlags.map((rf: string) => `- ${rf}`).join('\\n')}` : '',\n      analysisResult.nextSteps?.length ? `Next steps:\\n${analysisResult.nextSteps.map((ns: string) => `- ${ns}`).join('\\n')}` : '',\n      '',\n      'Rules:',\n      '- Be concise and practical',\n      '- Always remind users to consult healthcare professionals for concerning symptoms',\n      '- Use clear, non-technical language',\n      '- Reference specific parts of their analysis when relevant',\n      '- Avoid providing diagnoses or treatment plans',\n      '',\n      'When users ask about supplements or dietary supplements:',\n      '- Provide multiple (3-5+) specific supplement types that may be relevant to their condition',\n      '- DO NOT recommend specific brands or product names',\n      '- DO provide supplement categories/types (e.g., probiotics, digestive enzymes, omega-3 fatty acids, magnesium, vitamin D, etc.)',\n      '- Explain briefly why each supplement type might be helpful for their specific symptoms',\n      '- Always emphasize consulting a healthcare professional before starting any new supplements',\n      '- Consider multiple supplement categories: vitamins, minerals, herbal supplements, probiotics/prebiotics, enzymes, amino acids, etc.',\n    ]\n      .filter(Boolean)\n      .join('\\n')\n\n    const accept = (req.headers.get('accept') || '').toLowerCase()\n    const wantsStream = accept.includes('text/event-stream')\n\n    const chatMessages = [\n      { role: 'system' as const, content: systemPrompt },\n      { role: 'user' as const, content: question },\n    ]\n\n    if (wantsStream) {\n      const model = process.env.OPENAI_INSIGHTS_MODEL || 'gpt-4o-mini'\n      const promptText = `${systemPrompt}\\n${question}`\n      let maxTokens = 800\n      if (!allowViaFreeUse) {\n        const cm = new CreditManager(user.id)\n        const wallet = await cm.getWalletStatus()\n        const cappedMaxTokens = capMaxTokensToBudget(model, promptText, maxTokens, wallet.totalAvailableCents)\n        if (cappedMaxTokens <= 0) {\n          return NextResponse.json({ error: 'Insufficient credits' }, { status: 402 })\n        }\n        maxTokens = cappedMaxTokens\n      }\n\n      const wrapped = await chatCompletionWithCost(openai, {\n        model,\n        temperature: 0.2,\n        max_tokens: maxTokens,\n        messages: chatMessages as any,\n      } as any)\n\n      if (!allowViaFreeUse) {\n        const cm = new CreditManager(user.id)\n        const ok = await cm.chargeCents(wrapped.costCents)\n        if (!ok) {\n          return NextResponse.json({ error: 'Insufficient credits' }, { status: 402 })\n        }\n      } else {\n        await consumeFreeCredit(user.id, 'SYMPTOM_CHAT')\n      }\n\n      try {\n        await logAIUsage({\n          context: { feature: 'symptoms:chat', userId: user.id },\n          model,\n          promptTokens: wrapped.promptTokens,\n          completionTokens: wrapped.completionTokens,\n          costCents: wrapped.costCents,\n        })\n      } catch {\n        // Ignore logging failures\n      }\n\n      const text = wrapped.completion.choices?.[0]?.message?.content || ''\n      const enc = new TextEncoder()\n      const chunks = text.match(/[\\s\\S]{1,200}/g) || ['']\n      const stream = new ReadableStream({\n        start(controller) {\n          for (const chunk of chunks) {\n            controller.enqueue(enc.encode(`data: ${chunk}\\n\\n`))\n          }\n          controller.enqueue(enc.encode('event: end\\n\\n'))\n          controller.close()\n        },\n      })\n      return new Response(stream, { headers: { 'Content-Type': 'text/event-stream' } })\n    }\n\n    // Non-streaming fallback\n    {\n      const model = process.env.OPENAI_INSIGHTS_MODEL || 'gpt-4o-mini'\n      let maxTokens = 800\n      // Pre-check\n      if (!allowViaFreeUse) {\n        const cm = new CreditManager(user.id)\n        const wallet = await cm.getWalletStatus()\n        const cappedMaxTokens = capMaxTokensToBudget(\n          model,\n          `${systemPrompt}\\n${question}`,\n          maxTokens,\n          wallet.totalAvailableCents\n        )\n        if (cappedMaxTokens <= 0) {\n          return NextResponse.json({ error: 'Insufficient credits' }, { status: 402 })\n        }\n        maxTokens = cappedMaxTokens\n      }\n      const wrapped = await chatCompletionWithCost(openai, {\n        model,\n        temperature: 0.2,\n        max_tokens: maxTokens,\n        messages: chatMessages as any,\n      } as any)\n      if (!allowViaFreeUse) {\n        const cm = new CreditManager(user.id)\n        const ok = await cm.chargeCents(wrapped.costCents)\n        if (!ok) {\n          return NextResponse.json({ error: 'Insufficient credits' }, { status: 402 })\n        }\n      } else {\n        await consumeFreeCredit(user.id, 'SYMPTOM_CHAT')\n      }\n\n      // Log AI usage for non-streaming symptom chat\n      try {\n        await logAIUsage({\n          context: { feature: 'symptoms:chat', userId: user.id },\n          model,\n          promptTokens: wrapped.promptTokens,\n          completionTokens: wrapped.completionTokens,\n          costCents: wrapped.costCents,\n        })\n      } catch {\n        // Ignore logging failures\n      }\n\n      const text = wrapped.completion.choices?.[0]?.message?.content || ''\n      return NextResponse.json({ assistant: text })\n    }\n  } catch (error) {\n    console.error('[symptom-chat.POST] error', error)\n    return NextResponse.json({ error: 'server_error' }, { status: 500 })\n  }\n}\n","truncated":false,"size":8923},{"path":"app/api/analyze-symptoms/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { getToken } from 'next-auth/jwt'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\nimport { CreditManager, CREDIT_COSTS } from '@/lib/credit-system'\nimport { consumeFreeCredit, hasFreeCredits } from '@/lib/free-credits'\nimport OpenAI from 'openai'\nimport { chatCompletionWithCost } from '@/lib/metered-openai'\nimport { capMaxTokensToBudget } from '@/lib/cost-meter'\nimport { logAIUsage } from '@/lib/ai-usage-logger'\nimport { isSubscriptionActive } from '@/lib/subscription-utils'\nimport { logServerCall } from '@/lib/server-call-tracker'\n\n// Initialize OpenAI client only when API key is available (same pattern as analyze-food)\nconst getOpenAIClient = () => {\n  if (!process.env.OPENAI_API_KEY) return null\n  return new OpenAI({ apiKey: process.env.OPENAI_API_KEY })\n}\n\nexport async function POST(req: NextRequest) {\n  try {\n    // Auth check (with JWT fallback to avoid sporadic session resolution issues)\n    const session = await getServerSession(authOptions)\n    let userEmail: string | null = session?.user?.email ?? null\n    if (!userEmail) {\n      try {\n        const token = await getToken({\n          req,\n          secret: process.env.NEXTAUTH_SECRET || process.env.AUTH_SECRET || 'helfi-secret-key-production-2024',\n        })\n        if (token?.email) {\n          userEmail = token.email as string\n        }\n      } catch {\n        // ignore ‚Äì will fall through to 401 below if still missing\n      }\n    }\n    if (!userEmail) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    // Input parsing\n    const contentType = req.headers.get('content-type')\n    if (!contentType?.includes('application/json')) {\n      return NextResponse.json({ error: 'Expected application/json' }, { status: 400 })\n    }\n    const body = await req.json()\n    const { symptoms, duration, notes } = body as { symptoms?: string[] | string; duration?: string; notes?: string }\n\n    const symptomsList: string[] = Array.isArray(symptoms)\n      ? symptoms.filter(Boolean)\n      : (typeof symptoms === 'string' ? symptoms.split(/[,\\n]/).map(s => s.trim()).filter(Boolean) : [])\n\n    if (!symptomsList.length) {\n      return NextResponse.json({ error: 'Please enter at least one symptom' }, { status: 400 })\n    }\n\n    // Basic dependencies\n    const openai = getOpenAIClient()\n    if (!openai) {\n      return NextResponse.json({ error: 'OpenAI API key not configured' }, { status: 500 })\n    }\n\n    // Fetch user\n    const user = await prisma.user.findUnique({ where: { email: userEmail }, include: { subscription: true, creditTopUps: true } })\n    if (!user) {\n      return NextResponse.json({ error: 'User not found' }, { status: 404 })\n    }\n\n    logServerCall({\n      feature: 'symptomAnalysis',\n      endpoint: '/api/analyze-symptoms',\n      kind: 'analysis',\n    }).catch((error) => {\n      console.error('‚ùå Failed to log symptom analysis call:', error)\n    })\n\n    // PREMIUM/CREDITS/FREE USE GATING\n    const isPremium = isSubscriptionActive(user.subscription)\n    \n    // Check if user has purchased credits (non-expired)\n    const now = new Date()\n    const hasPurchasedCredits = user.creditTopUps.some(\n      (topUp: any) => topUp.expiresAt > now && (topUp.amountCents - topUp.usedCents) > 0\n    )\n    \n    const hasFreeSymptomCredits = await hasFreeCredits(user.id, 'SYMPTOM_ANALYSIS')\n    let allowViaFreeUse = false\n    if (!isPremium && !hasPurchasedCredits && hasFreeSymptomCredits) {\n      allowViaFreeUse = true\n    } else if (!isPremium && !hasPurchasedCredits) {\n      // No subscription, no credits, and no free credits - require payment\n      return NextResponse.json(\n        {\n          error: 'Payment required',\n          message: 'You\\'ve used all your free symptom analyses. Subscribe to a monthly plan or purchase credits to continue.',\n          requiresPayment: true,\n          exhaustedFreeCredits: true,\n        },\n        { status: 402 }\n      )\n    }\n    \n    const creditManager = new CreditManager(user.id)\n    // Trigger daily reset logic via credit system (ensures dailyMedicalAnalysisUsed resets too)\n    const creditStatus = await creditManager.checkCredits('SYMPTOM_ANALYSIS')\n\n    // Re-fetch to reflect any resets\n    const refreshedUser = await prisma.user.findUnique({ where: { id: user.id }, include: { subscription: true } })\n    if (!refreshedUser) {\n      return NextResponse.json({ error: 'User not found' }, { status: 404 })\n    }\n\n    // Daily/plan gating removed ‚Äì wallet pre-check below governs access\n\n    // Build prompt for careful, longer analysis with structured JSON\n    const symptomsStr = symptomsList.join(', ')\n    const durationStr = duration ? String(duration).trim() : 'unspecified'\n    const notesStr = notes ? String(notes).trim() : ''\n\n    const messages = [\n      {\n        role: 'user' as const,\n        content: `You are a careful clinical reasoning assistant that provides patient-friendly guidance without medical jargon.\nAnalyze the user's symptoms and produce:\n- A short summary in plain language\n- 4-7 likely causes with brief \"why likely\" and confidence (low/medium/high)\n- A clear list of red flags (urgent symptoms)\n- Practical next steps they can take now\n- Always include a disclaimer to contact a licensed medical professional\n\nImportant:\n- Be concise but careful. Do not reveal chain-of-thought; only conclusions.\n- Use non-alarming, supportive language.\n- If symptoms are potentially urgent, ensure they appear in red flags.\n\nUser Input:\nSymptoms: ${symptomsStr}\nDuration: ${durationStr}\nNotes: ${notesStr}\n\nReturn two parts:\n1) A readable explanation for the user (one to three short paragraphs and section headers)\n2) Then a compact JSON between <STRUCTURED_JSON> and </STRUCTURED_JSON> with this exact shape:\n<STRUCTURED_JSON>{\"summary\":\"string\",\"possibleCauses\":[{\"name\":\"string\",\"whyLikely\":\"string\",\"confidence\":\"low|medium|high\"}],\"redFlags\":[\"string\"],\"nextSteps\":[\"string\"],\"disclaimer\":\"string\"}</STRUCTURED_JSON>`\n      }\n    ]\n\n    // Wallet pre-check (skip when allowed via one-time free use)\n    const model = 'gpt-4o'\n    const promptText = messages.map((m) => (typeof (m as any).content === 'string' ? (m as any).content : '')).join('\\n')\n    let maxTokens = 1200\n    if (!allowViaFreeUse) {\n      const cm = new CreditManager(refreshedUser.id)\n      const wallet = await cm.getWalletStatus()\n      const cappedMaxTokens = capMaxTokensToBudget(model, promptText, maxTokens, wallet.totalAvailableCents)\n      if (cappedMaxTokens <= 0) {\n        return NextResponse.json({ error: 'Insufficient credits' }, { status: 402 })\n      }\n      maxTokens = cappedMaxTokens\n    }\n\n    // Immediate pre-charge (1 credit) before calling the model (skip for free trial)\n    let prechargedCents = 0\n    if (!allowViaFreeUse) {\n      try {\n        const cm = new CreditManager(refreshedUser.id)\n        const immediate = CREDIT_COSTS.SYMPTOM_ANALYSIS\n        const okPre = await cm.chargeCents(immediate)\n        if (!okPre) {\n          return NextResponse.json({ error: 'Insufficient credits' }, { status: 402 })\n        }\n        prechargedCents = immediate\n      } catch {\n        return NextResponse.json({ error: 'Billing error' }, { status: 402 })\n      }\n    }\n\n    // Progress is handled on UI; this call may take longer for deeper reasoning\n    const wrapped = await chatCompletionWithCost(openai, {\n      model,\n      messages,\n      max_tokens: maxTokens,\n      temperature: 0.4,\n    } as any)\n\n    const content = wrapped.completion.choices?.[0]?.message?.content || ''\n    if (!content) {\n      return NextResponse.json({ error: 'No analysis received from OpenAI' }, { status: 500 })\n    }\n\n    // Try to extract structured JSON block\n    let structured: any = null\n    try {\n      const m = content.match(/<STRUCTURED_JSON>([\\s\\S]*?)<\\/STRUCTURED_JSON>/i)\n      if (m && m[1]) {\n        structured = JSON.parse(m[1])\n      }\n    } catch {\n      // ignore parsing error, we'll still return analysisText\n    }\n\n    // Charge wallet and update counters (skip charge if allowed via free use)\n    if (!allowViaFreeUse) {\n      const cm = new CreditManager(refreshedUser.id)\n      const remainder = Math.max(0, wrapped.costCents - prechargedCents)\n      const ok = await cm.chargeCents(remainder)\n      if (!ok) {\n        return NextResponse.json({ error: 'Insufficient credits' }, { status: 402 })\n      }\n    }\n\n    // Update counters (for all users, not just premium)\n    await prisma.user.update({\n      where: { id: refreshedUser.id },\n      data: {\n        totalAnalysisCount: { increment: 1 },\n        monthlySymptomAnalysisUsed: { increment: 1 },\n      } as any,\n    })\n    \n    if (allowViaFreeUse) {\n      await consumeFreeCredit(refreshedUser.id, 'SYMPTOM_ANALYSIS')\n    }\n\n    // Log AI usage for cost tracking (fire-and-forget; does not affect user flow)\n    try {\n      await logAIUsage({\n        context: { feature: 'symptoms:analysis', userId: refreshedUser.id },\n        model,\n        promptTokens: wrapped.promptTokens,\n        completionTokens: wrapped.completionTokens,\n        costCents: wrapped.costCents,\n      })\n    } catch {\n      // Logging failures must never break the main feature\n    }\n\n    // Build response\n    const analysisText = content.replace(/<STRUCTURED_JSON>[\\s\\S]*?<\\/STRUCTURED_JSON>/i, '').trim()\n    const resp: any = {\n      success: true,\n      analysisText,\n    }\n    if (structured && typeof structured === 'object') {\n      resp.summary = structured.summary || null\n      resp.possibleCauses = Array.isArray(structured.possibleCauses) ? structured.possibleCauses : []\n      resp.redFlags = Array.isArray(structured.redFlags) ? structured.redFlags : []\n      resp.nextSteps = Array.isArray(structured.nextSteps) ? structured.nextSteps : []\n      resp.disclaimer = structured.disclaimer || 'This is not medical advice. If you have concerning or worsening symptoms, contact a licensed medical professional or emergency services.'\n    } else {\n      // Always ensure a disclaimer is present\n      resp.disclaimer = 'This is not medical advice. If you have concerning or worsening symptoms, contact a licensed medical professional or emergency services.'\n    }\n\n    try {\n      const analysisData = structured && typeof structured === 'object'\n        ? {\n            summary: resp.summary ?? null,\n            possibleCauses: resp.possibleCauses ?? [],\n            redFlags: resp.redFlags ?? [],\n            nextSteps: resp.nextSteps ?? [],\n            disclaimer: resp.disclaimer ?? null,\n          }\n        : {\n            summary: resp.summary ?? null,\n            possibleCauses: [],\n            redFlags: [],\n            nextSteps: [],\n            disclaimer: resp.disclaimer ?? null,\n          }\n\n      await prisma.symptomAnalysis.create({\n        data: {\n          userId: refreshedUser.id,\n          symptoms: symptomsList,\n          duration: duration ? String(duration).trim() : null,\n          notes: notes ? String(notes).trim() : null,\n          summary: resp.summary ?? null,\n          analysisText: analysisText || null,\n          analysisData,\n        },\n      })\n    } catch (historyError) {\n      console.warn('Failed to save symptom analysis history:', historyError)\n    }\n\n    return NextResponse.json(resp)\n  } catch (error) {\n    if (error instanceof Error) {\n      if (error.message.includes('insufficient_quota')) {\n        return NextResponse.json({ error: 'OpenAI API quota exceeded. Please check your billing.' }, { status: 429 })\n      }\n      if (error.message.includes('invalid_api_key')) {\n        return NextResponse.json({ error: 'Invalid OpenAI API key. Please check your configuration.' }, { status: 401 })\n      }\n    }\n    return NextResponse.json({ error: 'Failed to analyze symptoms' }, { status: 500 })\n  }\n}\n","truncated":false,"size":11858},{"path":"app/api/audit/food-log/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\n\n// Lightweight audit endpoint to catch cases where todaysFoods snapshots\n// were never written into the permanent FoodLog history. Intended to be\n// called by a scheduled job (e.g., Vercel Cron) with a shared secret.\nexport async function GET(req: NextRequest) {\n  const secret = process.env.AUDIT_SECRET\n  const authHeader = req.headers.get('authorization') || ''\n  if (!secret || authHeader !== `Bearer ${secret}`) {\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  }\n\n  const lookbackDays = 7\n  const since = new Date()\n  since.setDate(since.getDate() - lookbackDays)\n\n  try {\n    // Pull recent todaysFoods snapshots\n    const snapshots = await prisma.healthGoal.findMany({\n      where: {\n        name: '__TODAYS_FOODS_DATA__',\n        updatedAt: { gte: since },\n      },\n      select: {\n        userId: true,\n        category: true,\n        updatedAt: true,\n      },\n    })\n\n    const missing: Array<{\n      userId: string\n      localDate: string\n      reason: string\n    }> = []\n    let parsedSnapshots = 0\n\n    for (const snap of snapshots) {\n      let foods: any[] = []\n      try {\n        const parsed = JSON.parse(snap.category || '{}')\n        foods = Array.isArray(parsed?.foods) ? parsed.foods : []\n      } catch {\n        missing.push({\n          userId: snap.userId,\n          localDate: 'unknown',\n          reason: 'Failed to parse todaysFoods snapshot',\n        })\n        continue\n      }\n\n      parsedSnapshots += 1\n      const byDate = new Map<string, any[]>()\n      for (const f of foods) {\n        const date =\n          (typeof f?.localDate === 'string' && f.localDate.length >= 8\n            ? f.localDate\n            : null) ||\n          null\n        if (!date) continue\n        if (!byDate.has(date)) byDate.set(date, [])\n        byDate.get(date)?.push(f)\n      }\n\n      const entriesArray = Array.from(byDate.entries())\n      for (let i = 0; i < entriesArray.length; i++) {\n        const [date, entries] = entriesArray[i]\n        // Check if FoodLog has at least as many rows for that date\n        const count = await prisma.foodLog.count({\n          where: { userId: snap.userId, localDate: date },\n        })\n        if (count < entries.length) {\n          missing.push({\n            userId: snap.userId,\n            localDate: date,\n            reason: `Expected >=${entries.length} entries from snapshot; found ${count} in FoodLog`,\n          })\n        }\n      }\n    }\n\n    return NextResponse.json({\n      ok: true,\n      checkedSnapshots: parsedSnapshots,\n      missingCount: missing.length,\n      missing,\n    })\n  } catch (error) {\n    console.error('‚ùå Audit /api/audit/food-log error', error)\n    return NextResponse.json({ error: 'Audit failed', details: String(error) }, { status: 500 })\n  }\n}\n","truncated":false,"size":2857},{"path":"app/api/auth-test/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth/next'\nimport { authOptions } from '@/lib/auth'\n\n// This API route uses dynamic request data and should not be statically generated\nexport const runtime = 'nodejs'\nexport const dynamic = 'force-dynamic'\n\nexport async function GET(request: NextRequest) {\n  try {\n    console.log('=== AUTH TEST DEBUG START ===')\n    console.log('Request URL:', request.url)\n    console.log('Request headers:', Object.fromEntries(request.headers.entries()))\n    \n    // Test NextAuth session\n    const session = await getServerSession(authOptions)\n    \n    console.log('NextAuth session result:', session)\n    console.log('Session user:', session?.user)\n    console.log('Session user email:', session?.user?.email)\n    \n    // Return detailed debug info\n    return NextResponse.json({\n      debug: 'Authentication Test Endpoint',\n      timestamp: new Date().toISOString(),\n      session: session,\n      sessionExists: !!session,\n      userExists: !!session?.user,\n      userEmail: session?.user?.email || null,\n      authOptionsConfigured: {\n        hasProviders: !!authOptions.providers && authOptions.providers.length > 0,\n        sessionStrategy: authOptions.session?.strategy || 'default',\n        hasSecret: !!authOptions.secret,\n        debugEnabled: authOptions.debug || false\n      },\n      headers: {\n        authorization: request.headers.get('authorization') || null,\n        cookie: request.headers.get('cookie') || null,\n        userAgent: request.headers.get('user-agent') || null\n      }\n    })\n    \n  } catch (error) {\n    console.error('Auth test error:', error)\n    return NextResponse.json({ \n      error: 'Auth test failed', \n      details: error instanceof Error ? error.message : 'Unknown error',\n      timestamp: new Date().toISOString()\n    }, { status: 500 })\n  }\n} ","truncated":false,"size":1871},{"path":"app/api/auth/[...nextauth]/route.ts","content":"import NextAuth from 'next-auth'\nimport { authOptions } from '@/lib/auth'\n\nconst handler = NextAuth(authOptions)\n\nexport { handler as GET, handler as POST } ","truncated":false,"size":157},{"path":"app/api/auth/fitbit/authorize/route.ts","content":"export const dynamic = 'force-dynamic';\n\nimport { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\n\n/**\n * Initiate Fitbit OAuth flow\n * GET /api/auth/fitbit/authorize\n */\nexport async function GET(request: NextRequest) {\n  try {\n    const session = await getServerSession(authOptions)\n    \n    if (!session?.user?.id) {\n      return NextResponse.json(\n        { error: 'Unauthorized - Please sign in first' },\n        { status: 401 }\n      )\n    }\n\n    const clientId = process.env.FITBIT_CLIENT_ID\n    const redirectUri = process.env.FITBIT_REDIRECT_URI || 'https://helfi.ai/api/auth/fitbit/callback'\n    const scopes = 'activity heartrate sleep profile weight'\n    \n    if (!clientId) {\n      return NextResponse.json(\n        { error: 'Fitbit client ID not configured' },\n        { status: 500 }\n      )\n    }\n\n    // Generate state parameter for CSRF protection\n    const state = Buffer.from(JSON.stringify({ userId: session.user.id })).toString('base64')\n    \n    // Store state in session/cookie for verification\n    const authUrl = `https://www.fitbit.com/oauth2/authorize?` +\n      `response_type=code&` +\n      `client_id=${clientId}&` +\n      `redirect_uri=${encodeURIComponent(redirectUri)}&` +\n      `scope=${encodeURIComponent(scopes)}&` +\n      `state=${encodeURIComponent(state)}`\n\n    return NextResponse.redirect(authUrl)\n  } catch (error) {\n    console.error('‚ùå Fitbit authorization error:', error)\n    return NextResponse.json(\n      { error: 'Failed to initiate Fitbit authorization' },\n      { status: 500 }\n    )\n  }\n}\n","truncated":false,"size":1666},{"path":"app/api/auth/fitbit/callback/route.ts","content":"export const dynamic = 'force-dynamic';\n\nimport { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\n\n/**\n * Handle Fitbit OAuth callback\n * GET /api/auth/fitbit/callback\n */\nexport async function GET(request: NextRequest) {\n  try {\n    const searchParams = request.nextUrl.searchParams\n    const code = searchParams.get('code')\n    const state = searchParams.get('state')\n    const error = searchParams.get('error')\n\n    if (error) {\n      console.error('‚ùå Fitbit OAuth error:', error)\n      const errorHtml = `\n        <!DOCTYPE html>\n        <html>\n          <head>\n            <title>Fitbit Connection Failed</title>\n          </head>\n          <body>\n            <script>\n              if (window.opener) {\n                window.opener.postMessage({ type: 'FITBIT_ERROR', error: '${error}' }, '*')\n                setTimeout(() => window.close(), 2000)\n              } else {\n                window.location.href = '/devices?fitbit_error=${encodeURIComponent(error)}'\n              }\n            </script>\n            <div style=\"text-align: center; padding: 40px; font-family: Arial, sans-serif;\">\n              <h2>‚ùå Connection Failed</h2>\n              <p>Error: ${error}</p>\n              <p>This window will close automatically.</p>\n            </div>\n          </body>\n        </html>\n      `\n      return new NextResponse(errorHtml, {\n        headers: { 'Content-Type': 'text/html' },\n      })\n    }\n\n    if (!code || !state) {\n      const errorHtml = `\n        <!DOCTYPE html>\n        <html>\n          <head>\n            <title>Fitbit Connection Failed</title>\n          </head>\n          <body>\n            <script>\n              if (window.opener) {\n                window.opener.postMessage({ type: 'FITBIT_ERROR', error: 'missing_params' }, '*')\n                setTimeout(() => window.close(), 2000)\n              } else {\n                window.location.href = '/devices?fitbit_error=missing_params'\n              }\n            </script>\n            <div style=\"text-align: center; padding: 40px; font-family: Arial, sans-serif;\">\n              <h2>‚ùå Connection Failed</h2>\n              <p>Missing required parameters.</p>\n              <p>This window will close automatically.</p>\n            </div>\n          </body>\n        </html>\n      `\n      return new NextResponse(errorHtml, {\n        headers: { 'Content-Type': 'text/html' },\n      })\n    }\n\n    // Verify state and get userId\n    let userId: string\n    try {\n      const decodedState = JSON.parse(Buffer.from(state, 'base64').toString())\n      userId = decodedState.userId\n    } catch (e) {\n      console.error('‚ùå Invalid state parameter:', e)\n      return NextResponse.redirect(\n        new URL('/devices?fitbit_error=invalid_state', request.nextUrl.origin)\n      )\n    }\n\n    // Verify user session matches state\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id || session.user.id !== userId) {\n      return NextResponse.redirect(\n        new URL('/devices?fitbit_error=session_mismatch', request.nextUrl.origin)\n      )\n    }\n\n    const clientId = process.env.FITBIT_CLIENT_ID\n    const clientSecret = process.env.FITBIT_CLIENT_SECRET\n    const redirectUri = process.env.FITBIT_REDIRECT_URI || 'https://helfi.ai/api/auth/fitbit/callback'\n\n    if (!clientId || !clientSecret) {\n      console.error('‚ùå Fitbit credentials not configured')\n      return NextResponse.redirect(\n        new URL('/devices?fitbit_error=config_missing', request.nextUrl.origin)\n      )\n    }\n\n    // Exchange authorization code for access token\n    const tokenResponse = await fetch('https://api.fitbit.com/oauth2/token', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n        Authorization: `Basic ${Buffer.from(`${clientId}:${clientSecret}`).toString('base64')}`,\n      },\n      body: new URLSearchParams({\n        grant_type: 'authorization_code',\n        code,\n        redirect_uri: redirectUri,\n      }),\n    })\n\n    if (!tokenResponse.ok) {\n      const errorData = await tokenResponse.text()\n      console.error('‚ùå Fitbit token exchange failed:', errorData)\n      return NextResponse.redirect(\n        new URL('/devices?fitbit_error=token_exchange_failed', request.nextUrl.origin)\n      )\n    }\n\n    const tokens = await tokenResponse.json()\n\n    // Get Fitbit user profile to get user ID\n    const profileResponse = await fetch('https://api.fitbit.com/1/user/-/profile.json', {\n      headers: {\n        Authorization: `Bearer ${tokens.access_token}`,\n      },\n    })\n\n    if (!profileResponse.ok) {\n      console.error('‚ùå Failed to fetch Fitbit profile')\n      return NextResponse.redirect(\n        new URL('/devices?fitbit_error=profile_fetch_failed', request.nextUrl.origin)\n      )\n    }\n\n    const profile = await profileResponse.json()\n    const fitbitUserId = profile.user.encodedId\n\n    // Store or update Fitbit account in database\n    const expiresAt = tokens.expires_in\n      ? Math.floor(Date.now() / 1000) + tokens.expires_in\n      : null\n\n    await prisma.account.upsert({\n      where: {\n        provider_providerAccountId: {\n          provider: 'fitbit',\n          providerAccountId: fitbitUserId,\n        },\n      },\n      update: {\n        access_token: tokens.access_token,\n        refresh_token: tokens.refresh_token,\n        expires_at: expiresAt,\n        token_type: tokens.token_type,\n        scope: tokens.scope,\n      },\n      create: {\n        userId: session.user.id,\n        type: 'oauth',\n        provider: 'fitbit',\n        providerAccountId: fitbitUserId,\n        access_token: tokens.access_token,\n        refresh_token: tokens.refresh_token,\n        expires_at: expiresAt,\n        token_type: tokens.token_type,\n        scope: tokens.scope,\n      },\n    })\n\n    console.log('‚úÖ Fitbit account linked successfully:', { userId: session.user.id, fitbitUserId })\n\n    // Return a page that will redirect and close popup\n    // Since window.opener might be lost after Fitbit redirects, we'll use a redirect approach\n    // The parent window will poll for connection status\n    const html = `\n      <!DOCTYPE html>\n      <html>\n        <head>\n          <title>Fitbit Connected</title>\n          <meta http-equiv=\"refresh\" content=\"2;url=/devices?fitbit_connected=true\">\n        </head>\n        <body style=\"margin: 0; padding: 0; font-family: Arial, sans-serif; background: linear-gradient(135deg, #10b981 0%, #059669 100%); display: flex; align-items: center; justify-content: center; min-height: 100vh;\">\n          <div style=\"text-align: center; padding: 40px; color: white;\">\n            <div style=\"font-size: 48px; margin-bottom: 20px;\">‚úÖ</div>\n            <h2 style=\"margin: 0 0 10px 0; font-size: 24px;\">Fitbit Connected Successfully!</h2>\n            <p style=\"margin: 0; opacity: 0.9;\">Redirecting you back to Helfi...</p>\n            <p style=\"margin-top: 20px; font-size: 14px; opacity: 0.8;\">You can close this window if it doesn't close automatically.</p>\n          </div>\n          <script>\n            // Try to notify parent and close popup\n            try {\n              if (window.opener && !window.opener.closed) {\n                window.opener.postMessage({ type: 'FITBIT_CONNECTED', success: true }, '*')\n                setTimeout(() => {\n                  try {\n                    window.close()\n                  } catch (e) {\n                    // If we can't close, redirect parent\n                    if (window.opener) {\n                      window.opener.location.href = '/devices?fitbit_connected=true'\n                    }\n                  }\n                }, 1000)\n              } else {\n                // Not a popup or opener lost, redirect this window\n                setTimeout(() => {\n                  window.location.href = '/devices?fitbit_connected=true'\n                }, 2000)\n              }\n            } catch (e) {\n              // Fallback: redirect this window\n              setTimeout(() => {\n                window.location.href = '/devices?fitbit_connected=true'\n              }, 2000)\n            }\n          </script>\n        </body>\n      </html>\n    `\n\n    return new NextResponse(html, {\n      headers: { 'Content-Type': 'text/html' },\n    })\n  } catch (error) {\n    console.error('‚ùå Fitbit callback error:', error)\n    return NextResponse.redirect(\n      new URL('/devices?fitbit_error=callback_failed', request.nextUrl.origin)\n    )\n  }\n}\n","truncated":false,"size":8527},{"path":"app/api/auth/garmin/authorize/route.ts","content":"export const dynamic = 'force-dynamic'\n\nimport { NextRequest, NextResponse } from 'next/server'\nimport crypto from 'crypto'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport {\n  assertGarminConfigured,\n  buildGarminAuthorizeUrl,\n  generatePkcePair,\n} from '@/lib/garmin-oauth'\n\n/**\n * Initiate Garmin OAuth 2.0 PKCE flow\n * GET /api/auth/garmin/authorize\n */\nexport async function GET(request: NextRequest) {\n  try {\n    const garminConnectEnabled = process.env.NEXT_PUBLIC_GARMIN_CONNECT_ENABLED !== 'false'\n    if (!garminConnectEnabled) {\n      return NextResponse.redirect(new URL('/devices?garmin_error=disabled', request.nextUrl.origin))\n    }\n\n    const session = await getServerSession(authOptions)\n    \n    if (!session?.user?.id) {\n      return NextResponse.json({ error: 'Unauthorized - please sign in first' }, { status: 401 })\n    }\n\n    assertGarminConfigured()\n    const callbackUrl =\n      process.env.GARMIN_REDIRECT_URI ||\n      new URL('/api/auth/garmin/callback', request.nextUrl.origin).toString()\n\n    const { codeVerifier, codeChallenge } = generatePkcePair()\n    const state = crypto.randomUUID()\n    const authUrl = buildGarminAuthorizeUrl(codeChallenge, state, callbackUrl)\n    const response = NextResponse.redirect(authUrl)\n    response.cookies.set(\n      'garmin_pkce',\n      JSON.stringify({\n        state,\n        codeVerifier,\n        userId: session.user.id,\n        exp: Date.now() + 15 * 60 * 1000,\n      }),\n      {\n        httpOnly: true,\n        secure: true,\n        sameSite: 'lax',\n        path: '/',\n        maxAge: 15 * 60,\n      }\n    )\n    return response\n  } catch (error) {\n    console.error('‚ùå Garmin authorization init failed:', error)\n    return NextResponse.json(\n      { error: 'Failed to start Garmin authorization', detail: (error as Error)?.message },\n      { status: 500 }\n    )\n  }\n}\n","truncated":false,"size":1886},{"path":"app/api/auth/garmin/callback/route.ts","content":"export const dynamic = 'force-dynamic'\nexport const runtime = 'nodejs'\n\nimport { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\nimport {\n  assertGarminConfigured,\n  exchangeGarminCodeForTokens,\n  fetchGarminUserId,\n  registerGarminUser,\n} from '@/lib/garmin-oauth'\n\n/**\n * Garmin OAuth callback\n * GET /api/auth/garmin/callback\n */\nexport async function GET(request: NextRequest) {\n  const url = new URL(request.url)\n  const code = url.searchParams.get('code')\n  const state = url.searchParams.get('state')\n  const pkceCookie = request.cookies.get('garmin_pkce')?.value\n\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.id) {\n    return NextResponse.redirect(new URL('/devices?garmin_error=unauthorized', request.nextUrl.origin))\n  }\n\n  if (!code || !state) {\n    return NextResponse.redirect(new URL('/devices?garmin_error=missing_params', request.nextUrl.origin))\n  }\n\n  try {\n    assertGarminConfigured()\n\n    if (!pkceCookie) {\n      return NextResponse.redirect(new URL('/devices?garmin_error=invalid_request_token', request.nextUrl.origin))\n    }\n\n    let parsedPkce: { state: string; codeVerifier: string; userId: string; exp: number } | null = null\n    try {\n      parsedPkce = JSON.parse(pkceCookie)\n    } catch {\n      parsedPkce = null\n    }\n\n    if (!parsedPkce || parsedPkce.state !== state || parsedPkce.userId !== session.user.id) {\n      return NextResponse.redirect(new URL('/devices?garmin_error=invalid_request_token', request.nextUrl.origin))\n    }\n\n    const callbackUrl =\n      process.env.GARMIN_REDIRECT_URI ||\n      new URL('/api/auth/garmin/callback', request.nextUrl.origin).toString()\n\n    const tokenResponse = await exchangeGarminCodeForTokens(code, parsedPkce.codeVerifier, callbackUrl)\n    const expiresAt = tokenResponse.expires_in\n      ? Math.floor(Date.now() / 1000) + tokenResponse.expires_in\n      : null\n\n    const userInfo = await fetchGarminUserId(tokenResponse.access_token)\n\n    // Store Garmin tokens on the Account table (provider = garmin)\n    const existingAccount = await prisma.account.findFirst({\n      where: {\n        userId: session.user.id,\n        provider: 'garmin',\n      },\n    })\n\n    if (existingAccount) {\n      await prisma.account.update({\n        where: { id: existingAccount.id },\n        data: {\n          providerAccountId: userInfo.userId || existingAccount.providerAccountId,\n          access_token: tokenResponse.access_token,\n          refresh_token: tokenResponse.refresh_token,\n          token_type: tokenResponse.token_type || 'bearer',\n          scope: tokenResponse.scope || existingAccount.scope,\n          expires_at: expiresAt ?? existingAccount.expires_at,\n        },\n      })\n    } else {\n      await prisma.account.create({\n        data: {\n          userId: session.user.id,\n          type: 'oauth',\n          provider: 'garmin',\n          providerAccountId: userInfo.userId || tokenResponse.access_token,\n          access_token: tokenResponse.access_token,\n          refresh_token: tokenResponse.refresh_token,\n          token_type: tokenResponse.token_type || 'bearer',\n          scope: tokenResponse.scope || 'garmin_wellness',\n          expires_at: expiresAt ?? undefined,\n        },\n      })\n    }\n\n    // Register the user for push notifications starting 30 days back\n    const uploadStart = Date.now() - 30 * 24 * 60 * 60 * 1000\n    try {\n      const registration = await registerGarminUser(tokenResponse.access_token, uploadStart)\n      if (!registration.ok) {\n        console.warn('‚ö†Ô∏è Garmin registration failed:', registration.status, await registration.text())\n      }\n    } catch (regError) {\n      console.warn('‚ö†Ô∏è Garmin registration error:', regError)\n    }\n\n    const successHtml = `\n      <!DOCTYPE html>\n      <html>\n        <body style=\"font-family: sans-serif; padding: 20px;\">\n          <h3>Garmin Connected</h3>\n          <p>You can close this window.</p>\n          <script>\n            try {\n              if (window.opener) {\n                window.opener.postMessage({ type: 'GARMIN_CONNECTED', success: true }, '*');\n                window.opener.location.href = '/devices?garmin_connected=true';\n              }\n            } catch (e) {}\n            setTimeout(function() { window.location.href = '/devices?garmin_connected=true'; }, 500);\n          </script>\n        </body>\n      </html>\n    `\n\n    const successResponse = new NextResponse(successHtml, {\n      status: 200,\n      headers: { 'Content-Type': 'text/html' },\n    })\n    successResponse.cookies.set('garmin_pkce', '', { maxAge: 0, path: '/' })\n    return successResponse\n  } catch (error) {\n    console.error('‚ùå Garmin callback error:', error)\n    return NextResponse.redirect(new URL('/devices?garmin_error=callback_failed', request.nextUrl.origin))\n  }\n}\n","truncated":false,"size":4892},{"path":"app/api/auth/password-reset/confirm/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\nimport crypto from 'crypto'\nimport bcrypt from 'bcryptjs'\n\nexport async function POST(request: NextRequest) {\n  try {\n    const body = await request.json().catch(() => ({}))\n    const email = String(body?.email || '').trim().toLowerCase()\n    const token = String(body?.token || '').trim()\n    const password = String(body?.password || '')\n\n    if (!email || !token || !password) {\n      return NextResponse.json({ error: 'Missing required fields' }, { status: 400 })\n    }\n\n    if (password.length < 8) {\n      return NextResponse.json({ error: 'Password must be at least 8 characters long' }, { status: 400 })\n    }\n\n    const tokenHash = crypto.createHash('sha256').update(token).digest('hex')\n    const record = await prisma.passwordResetToken.findUnique({\n      where: { tokenHash },\n    })\n\n    if (!record || record.email !== email) {\n      return NextResponse.json({ error: 'Invalid or expired reset link' }, { status: 400 })\n    }\n\n    if (record.expires < new Date()) {\n      await prisma.passwordResetToken.deleteMany({ where: { email } })\n      return NextResponse.json({ error: 'Reset link expired' }, { status: 400 })\n    }\n\n    const passwordHash = await bcrypt.hash(password, 12)\n    const user = await prisma.user.findUnique({ where: { email } })\n    if (!user) {\n      return NextResponse.json({ error: 'Account not found' }, { status: 404 })\n    }\n\n    await prisma.user.update({\n      where: { email },\n      data: {\n        passwordHash,\n        emailVerified: user.emailVerified ?? new Date(),\n      },\n    })\n\n    await prisma.passwordResetToken.deleteMany({ where: { email } })\n\n    return NextResponse.json({ success: true })\n  } catch (error) {\n    console.error('Password reset confirm error:', error)\n    return NextResponse.json({ error: 'Failed to reset password' }, { status: 500 })\n  }\n}\n","truncated":false,"size":1914},{"path":"app/api/auth/password-reset/request/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\nimport { Resend } from 'resend'\nimport crypto from 'crypto'\nimport { getEmailFooter } from '@/lib/email-footer'\n\nconst RESET_TOKEN_TTL_HOURS = 2\n\nfunction getResend() {\n  if (!process.env.RESEND_API_KEY) return null\n  return new Resend(process.env.RESEND_API_KEY)\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    const body = await request.json().catch(() => ({}))\n    const email = String(body?.email || '').trim().toLowerCase()\n    if (!email) {\n      return NextResponse.json({ error: 'Email is required' }, { status: 400 })\n    }\n\n    const user = await prisma.user.findUnique({ where: { email } })\n    // Always return success to avoid revealing which emails exist.\n    if (!user) {\n      return NextResponse.json({ success: true })\n    }\n\n    const token = crypto.randomBytes(32).toString('hex')\n    const tokenHash = crypto.createHash('sha256').update(token).digest('hex')\n    const expires = new Date(Date.now() + RESET_TOKEN_TTL_HOURS * 60 * 60 * 1000)\n\n    await prisma.passwordResetToken.deleteMany({ where: { email } })\n    await prisma.passwordResetToken.create({\n      data: {\n        email,\n        tokenHash,\n        expires,\n      },\n    })\n\n    const resend = getResend()\n    if (!resend) {\n      return NextResponse.json({ error: 'Email system not configured' }, { status: 500 })\n    }\n\n    const resetUrl = `https://helfi.ai/auth/reset-password?token=${token}&email=${encodeURIComponent(email)}`\n\n    await resend.emails.send({\n      from: 'Helfi Team <support@helfi.ai>',\n      to: email,\n      subject: 'Reset your Helfi password',\n      html: `\n        <div style=\"font-family: 'Segoe UI', Arial, sans-serif; max-width: 600px; margin: 0 auto; color: #333; background: #f8fafc;\">\n          <div style=\"background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; padding: 40px 30px; text-align: center; border-radius: 12px 12px 0 0;\">\n            <h1 style=\"margin: 0; font-size: 32px; font-weight: bold; letter-spacing: -0.5px;\">Helfi</h1>\n            <p style=\"margin: 12px 0 0 0; opacity: 0.95; font-size: 16px;\">Password Reset</p>\n          </div>\n          \n          <div style=\"padding: 40px 30px; background: white; border-radius: 0 0 12px 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);\">\n            <p style=\"margin: 0 0 20px 0; line-height: 1.7; font-size: 16px; color: #4b5563;\">\n              We received a request to reset your password. Click the button below to set a new password.\n            </p>\n            \n            <div style=\"background: #fef3c7; border: 1px solid #f59e0b; border-radius: 8px; padding: 16px; margin: 20px 0;\">\n              <p style=\"margin: 0; color: #92400e; font-size: 14px;\">\n                <strong>‚ö†Ô∏è Security Notice:</strong> This link expires in ${RESET_TOKEN_TTL_HOURS} hours.\n              </p>\n            </div>\n            \n            <div style=\"margin: 30px 0; text-align: center;\">\n              <a href=\"${resetUrl}\" style=\"display: inline-block; background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; text-decoration: none; padding: 16px 32px; border-radius: 8px; font-weight: 600; font-size: 16px; box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);\">\n                Reset Password\n              </a>\n            </div>\n            \n            <p style=\"margin: 20px 0 0 0; line-height: 1.7; font-size: 14px; color: #6b7280;\">\n              If you did not request this, you can ignore this email.\n            </p>\n            \n            ${getEmailFooter({ recipientEmail: email, emailType: 'support' })}\n          </div>\n        </div>\n      `,\n    })\n\n    return NextResponse.json({ success: true })\n  } catch (error) {\n    console.error('Password reset request error:', error)\n    return NextResponse.json({ error: 'Failed to request password reset' }, { status: 500 })\n  }\n}\n","truncated":false,"size":3914},{"path":"app/api/auth/refresh/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { decode, encode } from 'next-auth/jwt'\nimport { prisma } from '@/lib/prisma'\n\nconst SECRET = process.env.NEXTAUTH_SECRET\nconst REFRESH_HEADER = 'x-helfi-refresh-token'\nconst SESSION_MAX_AGE_SECONDS = 7 * 24 * 60 * 60 // 7 days for session cookies; refresh token is long-lived\n\nexport async function POST(req: NextRequest) {\n  try {\n    if (process.env.NODE_ENV === 'production') {\n      return NextResponse.json({ error: 'Not found' }, { status: 404 })\n    }\n    if (!SECRET) {\n      return NextResponse.json({ error: 'Auth secret not configured' }, { status: 500 })\n    }\n    const body = await req.json().catch(() => ({}))\n    const headerToken = req.headers.get(REFRESH_HEADER)\n    const cookieToken = req.cookies.get('__Secure-helfi-refresh-token')?.value\n    const refreshToken = typeof body.token === 'string' && body.token.length > 0\n      ? body.token\n      : headerToken || cookieToken\n\n    if (!refreshToken) {\n      return NextResponse.json({ error: 'Missing refresh token' }, { status: 400 })\n    }\n\n    const decoded = await decode({ token: refreshToken, secret: SECRET }).catch(() => null)\n    const exp = (decoded as any)?.exp\n    const nowSeconds = Math.floor(Date.now() / 1000)\n\n    if (!decoded || !exp || typeof exp !== 'number' || exp <= nowSeconds) {\n      return NextResponse.json({ error: 'Invalid or expired token' }, { status: 401 })\n    }\n\n    if ((decoded as any)?.kind && (decoded as any).kind !== 'refresh') {\n      return NextResponse.json({ error: 'Wrong token kind' }, { status: 401 })\n    }\n\n    const userId = (decoded as any)?.sub as string\n    if (!userId) {\n      return NextResponse.json({ error: 'Invalid user' }, { status: 401 })\n    }\n\n    const user = await prisma.user.findUnique({ where: { id: userId } })\n    if (!user) {\n      return NextResponse.json({ error: 'User not found' }, { status: 401 })\n    }\n\n    const sessionExp = nowSeconds + SESSION_MAX_AGE_SECONDS\n    const sessionToken = await encode({\n      token: {\n        sub: user.id,\n        id: user.id,\n        email: user.email,\n        name: user.name || user.email.split('@')[0],\n        image: user.image,\n        iat: nowSeconds,\n        exp: sessionExp,\n      },\n      secret: SECRET,\n      maxAge: SESSION_MAX_AGE_SECONDS,\n    })\n\n    const response = NextResponse.json({ ok: true, sessionExpiresAt: sessionExp * 1000 })\n    const secure = false\n    const sameSite = 'lax'\n\n    response.cookies.set('__Secure-next-auth.session-token', sessionToken, {\n      httpOnly: true,\n      secure,\n      sameSite,\n      path: '/',\n      maxAge: SESSION_MAX_AGE_SECONDS,\n    })\n    // Refresh cookie: renew alongside session so the server always has a restore token\n    response.cookies.set('__Secure-helfi-refresh-token', refreshToken, {\n      httpOnly: true,\n      secure,\n      sameSite,\n      path: '/',\n      maxAge: SESSION_MAX_AGE_SECONDS,\n    })\n    response.cookies.set('next-auth.session-token', sessionToken, {\n      httpOnly: true,\n      secure,\n      sameSite,\n      path: '/',\n      maxAge: SESSION_MAX_AGE_SECONDS,\n    })\n\n    return response\n  } catch (err) {\n    console.error('Refresh token exchange failed', err)\n    return NextResponse.json({ error: 'Refresh failed' }, { status: 500 })\n  }\n}\n","truncated":false,"size":3278},{"path":"app/api/auth/resend-verification/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\nimport { Resend } from 'resend'\nimport { getEmailFooter } from '@/lib/email-footer'\n\n// Initialize Resend\nfunction getResend() {\n  if (!process.env.RESEND_API_KEY) {\n    return null\n  }\n  return new Resend(process.env.RESEND_API_KEY)\n}\n\n// Function to generate verification token\nfunction generateVerificationToken(): string {\n  return Math.random().toString(36).substring(2) + Date.now().toString(36)\n}\n\n// Function to send verification email\nasync function sendVerificationEmail(email: string, token: string) {\n  const resend = getResend()\n  if (!resend) {\n    console.log('üìß Resend API not configured, skipping verification email')\n    return false\n  }\n\n  try {\n    const verificationUrl = `https://helfi.ai/api/auth/verify?token=${token}&email=${encodeURIComponent(email)}`\n    \n    const emailResponse = await resend.emails.send({\n      from: 'Helfi Team <support@helfi.ai>',\n      to: email,\n      subject: 'üîê Verify Your Helfi Account - Action Required',\n      html: `\n        <div style=\"font-family: 'Segoe UI', Arial, sans-serif; max-width: 600px; margin: 0 auto; color: #333; background: #f8fafc;\">\n          <div style=\"background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; padding: 40px 30px; text-align: center; border-radius: 12px 12px 0 0;\">\n            <h1 style=\"margin: 0; font-size: 32px; font-weight: bold; letter-spacing: -0.5px;\">Helfi</h1>\n            <p style=\"margin: 12px 0 0 0; opacity: 0.95; font-size: 16px;\">Account Verification Required</p>\n          </div>\n          \n          <div style=\"padding: 40px 30px; background: white; border-radius: 0 0 12px 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);\">\n            <h2 style=\"margin: 0 0 20px 0; color: #374151; font-size: 24px;\">üîê Verify Your Email Address</h2>\n            \n            <p style=\"margin: 0 0 20px 0; line-height: 1.7; font-size: 16px; color: #4b5563;\">\n              Please verify your email address by clicking the button below to complete your account setup.\n            </p>\n            \n            <div style=\"background: #fef3c7; border: 1px solid #f59e0b; border-radius: 8px; padding: 16px; margin: 20px 0;\">\n              <p style=\"margin: 0; color: #92400e; font-size: 14px;\">\n                <strong>‚ö†Ô∏è Security Notice:</strong> This link expires in 24 hours for your protection.\n              </p>\n            </div>\n            \n            <div style=\"margin: 30px 0; text-align: center;\">\n              <a href=\"${verificationUrl}\" style=\"display: inline-block; background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; text-decoration: none; padding: 16px 32px; border-radius: 8px; font-weight: 600; font-size: 16px; box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);\">\n                ‚úÖ Verify Email Address\n              </a>\n            </div>\n            \n            <div style=\"background: #f3f4f6; border-radius: 8px; padding: 20px; margin: 30px 0;\">\n              <p style=\"margin: 0 0 10px 0; font-size: 14px; color: #374151;\"><strong>Can't click the button?</strong></p>\n              <p style=\"margin: 0; font-size: 14px; color: #6b7280; word-break: break-all;\">\n                Copy and paste this link: ${verificationUrl}\n              </p>\n            </div>\n            \n            <p style=\"margin: 30px 0 0 0; line-height: 1.7; font-size: 14px; color: #6b7280;\">\n              If you didn't create a Helfi account, please ignore this email or contact our support team.\n            </p>\n            \n            ${getEmailFooter({ recipientEmail: email, emailType: 'verification' })}\n          </div>\n        </div>\n      `\n    })\n\n    console.log(`‚úÖ [VERIFICATION EMAIL RESENT] Sent to ${email} with ID: ${emailResponse.data?.id}`)\n    return true\n  } catch (error) {\n    console.error(`‚ùå [VERIFICATION EMAIL RESEND] Failed to send to ${email}:`, error)\n    return false\n  }\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    const { email } = await request.json()\n\n    if (!email) {\n      return NextResponse.json({ error: 'Email address is required' }, { status: 400 })\n    }\n\n    console.log('üìß Resend verification request for:', email)\n\n    // Find user in database\n    const user = await prisma.user.findUnique({\n      where: { email: email.toLowerCase() }\n    })\n\n    if (!user) {\n      return NextResponse.json({ error: 'Account not found' }, { status: 404 })\n    }\n\n    // Check if user is already verified\n    if (user.emailVerified) {\n      return NextResponse.json({ error: 'Email is already verified' }, { status: 400 })\n    }\n\n    // Delete any existing verification tokens for this user\n    await prisma.verificationToken.deleteMany({\n      where: { identifier: user.email }\n    })\n\n    // Generate new verification token\n    const verificationToken = generateVerificationToken()\n    const expiresAt = new Date(Date.now() + 24 * 60 * 60 * 1000) // 24 hours\n\n    // Save new verification token\n    await prisma.verificationToken.create({\n      data: {\n        identifier: user.email,\n        token: verificationToken,\n        expires: expiresAt\n      }\n    })\n\n    // Send verification email\n    const emailSent = await sendVerificationEmail(user.email, verificationToken)\n\n    if (!emailSent) {\n      return NextResponse.json({ error: 'Failed to send verification email' }, { status: 500 })\n    }\n\n    return NextResponse.json({ \n      success: true, \n      message: 'Verification email sent successfully' \n    })\n\n  } catch (error) {\n    console.error('‚ùå Resend verification error:', error)\n    return NextResponse.json({ error: 'Server error' }, { status: 500 })\n  }\n} ","truncated":false,"size":5688},{"path":"app/api/auth/restore/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { decode, encode } from 'next-auth/jwt'\n\nconst SECRET = process.env.NEXTAUTH_SECRET\n\nexport async function POST(req: NextRequest) {\n  try {\n    if (process.env.NODE_ENV === 'production') {\n      return NextResponse.json({ error: 'Not found' }, { status: 404 })\n    }\n    if (!SECRET) {\n      return NextResponse.json({ error: 'Auth secret not configured' }, { status: 500 })\n    }\n    const { token } = await req.json().catch(() => ({}))\n    const headerToken = req.headers.get('x-helfi-refresh-token') || req.headers.get('x-helfi-remember-token')\n    const sessionToken = token || headerToken\n\n    if (!sessionToken || typeof sessionToken !== 'string') {\n      return NextResponse.json({ error: 'Missing token' }, { status: 400 })\n    }\n\n    const decoded = await decode({ token: sessionToken, secret: SECRET }).catch(() => null)\n    if (!decoded || !decoded.exp || typeof decoded.exp !== 'number') {\n      return NextResponse.json({ error: 'Invalid token' }, { status: 401 })\n    }\n\n    const nowSeconds = Math.floor(Date.now() / 1000)\n    const exp = decoded.exp as number\n    const ttlSeconds = Math.max(exp - nowSeconds, 5)\n    if (ttlSeconds <= 0) {\n      return NextResponse.json({ error: 'Token expired' }, { status: 401 })\n    }\n\n    const response = NextResponse.json({ ok: true })\n    const secure = false\n    const maxAge = ttlSeconds\n    const sameSite = 'lax'\n\n    const needsSessionEncode = (decoded as any)?.kind === 'refresh'\n    const cookieValue = needsSessionEncode\n      ? await encode({\n          token: {\n            sub: (decoded as any)?.sub,\n            id: (decoded as any)?.id || (decoded as any)?.sub,\n            email: (decoded as any)?.email,\n            name: (decoded as any)?.name,\n            image: (decoded as any)?.image,\n            iat: nowSeconds,\n            exp: nowSeconds + maxAge,\n          },\n          secret: SECRET,\n          maxAge,\n        })\n      : sessionToken\n\n    // Use SameSite=None; Secure for iOS PWA compatibility\n    response.cookies.set('__Secure-next-auth.session-token', cookieValue, {\n      httpOnly: true,\n      sameSite,\n      secure,\n      path: '/',\n      maxAge,\n    })\n    response.cookies.set('next-auth.session-token', cookieValue, {\n      httpOnly: true,\n      sameSite,\n      secure,\n      path: '/',\n      maxAge,\n    })\n\n    return response\n  } catch (err) {\n    console.error('Auth restore failed', err)\n    return NextResponse.json({ error: 'Restore failed' }, { status: 500 })\n  }\n}\n","truncated":false,"size":2529},{"path":"app/api/auth/session.backup/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth/next'\nimport { authOptions } from '@/lib/auth'\nimport { createSession } from '@/lib/session'\nimport { prisma } from '@/lib/prisma'\n\nexport async function GET(request: NextRequest) {\n  try {\n    console.log('=== SESSION BRIDGE API CALLED ===')\n    \n    // Get NextAuth session\n    const session = await getServerSession(authOptions)\n    console.log('NextAuth session:', session ? 'EXISTS' : 'NONE')\n    \n    if (!session?.user?.email) {\n      return NextResponse.json({ \n        error: 'No valid NextAuth session',\n        redirect: '/auth/signin'\n      }, { status: 401 })\n    }\n    \n    console.log('Creating custom session for:', session.user.email)\n    \n    // Get the most recent session for this user from NextAuth\n    const user = await prisma.user.findUnique({\n      where: { email: session.user.email },\n      include: {\n        sessions: {\n          orderBy: { expires: 'desc' },\n          take: 1\n        }\n      }\n    })\n    \n    if (!user || user.sessions.length === 0) {\n      return NextResponse.json({ \n        error: 'No database session found',\n        details: 'NextAuth session exists but no database session'\n      }, { status: 500 })\n    }\n    \n    const dbSession = user.sessions[0]\n    console.log('Found database session:', dbSession.sessionToken.substring(0, 8) + '...')\n    \n    // Create response with proper cookie\n    const response = NextResponse.json({\n      success: true,\n      message: 'Custom session cookie set',\n      userEmail: session.user.email,\n      sessionToken: dbSession.sessionToken.substring(0, 8) + '...',\n      expires: dbSession.expires\n    })\n    \n    // Set the session cookie with proper settings\n    response.cookies.set('helfi-session', dbSession.sessionToken, {\n      httpOnly: true,\n      secure: true,\n      sameSite: 'lax',\n      maxAge: 30 * 24 * 60 * 60, // 30 days\n      path: '/',\n      domain: '.helfi.ai' // Allow on all subdomains\n    })\n    \n    console.log('‚úÖ Session cookie set successfully')\n    \n    return response\n    \n  } catch (error) {\n    console.error('Session bridge error:', error)\n    return NextResponse.json({\n      error: 'Failed to create session bridge',\n      details: error instanceof Error ? error.message : 'Unknown error'\n    }, { status: 500 })\n  }\n}\n\nexport async function DELETE(request: NextRequest) {\n  try {\n    console.log('=== SESSION DELETION ENDPOINT ===')\n    \n    // Get session token from cookie\n    const cookies = request.headers.get('cookie') || ''\n    const sessionMatch = cookies.match(/helfi-session=([^;]+)/)\n    const sessionToken = sessionMatch ? sessionMatch[1] : null\n    \n    if (sessionToken) {\n      // Delete custom session from database\n      const { deleteSession } = await import('@/lib/session')\n      await deleteSession(sessionToken)\n      console.log('Custom session deleted')\n    }\n    \n    // Create response and clear the cookie\n    const response = NextResponse.json({ success: true, message: 'Session deleted' })\n    response.cookies.set('helfi-session', '', {\n      httpOnly: true,\n      secure: process.env.NODE_ENV === 'production',\n      sameSite: 'lax',\n      maxAge: 0,\n      path: '/'\n    })\n    \n    return response\n    \n  } catch (error) {\n    console.error('Error deleting custom session:', error)\n    return NextResponse.json({\n      error: 'Failed to delete session',\n      details: error instanceof Error ? error.message : 'Unknown error'\n    }, { status: 500 })\n  }\n} ","truncated":false,"size":3515},{"path":"app/api/auth/signup/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\nimport bcrypt from 'bcryptjs'\nimport { getEmailFooter } from '@/lib/email-footer'\nimport { notifyOwner } from '@/lib/owner-notifications'\nimport { ensureFreeCreditColumns } from '@/lib/free-credits'\nimport { sendOwnerSignupEmail } from '@/lib/admin-alerts'\n\n// This API route uses dynamic data and should not be statically generated\nexport const runtime = 'nodejs'\nexport const dynamic = 'force-dynamic'\n\n// Function to generate verification token\nfunction generateVerificationToken(): string {\n  return Math.random().toString(36).substring(2) + Date.now().toString(36)\n}\n\n// Function to send verification email\nasync function sendVerificationEmail(email: string, token: string) {\n  try {\n    const { Resend } = await import('resend')\n    \n    if (!process.env.RESEND_API_KEY) {\n      console.log('üìß Resend API not configured, skipping verification email')\n      return false\n    }\n\n    const resend = new Resend(process.env.RESEND_API_KEY)\n    const verificationUrl = `https://helfi.ai/api/auth/verify?token=${token}&email=${encodeURIComponent(email)}`\n    \n    const emailResponse = await resend.emails.send({\n      from: 'Helfi Team <support@helfi.ai>',\n      to: email,\n      subject: 'üîê Verify Your Helfi Account - Action Required',\n      html: `\n        <div style=\"font-family: 'Segoe UI', Arial, sans-serif; max-width: 600px; margin: 0 auto; color: #333; background: #f8fafc;\">\n          <div style=\"background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; padding: 40px 30px; text-align: center; border-radius: 12px 12px 0 0;\">\n            <h1 style=\"margin: 0; font-size: 32px; font-weight: bold; letter-spacing: -0.5px;\">Helfi</h1>\n            <p style=\"margin: 12px 0 0 0; opacity: 0.95; font-size: 16px;\">Account Verification Required</p>\n          </div>\n          \n          <div style=\"padding: 40px 30px; background: white; border-radius: 0 0 12px 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);\">\n            <h2 style=\"margin: 0 0 20px 0; color: #374151; font-size: 24px;\">üîê Verify Your Email Address</h2>\n            \n            <p style=\"margin: 0 0 20px 0; line-height: 1.7; font-size: 16px; color: #4b5563;\">\n              Welcome to Helfi! To complete your account setup and ensure security, please verify your email address by clicking the button below.\n            </p>\n            \n            <div style=\"background: #fef3c7; border: 1px solid #f59e0b; border-radius: 8px; padding: 16px; margin: 20px 0;\">\n              <p style=\"margin: 0; color: #92400e; font-size: 14px;\">\n                <strong>‚ö†Ô∏è Security Notice:</strong> This link expires in 24 hours for your protection.\n              </p>\n            </div>\n            \n            <div style=\"margin: 30px 0; text-align: center;\">\n              <a href=\"${verificationUrl}\" style=\"display: inline-block; background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; text-decoration: none; padding: 16px 32px; border-radius: 8px; font-weight: 600; font-size: 16px; box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);\">\n                ‚úÖ Verify Email Address\n              </a>\n            </div>\n            \n            <div style=\"background: #f3f4f6; border-radius: 8px; padding: 20px; margin: 30px 0;\">\n              <p style=\"margin: 0 0 10px 0; font-size: 14px; color: #374151;\"><strong>Can't click the button?</strong></p>\n              <p style=\"margin: 0; font-size: 14px; color: #6b7280; word-break: break-all;\">\n                Copy and paste this link: ${verificationUrl}\n              </p>\n            </div>\n            \n            <p style=\"margin: 30px 0 0 0; line-height: 1.7; font-size: 14px; color: #6b7280;\">\n              If you didn't create a Helfi account, please ignore this email or contact our support team.\n            </p>\n            \n            ${getEmailFooter({ recipientEmail: email, emailType: 'verification' })}\n          </div>\n        </div>\n      `\n    })\n\n    console.log(`‚úÖ [VERIFICATION EMAIL] Sent to ${email} with ID: ${emailResponse.data?.id}`)\n    return true\n  } catch (error) {\n    console.error(`‚ùå [VERIFICATION EMAIL] Failed to send to ${email}:`, error)\n    return false\n  }\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    const { email, password } = await request.json()\n\n    if (!email || !password) {\n      return NextResponse.json(\n        { error: 'Email and password are required' },\n        { status: 400 }\n      )\n    }\n\n    if (String(password).length < 8) {\n      return NextResponse.json(\n        { error: 'Password must be at least 8 characters long' },\n        { status: 400 }\n      )\n    }\n\n    // Check if user already exists\n    const existingUser = await prisma.user.findUnique({\n      where: { email: email.toLowerCase() }\n    })\n\n    if (existingUser) {\n      return NextResponse.json(\n        { error: 'An account with this email already exists' },\n        { status: 409 }\n      )\n    }\n\n    console.log('üë§ Creating new UNVERIFIED user via direct signup:', email)\n    const passwordHash = await bcrypt.hash(String(password), 12)\n    \n    // Create user but DON'T verify email yet\n    // Grant free credits: 5 food, 2 symptom, 2 medical, 2 interaction, 1 health intake, 3 insights\n    // Plus 2 free uses for chats and re-analyses to let new users try every feature.\n    await ensureFreeCreditColumns()\n    const user = await prisma.user.create({\n      data: {\n        email: email.toLowerCase(),\n        name: email.split('@')[0],\n        emailVerified: null, // CRITICAL: User is NOT verified\n        passwordHash,\n        freeFoodAnalysisRemaining: 5,\n        freeSymptomAnalysisRemaining: 2,\n        freeMedicalAnalysisRemaining: 2,\n        freeInteractionAnalysisRemaining: 2,\n        freeHealthIntakeRemaining: 1,\n        freeInsightsUpdateRemaining: 3,\n        freeSymptomChatRemaining: 2,\n        freeMedicalChatRemaining: 2,\n        freeInsightsChatRemaining: 2,\n        freeVoiceChatRemaining: 2,\n        freeFoodReanalysisRemaining: 2,\n        freeInteractionReanalysisRemaining: 2,\n      } as any\n    })\n    \n    // Generate verification token\n    const verificationToken = generateVerificationToken()\n    const expiresAt = new Date(Date.now() + 24 * 60 * 60 * 1000) // 24 hours\n    \n    // Save verification token\n    await prisma.verificationToken.create({\n      data: {\n        identifier: user.email,\n        token: verificationToken,\n        expires: expiresAt\n      }\n    })\n    \n    // Send verification email (don't await to avoid blocking)\n    console.log('üìß Sending verification email to new user')\n    sendVerificationEmail(user.email, verificationToken).catch(error => {\n      console.error('‚ùå Verification email failed (non-blocking):', error)\n    })\n\n    // Notify owner of new signup (don't await to avoid blocking)\n    notifyOwner({\n      event: 'signup',\n      userEmail: user.email,\n      userName: user.name || undefined,\n    }).catch(error => {\n      console.error('‚ùå Owner notification failed (non-blocking):', error)\n    })\n\n    sendOwnerSignupEmail({\n      userEmail: user.email,\n      userName: user.name || undefined,\n    }).catch(error => {\n      console.error('‚ùå Signup email alert failed (non-blocking):', error)\n    })\n\n    console.log('‚úÖ Direct signup successful:', { id: user.id, email: user.email })\n\n    return NextResponse.json({ \n      success: true, \n      message: 'Account created successfully. Please check your email to verify your account.' \n    })\n\n  } catch (error) {\n    console.error('‚ùå Direct signup error:', error)\n    return NextResponse.json(\n      { error: 'Failed to create account. Please try again.' },\n      { status: 500 }\n    )\n  }\n} \n","truncated":false,"size":7740},{"path":"app/api/auth/verify/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\n\n// This API route uses dynamic data and should not be statically generated\nexport const runtime = 'nodejs'\nexport const dynamic = 'force-dynamic'\n\nexport async function GET(request: NextRequest) {\n  try {\n    const url = new URL(request.url)\n    const token = url.searchParams.get('token')\n    const email = url.searchParams.get('email')\n\n    if (!token || !email) {\n      return NextResponse.redirect(new URL('/auth/verify?error=verification_missing_params', 'https://helfi.ai'))\n    }\n\n    console.log('üîê Email verification attempt:', { email, token: token.substring(0, 8) + '...' })\n\n    // Find verification token in database\n    const verificationRecord = await prisma.verificationToken.findUnique({\n      where: {\n        identifier_token: {\n          identifier: email,\n          token: token\n        }\n      }\n    })\n\n    if (!verificationRecord) {\n      console.log('‚ùå Invalid verification token:', { email, token: token.substring(0, 8) + '...' })\n      return NextResponse.redirect(new URL('/auth/verify?error=verification_invalid_token', 'https://helfi.ai'))\n    }\n\n    // Check if token has expired\n    if (verificationRecord.expires < new Date()) {\n      console.log('‚è∞ Verification token expired:', { email, expires: verificationRecord.expires })\n      \n      // Clean up expired token\n      await prisma.verificationToken.delete({\n        where: {\n          identifier_token: {\n            identifier: email,\n            token: token\n          }\n        }\n      })\n      \n      return NextResponse.redirect(new URL('/auth/verify?error=verification_expired', 'https://helfi.ai'))\n    }\n\n    // Find the user\n    const user = await prisma.user.findUnique({\n      where: { email: email }\n    })\n\n    if (!user) {\n      console.log('‚ùå User not found for verification:', email)\n      return NextResponse.redirect(new URL('/auth/verify?error=verification_user_not_found', 'https://helfi.ai'))\n    }\n\n    // Verify the user's email\n    await prisma.user.update({\n      where: { email: email },\n      data: {\n        emailVerified: new Date()\n      }\n    })\n\n    // Clean up the verification token\n    await prisma.verificationToken.delete({\n      where: {\n        identifier_token: {\n          identifier: email,\n          token: token\n        }\n      }\n    })\n\n    console.log('‚úÖ Email verification successful:', email)\n\n    // Send welcome email now that user is verified\n    try {\n      const { Resend } = await import('resend')\n      \n      if (process.env.RESEND_API_KEY) {\n        const resend = new Resend(process.env.RESEND_API_KEY)\n        const userName = user.name || user.email.split('@')[0]\n        \n        const welcomeMessage = `Hi ${userName},\n\nWelcome to the Helfi community! We're thrilled to have you on board.\n\nüöÄ Getting Started:\n‚Ä¢ Complete your health profile for personalized insights\n‚Ä¢ Start logging your meals with AI-powered analysis\n‚Ä¢ Set your health goals and track your progress\n‚Ä¢ Explore our medication interaction checker\n\nüí° Pro Tip: The more you use Helfi, the smarter your AI health coach becomes!\n\nNeed help getting started? Just reply to this email or contact our support team.\n\nBest regards,\nThe Helfi Team`\n\n        await resend.emails.send({\n          from: 'Helfi Team <support@helfi.ai>',\n          to: user.email,\n          subject: 'üéâ Welcome to Helfi - Your AI Health Journey Begins!',\n          html: `\n            <div style=\"font-family: 'Segoe UI', Arial, sans-serif; max-width: 600px; margin: 0 auto; color: #333; background: #f8fafc;\">\n              <div style=\"background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; padding: 40px 30px; text-align: center; border-radius: 12px 12px 0 0;\">\n                <h1 style=\"margin: 0; font-size: 32px; font-weight: bold; letter-spacing: -0.5px;\">Helfi</h1>\n                <p style=\"margin: 12px 0 0 0; opacity: 0.95; font-size: 16px;\">Your AI-Powered Health Coach</p>\n              </div>\n              \n              <div style=\"padding: 40px 30px; background: white; border-radius: 0 0 12px 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);\">\n                ${welcomeMessage.split('\\n').map((line: string) => \n                  line.trim() ? `<p style=\"margin: 18px 0; line-height: 1.7; font-size: 16px;\">${line}</p>` : '<div style=\"height: 10px;\"></div>'\n                ).join('')}\n                \n                <div style=\"margin-top: 40px; padding-top: 30px; border-top: 2px solid #e5e7eb; text-align: center;\">\n                  <a href=\"https://helfi.ai/auth/signin\" style=\"display: inline-block; background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; text-decoration: none; padding: 16px 32px; border-radius: 8px; font-weight: 600; font-size: 16px; margin: 10px 0; box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);\">üöÄ Start Your Health Journey</a>\n                </div>\n                \n                <div style=\"margin-top: 40px; padding-top: 30px; border-top: 1px solid #e5e7eb; font-size: 14px; color: #6b7280; text-align: center;\">\n                  <p style=\"margin: 0 0 16px 0; font-size: 16px; color: #374151;\"><strong>Best regards,<br>The Helfi Team</strong></p>\n                  <p style=\"margin: 20px 0 0 0; font-size: 14px;\">\n                    <a href=\"https://helfi.ai\" style=\"color: #10b981; text-decoration: none; font-weight: 500;\">üåê helfi.ai</a> | \n                    <a href=\"mailto:support@helfi.ai\" style=\"color: #10b981; text-decoration: none; font-weight: 500;\">üìß support@helfi.ai</a>\n                  </p>\n                </div>\n              </div>\n            </div>\n          `\n        })\n        \n        console.log('üìß Welcome email sent to newly verified user:', userName)\n      }\n    } catch (emailError) {\n      console.error('‚ùå Welcome email failed (non-blocking):', emailError)\n    }\n\n    // Redirect to sign-in after successful verification\n    return NextResponse.redirect(new URL('/auth/signin?message=verified', 'https://helfi.ai'))\n\n  } catch (error) {\n    console.error('‚ùå Email verification error:', error)\n    return NextResponse.redirect(new URL('/auth/verify?error=verification_server_error', 'https://helfi.ai'))\n  }\n} \n","truncated":false,"size":6260},{"path":"app/api/barcode/label/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\n\nconst toNumber = (value: any): number | null => {\n  if (value === null || value === undefined || value === '') return null\n  const parsed = typeof value === 'string' ? parseFloat(value) : Number(value)\n  return Number.isFinite(parsed) ? parsed : null\n}\n\nconst normalizeText = (value: any): string | null => {\n  if (value === null || value === undefined) return null\n  const trimmed = String(value).trim()\n  return trimmed.length ? trimmed : null\n}\n\nconst stripNutritionFromServingSize = (raw: string) => {\n  return String(raw || '')\n    .replace(/\\([^)]*(calories?|kcal|kilojoules?|kj|protein|carbs?|fat|fibre|fiber|sugar)[^)]*\\)/gi, '')\n    .replace(/\\b\\d+(?:\\.\\d+)?\\s*(kcal|cal|kj)\\b[^,)]*(?:protein|carb|fat|fiber|fibre|sugar)[^,)]*/gi, '')\n    .replace(/\\s+/g, ' ')\n    .trim()\n}\n\nconst parseServingWeight = (servingSize?: string | null): number | null => {\n  if (!servingSize) return null\n  const raw = String(servingSize)\n  const gramsMatch = raw.match(/(\\d+(?:\\.\\d+)?)\\s*g\\b/i)\n  if (gramsMatch) return parseFloat(gramsMatch[1])\n  const mlMatch = raw.match(/(\\d+(?:\\.\\d+)?)\\s*ml\\b/i)\n  if (mlMatch) return parseFloat(mlMatch[1])\n  const ozMatch = raw.match(/(\\d+(?:\\.\\d+)?)\\s*(oz|ounce|ounces)\\b/i)\n  if (ozMatch) return parseFloat(ozMatch[1]) * 28.3495\n  return null\n}\n\nconst validateServingSanity = (data: {\n  servingSize?: string | null\n  calories: number | null\n  proteinG: number | null\n  carbsG: number | null\n  fatG: number | null\n  fiberG: number | null\n}) => {\n  const weight = parseServingWeight(data.servingSize || null)\n  if (!weight || weight <= 0) return { ok: true }\n  const safe = (v: number | null) => (Number.isFinite(Number(v)) && Number(v) > 0 ? Number(v) : 0)\n  const macroSum = safe(data.proteinG) + safe(data.carbsG) + safe(data.fatG) + safe(data.fiberG)\n  const macroLimit = weight * 1.3 + 2\n  if (macroSum > macroLimit) {\n    return { ok: false, message: 'Nutrition values do not fit the serving size. Please retake the label photo.' }\n  }\n  const calories = safe(data.calories)\n  const calorieLimit = weight * 9.5 + 10\n  if (calories > calorieLimit) {\n    return { ok: false, message: 'Calories do not fit the serving size. Please retake the label photo.' }\n  }\n  return { ok: true }\n}\n\nexport async function POST(req: NextRequest) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.email) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const user = await prisma.user.findUnique({\n      where: { email: session.user.email },\n      select: { id: true },\n    })\n\n    if (!user) {\n      return NextResponse.json({ error: 'User not found' }, { status: 404 })\n    }\n\n    const body = await req.json()\n    const rawBarcode = normalizeText(body?.barcode)\n    if (!rawBarcode) {\n      return NextResponse.json({ error: 'Missing barcode' }, { status: 400 })\n    }\n\n    const barcode = rawBarcode.replace(/[^0-9A-Za-z]/g, '')\n    if (!barcode) {\n      return NextResponse.json({ error: 'Invalid barcode' }, { status: 400 })\n    }\n\n    const item = body?.item || {}\n    const name = normalizeText(item?.name) || 'Packaged item'\n    const brand = normalizeText(item?.brand)\n    const rawServingSize = normalizeText(item?.serving_size || item?.servingSize)\n    const servingSize = rawServingSize ? stripNutritionFromServingSize(rawServingSize) : null\n\n    const calories = toNumber(item?.calories)\n    const proteinG = toNumber(item?.protein_g ?? item?.proteinG)\n    const carbsG = toNumber(item?.carbs_g ?? item?.carbsG)\n    const fatG = toNumber(item?.fat_g ?? item?.fatG)\n    const fiberG = toNumber(item?.fiber_g ?? item?.fiberG)\n    const sugarG = toNumber(item?.sugar_g ?? item?.sugarG)\n    const quantityG = toNumber(item?.quantity_g ?? item?.quantityG)\n    const piecesPerServing = toNumber(item?.piecesPerServing ?? item?.pieces_per_serving)\n\n    const nutritionValues = [calories, proteinG, carbsG, fatG, fiberG, sugarG]\n    const hasNutrition = nutritionValues.some((v) => Number.isFinite(Number(v)) && Number(v) > 0)\n    if (!hasNutrition) {\n      return NextResponse.json(\n        {\n          error: 'nutrition_missing',\n          message: 'We could not read clear nutrition values from that photo. Please try a clearer label photo.',\n        },\n        { status: 422 },\n      )\n    }\n\n    const sanity = validateServingSanity({\n      servingSize,\n      calories,\n      proteinG,\n      carbsG,\n      fatG,\n      fiberG,\n    })\n    if (!sanity.ok) {\n      return NextResponse.json(\n        {\n          error: 'nutrition_mismatch',\n          message: sanity.message || 'Nutrition values do not match the serving size.',\n        },\n        { status: 422 },\n      )\n    }\n\n    const isReport = Boolean(body?.report)\n    const now = new Date()\n\n    const updateData = {\n      name,\n      brand,\n      servingSize,\n      calories,\n      proteinG,\n      carbsG,\n      fatG,\n      fiberG,\n      sugarG,\n      quantityG,\n      piecesPerServing,\n      source: 'label-photo',\n      updatedById: user.id,\n      updatedAt: now,\n      ...(isReport ? { reportCount: { increment: 1 }, lastReportedAt: now } : {}),\n    }\n\n    const createData = {\n      barcode,\n      name,\n      brand,\n      servingSize,\n      calories,\n      proteinG,\n      carbsG,\n      fatG,\n      fiberG,\n      sugarG,\n      quantityG,\n      piecesPerServing,\n      source: 'label-photo',\n      reportCount: isReport ? 1 : 0,\n      lastReportedAt: isReport ? now : null,\n      createdById: user.id,\n      updatedById: user.id,\n      createdAt: now,\n      updatedAt: now,\n    }\n\n    const record = await prisma.barcodeProduct.upsert({\n      where: { barcode },\n      update: updateData,\n      create: createData,\n    })\n\n    return NextResponse.json({\n      success: true,\n      product: {\n        barcode: record.barcode,\n        name: record.name,\n        brand: record.brand,\n        servingSize: record.servingSize,\n      },\n    })\n  } catch (error) {\n    console.error('Barcode label save failed', error)\n    return NextResponse.json({ error: 'Failed to save barcode label' }, { status: 500 })\n  }\n}\n","truncated":false,"size":6254},{"path":"app/api/barcode/lookup/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\nimport { CreditManager } from '@/lib/credit-system'\nimport { normalizeBarcodeFood, summarizeDiscreteItemsForLog } from '@/lib/food-normalization'\n\n// Barcode lookup with multiple API fallbacks:\n// 1. FatSecret (primary - has great barcode coverage for packaged foods)\n// 2. OpenFoodFacts (fallback - open database with excellent global coverage)\n// 3. USDA (secondary fallback - search by product name if barcode not found)\n\nconst FATSECRET_CLIENT_ID = process.env.FATSECRET_CLIENT_ID || '5b035e5de0b041ffb0b8522abd75dd0b'\nconst FATSECRET_CLIENT_SECRET = process.env.FATSECRET_CLIENT_SECRET || 'd544f96d19494c9ca8a3dec1bcaf1da3'\nconst USDA_API_KEY = process.env.USDA_API_KEY\nconst OPENFOODFACTS_USER_AGENT = 'helfi-app/1.0 (support@helfi.ai)'\nconst BARCODE_SCAN_COST_CENTS = 3\n\ntype FatSecretServing = {\n  measurement_description?: string\n  serving_description?: string\n  calories?: string\n  protein?: string\n  carbohydrate?: string\n  fat?: string\n  fiber?: string\n  sugar?: string\n}\n\ntype FatSecretFood = {\n  food_id?: string\n  food_name?: string\n  brand_name?: string\n  servings?: { serving?: FatSecretServing[] | FatSecretServing }\n}\n\ninterface NormalizedFood {\n  source: 'helfi' | 'fatsecret' | 'openfoodfacts' | 'usda'\n  id: string\n  name: string\n  brand?: string | null\n  serving_size: string\n  servings?: number | null\n  calories: number | null\n  protein_g: number | null\n  carbs_g: number | null\n  fat_g: number | null\n  fiber_g: number | null\n  sugar_g: number | null\n  barcode?: string | null\n  basis?: 'per_serving' | 'per_100g' | null\n  quantity_g?: number | null\n  energyUnit?: 'kcal' | 'kJ' | null\n  piecesPerServing?: number | null\n  pieces?: number | null\n}\n\ntype OpenFoodFactsResult = {\n  food: NormalizedFood | null\n  productName: string | null\n}\n\nconst parseNumber = (val?: string | number | null): number | null => {\n  if (val === undefined || val === null) return null\n  const num = typeof val === 'number' ? val : parseFloat(val)\n  return Number.isFinite(num) ? num : null\n}\n\nconst parseGramsFromLabel = (label?: string | null): number | null => {\n  if (!label) return null\n  const normalized = String(label).toLowerCase()\n  const g = normalized.match(/(\\d+(?:\\.\\d+)?)\\s*(g|gram|grams)/i)\n  if (g) return parseFloat(g[1])\n  const ml = normalized.match(/(\\d+(?:\\.\\d+)?)\\s*(ml|milliliter|millilitre)/i)\n  if (ml) return parseFloat(ml[1])\n  const oz = normalized.match(/(\\d+(?:\\.\\d+)?)\\s*(oz|ounce|ounces)/i)\n  if (oz) return parseFloat(oz[1]) * 28.3495\n  return null\n}\n\nconst parseServingWeight = (servingSize?: string | null): number | null => {\n  if (!servingSize) return null\n  const normalized = String(servingSize).toLowerCase()\n  const g = normalized.match(/(\\d+(?:\\.\\d+)?)\\s*(g|gram|grams)\\b/i)\n  if (g) return parseFloat(g[1])\n  const ml = normalized.match(/(\\d+(?:\\.\\d+)?)\\s*(ml|milliliter|millilitre)\\b/i)\n  if (ml) return parseFloat(ml[1])\n  const oz = normalized.match(/(\\d+(?:\\.\\d+)?)\\s*(oz|ounce|ounces)\\b/i)\n  if (oz) return parseFloat(oz[1]) * 28.3495\n  return null\n}\n\nconst isLikelyOilProduct = (nameRaw: string | null | undefined): boolean => {\n  const name = String(nameRaw || '').toLowerCase()\n  if (!name) return false\n  return (\n    name.includes('oil') ||\n    name.includes('olive oil') ||\n    name.includes('avocado oil') ||\n    name.includes('coconut oil') ||\n    name.includes('sesame oil') ||\n    name.includes('canola oil') ||\n    name.includes('sunflower oil') ||\n    name.includes('vegetable oil') ||\n    name.includes('grapeseed oil')\n  )\n}\n\nconst isServingNutritionPlausible = (data: {\n  servingSize?: string | null\n  calories?: number | null\n  protein?: number | null\n  carbs?: number | null\n  fat?: number | null\n  fiber?: number | null\n}) => {\n  const weight = parseServingWeight(data.servingSize || null)\n  if (!weight || weight <= 0) return true\n  const safe = (v?: number | null) => (Number.isFinite(Number(v)) && Number(v) > 0 ? Number(v) : 0)\n  const macroSum = safe(data.protein) + safe(data.carbs) + safe(data.fat) + safe(data.fiber)\n  const macroLimit = weight * 1.3 + 2\n  if (macroSum > macroLimit) return false\n  const calories = safe(data.calories)\n  const calorieLimit = weight * 9.5 + 10\n  if (calories > calorieLimit) return false\n  return true\n}\n\n// ============ Helfi Barcode Cache ============\n\nasync function fetchFoodFromHelfiBarcode(barcode: string): Promise<NormalizedFood | null> {\n  try {\n    const record = await prisma.barcodeProduct.findUnique({\n      where: { barcode },\n    })\n    if (!record) return null\n    const plausible = isServingNutritionPlausible({\n      servingSize: record.servingSize || null,\n      calories: record.calories ?? null,\n      protein: record.proteinG ?? null,\n      carbs: record.carbsG ?? null,\n      fat: record.fatG ?? null,\n      fiber: record.fiberG ?? null,\n    })\n    if (!plausible) {\n      console.warn('Helfi barcode cache rejected due to implausible nutrition', barcode)\n      return null\n    }\n    return {\n      source: 'helfi',\n      id: record.id,\n      name: record.name || 'Scanned food',\n      brand: record.brand || null,\n      serving_size: record.servingSize || '1 serving',\n      calories: record.calories ?? null,\n      protein_g: record.proteinG ?? null,\n      carbs_g: record.carbsG ?? null,\n      fat_g: record.fatG ?? null,\n      fiber_g: record.fiberG ?? null,\n      sugar_g: record.sugarG ?? null,\n      barcode,\n      basis: null,\n      quantity_g: record.quantityG ?? null,\n      piecesPerServing: record.piecesPerServing ?? null,\n      pieces: record.piecesPerServing ?? null,\n      energyUnit: null,\n    }\n  } catch (err) {\n    console.warn('Helfi barcode lookup failed', err)\n    return null\n  }\n}\n\n// ============ FatSecret API ============\n\nasync function getFatSecretAccessToken(): Promise<string | null> {\n  if (!FATSECRET_CLIENT_ID || !FATSECRET_CLIENT_SECRET) {\n    console.log('FatSecret credentials not configured, skipping')\n    return null\n  }\n\n  try {\n    const params = new URLSearchParams({\n      grant_type: 'client_credentials',\n      scope: 'basic',\n    })\n\n    const auth = Buffer.from(`${FATSECRET_CLIENT_ID}:${FATSECRET_CLIENT_SECRET}`).toString('base64')\n\n    const res = await fetch('https://oauth.fatsecret.com/connect/token', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n        Authorization: `Basic ${auth}`,\n      },\n      body: params.toString(),\n      cache: 'no-store',\n    })\n\n    if (!res.ok) {\n      const txt = await res.text()\n      console.warn('FatSecret token request failed', res.status, txt.substring(0, 200))\n      return null\n    }\n\n    const data = await res.json()\n    return data.access_token || null\n  } catch (err) {\n    console.warn('FatSecret token error', err)\n    return null\n  }\n}\n\nasync function fetchFoodFromFatSecret(barcode: string): Promise<NormalizedFood | null> {\n  const token = await getFatSecretAccessToken()\n  if (!token) return null\n\n  try {\n    // Step 1: find food_id from barcode\n    const findParams = new URLSearchParams({\n      method: 'food.find_id_for_barcode',\n      barcode,\n      format: 'json',\n    })\n\n    const findRes = await fetch(`https://platform.fatsecret.com/rest/server.api?${findParams.toString()}`, {\n      headers: {\n        Authorization: `Bearer ${token}`,\n        'Content-Type': 'application/json',\n      },\n      cache: 'no-store',\n      next: { revalidate: 0 },\n    })\n\n    if (!findRes.ok) {\n      const txt = await findRes.text()\n      console.warn('FatSecret barcode lookup failed', findRes.status, txt.substring(0, 200))\n      return null\n    }\n\n    const findData = await findRes.json()\n    const foodId =\n      findData?.food?.food_id ||\n      findData?.food_id ||\n      findData?.food?.[0]?.food_id\n\n    if (!foodId) {\n      console.log('FatSecret: No food_id found for barcode', barcode)\n      return null\n    }\n\n    // Step 2: fetch food details\n    const foodParams = new URLSearchParams({\n      method: 'food.get.v2',\n      food_id: String(foodId),\n      format: 'json',\n    })\n\n    const foodRes = await fetch(`https://platform.fatsecret.com/rest/server.api?${foodParams.toString()}`, {\n      headers: {\n        Authorization: `Bearer ${token}`,\n        'Content-Type': 'application/json',\n      },\n      cache: 'no-store',\n      next: { revalidate: 0 },\n    })\n\n    if (!foodRes.ok) {\n      const txt = await foodRes.text()\n      console.warn('FatSecret food.get.v2 failed', foodRes.status, txt.substring(0, 200))\n      return null\n    }\n\n    const foodJson = await foodRes.json()\n    const food: FatSecretFood | null = (foodJson as any)?.food || null\n    if (!food?.food_name) return null\n\n    // Handle both array and single serving object\n    const servingsRaw = food.servings?.serving\n    const servings = Array.isArray(servingsRaw) ? servingsRaw : servingsRaw ? [servingsRaw] : []\n    if (servings.length === 0) return null\n\n    const preferred =\n      servings.find(\n        (s) =>\n          s.measurement_description?.toLowerCase().includes('100 g') ||\n          s.measurement_description?.toLowerCase().includes('serving'),\n      ) || servings[0]\n\n    console.log('‚úÖ FatSecret found:', food.food_name, 'for barcode', barcode)\n\n    const servingSize = preferred.measurement_description || preferred.serving_description || '1 serving'\n    const quantity_g = parseGramsFromLabel(servingSize)\n    const basis: NormalizedFood['basis'] = servingSize.toLowerCase().includes('100 g') ? 'per_100g' : 'per_serving'\n\n    return {\n      source: 'fatsecret',\n      id: String(foodId),\n      name: food.food_name,\n      brand: food.brand_name || null,\n      serving_size: servingSize,\n      calories: parseNumber(preferred.calories),\n      protein_g: parseNumber(preferred.protein),\n      carbs_g: parseNumber(preferred.carbohydrate),\n      fat_g: parseNumber(preferred.fat),\n      fiber_g: parseNumber(preferred.fiber),\n      sugar_g: parseNumber(preferred.sugar),\n      barcode,\n      basis,\n      quantity_g,\n      energyUnit: null,\n    }\n  } catch (err) {\n    console.warn('FatSecret barcode handler error', err)\n    return null\n  }\n}\n\n// ============ OpenFoodFacts API ============\n\nasync function fetchFoodFromOpenFoodFacts(barcode: string): Promise<OpenFoodFactsResult> {\n  try {\n    const url = `https://world.openfoodfacts.org/api/v0/product/${barcode}.json`\n    \n    const res = await fetch(url, {\n      headers: {\n        'User-Agent': OPENFOODFACTS_USER_AGENT,\n      },\n      cache: 'no-store',\n      next: { revalidate: 0 },\n    })\n\n    if (!res.ok) {\n      console.warn('OpenFoodFacts barcode lookup failed', res.status)\n      return { food: null, productName: null }\n    }\n\n    const data = await res.json()\n    \n    if (data.status !== 1 || !data.product) {\n      console.log('OpenFoodFacts: Product not found for barcode', barcode)\n      return { food: null, productName: null }\n    }\n\n    const product = data.product\n    const nutr = product.nutriments || {}\n\n    const name: string =\n      product.product_name ||\n      product.generic_name ||\n      product.brands ||\n      product.categories ||\n      product.labels ||\n      barcode\n\n    if (!name) return { food: null, productName: null }\n\n    // Prefer per-serving values, fallback to per 100g\n    const kcalServing = parseNumber(nutr['energy-kcal_serving'])\n    const energyServing = parseNumber(nutr['energy_serving'])\n    const proteinServing = parseNumber(nutr['proteins_serving'])\n    const carbsServing = parseNumber(nutr['carbohydrates_serving'])\n    const fatServing = parseNumber(nutr['fat_serving'])\n    const fiberServing = parseNumber(nutr['fiber_serving'])\n    const sugarServing = parseNumber(nutr['sugars_serving'])\n\n    let calories: number | null = null\n    let protein_g: number | null = null\n    let carbs_g: number | null = null\n    let fat_g: number | null = null\n    let fiber_g: number | null = null\n    let sugar_g: number | null = null\n    let serving_size = product.serving_size || '1 serving'\n    let basis: NormalizedFood['basis'] = 'per_serving'\n    let energyUnit: NormalizedFood['energyUnit'] = kcalServing != null ? 'kcal' : energyServing != null ? 'kJ' : null\n    const quantity_g = parseGramsFromLabel(serving_size) || null\n\n    if (kcalServing != null || proteinServing != null || carbsServing != null || fatServing != null) {\n      calories = kcalServing ?? energyServing ?? parseNumber(nutr['energy-kcal_100g'] ?? nutr['energy_100g'])\n      protein_g = proteinServing ?? parseNumber(nutr['proteins_100g'])\n      carbs_g = carbsServing ?? parseNumber(nutr['carbohydrates_100g'])\n      fat_g = fatServing ?? parseNumber(nutr['fat_100g'])\n      fiber_g = fiberServing ?? parseNumber(nutr['fiber_100g'])\n      sugar_g = sugarServing ?? parseNumber(nutr['sugars_100g'])\n      basis = 'per_serving'\n    } else {\n      // Use per 100g values\n      calories = parseNumber(nutr['energy-kcal_100g'] ?? nutr['energy_100g'])\n      protein_g = parseNumber(nutr['proteins_100g'])\n      carbs_g = parseNumber(nutr['carbohydrates_100g'])\n      fat_g = parseNumber(nutr['fat_100g'])\n      fiber_g = parseNumber(nutr['fiber_100g'])\n      sugar_g = parseNumber(nutr['sugars_100g'])\n      serving_size = '100 g'\n      basis = 'per_100g'\n    }\n\n    console.log('‚úÖ OpenFoodFacts found:', name, 'for barcode', barcode)\n\n    return {\n      food: {\n        source: 'openfoodfacts',\n        id: barcode,\n        name,\n        brand: product.brands || null,\n        serving_size,\n        calories,\n        protein_g,\n        carbs_g,\n        fat_g,\n        fiber_g,\n        sugar_g,\n        barcode,\n        basis,\n        quantity_g,\n        energyUnit,\n      },\n      productName: name,\n    }\n  } catch (err) {\n    console.warn('OpenFoodFacts barcode handler error', err)\n    return { food: null, productName: null }\n  }\n}\n\n// ============ USDA API (search by product name) ============\n\nasync function searchFoodFromUSDA(productName: string, barcode: string): Promise<NormalizedFood | null> {\n  if (!USDA_API_KEY) {\n    console.log('USDA API key not configured, skipping')\n    return null\n  }\n\n  try {\n    const params = new URLSearchParams({\n      api_key: USDA_API_KEY,\n      query: productName,\n      pageSize: '1',\n      dataType: 'Branded',\n    })\n\n    const url = `https://api.nal.usda.gov/fdc/v1/foods/search?${params.toString()}`\n\n    const res = await fetch(url, {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      cache: 'no-store',\n      next: { revalidate: 0 },\n    })\n\n    if (!res.ok) {\n      console.warn('USDA search failed', res.status)\n      return null\n    }\n\n    const data = await res.json()\n    const foods = data.foods || []\n    \n    if (foods.length === 0) {\n      console.log('USDA: No results for query', productName)\n      return null\n    }\n\n    const food = foods[0]\n    const nutrients = food.foodNutrients || []\n\n    const findNutrient = (name: string): number | null => {\n      const n = nutrients.find(\n        (n: any) => n.nutrientName?.toLowerCase().includes(name.toLowerCase())\n      )\n      return n ? parseNumber(n.value) : null\n    }\n\n    console.log('‚úÖ USDA found:', food.description, 'for barcode', barcode)\n\n    const servingSize =\n      food.servingSize ? `${food.servingSize} ${food.servingSizeUnit || 'g'}` : '100 g'\n    const quantity_g = parseGramsFromLabel(servingSize)\n    const basis: NormalizedFood['basis'] = food.servingSize ? 'per_serving' : 'per_100g'\n\n    return {\n      source: 'usda',\n      id: String(food.fdcId),\n      name: food.description || productName,\n      brand: food.brandName || food.brandOwner || null,\n      serving_size: servingSize,\n      calories: findNutrient('energy'),\n      protein_g: findNutrient('protein'),\n      carbs_g: findNutrient('carbohydrate'),\n      fat_g: findNutrient('fat') ?? findNutrient('lipid'),\n      fiber_g: findNutrient('fiber'),\n      sugar_g: findNutrient('sugar'),\n      barcode,\n      basis,\n      quantity_g,\n      energyUnit: null,\n    }\n  } catch (err) {\n    console.warn('USDA search error', err)\n    return null\n  }\n}\n\n// ============ Main Handler ============\n\nexport async function GET(req: NextRequest) {\n  const { searchParams } = new URL(req.url)\n  const code = (searchParams.get('code') || '').trim().replace(/[^0-9A-Za-z]/g, '')\n  \n  if (!code) {\n    return NextResponse.json({ error: 'Missing barcode code' }, { status: 400 })\n  }\n\n  // Require signed-in user for credit charge\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.email) {\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  }\n\n  const user = await prisma.user.findUnique({\n    where: { email: session.user.email },\n    include: { subscription: true, creditTopUps: true },\n  })\n\n  if (!user) {\n    return NextResponse.json({ error: 'User not found' }, { status: 404 })\n  }\n\n  const cm = new CreditManager(user.id)\n  const wallet = await cm.getWalletStatus()\n  // Pre-check for sufficient credits, but only charge if a product is actually found\n  if (wallet.totalAvailableCents < BARCODE_SCAN_COST_CENTS) {\n    return NextResponse.json(\n      { error: 'Insufficient credits', message: 'Barcode scanning requires 3 credits.' },\n      { status: 402 },\n    )\n  }\n\n  console.log('üîç Looking up barcode:', code)\n  let food: NormalizedFood | null = null\n  let openFoodFacts: OpenFoodFactsResult | null = null\n\n  // Try Helfi cache first (user-labeled nutrition from barcode scans)\n  food = await fetchFoodFromHelfiBarcode(code)\n\n  // Try FatSecret first (best for packaged foods)\n  if (!food) {\n    food = await fetchFoodFromFatSecret(code)\n  }\n\n  // Try OpenFoodFacts second (great global coverage) if still missing\n  if (!food) {\n    openFoodFacts = await fetchFoodFromOpenFoodFacts(code)\n    if (openFoodFacts.food) {\n      food = openFoodFacts.food\n    }\n  }\n\n  // Try USDA using the best available product name (OpenFoodFacts often has a label even when nutrition is missing)\n  if (!food) {\n    const usdaQuery = openFoodFacts?.productName || code\n    const usdaFood = await searchFoodFromUSDA(usdaQuery, code)\n    if (usdaFood) {\n      food = usdaFood\n    }\n  }\n\n  if (food) {\n    console.log('[BARCODE_DEBUG] source payload', {\n      source: food.source,\n      serving_size: food.serving_size,\n      calories: food.calories,\n      protein_g: food.protein_g,\n      carbs_g: food.carbs_g,\n      fat_g: food.fat_g,\n      fiber_g: food.fiber_g,\n      sugar_g: food.sugar_g,\n      basis: food.basis || null,\n      quantity_g: food.quantity_g || null,\n      energyUnit: food.energyUnit || null,\n    })\n\n    const normalized = normalizeBarcodeFood(food)\n    food = {\n      ...food,\n      ...normalized.food,\n      source: food.source,\n      serving_size: normalized.food.serving_size || food.serving_size || '1 serving',\n      name: food.name || 'Scanned food',\n      id: String(food.id || code),\n    }\n\n    const protein = Number(food.protein_g ?? 0)\n    const carbs = Number(food.carbs_g ?? 0)\n    const sugar = Number(food.sugar_g ?? 0)\n    const fiber = Number(food.fiber_g ?? 0)\n    const fat = Number(food.fat_g ?? 0)\n    const nonFatMacros =\n      (Number.isFinite(protein) && protein > 0.5) ||\n      (Number.isFinite(carbs) && carbs > 0.5) ||\n      (Number.isFinite(sugar) && sugar > 0.5) ||\n      (Number.isFinite(fiber) && fiber > 0.5)\n    if (food.source !== 'helfi' && isLikelyOilProduct(food.name) && Number.isFinite(fat) && fat > 10 && nonFatMacros) {\n      return NextResponse.json(\n        {\n          found: false,\n          error: 'nutrition_suspect',\n          message: 'Barcode nutrition for oils looks unreliable. Please scan the nutrition label to lock in the correct values.',\n          product: {\n            name: food.name || null,\n            brand: food.brand || null,\n            serving_size: food.serving_size || null,\n          },\n          barcode: code,\n        },\n        { status: 422 },\n      )\n    }\n\n    const nutritionValues = [\n      food.calories,\n      food.protein_g,\n      food.carbs_g,\n      food.fat_g,\n      food.fiber_g,\n      food.sugar_g,\n    ]\n    const hasMeaningfulNutrition = nutritionValues.some((v) => Number.isFinite(Number(v)) && Number(v) > 0)\n    if (!hasMeaningfulNutrition) {\n      return NextResponse.json(\n        {\n          found: false,\n          error: 'nutrition_missing',\n          message: 'Product found, but nutrition data is missing. Please scan the nutrition label instead.',\n          product: {\n            name: food.name || null,\n            brand: food.brand || null,\n            serving_size: food.serving_size || null,\n          },\n          barcode: code,\n        },\n        { status: 422 },\n      )\n    }\n\n    const discreteLog = summarizeDiscreteItemsForLog([food])\n    if (discreteLog.length > 0) {\n      console.log('[BARCODE_DEBUG] discrete normalization', discreteLog)\n    }\n    console.log('[BARCODE_DEBUG] normalized barcode payload', normalized.debug)\n\n    // Charge only when we actually have a product to return\n    const charged = await cm.chargeCents(BARCODE_SCAN_COST_CENTS)\n    if (!charged) {\n      return NextResponse.json(\n        { error: 'Insufficient credits', message: 'Barcode scanning requires 3 credits.' },\n        { status: 402 },\n      )\n    }\n    return NextResponse.json({ found: true, food })\n  }\n\n  console.log('‚ö†Ô∏è No barcode match found after FatSecret, OpenFoodFacts, or USDA for:', code)\n  \n  return NextResponse.json(\n    {\n      found: false,\n      message: 'No product found for this barcode. Try searching by product name instead.',\n      barcode: code,\n    },\n    { status: 404 },\n  )\n}\n","truncated":false,"size":21660},{"path":"app/api/billing/confirm/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\nimport Stripe from 'stripe'\nimport { notifyOwner } from '@/lib/owner-notifications'\nimport { reportCriticalError } from '@/lib/error-reporter'\n\n// Force dynamic so this route isn't considered for static optimization at build time\nexport const dynamic = 'force-dynamic'\nexport const revalidate = 0\n\nexport async function GET(request: NextRequest) {\n  let sessionParam: string | null = null\n  try {\n    sessionParam = new URL(request.url).searchParams.get('session_id')\n    if (!sessionParam) {\n      return NextResponse.json({ error: 'missing_session_id' }, { status: 400 })\n    }\n    const secretKey = process.env.STRIPE_SECRET_KEY\n    if (!secretKey) {\n      return NextResponse.json({ error: 'stripe_not_configured' }, { status: 500 })\n    }\n    const stripe = new Stripe(secretKey, { apiVersion: '2024-06-20' })\n    const checkout = await stripe.checkout.sessions.retrieve(sessionParam, {\n      expand: ['line_items', 'payment_intent'],\n    })\n\n    if (checkout.payment_status !== 'paid') {\n      return NextResponse.json({ error: 'not_paid' }, { status: 400 })\n    }\n\n    const serverSession = (await getServerSession(authOptions as any)) as any\n    const sessionUserId = (serverSession?.user?.id as string) || ''\n    const sessionEmail = ((serverSession?.user?.email as string) || '').toLowerCase()\n    const metadata = (checkout.metadata || {}) as Record<string, string>\n    const metaUserId = String(metadata.helfi_user_id || '').trim()\n    const metaEmail = String(metadata.helfi_user_email || '').toLowerCase().trim()\n    const checkoutEmail = String(checkout.customer_details?.email || checkout.customer_email || '').toLowerCase().trim()\n    const expectedUserId = metaUserId\n    const expectedEmail = metaEmail || checkoutEmail\n\n    if ((sessionUserId || sessionEmail) && (expectedUserId || expectedEmail)) {\n      const matchesId = expectedUserId && sessionUserId && expectedUserId === sessionUserId\n      const matchesEmail = expectedEmail && sessionEmail && expectedEmail === sessionEmail\n      if (!matchesId && !matchesEmail) {\n        return NextResponse.json({ error: 'user_mismatch' }, { status: 403 })\n      }\n    }\n\n    let user = null as { id: string; email: string; name: string | null } | null\n    if (expectedUserId) {\n      user = await prisma.user.findUnique({ where: { id: expectedUserId }, select: { id: true, email: true, name: true } })\n    } else if (expectedEmail) {\n      user = await prisma.user.findUnique({ where: { email: expectedEmail }, select: { id: true, email: true, name: true } })\n    } else if (sessionEmail) {\n      user = await prisma.user.findUnique({ where: { email: sessionEmail }, select: { id: true, email: true, name: true } })\n    }\n\n    if (!user) {\n      return NextResponse.json({ error: 'user_not_found' }, { status: 404 })\n    }\n\n    // Only process one time\n    const existing = await prisma.creditTopUp.findFirst({\n      where: { source: `stripe:${checkout.id}` },\n    })\n    if (existing) {\n      return NextResponse.json({ ok: true, alreadyProcessed: true })\n    }\n\n    // For credit purchases we used Checkout in 'payment' mode.\n    const paymentCents = typeof checkout.amount_total === 'number' ? checkout.amount_total : 0\n    if (paymentCents <= 0 || checkout.mode !== 'payment') {\n      return NextResponse.json({ error: 'not_a_credit_purchase' }, { status: 400 })\n    }\n\n    const purchasedAt = new Date()\n    const expiresAt = new Date(purchasedAt)\n    expiresAt.setUTCMonth(expiresAt.getUTCMonth() + 12)\n\n    // Map paid amount to wallet credits (not 1:1 dollars). New schedule (75% profit target):\n    // $5 -> 250 credits, $10 -> 500 credits, $20 -> 1,000 credits. Fallback: use payment amount.\n    let creditAmount = 0\n    if (paymentCents >= 2000) creditAmount = 1000\n    else if (paymentCents >= 1000) creditAmount = 500\n    else if (paymentCents >= 500) creditAmount = 250\n    const walletCredits = creditAmount > 0 ? creditAmount : paymentCents\n\n    await prisma.creditTopUp.create({\n      data: {\n        userId: user.id,\n        amountCents: walletCredits,\n        usedCents: 0,\n        purchasedAt,\n        expiresAt,\n        source: `stripe:${checkout.id}`,\n      },\n    })\n\n    // Notify owner of credit purchase (don't await to avoid blocking response)\n    notifyOwner({\n      event: 'credit_purchase',\n      userEmail: user.email,\n      userName: user.name || undefined,\n      amount: paymentCents,\n      currency: (checkout.currency || 'usd').toUpperCase(),\n      creditAmount: creditAmount || undefined,\n    }).catch(error => {\n      console.error('‚ùå Owner notification failed (non-blocking):', error)\n    })\n\n    return NextResponse.json({ ok: true })\n  } catch (err) {\n    reportCriticalError({\n      source: 'billing.confirm',\n      error: err,\n      details: {\n        sessionId: sessionParam || undefined,\n      },\n    })\n    console.error('[billing.confirm] error', err)\n    return NextResponse.json({ error: 'server_error' }, { status: 500 })\n  }\n}\n","truncated":false,"size":5125},{"path":"app/api/billing/create-checkout-session/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport Stripe from 'stripe'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\nimport crypto from 'crypto'\nimport { getAffiliateCookieData, isAffiliateAttributionFresh } from '@/lib/affiliate-cookies'\n\n// POST /api/billing/create-checkout-session\nexport async function POST(request: NextRequest) {\n  try {\n    const secretKey = process.env.STRIPE_SECRET_KEY\n    if (!secretKey) {\n      return NextResponse.json({ error: 'Stripe not configured' }, { status: 500 })\n    }\n\n    const stripe = new Stripe(secretKey, {\n      apiVersion: '2024-06-20',\n    })\n\n    const url = new URL(request.url)\n    const origin = url.origin\n\n    const body = await request.json().catch(() => ({} as any))\n    const requestedPlan: string | undefined = body?.plan\n    const quantity: number = Number(body?.quantity || 1)\n\n    const PLAN_TO_PRICE: Record<string, string | undefined> = {\n      // Monthly subscription plans\n      plan_10_monthly: process.env.STRIPE_PRICE_10_MONTHLY,\n      plan_20_monthly: process.env.STRIPE_PRICE_20_MONTHLY,\n      plan_30_monthly: process.env.STRIPE_PRICE_30_MONTHLY,\n      plan_50_monthly: process.env.STRIPE_PRICE_50_MONTHLY,\n      // Legacy plan names (for backward compatibility)\n      premium_monthly: process.env.STRIPE_PRICE_PREMIUM_MONTHLY,\n      premium_yearly: process.env.STRIPE_PRICE_PREMIUM_YEARLY,\n      premium_plus_monthly: process.env.STRIPE_PRICE_PREMIUM_PLUS_MONTHLY,\n      premium_plus_yearly: process.env.STRIPE_PRICE_PREMIUM_PLUS_YEARLY,\n      // Credit top-ups (one-time payments)\n      credits_250: process.env.STRIPE_PRICE_CREDITS_250,\n      credits_500: process.env.STRIPE_PRICE_CREDITS_500,\n      credits_1000: process.env.STRIPE_PRICE_CREDITS_1000,\n      // Legacy credit name\n      credits_100: process.env.STRIPE_PRICE_CREDITS_100,\n    }\n\n    const priceId = requestedPlan ? PLAN_TO_PRICE[requestedPlan] : undefined\n\n    if (!priceId) {\n      return NextResponse.json({ error: 'Invalid plan or price not configured' }, { status: 400 })\n    }\n\n    const isCredits = (requestedPlan ?? '').startsWith('credits_')\n\n    // Get user email from session if available\n    const session = await getServerSession(authOptions)\n    const customerEmail = session?.user?.email || undefined\n\n    const affiliateCookie = getAffiliateCookieData(request)\n    const hasFreshAffiliateAttribution =\n      affiliateCookie && isAffiliateAttributionFresh(affiliateCookie.clickedAtMs)\n        ? true\n        : false\n    const baseMetadata: Record<string, string> = {}\n    if (hasFreshAffiliateAttribution) {\n      baseMetadata.helfi_aff_code = affiliateCookie!.code\n      baseMetadata.helfi_aff_click = affiliateCookie!.clickId\n      baseMetadata.helfi_aff_ts = String(affiliateCookie!.clickedAtMs)\n    }\n    if (session?.user?.id) {\n      baseMetadata.helfi_user_id = String(session.user.id)\n    }\n    if (customerEmail) {\n      baseMetadata.helfi_user_email = String(customerEmail).toLowerCase()\n    }\n\n    // Check if user already has an active subscription (only for subscription plans, not credit top-ups)\n    if (!isCredits && customerEmail) {\n      try {\n        const user = await prisma.user.findUnique({\n          where: { email: customerEmail.toLowerCase() },\n          include: { subscription: true }\n        })\n\n        if (user?.subscription) {\n          // Check if subscription is active (no endDate or endDate is in the future)\n          const now = new Date()\n          const isActive = !user.subscription.endDate || new Date(user.subscription.endDate) > now\n\n          if (isActive) {\n            // Determine current plan tier for better error message\n            const currentTier = user.subscription.monthlyPriceCents\n            let tierName = 'Premium'\n            if (currentTier === 1000) tierName = '$10/month (700 credits)'\n            else if (currentTier === 2000) tierName = '$20/month (1,400 credits)'\n            else if (currentTier === 3000) tierName = '$30/month (2,100 credits)'\n            else if (currentTier === 5000) tierName = '$50/month (3,500 credits)'\n            else if (currentTier) tierName = `$${(currentTier / 100).toFixed(0)}/month`\n\n            return NextResponse.json(\n              { \n                error: 'You already have an active subscription',\n                message: `You are currently subscribed to ${tierName}. Please cancel your existing subscription before subscribing to a new plan.`,\n                currentPlan: tierName\n              },\n              { status: 400 }\n            )\n          }\n        }\n      } catch (error) {\n        console.error('Error checking existing subscription:', error)\n        // Continue with checkout if we can't check (don't block user)\n      }\n    }\n\n    const checkoutSession = await stripe.checkout.sessions.create({\n      mode: isCredits ? 'payment' : 'subscription',\n      line_items: [\n        {\n          price: priceId,\n          quantity: quantity,\n        },\n      ],\n      success_url: `${origin}/billing?checkout=success&session_id={CHECKOUT_SESSION_ID}`,\n      cancel_url: `${origin}/billing?checkout=cancelled`,\n      customer_email: customerEmail,\n      allow_promotion_codes: true,\n      payment_method_collection: 'always',\n      ...(Object.keys(baseMetadata).length ? { metadata: baseMetadata } : {}),\n      ...(isCredits\n        ? Object.keys(baseMetadata).length\n          ? { payment_intent_data: { metadata: baseMetadata } }\n          : {}\n        : Object.keys(baseMetadata).length\n          ? { subscription_data: { metadata: baseMetadata } }\n          : {}),\n      // No trial period - subscriptions start immediately\n    })\n\n    return NextResponse.json({ url: checkoutSession.url })\n  } catch (error) {\n    console.error('Error creating checkout session:', error)\n    return NextResponse.json({ error: 'Failed to create checkout session' }, { status: 500 })\n  }\n}\n","truncated":false,"size":5941},{"path":"app/api/billing/portal/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport Stripe from 'stripe'\n\nexport async function POST(req: NextRequest) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.email) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const secretKey = process.env.STRIPE_SECRET_KEY\n    if (!secretKey) {\n      return NextResponse.json({ error: 'Stripe not configured' }, { status: 500 })\n    }\n\n    const stripe = new Stripe(secretKey, { apiVersion: '2024-06-20' })\n    const email = session.user.email.toLowerCase()\n\n    // Find Stripe customer by email\n    const customers = await stripe.customers.list({ email, limit: 1 })\n    if (!customers.data.length) {\n      // User might have admin-granted subscription without Stripe customer\n      // Return a helpful error message\n      return NextResponse.json({ \n        error: 'No Stripe customer found',\n        message: 'Your subscription was granted by an administrator. Please contact support to manage your subscription, or subscribe through Stripe to enable self-service management.'\n      }, { status: 404 })\n    }\n\n    const customerId = customers.data[0].id\n    const returnUrl = `${req.nextUrl.origin}/billing`\n\n    const portalSession = await stripe.billingPortal.sessions.create({\n      customer: customerId,\n      return_url: returnUrl,\n    })\n\n    return NextResponse.json({ url: portalSession.url })\n  } catch (error: any) {\n    console.error('Error creating portal session:', error)\n    return NextResponse.json({ \n      error: 'Failed to create portal session',\n      details: error?.message || 'Unknown error',\n      code: error?.code || 'NO_CODE'\n    }, { status: 500 })\n  }\n}\n","truncated":false,"size":1811},{"path":"app/api/billing/subscription/debug/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\n\n// Debug endpoint to check what's happening\nexport async function GET(request: NextRequest) {\n  const debug: any = {\n    timestamp: new Date().toISOString(),\n    checks: []\n  }\n\n  try {\n    // Check 1: Session\n    const session = await getServerSession(authOptions)\n    debug.checks.push({\n      name: 'Session',\n      status: session ? 'OK' : 'FAILED',\n      email: session?.user?.email || 'N/A'\n    })\n\n    if (!session?.user?.email) {\n      return NextResponse.json({ error: 'Unauthorized', debug }, { status: 401 })\n    }\n\n    // Check 2: Stripe Config\n    const stripeKey = process.env.STRIPE_SECRET_KEY\n    debug.checks.push({\n      name: 'Stripe Config',\n      status: stripeKey ? 'OK' : 'FAILED',\n      keyPrefix: stripeKey ? stripeKey.substring(0, 10) + '...' : 'NOT SET'\n    })\n\n    // Check 3: User lookup\n    let user\n    try {\n      user = await prisma.user.findUnique({\n        where: { email: session.user.email.toLowerCase() },\n        select: { id: true, email: true }\n      })\n      debug.checks.push({\n        name: 'User Lookup',\n        status: user ? 'OK' : 'NOT FOUND',\n        userId: user?.id || 'N/A'\n      })\n    } catch (error: any) {\n      debug.checks.push({\n        name: 'User Lookup',\n        status: 'ERROR',\n        error: error?.message\n      })\n      return NextResponse.json({ error: 'User lookup failed', debug }, { status: 500 })\n    }\n\n    if (!user) {\n      return NextResponse.json({ error: 'User not found', debug }, { status: 404 })\n    }\n\n    // Check 4: Subscription lookup\n    let subscription\n    try {\n      subscription = await prisma.subscription.findFirst({\n        where: { userId: user.id },\n      })\n      debug.checks.push({\n        name: 'Subscription Lookup',\n        status: subscription ? 'OK' : 'NOT FOUND',\n        subscriptionId: subscription?.id || 'N/A',\n        monthlyPriceCents: subscription?.monthlyPriceCents || 'N/A'\n      })\n    } catch (error: any) {\n      debug.checks.push({\n        name: 'Subscription Lookup',\n        status: 'ERROR',\n        error: error?.message,\n        stack: error?.stack\n      })\n      return NextResponse.json({ error: 'Subscription lookup failed', debug }, { status: 500 })\n    }\n\n    // Check 5: Try to access stripeSubscriptionId\n    try {\n      const stripeId = (subscription as any)?.stripeSubscriptionId\n      debug.checks.push({\n        name: 'Stripe Subscription ID Access',\n        status: 'OK',\n        value: stripeId || 'NULL'\n      })\n    } catch (error: any) {\n      debug.checks.push({\n        name: 'Stripe Subscription ID Access',\n        status: 'ERROR',\n        error: error?.message\n      })\n    }\n\n    return NextResponse.json({ \n      success: true,\n      debug,\n      subscription: subscription ? {\n        id: subscription.id,\n        monthlyPriceCents: subscription.monthlyPriceCents,\n        stripeSubscriptionId: (subscription as any).stripeSubscriptionId || null\n      } : null\n    })\n  } catch (error: any) {\n    debug.checks.push({\n      name: 'Overall Error',\n      status: 'ERROR',\n      error: error?.message,\n      stack: error?.stack\n    })\n    return NextResponse.json({ error: 'Debug endpoint failed', debug }, { status: 500 })\n  }\n}\n\n","truncated":false,"size":3355},{"path":"app/api/billing/subscription/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport Stripe from 'stripe'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\n\nconst stripe = new Stripe(process.env.STRIPE_SECRET_KEY || '', { apiVersion: '2024-06-20' })\n\n// GET /api/billing/subscription - Get current subscription status\nexport async function GET(request: NextRequest) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.email) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    // Check Stripe configuration\n    const stripeSecretKey = process.env.STRIPE_SECRET_KEY\n    if (!stripeSecretKey) {\n      console.error('STRIPE_SECRET_KEY is not set')\n      return NextResponse.json({ \n        error: 'Stripe not configured',\n        details: 'STRIPE_SECRET_KEY environment variable is missing'\n      }, { status: 500 })\n    }\n\n    // Fetch user and subscription separately to avoid Prisma client issues\n    let user\n    try {\n      user = await prisma.user.findUnique({\n        where: { email: session.user.email.toLowerCase() },\n        select: { id: true, email: true, name: true }\n      })\n    } catch (error) {\n      console.error('Error fetching user:', error)\n      return NextResponse.json({ \n        error: 'Database error',\n        details: error instanceof Error ? error.message : 'Unknown error'\n      }, { status: 500 })\n    }\n\n    if (!user) {\n      return NextResponse.json({ error: 'User not found' }, { status: 404 })\n    }\n\n    // Fetch subscription using raw SQL to avoid Prisma schema issues with stripeSubscriptionId column\n    let subscription\n    try {\n      const subscriptionResult: any[] = await prisma.$queryRawUnsafe(\n        `SELECT id, \"userId\", plan, \"monthlyPriceCents\", \"startDate\", \"endDate\"\n         FROM \"Subscription\"\n         WHERE \"userId\" = $1\n         LIMIT 1`,\n        user.id\n      )\n      subscription = subscriptionResult && subscriptionResult.length > 0 ? subscriptionResult[0] : null\n      \n      // Try to get stripeSubscriptionId separately if column exists\n      if (subscription) {\n        try {\n          const stripeIdResult: any[] = await prisma.$queryRawUnsafe(\n            `SELECT \"stripeSubscriptionId\" FROM \"Subscription\" WHERE \"userId\" = $1 LIMIT 1`,\n            user.id\n          )\n          if (stripeIdResult && stripeIdResult.length > 0) {\n            subscription.stripeSubscriptionId = stripeIdResult[0].stripeSubscriptionId || null\n          } else {\n            subscription.stripeSubscriptionId = null\n          }\n        } catch {\n          // Column doesn't exist, set to null\n          subscription.stripeSubscriptionId = null\n        }\n      }\n    } catch (error: any) {\n      console.error('Error fetching subscription:', error)\n      return NextResponse.json({ \n        error: 'Database error',\n        details: error?.message || 'Unknown error'\n      }, { status: 500 })\n    }\n    \n    if (!subscription) {\n      return NextResponse.json({ \n        hasSubscription: false,\n        subscription: null\n      })\n    }\n\n    // Check if subscription is active\n    const now = new Date()\n    const endDate = subscription.endDate ? new Date(subscription.endDate) : null\n    const isActive = !endDate || endDate > now\n\n    // Get Stripe subscription details if available\n    let stripeSubscription = null\n    // Safely access stripeSubscriptionId field (may not exist in Prisma types yet)\n    const stripeSubscriptionId = (subscription as any).stripeSubscriptionId || null\n    \n    if (stripeSubscriptionId) {\n      try {\n        stripeSubscription = await stripe.subscriptions.retrieve(stripeSubscriptionId)\n      } catch (error: any) {\n        console.error('Error fetching Stripe subscription:', error?.message || error)\n        // Continue without Stripe data - subscription might have been deleted in Stripe\n      }\n    } else {\n      // Try to find Stripe subscription by customer email\n      try {\n        const customers = await stripe.customers.list({\n          email: session.user.email.toLowerCase(),\n          limit: 1\n        })\n        \n        if (customers.data.length > 0) {\n          const customer = customers.data[0]\n          const subscriptions = await stripe.subscriptions.list({\n            customer: customer.id,\n            status: 'all',\n            limit: 1\n          })\n          \n          if (subscriptions.data.length > 0) {\n            stripeSubscription = subscriptions.data[0]\n            // Update database with Stripe subscription ID (only if column exists) - use raw SQL\n            try {\n              await prisma.$executeRawUnsafe(\n                `UPDATE \"Subscription\" SET \"stripeSubscriptionId\" = $1 WHERE \"userId\" = $2`,\n                stripeSubscription.id,\n                user.id\n              )\n            } catch (updateError: any) {\n              console.error('Error updating stripeSubscriptionId:', updateError?.message || updateError)\n              // Continue without updating - column might not exist yet\n            }\n          }\n        }\n      } catch (error: any) {\n        console.error('Error finding Stripe subscription by email:', error?.message || error)\n        // Continue without Stripe data - user might not have Stripe customer yet\n      }\n    }\n\n    // Determine plan tier name\n    const currentTier = subscription.monthlyPriceCents\n    let tierName = 'Premium'\n    let credits = 0\n\n    const subscriptionCreditsMap: Record<number, number> = {\n      1000: 700,  // $10/month ‚Üí 700 credits\n      2000: 1400, // $20/month ‚Üí 1,400 credits\n      3000: 2100, // $30/month ‚Üí 2,100 credits\n      5000: 3500, // $50/month ‚Üí 3,500 credits\n    }\n\n    if (currentTier && subscriptionCreditsMap[currentTier]) {\n      tierName = `$${(currentTier / 100).toFixed(0)}/month`\n      credits = subscriptionCreditsMap[currentTier]\n    } else if (currentTier) {\n      tierName = `$${(currentTier / 100).toFixed(0)}/month`\n      // Estimate credits based on price (rough approximation)\n      credits = Math.round(currentTier / 2) // $1 = ~50 credits\n    } else {\n      // Default for admin-granted subscriptions without price set\n      tierName = 'Premium'\n      credits = 1000 // Default estimate\n    }\n\n    return NextResponse.json({\n      hasSubscription: true,\n      isActive,\n      subscription: {\n        id: subscription.id,\n        plan: subscription.plan,\n        tier: tierName,\n        credits,\n        monthlyPriceCents: subscription.monthlyPriceCents,\n        startDate: subscription.startDate?.toISOString() || subscription.startDate,\n        endDate: subscription.endDate?.toISOString() || subscription.endDate || null,\n        stripeSubscriptionId: stripeSubscriptionId,\n        stripeStatus: stripeSubscription?.status,\n        stripeCancelAtPeriodEnd: stripeSubscription?.cancel_at_period_end,\n        stripeCurrentPeriodEnd: stripeSubscription?.current_period_end ? new Date(stripeSubscription.current_period_end * 1000).toISOString() : null,\n        isStripeManaged: !!stripeSubscriptionId || !!stripeSubscription\n      }\n    })\n  } catch (error: any) {\n    console.error('Error fetching subscription:', error)\n    console.error('Error details:', {\n      message: error?.message,\n      stack: error?.stack,\n      name: error?.name,\n      code: error?.code\n    })\n    \n    // Always return detailed error to help diagnose (we can remove later)\n    return NextResponse.json({ \n      error: 'Failed to fetch subscription',\n      details: {\n        message: error?.message || 'Unknown error',\n        name: error?.name || 'Error',\n        code: error?.code || 'NO_CODE',\n        stack: error?.stack ? error.stack.split('\\n').slice(0, 5).join('\\n') : 'No stack trace'\n      }\n    }, { status: 500 })\n  }\n}\n\n// POST /api/billing/subscription - Cancel, upgrade, or downgrade subscription\nexport async function POST(request: NextRequest) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.email) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const body = await request.json()\n    const { action, newPlan } = body // action: 'cancel' | 'upgrade' | 'downgrade', newPlan: 'plan_20_monthly' | etc.\n\n    const user = await prisma.user.findUnique({\n      where: { email: session.user.email.toLowerCase() },\n      select: { id: true }\n    })\n\n    if (!user) {\n      return NextResponse.json({ error: 'User not found' }, { status: 404 })\n    }\n\n    // Fetch subscription using raw SQL to avoid Prisma schema issues\n    let dbSubscription\n    try {\n      const subscriptionResult: any[] = await prisma.$queryRawUnsafe(\n        `SELECT id, \"userId\", plan, \"monthlyPriceCents\", \"startDate\", \"endDate\"\n         FROM \"Subscription\"\n         WHERE \"userId\" = $1\n         LIMIT 1`,\n        user.id\n      )\n      dbSubscription = subscriptionResult && subscriptionResult.length > 0 ? subscriptionResult[0] : null\n      \n      // Try to get stripeSubscriptionId separately if column exists\n      if (dbSubscription) {\n        try {\n          const stripeIdResult: any[] = await prisma.$queryRawUnsafe(\n            `SELECT \"stripeSubscriptionId\" FROM \"Subscription\" WHERE \"userId\" = $1 LIMIT 1`,\n            user.id\n          )\n          if (stripeIdResult && stripeIdResult.length > 0) {\n            dbSubscription.stripeSubscriptionId = stripeIdResult[0].stripeSubscriptionId || null\n          } else {\n            dbSubscription.stripeSubscriptionId = null\n          }\n        } catch {\n          // Column doesn't exist, set to null\n          dbSubscription.stripeSubscriptionId = null\n        }\n      }\n    } catch (error: any) {\n      console.error('Error fetching subscription:', error)\n      return NextResponse.json({ \n        error: 'Database error',\n        message: error?.message || 'Failed to fetch subscription'\n      }, { status: 500 })\n    }\n\n    if (!dbSubscription) {\n      return NextResponse.json({ error: 'No active subscription found' }, { status: 400 })\n    }\n\n    // Find or get Stripe subscription\n    let stripeSubscriptionId = dbSubscription.stripeSubscriptionId || null\n    \n    if (!stripeSubscriptionId) {\n      // Try to find by customer email\n      try {\n        const customers = await stripe.customers.list({\n          email: session.user.email.toLowerCase(),\n          limit: 1\n        })\n        \n        if (customers.data.length > 0) {\n          const customer = customers.data[0]\n          const subscriptions = await stripe.subscriptions.list({\n            customer: customer.id,\n            status: 'active',\n            limit: 1\n          })\n          \n          if (subscriptions.data.length > 0) {\n            stripeSubscriptionId = subscriptions.data[0].id\n            // Update database (only if column exists) - use raw SQL\n            try {\n              await prisma.$executeRawUnsafe(\n                `UPDATE \"Subscription\" SET \"stripeSubscriptionId\" = $1 WHERE \"userId\" = $2`,\n                stripeSubscriptionId,\n                user.id\n              )\n            } catch (updateError) {\n              console.error('Error updating stripeSubscriptionId (column may not exist yet):', updateError)\n              // Continue without updating\n            }\n          }\n        }\n      } catch (error) {\n        console.error('Error finding Stripe subscription:', error)\n      }\n    }\n\n    if (action === 'cancel') {\n      if (stripeSubscriptionId) {\n        // Cancel Stripe subscription at period end\n        const updatedSubscription = await stripe.subscriptions.update(stripeSubscriptionId, {\n          cancel_at_period_end: true\n        })\n        \n        // Get the actual cancellation date (current_period_end)\n        const cancellationDate = updatedSubscription.current_period_end \n          ? new Date(updatedSubscription.current_period_end * 1000)\n          : null\n        \n        return NextResponse.json({ \n          success: true,\n          message: 'Subscription will be canceled at the end of the current billing period',\n          cancellationDate: cancellationDate?.toISOString() || null\n        })\n      } else {\n        // Admin-granted subscription - set endDate to end of current period\n        const startDate = dbSubscription.startDate ? new Date(dbSubscription.startDate) : new Date()\n        const endDate = new Date(startDate)\n        endDate.setMonth(endDate.getMonth() + 1) // Cancel at end of current month\n        \n        // Use raw SQL to update endDate\n        await prisma.$executeRawUnsafe(\n          `UPDATE \"Subscription\" SET \"endDate\" = $1 WHERE \"userId\" = $2`,\n          endDate,\n          user.id\n        )\n        \n        return NextResponse.json({ \n          success: true,\n          message: 'Subscription will be canceled at the end of the current billing period',\n          cancellationDate: endDate.toISOString()\n        })\n      }\n    } else if (action === 'upgrade' || action === 'downgrade') {\n      if (!newPlan) {\n        return NextResponse.json({ error: 'New plan required for upgrade/downgrade' }, { status: 400 })\n      }\n\n      const PLAN_TO_PRICE: Record<string, string | undefined> = {\n        plan_10_monthly: process.env.STRIPE_PRICE_10_MONTHLY,\n        plan_20_monthly: process.env.STRIPE_PRICE_20_MONTHLY,\n        plan_30_monthly: process.env.STRIPE_PRICE_30_MONTHLY,\n        plan_50_monthly: process.env.STRIPE_PRICE_50_MONTHLY,\n      }\n\n      const newPriceId = PLAN_TO_PRICE[newPlan]\n      if (!newPriceId) {\n        return NextResponse.json({ error: 'Invalid plan' }, { status: 400 })\n      }\n\n      if (stripeSubscriptionId) {\n        // Update Stripe subscription\n        const stripeSub = await stripe.subscriptions.retrieve(stripeSubscriptionId)\n        const currentPriceId = stripeSub.items.data[0]?.price?.id\n\n        if (currentPriceId === newPriceId) {\n          return NextResponse.json({ error: 'You are already on this plan' }, { status: 400 })\n        }\n\n        // Update subscription to new price\n        await stripe.subscriptions.update(stripeSubscriptionId, {\n          items: [{\n            id: stripeSub.items.data[0].id,\n            price: newPriceId,\n          }],\n          proration_behavior: 'always_invoice', // Prorate the difference\n        })\n\n        // Determine new tier\n        let newPriceCents = 2000\n        if (newPlan === 'plan_10_monthly') newPriceCents = 1000\n        else if (newPlan === 'plan_20_monthly') newPriceCents = 2000\n        else if (newPlan === 'plan_30_monthly') newPriceCents = 3000\n        else if (newPlan === 'plan_50_monthly') newPriceCents = 5000\n\n        // Update database using raw SQL\n        await prisma.$executeRawUnsafe(\n          `UPDATE \"Subscription\" SET \"monthlyPriceCents\" = $1 WHERE \"userId\" = $2`,\n          newPriceCents,\n          user.id\n        )\n\n        return NextResponse.json({ \n          success: true,\n          message: `Subscription ${action === 'upgrade' ? 'upgraded' : 'downgraded'} successfully`\n        })\n      } else {\n        // Admin-granted subscription - update database only\n        let newPriceCents = 2000\n        if (newPlan === 'plan_10_monthly') newPriceCents = 1000\n        else if (newPlan === 'plan_20_monthly') newPriceCents = 2000\n        else if (newPlan === 'plan_30_monthly') newPriceCents = 3000\n        else if (newPlan === 'plan_50_monthly') newPriceCents = 5000\n\n        // Update database using raw SQL\n        await prisma.$executeRawUnsafe(\n          `UPDATE \"Subscription\" SET \"monthlyPriceCents\" = $1 WHERE \"userId\" = $2`,\n          newPriceCents,\n          user.id\n        )\n\n        return NextResponse.json({ \n          success: true,\n          message: `Subscription ${action === 'upgrade' ? 'upgraded' : 'downgraded'} successfully`\n        })\n      }\n    } else {\n      return NextResponse.json({ error: 'Invalid action' }, { status: 400 })\n    }\n  } catch (error: any) {\n    console.error('Error managing subscription:', error)\n    return NextResponse.json({ \n      error: 'Failed to manage subscription',\n      message: error?.message || 'Unknown error occurred',\n      details: error?.code || 'NO_CODE'\n    }, { status: 500 })\n  }\n}\n","truncated":false,"size":16102},{"path":"app/api/billing/webhook/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport Stripe from 'stripe'\nimport { prisma } from '@/lib/prisma'\nimport { Resend } from 'resend'\nimport { notifyOwner } from '@/lib/owner-notifications'\nimport { getEmailFooter } from '@/lib/email-footer'\nimport { reportCriticalError } from '@/lib/error-reporter'\n\nconst stripe = new Stripe(process.env.STRIPE_SECRET_KEY || '', { apiVersion: '2024-06-20' })\nconst resend = process.env.RESEND_API_KEY ? new Resend(process.env.RESEND_API_KEY) : null\nconst endpointSecret = process.env.STRIPE_WEBHOOK_SECRET || ''\nconst SUBSCRIBER_MILESTONE_INTERVAL = 20\n\nasync function getBalanceTransactionForPaymentIntent(paymentIntentId: string) {\n  const pi = await stripe.paymentIntents.retrieve(paymentIntentId, {\n    expand: ['charges.data.balance_transaction'],\n  })\n  const charge = (pi as any)?.charges?.data?.[0] as Stripe.Charge | undefined\n  const balanceTx = (charge as any)?.balance_transaction as Stripe.BalanceTransaction | undefined\n  return { charge, balanceTx }\n}\n\nfunction isStripeSubscriptionActive(subscription: Stripe.Subscription): boolean {\n  return subscription.status === 'active' || subscription.status === 'trialing'\n}\n\nasync function findCheckoutSessionForPaymentIntent(paymentIntentId: string): Promise<Stripe.Checkout.Session | null> {\n  try {\n    const sessions = await stripe.checkout.sessions.list({\n      payment_intent: paymentIntentId,\n      limit: 1,\n    })\n    return sessions.data[0] ?? null\n  } catch {\n    return null\n  }\n}\n\nfunction addDays(date: Date, days: number): Date {\n  const d = new Date(date)\n  d.setUTCDate(d.getUTCDate() + days)\n  return d\n}\n\nasync function ensureSubscriberMilestonesTable() {\n  await prisma.$executeRawUnsafe(`\n    CREATE TABLE IF NOT EXISTS SubscriberMilestones (\n      id TEXT PRIMARY KEY,\n      total_count INT NOT NULL DEFAULT 0,\n      last_notified_count INT NOT NULL DEFAULT 0,\n      updated_at TIMESTAMP NOT NULL DEFAULT NOW()\n    )\n  `)\n\n  await prisma.$executeRawUnsafe(`\n    INSERT INTO SubscriberMilestones (id, total_count, last_notified_count)\n    VALUES ('global', 0, 0)\n    ON CONFLICT (id) DO NOTHING\n  `)\n}\n\nasync function incrementSubscriberMilestoneCounter(): Promise<{\n  totalCount: number\n  shouldNotify: boolean\n}> {\n  await ensureSubscriberMilestonesTable()\n\n  return prisma.$transaction(async (tx) => {\n    const rows = await tx.$queryRawUnsafe<\n      Array<{ total_count: number; last_notified_count: number }>\n    >(`SELECT total_count, last_notified_count FROM SubscriberMilestones WHERE id = 'global' FOR UPDATE`)\n    const currentCount = rows[0]?.total_count ?? 0\n    const lastNotified = rows[0]?.last_notified_count ?? 0\n    const totalCount = currentCount + 1\n    const shouldNotify =\n      totalCount % SUBSCRIBER_MILESTONE_INTERVAL === 0 && totalCount > lastNotified\n    const nextNotified = shouldNotify ? totalCount : lastNotified\n\n    await tx.$executeRawUnsafe(\n      `UPDATE SubscriberMilestones\n       SET total_count = $1, last_notified_count = $2, updated_at = NOW()\n       WHERE id = 'global'`,\n      totalCount,\n      nextNotified\n    )\n\n    return { totalCount, shouldNotify }\n  })\n}\n\nasync function sendSubscriberMilestoneEmail(options: {\n  recipientEmail: string\n  totalCount: number\n  latestSubscriberEmail: string\n}) {\n  if (!resend) {\n    console.log('üìß Resend API not configured, skipping subscriber milestone email')\n    return\n  }\n\n  const { recipientEmail, totalCount, latestSubscriberEmail } = options\n  const subject = `Helfi milestone reached: ${totalCount} paid subscribers`\n  const html = `\n    <div style=\"font-family: Arial, sans-serif; line-height: 1.5; color: #111827;\">\n      <h2 style=\"margin: 0 0 16px 0;\">Subscriber milestone reached</h2>\n      <p style=\"margin: 0 0 8px 0;\"><strong>Total paid subscribers:</strong> ${totalCount}</p>\n      <p style=\"margin: 0 0 16px 0;\"><strong>Latest subscriber:</strong> ${latestSubscriberEmail}</p>\n      <p style=\"margin: 0 0 16px 0;\">You asked to be notified every ${SUBSCRIBER_MILESTONE_INTERVAL} new subscribers.</p>\n      ${getEmailFooter({\n        recipientEmail,\n        emailType: 'admin',\n        reasonText: 'You received this email because you requested subscriber milestone alerts.'\n      })}\n    </div>\n  `\n\n  const emailResponse = await resend.emails.send({\n    from: 'Helfi Alerts <support@helfi.ai>',\n    to: recipientEmail,\n    subject,\n    html,\n  })\n\n  console.log(`‚úÖ [SUBSCRIBER MILESTONE] Sent to ${recipientEmail} with ID: ${emailResponse.data?.id}`)\n}\n\nexport async function POST(request: NextRequest) {\n  const sig = request.headers.get('stripe-signature') || ''\n  const rawBody = await request.text()\n\n  let event: Stripe.Event\n  try {\n    event = stripe.webhooks.constructEvent(rawBody, sig, endpointSecret)\n  } catch (err) {\n    return NextResponse.json({ error: 'Invalid signature' }, { status: 400 })\n  }\n\n  try {\n    switch (event.type) {\n      case 'customer.subscription.created':\n      case 'customer.subscription.updated': {\n        const sub = event.data.object as Stripe.Subscription\n        const currentPeriodStart = sub.current_period_start\n          ? new Date(sub.current_period_start * 1000)\n          : new Date()\n        const currentPeriodEnd = sub.current_period_end\n          ? new Date(sub.current_period_end * 1000)\n          : null\n        // Get customer email via customer ID\n        const customerId = typeof sub.customer === 'string' ? sub.customer : sub.customer?.id\n        let email: string | undefined\n        if (customerId) {\n          try {\n            const customer = await stripe.customers.retrieve(customerId)\n            if ((customer as Stripe.Customer).email) {\n              email = (customer as Stripe.Customer).email as string\n            }\n          } catch {\n            // ignore customer fetch errors\n          }\n        }\n        if (!email) break\n\n        // Determine monthly price from subscription\n        const amountCents = sub.items.data[0]?.price?.unit_amount || 0\n        \n        // Check if subscription already exists and if tier is changing\n        const existingUser = await prisma.user.findUnique({\n          where: { email: email.toLowerCase() },\n          include: { subscription: true }\n        })\n\n        const isActive = isStripeSubscriptionActive(sub)\n        if (!isActive) {\n          if (existingUser?.subscription) {\n            await prisma.subscription.update({\n              where: { userId: existingUser.id },\n              data: {\n                stripeSubscriptionId: sub.id,\n                monthlyPriceCents: amountCents,\n                endDate: new Date(),\n              },\n            })\n          }\n          console.log(`[Webhook] Subscription ${sub.id} for ${email} is ${sub.status}. Access paused.`)\n          break\n        }\n        \n        const existingSub = existingUser?.subscription\n        const isNewSubscription = !existingSub\n        const isTierChange = existingSub && existingSub.monthlyPriceCents !== amountCents\n        // Also reset if switching from admin-granted (no stripeSubscriptionId) to Stripe-managed subscription\n        // This is critical: if subscription exists but doesn't have stripeSubscriptionId, and we're adding one, reset everything\n        const isSwitchingToStripe = existingSub && !existingSub.stripeSubscriptionId\n        const hasNewStripeId = !existingSub?.stripeSubscriptionId || existingSub.stripeSubscriptionId !== sub.id\n        \n        // If tier is changing, new subscription, or switching to Stripe, reset startDate to start new billing cycle\n        const shouldResetCredits = isNewSubscription || isTierChange || isSwitchingToStripe || hasNewStripeId\n        // Always align startDate/reset to Stripe period start when switching to Stripe or creating new subscription\n        const newStartDate = shouldResetCredits ? currentPeriodStart : (existingSub?.startDate || currentPeriodStart)\n        \n        // Log for debugging\n        console.log(`[Webhook] Subscription ${sub.id} for ${email}:`, {\n          isNewSubscription,\n          isTierChange,\n          isSwitchingToStripe,\n          hasNewStripeId,\n          shouldResetCredits,\n          existingStripeId: existingSub?.stripeSubscriptionId,\n          newStripeId: sub.id,\n          existingStartDate: existingSub?.startDate,\n          newStartDate,\n          currentPeriodStart,\n          currentPeriodEnd\n        })\n        \n        // Set plan to PREMIUM and store Stripe subscription ID\n        // IMPORTANT: Always update startDate when switching to Stripe, even if using upsert\n        // Use direct update if subscription exists to ensure startDate is always updated when switching to Stripe\n        let user\n        if (existingSub) {\n          // Subscription exists - update it directly to ensure startDate is always set correctly\n          await prisma.subscription.update({\n            where: { userId: existingUser.id },\n            data: {\n              plan: 'PREMIUM',\n              monthlyPriceCents: amountCents,\n              stripeSubscriptionId: sub.id,\n              startDate: newStartDate, // Always update startDate when switching to Stripe\n              endDate: currentPeriodEnd\n            }\n          })\n          // Fetch updated user with subscription\n          user = await prisma.user.findUnique({\n            where: { email: email.toLowerCase() },\n            include: { subscription: true }\n          })\n        } else {\n          // New subscription - use upsert create\n          user = await prisma.user.update({\n            where: { email: email.toLowerCase() },\n            data: {\n              subscription: { \n                create: { \n                  plan: 'PREMIUM',\n                  monthlyPriceCents: amountCents,\n                  stripeSubscriptionId: sub.id,\n                  startDate: newStartDate,\n                  endDate: currentPeriodEnd\n                }\n              },\n            },\n            include: { subscription: true }\n          })\n        }\n        \n        if (!user) {\n          console.error(`[Webhook] Failed to update user ${email} after subscription update`)\n          break\n        }\n        \n        // Reset monthly counters and wallet when starting new subscription cycle or changing tier\n        if (shouldResetCredits) {\n          console.log(`[Webhook] Resetting credits for user ${user.id} - switching to Stripe or new subscription`, {\n            walletResetAt: newStartDate\n          })\n          await prisma.user.update({\n            where: { id: user.id },\n            data: {\n              dailyAnalysisCredits: 30,\n              walletMonthlyUsedCents: 0,\n              walletMonthlyResetAt: newStartDate,\n              monthlySymptomAnalysisUsed: 0,\n              monthlyFoodAnalysisUsed: 0,\n              monthlyMedicalImageAnalysisUsed: 0,\n              monthlyInteractionAnalysisUsed: 0,\n              monthlyInsightsGenerationUsed: 0,\n            } as any\n          })\n        }\n\n        if (isNewSubscription) {\n          let milestoneResult: { totalCount: number; shouldNotify: boolean } | null = null\n          try {\n            milestoneResult = await incrementSubscriberMilestoneCounter()\n          } catch (error) {\n            console.error('‚ùå Subscriber milestone counter failed:', error)\n          }\n          if (milestoneResult?.shouldNotify) {\n            const milestoneRecipient =\n              (process.env.OWNER_EMAIL || 'louie@helfi.ai').trim() || 'louie@helfi.ai'\n            sendSubscriberMilestoneEmail({\n              recipientEmail: milestoneRecipient,\n              totalCount: milestoneResult.totalCount,\n              latestSubscriberEmail: email,\n            }).catch((error) => {\n              console.error('‚ùå Subscriber milestone email failed (non-blocking):', error)\n            })\n          }\n        }\n\n        // Notify owner of subscription purchase (don't await to avoid blocking webhook)\n        const currency = sub.currency?.toUpperCase() || 'USD'\n        const planName = `Premium (${currency === 'USD' ? '$' : ''}${(amountCents / 100).toFixed(0)}/month)`\n        \n        notifyOwner({\n          event: 'subscription',\n          userEmail: email,\n          userName: user.name || undefined,\n          amount: amountCents,\n          currency: currency,\n          planName: planName,\n        }).catch(error => {\n          console.error('‚ùå Owner notification failed (non-blocking):', error)\n        })\n\n        break\n      }\n      case 'customer.subscription.trial_will_end': {\n        // Trial periods removed - this event can be ignored\n        break\n      }\n      case 'customer.subscription.deleted': {\n        const sub = event.data.object as Stripe.Subscription\n        const customerId = typeof sub.customer === 'string' ? sub.customer : sub.customer?.id\n        let email: string | undefined\n        if (customerId) {\n          try {\n            const customer = await stripe.customers.retrieve(customerId)\n            if ((customer as Stripe.Customer).email) {\n              email = (customer as Stripe.Customer).email as string\n            }\n          } catch {}\n        }\n        if (email) {\n          // Delete subscription instead of setting to FREE\n          // First find the user by email to get userId\n          const user = await prisma.user.findUnique({\n            where: { email: email.toLowerCase() },\n            select: { id: true }\n          })\n          \n          if (user) {\n            await prisma.subscription.delete({\n              where: { userId: user.id }\n            }).catch(() => {\n              // Ignore if subscription doesn't exist\n            })\n          }\n        }\n        break\n      }\n      case 'account.updated': {\n        const acct = event.data.object as Stripe.Account\n        const accountId = acct.id\n        await prisma.affiliate\n          .update({\n            where: { stripeConnectAccountId: accountId },\n            data: {\n              stripeConnectDetailsSubmitted: !!acct.details_submitted,\n              stripeConnectChargesEnabled: !!acct.charges_enabled,\n              stripeConnectPayoutsEnabled: !!acct.payouts_enabled,\n              stripeConnectOnboardedAt: acct.details_submitted ? new Date() : undefined,\n            },\n          })\n          .catch(() => {})\n        break\n      }\n      case 'invoice.paid': {\n        const invoice = event.data.object as Stripe.Invoice\n\n        // Only pay commission on the initial subscription payment (first invoice)\n        if (invoice.billing_reason !== 'subscription_create') break\n\n        const subscriptionId = typeof invoice.subscription === 'string' ? invoice.subscription : invoice.subscription?.id\n        if (!subscriptionId) break\n\n        const subscription = await stripe.subscriptions.retrieve(subscriptionId)\n        const affCode = (subscription.metadata as any)?.helfi_aff_code || (invoice.metadata as any)?.helfi_aff_code\n        const affClickId = (subscription.metadata as any)?.helfi_aff_click || (invoice.metadata as any)?.helfi_aff_click\n\n        if (!affCode || !affClickId) break\n\n        const affiliate = await prisma.affiliate.findUnique({\n          where: { code: String(affCode).toLowerCase() },\n          select: { id: true, status: true },\n        })\n        if (!affiliate || affiliate.status !== 'ACTIVE') break\n\n        const click = await prisma.affiliateClick.findUnique({\n          where: { id: String(affClickId) },\n          select: { id: true, affiliateId: true, createdAt: true },\n        })\n        if (!click || click.affiliateId !== affiliate.id) break\n\n        const occurredAt = invoice.status_transitions?.paid_at\n          ? new Date(invoice.status_transitions.paid_at * 1000)\n          : new Date()\n        // Enforce 30-day attribution window from click to conversion\n        if (occurredAt.getTime() - click.createdAt.getTime() > 30 * 24 * 60 * 60 * 1000) break\n\n        const paymentIntentId = typeof invoice.payment_intent === 'string' ? invoice.payment_intent : invoice.payment_intent?.id\n        if (!paymentIntentId) break\n\n        const { charge, balanceTx } = await getBalanceTransactionForPaymentIntent(paymentIntentId)\n        if (!charge || !balanceTx) break\n\n        const currency = String(balanceTx.currency || charge.currency || invoice.currency || 'aud').toLowerCase()\n        const gross = Number(balanceTx.amount || 0)\n        const fee = Number(balanceTx.fee || 0)\n        const net = Number(balanceTx.net || 0)\n        const chargeId = charge.id\n\n        const customerId = typeof invoice.customer === 'string' ? invoice.customer : invoice.customer?.id\n        let customerEmail: string | null = null\n        if (customerId) {\n          try {\n            const customer = await stripe.customers.retrieve(customerId)\n            customerEmail = (customer as Stripe.Customer)?.email?.toLowerCase() || null\n          } catch {}\n        }\n        const referredUser = customerEmail\n          ? await prisma.user.findUnique({ where: { email: customerEmail }, select: { id: true } }).catch(() => null)\n          : null\n\n        const conversion = await prisma.affiliateConversion\n          .create({\n            data: {\n              affiliateId: affiliate.id,\n              clickId: click.id,\n              referredUserId: referredUser?.id || null,\n              type: 'SUBSCRIPTION_INITIAL',\n              stripeEventId: event.id,\n              stripeCheckoutSessionId: null,\n              stripePaymentIntentId: paymentIntentId,\n              stripeChargeId: chargeId,\n              stripeInvoiceId: invoice.id,\n              currency,\n              amountGrossCents: gross,\n              stripeFeeCents: fee,\n              amountNetCents: net,\n              occurredAt,\n            },\n            select: { id: true },\n          })\n          .catch(() => null)\n\n        if (!conversion) break\n\n        const commissionCents = Math.floor(net / 2)\n        await prisma.affiliateCommission.create({\n          data: {\n            affiliateId: affiliate.id,\n            conversionId: conversion.id,\n            status: 'PENDING',\n            currency,\n            netRevenueCents: net,\n            commissionCents,\n            payableAt: addDays(occurredAt, 30),\n          },\n        })\n\n        break\n      }\n      case 'checkout.session.completed': {\n        const session = event.data.object as Stripe.Checkout.Session\n        \n        // Only handle credit purchases (one-time payments), not subscriptions\n        if (session.mode === 'payment' && session.payment_status === 'paid') {\n          const customerEmail = session.customer_details?.email || session.customer_email\n          if (!customerEmail) break\n\n          const user = await prisma.user.findUnique({\n            where: { email: customerEmail.toLowerCase() },\n            select: { id: true, email: true, name: true }\n          })\n\n          if (user) {\n            // Get amount and credit details from line items\n            const amountCents = session.amount_total || 0\n            const currency = (session.currency || 'usd').toUpperCase()\n            \n            // Determine credit amount based on price (common credit packages)\n            // This is approximate - actual credits are handled in /api/billing/confirm\n            let creditAmount = 0\n            if (amountCents >= 1000) creditAmount = 1000 // $10 = 1000 credits\n            else if (amountCents >= 500) creditAmount = 500 // $5 = 500 credits\n            else if (amountCents >= 250) creditAmount = 250 // $2.50 = 250 credits\n\n            // Notify owner of credit purchase (don't await to avoid blocking webhook)\n            notifyOwner({\n              event: 'credit_purchase',\n              userEmail: user.email,\n              userName: user.name || undefined,\n              amount: amountCents,\n              currency: currency,\n              creditAmount: creditAmount || undefined,\n            }).catch(error => {\n              console.error('‚ùå Owner notification failed (non-blocking):', error)\n            })\n          }\n        }\n\n        // Affiliate attribution for top-ups (one-time payments)\n        if (session.mode === 'payment' && session.payment_status === 'paid') {\n          const affCode = (session.metadata as any)?.helfi_aff_code\n          const affClickId = (session.metadata as any)?.helfi_aff_click\n          if (!affCode || !affClickId) break\n\n          const affiliate = await prisma.affiliate.findUnique({\n            where: { code: String(affCode).toLowerCase() },\n            select: { id: true, status: true },\n          })\n          if (!affiliate || affiliate.status !== 'ACTIVE') break\n\n          const click = await prisma.affiliateClick.findUnique({\n            where: { id: String(affClickId) },\n            select: { id: true, affiliateId: true, createdAt: true },\n          })\n          if (!click || click.affiliateId !== affiliate.id) break\n\n          const occurredAt = session.created ? new Date(session.created * 1000) : new Date()\n          if (occurredAt.getTime() - click.createdAt.getTime() > 30 * 24 * 60 * 60 * 1000) break\n\n          const paymentIntentId =\n            typeof session.payment_intent === 'string' ? session.payment_intent : (session.payment_intent as any)?.id\n          if (!paymentIntentId) break\n\n          const { charge, balanceTx } = await getBalanceTransactionForPaymentIntent(paymentIntentId)\n          if (!charge || !balanceTx) break\n\n          const currency = String(balanceTx.currency || charge.currency || session.currency || 'aud').toLowerCase()\n          const gross = Number(balanceTx.amount || 0)\n          const fee = Number(balanceTx.fee || 0)\n          const net = Number(balanceTx.net || 0)\n          const chargeId = charge.id\n\n          const customerEmail = (session.customer_details?.email || session.customer_email || '').toLowerCase()\n          const referredUser = customerEmail\n            ? await prisma.user.findUnique({ where: { email: customerEmail }, select: { id: true } }).catch(() => null)\n            : null\n\n          const conversion = await prisma.affiliateConversion\n            .create({\n              data: {\n                affiliateId: affiliate.id,\n                clickId: click.id,\n                referredUserId: referredUser?.id || null,\n                type: 'TOPUP',\n                stripeEventId: event.id,\n                stripeCheckoutSessionId: session.id,\n                stripePaymentIntentId: paymentIntentId,\n                stripeChargeId: chargeId,\n                stripeInvoiceId: null,\n                currency,\n                amountGrossCents: gross,\n                stripeFeeCents: fee,\n                amountNetCents: net,\n                occurredAt,\n              },\n              select: { id: true },\n            })\n            .catch(() => null)\n\n          if (!conversion) break\n\n          const commissionCents = Math.floor(net / 2)\n          await prisma.affiliateCommission.create({\n            data: {\n              affiliateId: affiliate.id,\n              conversionId: conversion.id,\n              status: 'PENDING',\n              currency,\n              netRevenueCents: net,\n              commissionCents,\n              payableAt: addDays(occurredAt, 30),\n            },\n          })\n        }\n        break\n      }\n      case 'invoice.payment_failed': {\n        const invoice = event.data.object as Stripe.Invoice\n        const customerId = typeof invoice.customer === 'string' ? invoice.customer : invoice.customer?.id\n        const subscriptionId = typeof invoice.subscription === 'string' ? invoice.subscription : invoice.subscription?.id\n        let email: string | undefined\n        if (customerId) {\n          try {\n            const customer = await stripe.customers.retrieve(customerId)\n            if ((customer as Stripe.Customer).email) {\n              email = (customer as Stripe.Customer).email as string\n            }\n          } catch {}\n        }\n        if (!email) break\n\n        const user = await prisma.user.findUnique({\n          where: { email: email.toLowerCase() },\n          include: { subscription: true },\n        })\n        if (!user?.subscription) break\n\n        await prisma.subscription.update({\n          where: { userId: user.id },\n          data: {\n            stripeSubscriptionId: subscriptionId || user.subscription.stripeSubscriptionId,\n            endDate: new Date(),\n          },\n        })\n        console.log(`[Webhook] Payment failed for ${email}. Access paused.`)\n        break\n      }\n      case 'charge.refunded':\n      case 'charge.dispute.created': {\n        const charge = event.data.object as Stripe.Charge\n        const conversion = await prisma.affiliateConversion.findFirst({\n          where: { stripeChargeId: charge.id },\n          select: { id: true, commission: { select: { id: true, status: true, payableAt: true } } },\n        })\n        if (conversion?.commission && conversion.commission.status === 'PENDING') {\n          await prisma.affiliateCommission.update({\n            where: { id: conversion.commission.id },\n            data: { status: 'VOIDED' },\n          })\n        }\n\n        const now = new Date()\n\n        // Revoke subscription access for refunded/charged-back invoices.\n        const invoiceId = typeof charge.invoice === 'string' ? charge.invoice : charge.invoice?.id\n        if (invoiceId) {\n          try {\n            const invoice = await stripe.invoices.retrieve(invoiceId)\n            const subscriptionId =\n              typeof invoice.subscription === 'string' ? invoice.subscription : invoice.subscription?.id\n            if (subscriptionId) {\n              const updated = await prisma.subscription.updateMany({\n                where: { stripeSubscriptionId: subscriptionId },\n                data: { endDate: now },\n              })\n              if (!updated.count) {\n                const customerId = typeof charge.customer === 'string' ? charge.customer : charge.customer?.id\n                let email: string | undefined\n                if (customerId) {\n                  try {\n                    const customer = await stripe.customers.retrieve(customerId)\n                    if ((customer as Stripe.Customer).email) {\n                      email = (customer as Stripe.Customer).email as string\n                    }\n                  } catch {}\n                }\n                if (email) {\n                  const user = await prisma.user.findUnique({\n                    where: { email: email.toLowerCase() },\n                    select: { id: true },\n                  })\n                  if (user) {\n                    await prisma.subscription.updateMany({\n                      where: { userId: user.id },\n                      data: { endDate: now },\n                    })\n                  }\n                }\n              }\n            }\n          } catch {}\n        }\n\n        // Revoke top-up credits linked to the refunded/charged-back payment.\n        const paymentIntentId =\n          typeof charge.payment_intent === 'string' ? charge.payment_intent : charge.payment_intent?.id\n        if (paymentIntentId) {\n          const session = await findCheckoutSessionForPaymentIntent(paymentIntentId)\n          if (session?.id) {\n            const source = `stripe:${session.id}`\n            const topUps = await prisma.creditTopUp.findMany({ where: { source } })\n            if (topUps.length) {\n              for (const topUp of topUps) {\n                const nextUsed = Math.max(topUp.usedCents, topUp.amountCents)\n                await prisma.creditTopUp.update({\n                  where: { id: topUp.id },\n                  data: { usedCents: nextUsed },\n                })\n              }\n            }\n          }\n        }\n        break\n      }\n\n      default:\n        break\n    }\n\n    return NextResponse.json({ received: true })\n  } catch (e) {\n    reportCriticalError({\n      source: 'billing.webhook',\n      error: e,\n      details: {\n        eventType: event?.type,\n        eventId: event?.id,\n      },\n    })\n    console.error('Stripe webhook error', e)\n    return NextResponse.json({ error: 'Webhook handler failure' }, { status: 500 })\n  }\n}\n\nexport const runtime = 'nodejs'\nexport const dynamic = 'force-dynamic'\n","truncated":false,"size":28109},{"path":"app/api/chat/threads/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\n\nlet tablesEnsured = false\n\nasync function ensureChatTables(): Promise<void> {\n  if (tablesEnsured) return\n  try {\n    await prisma.$executeRawUnsafe(\n      'CREATE TABLE IF NOT EXISTS \"TalkToAIChatThread\" (\"id\" TEXT PRIMARY KEY, \"userId\" TEXT NOT NULL, \"title\" TEXT, \"createdAt\" TIMESTAMPTZ NOT NULL DEFAULT NOW(), \"updatedAt\" TIMESTAMPTZ NOT NULL DEFAULT NOW())'\n    )\n    await prisma.$executeRawUnsafe(\n      'CREATE TABLE IF NOT EXISTS \"TalkToAIChatMessage\" (\"id\" TEXT PRIMARY KEY, \"threadId\" TEXT NOT NULL, \"role\" TEXT NOT NULL, \"content\" TEXT NOT NULL, \"tokenCount\" INTEGER NULL, \"createdAt\" TIMESTAMPTZ NOT NULL DEFAULT NOW(), CONSTRAINT \"TalkToAIChatMessage_threadId_fkey\" FOREIGN KEY (\"threadId\") REFERENCES \"TalkToAIChatThread\"(\"id\") ON DELETE CASCADE)'\n    )\n    await prisma.$executeRawUnsafe(\n      'CREATE INDEX IF NOT EXISTS \"TalkToAIChatMessage_threadId_createdAt_idx\" ON \"TalkToAIChatMessage\" (\"threadId\", \"createdAt\")'\n    )\n    await prisma.$executeRawUnsafe(\n      'CREATE INDEX IF NOT EXISTS \"TalkToAIChatThread_userId_idx\" ON \"TalkToAIChatThread\" (\"userId\")'\n    )\n    tablesEnsured = true\n  } catch (error) {\n    console.error('[talk-to-ai] Failed to ensure tables', error)\n  }\n}\n\nfunction uuid(): string {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n    const r = (Math.random() * 16) | 0\n    const v = c === 'x' ? r : (r & 0x3) | 0x8\n    return v.toString(16)\n  })\n}\n\nexport type ChatThread = { id: string; title: string | null; createdAt: string; updatedAt: string }\n\nexport async function GET(_request: Request) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n    await ensureChatTables()\n    const rows: Array<{ id: string; title: string | null; createdAt: Date; updatedAt: Date }> = await prisma.$queryRawUnsafe(\n      'SELECT \"id\",\"title\",\"createdAt\",\"updatedAt\" FROM \"TalkToAIChatThread\" WHERE \"userId\" = $1 ORDER BY \"updatedAt\" DESC LIMIT 50',\n      session.user.id\n    )\n    const threads = rows.map((r) => ({ id: r.id, title: r.title, createdAt: r.createdAt.toISOString(), updatedAt: r.updatedAt.toISOString() }))\n    return NextResponse.json({ threads }, { status: 200 })\n  } catch (error) {\n    console.error('[talk-to-ai-threads.GET] error', error)\n    return NextResponse.json({ error: 'server_error' }, { status: 500 })\n  }\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n    const body = await request.json().catch(() => ({}))\n    const title = String(body?.title || '').trim() || null\n    await ensureChatTables()\n    const id = uuid()\n    await prisma.$executeRawUnsafe(\n      'INSERT INTO \"TalkToAIChatThread\" (\"id\",\"userId\",\"title\") VALUES ($1,$2,$3)',\n      id,\n      session.user.id,\n      title\n    )\n    return NextResponse.json({ threadId: id }, { status: 200 })\n  } catch (error) {\n    console.error('[talk-to-ai-threads.POST] error', error)\n    return NextResponse.json({ error: 'server_error' }, { status: 500 })\n  }\n}\n\nexport async function PATCH(request: NextRequest) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n    const body = await request.json().catch(() => ({}))\n    const threadId = String(body?.threadId || '')\n    const title = String(body?.title || '').trim()\n    if (!threadId || !title) {\n      return NextResponse.json({ error: 'threadId and title required' }, { status: 400 })\n    }\n    await ensureChatTables()\n    await prisma.$executeRawUnsafe(\n      'UPDATE \"TalkToAIChatThread\" SET \"title\" = $1, \"updatedAt\" = NOW() WHERE \"id\" = $2 AND \"userId\" = $3',\n      title,\n      threadId,\n      session.user.id\n    )\n    return NextResponse.json({ success: true }, { status: 200 })\n  } catch (error) {\n    console.error('[talk-to-ai-threads.PATCH] error', error)\n    return NextResponse.json({ error: 'server_error' }, { status: 500 })\n  }\n}\n\nexport async function DELETE(request: NextRequest) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n    const body = await request.json().catch(() => ({}))\n    const threadId = String(body?.threadId || '')\n    if (!threadId) {\n      return NextResponse.json({ error: 'threadId required' }, { status: 400 })\n    }\n    await ensureChatTables()\n    await prisma.$executeRawUnsafe(\n      'DELETE FROM \"TalkToAIChatThread\" WHERE \"id\" = $1 AND \"userId\" = $2',\n      threadId,\n      session.user.id\n    )\n    return NextResponse.json({ success: true }, { status: 200 })\n  } catch (error) {\n    console.error('[talk-to-ai-threads.DELETE] error', error)\n    return NextResponse.json({ error: 'server_error' }, { status: 500 })\n  }\n}\n\n","truncated":false,"size":5214},{"path":"app/api/chat/voice/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport OpenAI from 'openai'\nimport { prisma } from '@/lib/prisma'\nimport { CreditManager } from '@/lib/credit-system'\nimport { capMaxTokensToBudget, costCentsEstimateFromText, estimateTokensFromText } from '@/lib/cost-meter'\nimport { chatCompletionWithCost } from '@/lib/metered-openai'\nimport { logAIUsage } from '@/lib/ai-usage-logger'\nimport { ensureTalkToAITables, listMessages, appendMessage, createThread, updateThreadTitle, listThreads } from '@/lib/talk-to-ai-chat-store'\nimport { consumeFreeCredit, hasFreeCredits } from '@/lib/free-credits'\nimport { isSubscriptionActive } from '@/lib/subscription-utils'\n\nfunction getOpenAIClient(): OpenAI | null {\n  if (!process.env.OPENAI_API_KEY) return null\n  return new OpenAI({ apiKey: process.env.OPENAI_API_KEY })\n}\n\nasync function loadFullUserContext(userId: string) {\n  const [user, issues] = await Promise.all([\n    prisma.user.findUnique({\n      where: { id: userId },\n      select: {\n        gender: true,\n        height: true,\n        weight: true,\n        bodyType: true,\n        exerciseFrequency: true,\n        exerciseTypes: true,\n        healthGoals: {\n          select: {\n            id: true,\n            name: true,\n            category: true,\n            currentRating: true,\n            createdAt: true,\n            updatedAt: true,\n            healthLogs: {\n              select: {\n                rating: true,\n                notes: true,\n                createdAt: true,\n              },\n              orderBy: { createdAt: 'desc' },\n              take: 12,\n            },\n          },\n        },\n        supplements: {\n          select: {\n            name: true,\n            dosage: true,\n            timing: true,\n            updatedAt: true,\n          },\n        },\n        medications: {\n          select: {\n            name: true,\n            dosage: true,\n            timing: true,\n            updatedAt: true,\n          },\n        },\n        exerciseLogs: {\n          select: {\n            type: true,\n            duration: true,\n            intensity: true,\n            createdAt: true,\n          },\n          orderBy: { createdAt: 'desc' },\n          take: 20,\n        },\n        foodLogs: {\n          select: {\n            name: true,\n            description: true,\n            createdAt: true,\n          },\n          orderBy: { createdAt: 'desc' },\n          take: 20,\n        },\n      },\n    }),\n    prisma.$queryRawUnsafe<Array<{ id: string; name: string; polarity: string; slug: string }>>(\n      'SELECT id, name, polarity, slug FROM \"CheckinIssues\" WHERE \"userId\" = $1',\n      userId\n    ).catch(() => []),\n  ])\n\n  if (!user) return null\n\n  return {\n    profile: {\n      gender: user.gender,\n      weight: user.weight,\n      height: user.height,\n      bodyType: user.bodyType,\n      exerciseFrequency: user.exerciseFrequency,\n      exerciseTypes: user.exerciseTypes,\n    },\n    healthGoals: user.healthGoals,\n    supplements: user.supplements,\n    medications: user.medications,\n    exerciseLogs: user.exerciseLogs,\n    foodLogs: user.foodLogs,\n    issues: issues.map((i) => ({ id: i.id, name: i.name, polarity: i.polarity, slug: i.slug })),\n  }\n}\n\nfunction buildSystemPrompt(context: Awaited<ReturnType<typeof loadFullUserContext>>): string {\n  if (!context) {\n    return 'You are Helfi, a helpful AI health assistant. Provide accurate, supportive health guidance.'\n  }\n\n  const parts: string[] = [\n    'You are Helfi, an AI health assistant with comprehensive access to the user\\'s health data.',\n    'Your role is to provide personalized, evidence-based health guidance while always emphasizing that you are not a replacement for professional medical advice.',\n    '',\n    'USER PROFILE:',\n    `- Gender: ${context.profile.gender || 'Not specified'}`,\n    `- Weight: ${context.profile.weight ? `${context.profile.weight} kg` : 'Not specified'}`,\n    `- Height: ${context.profile.height ? `${context.profile.height} cm` : 'Not specified'}`,\n    `- Body Type: ${context.profile.bodyType || 'Not specified'}`,\n    `- Exercise Frequency: ${context.profile.exerciseFrequency || 'Not specified'}`,\n    `- Exercise Types: ${context.profile.exerciseTypes?.join(', ') || 'None specified'}`,\n    '',\n  ]\n\n  if (context.supplements.length > 0) {\n    parts.push('CURRENT SUPPLEMENTS:')\n    context.supplements.forEach((supp) => {\n      parts.push(`- ${supp.name}: ${supp.dosage || 'No dosage'} ${supp.timing?.length ? `(Timing: ${supp.timing.join(', ')})` : ''}`)\n    })\n    parts.push('')\n  }\n\n  if (context.medications.length > 0) {\n    parts.push('CURRENT MEDICATIONS:')\n    context.medications.forEach((med) => {\n      parts.push(`- ${med.name}: ${med.dosage || 'No dosage'} ${med.timing?.length ? `(Timing: ${med.timing.join(', ')})` : ''}`)\n    })\n    parts.push('')\n  }\n\n  if (context.healthGoals.length > 0) {\n    parts.push('HEALTH GOALS & TRACKING:')\n    context.healthGoals.forEach((goal) => {\n      if (goal.name.startsWith('__')) return\n      parts.push(`- ${goal.name}: Current rating ${goal.currentRating || 'N/A'}`)\n      if (goal.healthLogs.length > 0) {\n        const recent = goal.healthLogs.slice(0, 3)\n        parts.push(`  Recent logs: ${recent.map((l) => `Rating ${l.rating}${l.notes ? ` - ${l.notes}` : ''}`).join('; ')}`)\n      }\n    })\n    parts.push('')\n  }\n\n  if (context.issues.length > 0) {\n    parts.push('TRACKED HEALTH ISSUES:')\n    context.issues.forEach((issue) => {\n      parts.push(`- ${issue.name} (${issue.polarity === 'positive' ? 'Positive' : 'Negative'})`)\n    })\n    parts.push('')\n  }\n\n  if (context.exerciseLogs.length > 0) {\n    parts.push('RECENT EXERCISE LOGS:')\n    context.exerciseLogs.slice(0, 10).forEach((log) => {\n      parts.push(`- ${log.type}: ${log.duration} min${log.intensity ? ` (${log.intensity})` : ''} on ${log.createdAt.toLocaleDateString()}`)\n    })\n    parts.push('')\n  }\n\n  if (context.foodLogs.length > 0) {\n    parts.push('RECENT FOOD LOGS:')\n    context.foodLogs.slice(0, 10).forEach((log) => {\n      parts.push(`- ${log.name}${log.description ? `: ${log.description}` : ''} on ${log.createdAt.toLocaleDateString()}`)\n    })\n    parts.push('')\n  }\n\n  parts.push(\n    'RESPONSE FORMATTING (CRITICAL - FOLLOW EXACTLY):',\n    '',\n    'You MUST format all responses with proper structure. Example format:',\n    '',\n    '**Heading or Key Point**',\n    '',\n    'First paragraph here. Keep it concise and focused.',\n    '',\n    'Second paragraph here if needed.',\n    '',\n    '1. First numbered item',\n    '2. Second numbered item',\n    '3. Third numbered item',\n    '',\n    '‚Ä¢ Bullet point one',\n    '‚Ä¢ Bullet point two',\n    '',\n    '**Another Section**',\n    '',\n    'Final paragraph.',\n    '',\n    'RULES:',\n    '- ALWAYS separate paragraphs with a blank line (double newline: \\\\n\\\\n)',\n    '- Use numbered lists (1. 2. 3.) for sequential items',\n    '- Use bullet points (- or ‚Ä¢) for non-sequential items',\n    '- Use **bold** for section headings and key terms',\n    '- NEVER write responses as one continuous paragraph',\n    '- Keep paragraphs to 2-4 sentences maximum',\n    '- Break up long explanations into multiple paragraphs',\n    '- If your response is longer than 3 sentences, you MUST break it into multiple paragraphs',\n    '- Every 2-3 sentences should be followed by a blank line',\n    '',\n    'USER DATA USAGE:',\n    '- Only reference user data when directly relevant to their question',\n    '- Do NOT list all their supplements/medications unless specifically asked',\n    '- Do NOT dump their entire health profile unless requested',\n    '- When asked for \"concise\" or \"brief\" answers, provide ONLY the essential information',\n    '- Focus on answering the specific question asked, not providing a data dump',\n    '',\n    'GUIDELINES:',\n    '- Always remind users to consult healthcare professionals for medical advice',\n    '- Provide personalized recommendations based on their data ONLY when relevant',\n    '- Be supportive, clear, and non-alarming',\n    '- If asked about supplements, provide types/categories, not specific brands',\n    '- Consider interactions between medications and supplements when relevant',\n    '- Keep responses focused on the user\\'s actual question',\n  )\n\n  return parts.join('\\n')\n}\n\nexport async function GET(req: NextRequest) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n    await ensureTalkToAITables()\n    const url = new URL(req.url)\n    const threadId = url.searchParams.get('threadId')\n    \n    if (threadId) {\n      // Get specific thread messages\n      const messages = await listMessages(threadId, 60)\n      return NextResponse.json({ threadId, messages }, { status: 200 })\n    } else {\n      return NextResponse.json({ error: 'threadId required' }, { status: 400 })\n    }\n  } catch (error) {\n    console.error('[chat-voice.GET] error', error)\n    return NextResponse.json({ error: 'server_error' }, { status: 500 })\n  }\n}\n\nexport async function POST(req: NextRequest) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const body = await req.json().catch(() => ({}))\n    const question = String(body?.message || '').trim()\n    if (!question) {\n      return NextResponse.json({ error: 'Message required' }, { status: 400 })\n    }\n\n    const openai = getOpenAIClient()\n    if (!openai) {\n      return NextResponse.json({ error: 'OpenAI API key not configured' }, { status: 500 })\n    }\n\n    const user = await prisma.user.findUnique({\n      where: { id: session.user.id },\n      include: { subscription: true, creditTopUps: true },\n    })\n    if (!user) {\n      return NextResponse.json({ error: 'User not found' }, { status: 404 })\n    }\n\n    const isPremium = isSubscriptionActive(user.subscription)\n    const now = new Date()\n    const hasPurchasedCredits = user.creditTopUps?.some(\n      (topUp: any) => topUp.expiresAt > now && (topUp.amountCents - topUp.usedCents) > 0\n    )\n    const hasFreeChatCredits = await hasFreeCredits(user.id, 'VOICE_CHAT')\n    const allowViaFreeUse = !isPremium && !hasPurchasedCredits && hasFreeChatCredits\n    if (!isPremium && !hasPurchasedCredits && !hasFreeChatCredits) {\n      return NextResponse.json(\n        {\n          error: 'Payment required',\n          message: 'You\\'ve used all your free voice chat uses. Subscribe to a monthly plan or purchase credits to continue.',\n          requiresPayment: true,\n          exhaustedFreeCredits: true,\n        },\n        { status: 402 }\n      )\n    }\n\n    // Get or create thread\n    await ensureTalkToAITables()\n    let threadId: string\n    if (body.newThread) {\n      // Create new thread only if explicitly requested\n      const thread = await createThread(session.user.id)\n      threadId = thread.id\n    } else if (body.threadId) {\n      // Use existing thread\n      threadId = body.threadId\n    } else {\n      // Get most recent thread or create new one ONLY if no threads exist\n      const threads = await listThreads(session.user.id)\n      if (threads.length > 0) {\n        threadId = threads[0].id\n      } else {\n        // Only create if truly no threads exist\n        const thread = await createThread(session.user.id)\n        threadId = thread.id\n      }\n    }\n\n    // Load message history for context\n    const history = await listMessages(threadId, 30)\n    const historyMessages = history.map((m) => ({ role: m.role, content: m.content }))\n\n    // Load full user context\n    const context = await loadFullUserContext(session.user.id)\n    let systemPrompt = buildSystemPrompt(context)\n\n    // Optional additional focus: a health tip summary passed from inline chat (e.g. on Health Tips page)\n    const healthTipSummary =\n      typeof body?.healthTipSummary === 'string' ? body.healthTipSummary.trim() : ''\n    if (healthTipSummary) {\n      systemPrompt += `\\n\\nCURRENT HEALTH TIP CONTEXT (IMPORTANT):\\n${healthTipSummary}\\n\\nWhen the user asks questions in this chat, assume they are asking follow-up questions about this specific tip unless they clearly change the subject.`\n    }\n\n    const accept = (req.headers.get('accept') || '').toLowerCase()\n    const wantsStream = accept.includes('text/event-stream')\n\n    const model = process.env.OPENAI_INSIGHTS_MODEL || 'gpt-4o-mini'\n    // Add formatting reminder to user message for better compliance\n    const enhancedQuestion = `${question}\\n\\nPlease format your response with proper paragraphs, line breaks, and structure.`\n    const chatMessages = [\n      { role: 'system' as const, content: systemPrompt },\n      ...historyMessages,\n      { role: 'user' as const, content: enhancedQuestion },\n    ]\n\n    // Save user message\n    await appendMessage(threadId, 'user', question)\n\n    // Auto-generate title from first message if thread has no title\n    const threads = await listThreads(session.user.id)\n    const currentThread = threads.find(t => t.id === threadId)\n    if (currentThread && !currentThread.title) {\n      const title = question.length > 50 ? question.substring(0, 47) + '...' : question\n      await updateThreadTitle(threadId, title)\n    }\n\n    // Estimate cost (2x for user)\n    const promptText = `${systemPrompt}\\n${question}`\n    const estimateCents = costCentsEstimateFromText(model, promptText, 1000 * 4)\n    const userCostCents = estimateCents * 2 // Double the cost for user\n\n    // Check wallet\n    const cm = new CreditManager(user.id)\n    const wallet = await cm.getWalletStatus()\n\n    // If only estimating, return cost\n    if (body?.estimateOnly) {\n      return NextResponse.json({\n        estimatedCost: userCostCents,\n        availableCredits: wallet.totalAvailableCents,\n      })\n    }\n\n    let maxTokens = 1000\n    if (!allowViaFreeUse) {\n      const budgetCents = Math.floor(wallet.totalAvailableCents / 2)\n      const cappedMaxTokens = capMaxTokensToBudget(model, promptText, maxTokens, budgetCents)\n      if (cappedMaxTokens <= 0) {\n        return NextResponse.json(\n          {\n            error: 'Insufficient credits',\n            estimatedCost: userCostCents,\n            availableCredits: wallet.totalAvailableCents,\n          },\n          { status: 402 }\n        )\n      }\n      maxTokens = cappedMaxTokens\n    }\n\n    if (wantsStream) {\n      const wrapped = await chatCompletionWithCost(openai, {\n        model,\n        messages: chatMessages,\n        max_tokens: maxTokens,\n        temperature: 0.4,\n      } as any)\n\n      const assistantMessage =\n        wrapped.completion.choices?.[0]?.message?.content ||\n        'I apologize, but I could not generate a response.'\n\n      const actualUserCostCents = wrapped.costCents * 2\n      if (!allowViaFreeUse) {\n        const ok = await cm.chargeCents(actualUserCostCents)\n        if (!ok) {\n          return NextResponse.json(\n            {\n              error: 'Insufficient credits',\n              estimatedCost: actualUserCostCents,\n              availableCredits: wallet.totalAvailableCents,\n            },\n            { status: 402 }\n          )\n        }\n      } else {\n        await consumeFreeCredit(user.id, 'VOICE_CHAT')\n      }\n\n      // Save assistant message\n      await appendMessage(threadId, 'assistant', assistantMessage)\n\n      // Log usage for visibility\n      try {\n        await logAIUsage({\n          context: { feature: 'voice:chat', userId: user.id },\n          model,\n          promptTokens: wrapped.promptTokens,\n          completionTokens: wrapped.completionTokens,\n          costCents: actualUserCostCents,\n        })\n      } catch {\n        // Ignore logging failures\n      }\n\n      const enc = new TextEncoder()\n      const chunks = assistantMessage.match(/[\\s\\S]{1,200}/g) || ['']\n      const stream = new ReadableStream({\n        start(controller) {\n          for (const chunk of chunks) {\n            const payload = JSON.stringify({ token: chunk })\n            controller.enqueue(enc.encode(`data: ${payload}\\n\\n`))\n          }\n          controller.enqueue(enc.encode('event: end\\n\\n'))\n          controller.close()\n        },\n      })\n\n      return new Response(stream, {\n        headers: {\n          'Content-Type': 'text/event-stream',\n          'Cache-Control': 'no-cache',\n          Connection: 'keep-alive',\n        },\n      })\n    } else {\n      // Non-streaming\n      const wrapped = await chatCompletionWithCost(openai, {\n        model,\n        messages: chatMessages,\n        max_tokens: maxTokens,\n        temperature: 0.4,\n      })\n\n      // Charge user (2x cost)\n      const userCostCents = wrapped.costCents * 2\n      if (!allowViaFreeUse) {\n        const ok = await cm.chargeCents(userCostCents)\n        if (!ok) {\n          return NextResponse.json(\n            {\n              error: 'Insufficient credits',\n              estimatedCost: userCostCents,\n              availableCredits: wallet.totalAvailableCents,\n            },\n            { status: 402 }\n          )\n        }\n      } else {\n        await consumeFreeCredit(user.id, 'VOICE_CHAT')\n      }\n\n      // Log AI usage for cost tracking (voice chat, non-streaming)\n      try {\n        await logAIUsage({\n          context: { feature: 'voice:chat', userId: user.id },\n          model,\n          promptTokens: wrapped.promptTokens,\n          completionTokens: wrapped.completionTokens,\n          costCents: userCostCents,\n        })\n      } catch {\n        // Ignore logging failures\n      }\n\n      const assistantMessage = wrapped.completion.choices[0]?.message?.content || 'I apologize, but I could not generate a response.'\n\n      // Save assistant message\n      await appendMessage(threadId, 'assistant', assistantMessage)\n\n      return NextResponse.json({\n        assistant: assistantMessage,\n        estimatedCost: userCostCents,\n        threadId,\n      })\n    }\n  } catch (err: any) {\n    console.error('[voice-chat] Error:', err)\n    return NextResponse.json({ error: err.message || 'Internal server error' }, { status: 500 })\n  }\n}\n","truncated":false,"size":18103},{"path":"app/api/checkins/history/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\n\nexport async function GET(req: NextRequest) {\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.email) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  const user = await prisma.user.findUnique({ where: { email: session.user.email } })\n  if (!user) return NextResponse.json({ error: 'User not found' }, { status: 404 })\n\n  const { searchParams } = new URL(req.url)\n  const start = searchParams.get('start') || '1970-01-01'\n  const end = searchParams.get('end') || new Date().toISOString().slice(0,10)\n\n  try {\n    const rows: any[] = await prisma.$queryRawUnsafe(\n      `SELECT r.id, r.date, r.timestamp, r.issueId, i.name, i.polarity, r.value, r.note, r.isNa\n       FROM CheckinRatings r\n       JOIN CheckinIssues i ON i.id = r.issueId\n       WHERE r.userId = $1 AND r.date BETWEEN $2 AND $3\n       ORDER BY r.timestamp DESC, i.name ASC`,\n      user.id, start, end\n    )\n    return NextResponse.json({ history: rows })\n  } catch (e) {\n    console.error('checkins history error', e)\n    return NextResponse.json({ error: 'Failed to load history' }, { status: 500 })\n  }\n}\n\n\n","truncated":false,"size":1303},{"path":"app/api/checkins/issues/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\nimport crypto from 'crypto'\n\nexport async function GET() {\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.email) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  const user = await prisma.user.findUnique({ where: { email: session.user.email } })\n  if (!user) return NextResponse.json({ error: 'User not found' }, { status: 404 })\n\n  try {\n    await prisma.$executeRawUnsafe(`\n      CREATE TABLE IF NOT EXISTS CheckinIssues (\n        id TEXT PRIMARY KEY,\n        userId TEXT NOT NULL,\n        name TEXT NOT NULL,\n        polarity TEXT NOT NULL,\n        UNIQUE (userId, name)\n      )\n    `)\n    // Remove historical duplicates before creating unique index\n    await prisma.$executeRawUnsafe(`\n      DELETE FROM CheckinIssues a\n      USING CheckinIssues b\n      WHERE a.id > b.id AND a.userId = b.userId AND a.name = b.name\n    `)\n    // Ensure composite unique index exists even if table was created earlier without it\n    await prisma.$executeRawUnsafe(`\n      CREATE UNIQUE INDEX IF NOT EXISTS checkinissues_user_name_idx ON CheckinIssues (userId, name)\n    `)\n    const rows: any[] = await prisma.$queryRawUnsafe(`SELECT id, name, polarity FROM CheckinIssues WHERE userId = $1`, user.id)\n    return NextResponse.json({ issues: rows })\n  } catch {\n    return NextResponse.json({ issues: [] })\n  }\n}\n\nexport async function POST(req: NextRequest) {\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.email) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  const user = await prisma.user.findUnique({ where: { email: session.user.email } })\n  if (!user) return NextResponse.json({ error: 'User not found' }, { status: 404 })\n\n  const { issues } = await req.json() as { issues: Array<{ name: string, polarity?: 'positive'|'negative' }> }\n\n  try {\n    await prisma.$executeRawUnsafe(`\n      CREATE TABLE IF NOT EXISTS CheckinIssues (\n        id TEXT PRIMARY KEY,\n        userId TEXT NOT NULL,\n        name TEXT NOT NULL,\n        polarity TEXT NOT NULL,\n        UNIQUE (userId, name)\n      )\n    `)\n    // Remove duplicates across all users to allow unique index\n    await prisma.$executeRawUnsafe(`\n      DELETE FROM CheckinIssues a\n      USING CheckinIssues b\n      WHERE a.id > b.id AND a.userId = b.userId AND a.name = b.name\n    `)\n    // Backfill unique composite index for existing tables\n    await prisma.$executeRawUnsafe(`\n      CREATE UNIQUE INDEX IF NOT EXISTS checkinissues_user_name_idx ON CheckinIssues (userId, name)\n    `)\n\n    // Replace saved list with exactly what client sent\n    const names = issues.map(i => String(i.name || '').trim()).filter(Boolean)\n    if (names.length === 0) {\n      await prisma.$executeRawUnsafe(`DELETE FROM CheckinIssues WHERE userId = $1`, user.id)\n    } else {\n      const placeholders = names.map((_, idx) => `$${idx + 2}`).join(',')\n      await prisma.$executeRawUnsafe(\n        `DELETE FROM CheckinIssues WHERE userId = $1 AND name NOT IN (${placeholders})`,\n        user.id, ...names\n      )\n    }\n\n    for (const item of issues) {\n      const name = String(item.name || '').trim()\n      if (!name) continue\n      const polarity = (item.polarity === 'negative' || /pain|ache|anxiety|depress|fatigue|nausea|bloat|insomnia|brain fog|headache|migraine|cramp|stress|itch|rash|acne|diarrh|constipat|gas|heartburn/i.test(name)) ? 'negative' : 'positive'\n      const id = crypto.randomUUID()\n      // Use queryRawUnsafe for broad compatibility; ON CONFLICT upserts by (userId,name)\n      await prisma.$queryRawUnsafe(\n        `INSERT INTO CheckinIssues (id, userId, name, polarity) VALUES ($1,$2,$3,$4)\n         ON CONFLICT (userId, name) DO UPDATE SET polarity=EXCLUDED.polarity`,\n        id, user.id, name, polarity\n      )\n    }\n    return NextResponse.json({ success: true })\n  } catch (e) {\n    console.error('checkins issues save error', e)\n    return NextResponse.json({ error: (e as any)?.message || 'Failed to save issues' }, { status: 500 })\n  }\n}\n\n\n","truncated":false,"size":4180},{"path":"app/api/checkins/ratings/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\n\n// Delete a single rating entry\nexport async function DELETE(req: NextRequest) {\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.email) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  const user = await prisma.user.findUnique({ where: { email: session.user.email } })\n  if (!user) return NextResponse.json({ error: 'User not found' }, { status: 404 })\n\n  const { searchParams } = new URL(req.url)\n  const date = searchParams.get('date')\n  const issueId = searchParams.get('issueId')\n\n  if (!date || !issueId) {\n    return NextResponse.json({ error: 'Missing date or issueId' }, { status: 400 })\n  }\n\n  try {\n    await prisma.$executeRawUnsafe(\n      `DELETE FROM CheckinRatings WHERE userId = $1 AND date = $2 AND issueId = $3`,\n      user.id, date, issueId\n    )\n    return NextResponse.json({ success: true })\n  } catch (e) {\n    console.error('delete rating error', e)\n    return NextResponse.json({ error: 'Failed to delete rating' }, { status: 500 })\n  }\n}\n\n// Update a rating entry\nexport async function PATCH(req: NextRequest) {\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.email) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  const user = await prisma.user.findUnique({ where: { email: session.user.email } })\n  if (!user) return NextResponse.json({ error: 'User not found' }, { status: 404 })\n\n  const body = await req.json().catch(() => ({}))\n  const { date, issueId, value, note } = body\n\n  if (!date || !issueId) {\n    return NextResponse.json({ error: 'Missing date or issueId' }, { status: 400 })\n  }\n\n  try {\n    const clamped = (value === null || value === undefined) ? null : Math.max(0, Math.min(6, Number(value)))\n    // Use INSERT ... ON CONFLICT to handle both update and insert\n    await prisma.$executeRawUnsafe(\n      `INSERT INTO CheckinRatings (userId, issueId, date, value, note)\n       VALUES ($1, $2, $3, $4, $5)\n       ON CONFLICT (userId, issueId, date) DO UPDATE SET value = EXCLUDED.value, note = EXCLUDED.note`,\n      user.id, issueId, date, clamped, String(note || '')\n    )\n    return NextResponse.json({ success: true })\n  } catch (e) {\n    console.error('update rating error', e)\n    return NextResponse.json({ error: 'Failed to update rating' }, { status: 500 })\n  }\n}\n\n// Delete multiple ratings (by issue or all)\nexport async function POST(req: NextRequest) {\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.email) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  const user = await prisma.user.findUnique({ where: { email: session.user.email } })\n  if (!user) return NextResponse.json({ error: 'User not found' }, { status: 404 })\n\n  const body = await req.json().catch(() => ({}))\n  const { action, issueIds } = body\n\n  if (action === 'delete-all') {\n    try {\n      await prisma.$executeRawUnsafe(`DELETE FROM CheckinRatings WHERE userId = $1`, user.id)\n      return NextResponse.json({ success: true })\n    } catch (e) {\n      console.error('delete all ratings error', e)\n      return NextResponse.json({ error: 'Failed to delete all ratings' }, { status: 500 })\n    }\n  }\n\n  if (action === 'delete-by-issues' && Array.isArray(issueIds) && issueIds.length > 0) {\n    try {\n      const placeholders = issueIds.map((_, i) => `$${i + 2}`).join(',')\n      await prisma.$executeRawUnsafe(\n        `DELETE FROM CheckinRatings WHERE userId = $1 AND issueId IN (${placeholders})`,\n        user.id, ...issueIds\n      )\n      return NextResponse.json({ success: true })\n    } catch (e) {\n      console.error('delete by issues error', e)\n      return NextResponse.json({ error: 'Failed to delete ratings' }, { status: 500 })\n    }\n  }\n\n  return NextResponse.json({ error: 'Invalid action' }, { status: 400 })\n}\n\n","truncated":false,"size":3984},{"path":"app/api/checkins/settings/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\nimport { scheduleAllActiveReminders } from '@/lib/qstash'\n\nexport async function GET() {\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.email) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  const user = await prisma.user.findUnique({ where: { email: session.user.email } })\n  if (!user) return NextResponse.json({ error: 'User not found' }, { status: 404 })\n\n  // Ensure table exists with full schema\n  // await prisma.$executeRawUnsafe(`\n  //   CREATE TABLE IF NOT EXISTS CheckinSettings (\n  //     userId TEXT PRIMARY KEY,\n  //     time1 TEXT NOT NULL,\n  //     time2 TEXT NOT NULL,\n  //     time3 TEXT NOT NULL,\n  //     timezone TEXT NOT NULL,\n  //     frequency INTEGER NOT NULL DEFAULT 3\n  //   )\n  // `)\n  \n  // // Migrate old schema if needed\n  // await prisma.$executeRawUnsafe(`ALTER TABLE CheckinSettings ADD COLUMN IF NOT EXISTS time2 TEXT NOT NULL DEFAULT '18:00'`).catch(() => {})\n  // await prisma.$executeRawUnsafe(`ALTER TABLE CheckinSettings ADD COLUMN IF NOT EXISTS time3 TEXT NOT NULL DEFAULT '21:00'`).catch(() => {})\n  // await prisma.$executeRawUnsafe(`ALTER TABLE CheckinSettings ADD COLUMN IF NOT EXISTS frequency INTEGER NOT NULL DEFAULT 3`).catch(() => {})\n\n  // Load user's settings\n  const rows: Array<{ time1: string; time2: string; time3: string; timezone: string; frequency: number }> =\n    await prisma.$queryRawUnsafe(\n      `SELECT time1, time2, time3, timezone, frequency FROM CheckinSettings WHERE userId = $1`,\n      user.id\n    )\n\n  if (rows.length > 0) {\n    return NextResponse.json(rows[0])\n  }\n\n  // Return defaults if no settings exist\n  return NextResponse.json({\n    time1: '12:30',\n    time2: '18:30',\n    time3: '21:30',\n    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone || 'Australia/Melbourne',\n    frequency: 3\n  })\n}\n\nexport async function POST(req: NextRequest) {\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.email) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  const user = await prisma.user.findUnique({ where: { email: session.user.email } })\n  if (!user) return NextResponse.json({ error: 'User not found' }, { status: 404 })\n\n  const body = await req.json().catch(() => ({}))\n  let { time1, time2, time3, timezone, frequency } = body as any\n\n  // Normalize time on the server to avoid client formatting issues\n  const normalizeTime = (input?: string, defaultValue: string = '21:00'): string => {\n    if (!input) return defaultValue\n    const s = String(input).trim().toLowerCase()\n    const m24 = s.match(/^([01]?\\d|2[0-3]):([0-5]\\d)$/)\n    if (m24) return `${m24[1].padStart(2,'0')}:${m24[2]}`\n    const m12 = s.match(/^([0-1]?\\d):([0-5]\\d)\\s*(am|pm)$/)\n    if (m12) {\n      let h = parseInt(m12[1], 10)\n      const mm = m12[2]\n      const ap = m12[3]\n      if (ap === 'pm' && h !== 12) h += 12\n      if (ap === 'am' && h === 12) h = 0\n      return `${String(h).padStart(2,'0')}:${mm}`\n    }\n    // Fallback: digits HHMM\n    const digits = s.replace(/[^0-9]/g, '')\n    if (digits.length >= 3) {\n      const h = parseInt(digits.slice(0, digits.length - 2), 10)\n      const mm = parseInt(digits.slice(-2), 10)\n      return `${String(Math.max(0, Math.min(23, h))).padStart(2,'0')}:${String(Math.max(0, Math.min(59, mm))).padStart(2,'0')}`\n    }\n    return defaultValue\n  }\n\n  // Normalize all times with sensible defaults\n  time1 = normalizeTime(time1, '12:30')\n  time2 = normalizeTime(time2, '18:30')\n  time3 = normalizeTime(time3, '21:30')\n  timezone = (timezone && String(timezone).trim()) || Intl.DateTimeFormat().resolvedOptions().timeZone || 'Australia/Melbourne'\n  frequency = Math.max(1, Math.min(3, parseInt(String(frequency || 3), 10)))\n\n  // Auto-create table with full schema\n  try {\n    console.log('Saving CheckinSettings for', user.id, { time1, time2, time3, timezone, frequency })\n    // await prisma.$executeRawUnsafe(`\n    //   CREATE TABLE IF NOT EXISTS CheckinSettings (\n    //     userId TEXT PRIMARY KEY,\n    //     time1 TEXT NOT NULL,\n    //     time2 TEXT NOT NULL,\n    //     time3 TEXT NOT NULL,\n    //     timezone TEXT NOT NULL,\n    //     frequency INTEGER NOT NULL DEFAULT 3\n    //   )\n    // `)\n    \n    // // Migrate old schema if needed\n    // await prisma.$executeRawUnsafe(`ALTER TABLE CheckinSettings ADD COLUMN IF NOT EXISTS time2 TEXT NOT NULL DEFAULT '18:00'`).catch(() => {})\n    // await prisma.$executeRawUnsafe(`ALTER TABLE CheckinSettings ADD COLUMN IF NOT EXISTS time3 TEXT NOT NULL DEFAULT '21:00'`).catch(() => {})\n    // await prisma.$executeRawUnsafe(`ALTER TABLE CheckinSettings ADD COLUMN IF NOT EXISTS frequency INTEGER NOT NULL DEFAULT 3`).catch(() => {})\n    \n    // // Migrate existing records that only have time1\n    // await prisma.$executeRawUnsafe(`\n    //   UPDATE CheckinSettings \n    //   SET time2 = COALESCE(NULLIF(time2, ''), '18:00'),\n    //       time3 = COALESCE(NULLIF(time3, ''), '21:00'),\n    //       frequency = COALESCE(frequency, 3)\n    //   WHERE time2 IS NULL OR time2 = '' OR time3 IS NULL OR time3 = ''\n    // `).catch(() => {})\n\n    // Save settings\n    await prisma.$queryRawUnsafe(\n      `INSERT INTO CheckinSettings (userId, time1, time2, time3, timezone, frequency)\n       VALUES ($1,$2,$3,$4,$5,$6)\n       ON CONFLICT (userId) DO UPDATE SET \n         time1=EXCLUDED.time1, \n         time2=EXCLUDED.time2, \n         time3=EXCLUDED.time3, \n         timezone=EXCLUDED.timezone,\n         frequency=EXCLUDED.frequency`,\n      user.id, time1, time2, time3, timezone, frequency\n    )\n    // Schedule next occurrences for all active reminders and capture outcomes\n    const scheduleResults =\n      await scheduleAllActiveReminders(user.id, { time1, time2, time3, timezone, frequency }).catch((error) => {\n        console.error('[CHECKINS] Failed to schedule reminders via QStash', error)\n        return []\n      })\n\n    const failedSchedules = scheduleResults.filter((result) => !result.scheduled)\n    if (failedSchedules.length > 0) {\n      console.error('[CHECKINS] QStash scheduling failures detected', { failedSchedules })\n    }\n\n    // If user saved shortly after a reminder time, send one immediately to avoid waiting until tomorrow.\n    try {\n      const base =\n        process.env.PUBLIC_BASE_URL ||\n        (process.env.VERCEL_URL ? `https://${process.env.VERCEL_URL}` : '')\n      if (base) {\n        const now = new Date()\n        const fmt = new Intl.DateTimeFormat('en-GB', {\n          timeZone: timezone,\n          hour: '2-digit',\n          minute: '2-digit',\n          hour12: false,\n        })\n        const parts = fmt.formatToParts(now)\n        const ch = parseInt(parts.find(p => p.type === 'hour')?.value || '0', 10)\n        const cm = parseInt(parts.find(p => p.type === 'minute')?.value || '0', 10)\n        const currentTotal = ch * 60 + cm\n        const sendWindowMinutes = 5\n        const candidates: string[] = []\n        if (frequency >= 1) candidates.push(time1)\n        if (frequency >= 2) candidates.push(time2)\n        if (frequency >= 3) candidates.push(time3)\n        const schedulerSecret = process.env.SCHEDULER_SECRET || ''\n        for (const t of candidates) {\n          const [hh, mm] = t.split(':').map(v => parseInt(v, 10))\n          const target = hh * 60 + mm\n          let diff = currentTotal - target\n          if (diff < 0) diff += 1440\n          if (diff >= 0 && diff <= sendWindowMinutes) {\n            const headers: Record<string, string> = { 'Content-Type': 'application/json' }\n            if (schedulerSecret) {\n              headers.Authorization = `Bearer ${schedulerSecret}`\n            }\n            await fetch(`${base}/api/push/dispatch`, {\n              method: 'POST',\n              headers,\n              body: JSON.stringify({ userId: user.id, reminderTime: t, timezone }),\n            }).catch(() => {})\n            break\n          }\n        }\n      }\n    } catch {}\n\n    return NextResponse.json({ success: true, scheduleResults })\n  } catch (e) {\n    console.error('checkins settings save error', e)\n    const message = e instanceof Error ? e.message : 'Unknown error'\n    return NextResponse.json({ error: 'Failed to save settings', detail: message }, { status: 500 })\n  }\n}\n\n","truncated":false,"size":8378},{"path":"app/api/checkins/today/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\nimport crypto from 'crypto'\n\nexport async function GET() {\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.email) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  const user = await prisma.user.findUnique({ where: { email: session.user.email } })\n  if (!user) return NextResponse.json({ error: 'User not found' }, { status: 404 })\n\n  const today = new Date().toISOString().slice(0,10)\n\n  try {\n    // await prisma.$executeRawUnsafe(`\n    //   CREATE TABLE IF NOT EXISTS CheckinIssues (\n    //     id TEXT PRIMARY KEY,\n    //     userId TEXT NOT NULL,\n    //     name TEXT NOT NULL,\n    //     polarity TEXT NOT NULL\n    //   )\n    // `)\n    // await prisma.$executeRawUnsafe(`\n    //   CREATE TABLE IF NOT EXISTS CheckinRatings (\n    //     id TEXT PRIMARY KEY,\n    //     userId TEXT NOT NULL,\n    //     issueId TEXT NOT NULL,\n    //     date TEXT NOT NULL,\n    //     timestamp TIMESTAMP NOT NULL DEFAULT NOW(),\n    //     value INTEGER,\n    //     note TEXT,\n    //     isNa BOOLEAN DEFAULT false\n    //   )\n    // `)\n    // // Migrate old schema: add timestamp and id columns if they don't exist\n    // await prisma.$executeRawUnsafe(`ALTER TABLE CheckinRatings ADD COLUMN IF NOT EXISTS id TEXT`).catch(() => {})\n    // await prisma.$executeRawUnsafe(`ALTER TABLE CheckinRatings ADD COLUMN IF NOT EXISTS timestamp TIMESTAMP NOT NULL DEFAULT NOW()`).catch(() => {})\n    // // Ensure columns exist for older tables\n    // await prisma.$executeRawUnsafe(`ALTER TABLE CheckinRatings ALTER COLUMN value DROP NOT NULL`).catch(()=>{})\n    // await prisma.$executeRawUnsafe(`ALTER TABLE CheckinRatings ADD COLUMN IF NOT EXISTS note TEXT`).catch(()=>{})\n    // await prisma.$executeRawUnsafe(`ALTER TABLE CheckinRatings ADD COLUMN IF NOT EXISTS isNa BOOLEAN DEFAULT false`).catch(()=>{})\n    \n    // // Migrate existing records: generate IDs and timestamps for records without them\n    // await prisma.$executeRawUnsafe(`\n    //   UPDATE CheckinRatings \n    //   SET id = COALESCE(id, gen_random_uuid()::text),\n    //       timestamp = COALESCE(timestamp, NOW())\n    //   WHERE id IS NULL OR timestamp IS NULL\n    // `).catch(() => {})\n    \n    // // Create indexes for better query performance\n    // await prisma.$executeRawUnsafe(`CREATE INDEX IF NOT EXISTS idx_checkinratings_user_date ON CheckinRatings(userId, date)`).catch(() => {})\n    // await prisma.$executeRawUnsafe(`CREATE INDEX IF NOT EXISTS idx_checkinratings_timestamp ON CheckinRatings(timestamp DESC)`).catch(() => {})\n  } catch {}\n\n  let issues: any[] = await prisma.$queryRawUnsafe(`SELECT id, name, polarity FROM CheckinIssues WHERE userId = $1`, user.id)\n  \n  // If no issues found in CheckinIssues, sync from HealthGoal table\n  if (issues.length === 0) {\n    try {\n      // Try to get selected issues from __SELECTED_ISSUES__ record\n      const selectedIssuesRecord = await prisma.healthGoal.findFirst({\n        where: {\n          userId: user.id,\n          name: '__SELECTED_ISSUES__'\n        }\n      })\n      \n      let issueNames: string[] = []\n      \n      if (selectedIssuesRecord?.category) {\n        try {\n          const parsed = JSON.parse(selectedIssuesRecord.category)\n          if (Array.isArray(parsed)) {\n            issueNames = parsed.map((name: any) => String(name || '').trim()).filter(Boolean)\n          }\n        } catch {}\n      }\n      \n      // Fallback: get from regular health goals if no selected issues found\n      if (issueNames.length === 0) {\n        const healthGoals = await prisma.healthGoal.findMany({\n          where: {\n            userId: user.id,\n            name: { notIn: ['__EXERCISE_DATA__', '__HEALTH_SITUATIONS_DATA__', '__SELECTED_ISSUES__'] }\n          }\n        })\n        issueNames = healthGoals.map(goal => goal.name.trim()).filter(Boolean)\n      }\n      \n      // Sync issues to CheckinIssues table\n      if (issueNames.length > 0) {\n        // Ensure unique constraint exists\n        // await prisma.$executeRawUnsafe(`\n        //   CREATE UNIQUE INDEX IF NOT EXISTS checkinissues_user_name_idx ON CheckinIssues (userId, name)\n        // `).catch(() => {})\n        \n        for (const issueName of issueNames) {\n          const polarity = /pain|ache|anxiety|depress|fatigue|nausea|bloat|insomnia|brain fog|headache|migraine|cramp|stress|itch|rash|acne|diarrh|constipat|gas|heartburn/i.test(issueName) ? 'negative' : 'positive'\n          const id = crypto.randomUUID()\n          try {\n            await prisma.$queryRawUnsafe(\n              `INSERT INTO CheckinIssues (id, userId, name, polarity) VALUES ($1,$2,$3,$4)\n               ON CONFLICT (userId, name) DO UPDATE SET polarity=EXCLUDED.polarity`,\n              id, user.id, issueName, polarity\n            )\n          } catch (e) {\n            // Ignore conflicts, continue with next issue\n            console.error('Error syncing issue:', issueName, e)\n          }\n        }\n        \n        // Reload issues after sync\n        issues = await prisma.$queryRawUnsafe(`SELECT id, name, polarity FROM CheckinIssues WHERE userId = $1`, user.id)\n      }\n    } catch (e) {\n      console.error('Error syncing health goals to CheckinIssues:', e)\n    }\n  }\n  \n  // Get the most recent check-in for today (show latest entry per issue)\n  const allRatings: any[] = await prisma.$queryRawUnsafe(`\n    SELECT issueId, value, note, isNa, timestamp\n    FROM CheckinRatings \n    WHERE userId = $1 AND date = $2 \n    ORDER BY timestamp DESC\n  `, user.id, today)\n  \n  // Group by issueId and take the most recent one\n  const ratingsMap = new Map<string, any>()\n  for (const rating of allRatings) {\n    if (!ratingsMap.has(rating.issueId)) {\n      ratingsMap.set(rating.issueId, rating)\n    }\n  }\n  const ratings = Array.from(ratingsMap.values())\n\n  return NextResponse.json({ issues, ratings })\n}\n\nexport async function POST(req: NextRequest) {\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.email) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  const user = await prisma.user.findUnique({ where: { email: session.user.email } })\n  if (!user) return NextResponse.json({ error: 'User not found' }, { status: 404 })\n\n  const { ratings } = await req.json()\n  const today = new Date().toISOString().slice(0,10)\n  const now = new Date().toISOString()\n\n  try {\n    // await prisma.$executeRawUnsafe(`\n    //   CREATE TABLE IF NOT EXISTS CheckinRatings (\n    //     id TEXT PRIMARY KEY,\n    //     userId TEXT NOT NULL,\n    //     issueId TEXT NOT NULL,\n    //     date TEXT NOT NULL,\n    //     timestamp TIMESTAMP NOT NULL DEFAULT NOW(),\n    //     value INTEGER,\n    //     note TEXT,\n    //     isNa BOOLEAN DEFAULT false\n    //   )\n    // `)\n    // // Migrate old schema: add timestamp and id columns if they don't exist\n    // await prisma.$executeRawUnsafe(`ALTER TABLE CheckinRatings ADD COLUMN IF NOT EXISTS id TEXT`).catch(() => {})\n    // await prisma.$executeRawUnsafe(`ALTER TABLE CheckinRatings ADD COLUMN IF NOT EXISTS timestamp TIMESTAMP NOT NULL DEFAULT NOW()`).catch(() => {})\n    // // Ensure columns/nullability exist for older tables\n    // try { await prisma.$executeRawUnsafe(`ALTER TABLE CheckinRatings ADD COLUMN IF NOT EXISTS note TEXT`) } catch(_) {}\n    // try { await prisma.$executeRawUnsafe(`ALTER TABLE CheckinRatings ADD COLUMN IF NOT EXISTS isNa BOOLEAN DEFAULT false`) } catch(_) {}\n    // try { await prisma.$executeRawUnsafe(`ALTER TABLE CheckinRatings ALTER COLUMN value DROP NOT NULL`) } catch(_) {}\n    \n    // Create a new check-in entry (allowing multiple per day)\n    for (const r of ratings as Array<{ issueId: string, value?: number | null, note?: string, isNa?: boolean }>) {\n      const clamped = (r.value === null || r.value === undefined) ? null : Math.max(0, Math.min(6, Number(r.value)))\n      const id = crypto.randomUUID()\n      await prisma.$queryRawUnsafe(\n        `INSERT INTO CheckinRatings (id, userId, issueId, date, timestamp, value, note, isNa) \n         VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`,\n        id, user.id, r.issueId, today, now, clamped, String(r.note || ''), !!r.isNa\n      )\n    }\n    return NextResponse.json({ success: true })\n  } catch (e) {\n    console.error('checkins save error', e)\n    return NextResponse.json({ error: 'Failed to save ratings' }, { status: 500 })\n  }\n}\n\n\n","truncated":false,"size":8488},{"path":"app/api/credit/feature-usage-stats/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\n\nexport const dynamic = 'force-dynamic'\nexport const revalidate = 0\n\ntype RangeKey = '7d' | '1m' | '2m' | '6m' | 'all' | 'custom'\n\ntype UsageKey =\n  | 'foodAnalysis'\n  | 'symptomAnalysis'\n  | 'medicalImageAnalysis'\n  | 'insightsGeneration'\n  | 'chatLight'\n\ntype UsageStatsResponse = {\n  range: {\n    key: RangeKey\n    start: string | null\n    end: string | null\n  }\n  usage: Record<UsageKey, number>\n}\n\nfunction parseIsoDateOnly(value: string): Date | null {\n  const m = String(value || '').match(/^(\\d{4})-(\\d{2})-(\\d{2})$/)\n  if (!m) return null\n  const year = Number(m[1])\n  const month = Number(m[2])\n  const day = Number(m[3])\n  if (!Number.isFinite(year) || !Number.isFinite(month) || !Number.isFinite(day)) return null\n  if (month < 1 || month > 12) return null\n  if (day < 1 || day > 31) return null\n  return new Date(Date.UTC(year, month - 1, day, 0, 0, 0, 0))\n}\n\nfunction endOfUtcDay(date: Date): Date {\n  return new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), 23, 59, 59, 999))\n}\n\nfunction subtractMonthsUtc(date: Date, months: number): Date {\n  const d = new Date(date)\n  const year = d.getUTCFullYear()\n  const month = d.getUTCMonth()\n  const day = d.getUTCDate()\n  const hours = d.getUTCHours()\n  const minutes = d.getUTCMinutes()\n  const seconds = d.getUTCSeconds()\n  const ms = d.getUTCMilliseconds()\n\n  const targetMonth = month - months\n  const firstOfTarget = new Date(Date.UTC(year, targetMonth, 1, hours, minutes, seconds, ms))\n  const lastDayTargetMonth = new Date(Date.UTC(firstOfTarget.getUTCFullYear(), firstOfTarget.getUTCMonth() + 1, 0)).getUTCDate()\n  const safeDay = Math.min(day, lastDayTargetMonth)\n  return new Date(Date.UTC(firstOfTarget.getUTCFullYear(), firstOfTarget.getUTCMonth(), safeDay, hours, minutes, seconds, ms))\n}\n\nfunction getRangeFromRequest(req: NextRequest): { key: RangeKey; start: Date | null; end: Date | null } | { error: string } {\n  const url = new URL(req.url)\n  const key = (url.searchParams.get('range') || '7d') as RangeKey\n  const now = new Date()\n\n  if (key === 'all') {\n    return { key, start: null, end: null }\n  }\n\n  if (key === '7d') {\n    return { key, start: new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000), end: now }\n  }\n  if (key === '1m') {\n    return { key, start: subtractMonthsUtc(now, 1), end: now }\n  }\n  if (key === '2m') {\n    return { key, start: subtractMonthsUtc(now, 2), end: now }\n  }\n  if (key === '6m') {\n    return { key, start: subtractMonthsUtc(now, 6), end: now }\n  }\n\n  if (key === 'custom') {\n    const startRaw = url.searchParams.get('start') || ''\n    const endRaw = url.searchParams.get('end') || ''\n    const start = parseIsoDateOnly(startRaw)\n    const endStartOfDay = parseIsoDateOnly(endRaw)\n    if (!start || !endStartOfDay) {\n      return { error: 'Invalid custom range. Use start=YYYY-MM-DD&end=YYYY-MM-DD.' }\n    }\n    const end = endOfUtcDay(endStartOfDay)\n    if (start.getTime() > end.getTime()) {\n      return { error: 'Invalid custom range. Start date must be before end date.' }\n    }\n    return { key, start, end }\n  }\n\n  return { error: 'Invalid range. Use range=7d|1m|2m|6m|all|custom.' }\n}\n\nexport async function GET(req: NextRequest) {\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.id) {\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  }\n\n  const range = getRangeFromRequest(req)\n  if ('error' in range) {\n    return NextResponse.json({ error: range.error }, { status: 400 })\n  }\n\n  const user = await prisma.user.findUnique({\n    where: { id: session.user.id },\n    select: {\n      totalFoodAnalysisCount: true,\n      monthlyFoodAnalysisUsed: true,\n    },\n  })\n\n  const where: any = {\n    userId: session.user.id,\n    success: true,\n  }\n  if (range.start && range.end) {\n    where.createdAt = { gte: range.start, lte: range.end }\n  } else if (range.start) {\n    where.createdAt = { gte: range.start }\n  } else if (range.end) {\n    where.createdAt = { lte: range.end }\n  }\n\n  const events = await prisma.aIUsageEvent.findMany({\n    where,\n    select: {\n      feature: true,\n      scanId: true,\n      runId: true,\n      createdAt: true,\n    },\n  })\n\n  // Food \"times used\" should match what the user experiences (including cached results),\n  // not just the number of AI calls. The most reliable proxy we have today is FoodLog\n  // creation count in the selected time window.\n  const foodLogWhere: any = { userId: session.user.id }\n  if (range.start && range.end) {\n    foodLogWhere.createdAt = { gte: range.start, lte: range.end }\n  } else if (range.start) {\n    foodLogWhere.createdAt = { gte: range.start }\n  } else if (range.end) {\n    foodLogWhere.createdAt = { lte: range.end }\n  }\n  // Best-effort filter to focus on analyzed entries (most analyzed entries have nutrients/items).\n  foodLogWhere.OR = [{ nutrients: { not: null } }, { items: { not: null } }, { imageUrl: { not: null } }]\n  const foodLogCount = await prisma.foodLog.count({ where: foodLogWhere }).catch(async () => {\n    // Fallback: count all food logs if JSON filtering isn't supported on this DB version.\n    const fallbackWhere: any = { userId: session.user.id }\n    if (foodLogWhere.createdAt) fallbackWhere.createdAt = foodLogWhere.createdAt\n    return prisma.foodLog.count({ where: fallbackWhere })\n  })\n\n  const foodActionIds = new Set<string>()\n  let symptomCount = 0\n  let medicalCount = 0\n  let chatLightCount = 0\n\n  const insightsRunIds = new Set<string>()\n  let insightsLandingCount = 0\n\n  for (const ev of events) {\n    const f = String(ev.feature || '')\n\n    // Food photo analysis (AI calls only): keep this for fallback/debug, but prefer FoodLog count.\n    if (\n      (f === 'food:image-analysis' || f === 'food:text-analysis' || f === 'food:analyze-packaged') &&\n      !f.includes('reanalysis')\n    ) {\n      // Some endpoints double-log the same run; only trust scanId-based events for food.\n      if (typeof ev.scanId === 'string' && ev.scanId.trim().length > 0) {\n        foodActionIds.add(ev.scanId.trim())\n      }\n      continue\n    }\n\n    if (f === 'symptoms:analysis') {\n      symptomCount += 1\n      continue\n    }\n\n    if (f === 'medical-image:analysis') {\n      medicalCount += 1\n      continue\n    }\n\n    if (f === 'symptoms:chat' || f === 'medical-image:chat') {\n      chatLightCount += 1\n      continue\n    }\n\n    // Insights generation: count one per runId when present, otherwise only count the single-call landing generation.\n    if (f.startsWith('insights:') && f !== 'insights:ask' && f !== 'insights:unknown') {\n      if (typeof ev.runId === 'string' && ev.runId.trim().length > 0) {\n        insightsRunIds.add(ev.runId.trim())\n      } else if (f === 'insights:landing-generate') {\n        insightsLandingCount += 1\n      }\n    }\n  }\n\n  const payload: UsageStatsResponse = {\n    range: {\n      key: range.key,\n      start: range.start ? range.start.toISOString() : null,\n      end: range.end ? range.end.toISOString() : null,\n    },\n    usage: {\n      foodAnalysis:\n        range.key === 'all'\n          ? Math.max(\n              Number(foodLogCount || 0),\n              Number(user?.totalFoodAnalysisCount || 0),\n              Number(user?.monthlyFoodAnalysisUsed || 0),\n              Number(foodActionIds.size || 0)\n            )\n          : Math.max(Number(foodLogCount || 0), Number(foodActionIds.size || 0)),\n      symptomAnalysis: symptomCount,\n      medicalImageAnalysis: medicalCount,\n      insightsGeneration: insightsRunIds.size + insightsLandingCount,\n      chatLight: chatLightCount,\n    },\n  }\n\n  return NextResponse.json(payload)\n}\n","truncated":false,"size":7738},{"path":"app/api/credit/feature-usage/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\nimport { CREDIT_COSTS } from '@/lib/credit-system'\nimport { isSubscriptionActive } from '@/lib/subscription-utils'\nimport { logServerCall } from '@/lib/server-call-tracker'\n\n// ABSOLUTE GUARD RAIL:\n// This endpoint powers the \"This AI feature has been used X times‚Ä¶\" text.\n// Do NOT change how featureUsage is computed without reading `GUARD_RAILS.md`\n// and getting explicit user approval.\n//\n// This API depends on session headers and must never be statically rendered.\nexport const dynamic = 'force-dynamic'\nexport const revalidate = 0\n\nexport async function GET(_req: NextRequest) {\n  let debugStage = 'start'\n  try {\n    const url = new URL(_req.url)\n    const featureParam = (url.searchParams.get('feature') || '').trim()\n    // Authentication: rely on standard session (same as usage‚Äëbreakdown).\n    debugStage = 'resolve-session'\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.email) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    debugStage = 'load-user'\n    const user = await prisma.user.findUnique({\n      where: { email: session.user.email },\n      select: {\n        id: true,\n        // Monthly per‚Äëfeature counters\n        monthlySymptomAnalysisUsed: true,\n        monthlyFoodAnalysisUsed: true,\n        monthlyMedicalImageAnalysisUsed: true,\n        monthlyInteractionAnalysisUsed: true,\n        monthlyInsightsGenerationUsed: true,\n        // Lifetime counters (for back‚Äëfilling old usage)\n        totalAnalysisCount: true,\n        totalFoodAnalysisCount: true,\n        totalInteractionAnalysisCount: true,\n        // Wallet usage + subscription (for context only)\n        walletMonthlyUsedCents: true,\n        subscription: {\n          select: {\n            plan: true,\n            endDate: true,\n          },\n        },\n      },\n    })\n\n    if (!user) {\n      return NextResponse.json({ error: 'User not found' }, { status: 404 })\n    }\n\n    if (featureParam) {\n      logServerCall({\n        feature: featureParam,\n        endpoint: '/api/credit/feature-usage',\n        kind: 'feature_usage',\n      }).catch((error) => {\n        console.error('‚ùå Failed to log feature usage call:', error)\n      })\n    }\n\n    const hasSubscription = isSubscriptionActive(user.subscription)\n\n    debugStage = 'prepare-counts'\n    const foodMonthly = user.monthlyFoodAnalysisUsed || 0\n    const foodLifetime = user.totalFoodAnalysisCount || 0\n    const foodLabel: 'monthly' | 'total' = foodMonthly > 0 ? 'monthly' : 'total'\n    const actualFoodUsage = foodLabel === 'monthly' ? foodMonthly : foodLifetime\n\n    const symptomMonthly = user.monthlySymptomAnalysisUsed || 0\n    const symptomAnalysisLifetime = Math.max(\n      0,\n      (user.totalAnalysisCount || 0) -\n        (user.totalFoodAnalysisCount || 0) -\n        (user.totalInteractionAnalysisCount || 0)\n    )\n    const symptomLabel: 'monthly' | 'total' = symptomMonthly > 0 ? 'monthly' : 'total'\n    const symptomCount = symptomLabel === 'monthly' ? symptomMonthly : symptomAnalysisLifetime\n\n    const interactionMonthly = user.monthlyInteractionAnalysisUsed || 0\n    const interactionLifetime = user.totalInteractionAnalysisCount || 0\n\n    const medicalMonthly = user.monthlyMedicalImageAnalysisUsed || 0\n    const insightsMonthly = user.monthlyInsightsGenerationUsed || 0\n\n    // Health tips usage (no counters; derive from usage events)\n    const startOfUtcMonth = (() => {\n      const now = new Date()\n      return new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), 1, 0, 0, 0, 0))\n    })()\n    const healthTipsMonthly = await prisma.aIUsageEvent.count({\n      where: {\n        userId: user.id,\n        success: true,\n        createdAt: { gte: startOfUtcMonth },\n        feature: { startsWith: 'health-tips:' },\n      },\n    })\n\n    const featureUsage: any = {\n      symptomAnalysis: {\n        count: symptomCount,\n        costPerUse: CREDIT_COSTS.SYMPTOM_ANALYSIS,\n        label: symptomLabel,\n      },\n      foodAnalysis: {\n        count: actualFoodUsage,\n        costPerUse: CREDIT_COSTS.FOOD_ANALYSIS,\n        label: foodLabel,\n      },\n      interactionAnalysis: {\n        count: interactionMonthly > 0 ? interactionMonthly : interactionLifetime,\n        costPerUse: CREDIT_COSTS.INTERACTION_ANALYSIS,\n        label: interactionMonthly > 0 ? 'monthly' : 'total',\n      },\n      medicalImageAnalysis: {\n        count: medicalMonthly,\n        costPerUse: CREDIT_COSTS.MEDICAL_IMAGE_ANALYSIS,\n        label: medicalMonthly > 0 ? 'monthly' : 'total',\n      },\n      insightsGeneration: {\n        count: insightsMonthly,\n        costPerUse: CREDIT_COSTS.INSIGHTS_GENERATION,\n        label: insightsMonthly > 0 ? 'monthly' : 'total',\n      },\n      healthTips: {\n        count: healthTipsMonthly,\n        costPerUse: 0,\n        label: 'monthly',\n        totalCredits: 0,\n      },\n    }\n\n    return NextResponse.json({\n      debugStage: 'success',\n      schemaVersion: 3,\n      featureUsage,\n      hasSubscription,\n      actualCreditsUsed: user.walletMonthlyUsedCents || 0,\n    })\n  } catch (err: any) {\n    console.error('Error fetching feature usage:', err)\n    // Degrade gracefully: return zeros so UI can still render without errors.\n    return NextResponse.json({\n      debugStage,\n      schemaVersion: 2,\n      featureUsage: {\n        symptomAnalysis: {\n          count: 0,\n          costPerUse: CREDIT_COSTS.SYMPTOM_ANALYSIS,\n          label: 'total',\n        },\n        foodAnalysis: {\n          count: 0,\n          costPerUse: CREDIT_COSTS.FOOD_ANALYSIS,\n          label: 'total',\n        },\n        interactionAnalysis: {\n          count: 0,\n          costPerUse: CREDIT_COSTS.INTERACTION_ANALYSIS,\n          label: 'total',\n        },\n        medicalImageAnalysis: {\n          count: 0,\n          costPerUse: CREDIT_COSTS.MEDICAL_IMAGE_ANALYSIS,\n          label: 'total',\n        },\n        insightsGeneration: {\n          count: 0,\n          costPerUse: CREDIT_COSTS.INSIGHTS_GENERATION,\n          label: 'total',\n        },\n        healthTips: {\n          count: 0,\n          costPerUse: 0,\n          label: 'total',\n          totalCredits: 0,\n        },\n      },\n      hasSubscription: false,\n      actualCreditsUsed: 0,\n      degraded: true,\n      errorType: err?.name || 'UnknownError',\n      errorMessage: err?.message || 'Unknown error',\n    })\n  }\n}\n","truncated":false,"size":6500},{"path":"app/api/credit/status/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { getToken } from 'next-auth/jwt'\nimport { authOptions } from '@/lib/auth'\nimport { getFreeCreditsStatus, hasExhaustedFreeCredits } from '@/lib/free-credits'\nimport { prisma } from '@/lib/prisma'\nimport { isSubscriptionActive } from '@/lib/subscription-utils'\nimport { logServerCall } from '@/lib/server-call-tracker'\n\n// ABSOLUTE GUARD RAIL:\n// This endpoint powers the \"Credits remaining\" bar. Do NOT change credit\n// calculation rules or disable billing here without:\n//   1) Reading `GUARD_RAILS.md` (credits section), and\n//   2) Getting explicit written approval from the user.\n//\n// This API must always be dynamic because it depends on per-request auth headers.\nexport const dynamic = 'force-dynamic'\nexport const revalidate = 0\n\n// Direct mapping of subscription price ‚Üí monthly wallet credits\n// Mirrors CreditManager.SUBSCRIPTION_CREDITS_MAP but kept local here to\n// avoid depending on wallet internals (display‚Äëonly endpoint).\nconst SUBSCRIPTION_CREDITS_MAP: Record<number, number> = {\n  1000: 700,  // $10/month ‚Üí 700 credits\n  2000: 1400, // $20/month ‚Üí 1,400 credits\n  3000: 2100, // $30/month ‚Üí 2,100 credits\n  5000: 3500, // $50/month ‚Üí 3,500 credits\n}\n\nfunction creditsForSubscriptionPrice(monthlyPriceCents: number | null | undefined): number {\n  if (!monthlyPriceCents) return 0\n  if (SUBSCRIPTION_CREDITS_MAP[monthlyPriceCents]) {\n    return SUBSCRIPTION_CREDITS_MAP[monthlyPriceCents]\n  }\n  // Fallback: 50% of price as credits if an unknown tier appears\n  const percent = Number(process.env.HELFI_WALLET_PLAN_PERCENT || '0.5')\n  const safePercent = percent > 0 && percent <= 1 ? percent : 0.5\n  return Math.floor(monthlyPriceCents * safePercent)\n}\n\nfunction monthlyCapFromSubscription(sub: any | null | undefined): number {\n  if (!isSubscriptionActive(sub)) return 0\n  if (sub.monthlyPriceCents != null) {\n    return creditsForSubscriptionPrice(sub.monthlyPriceCents)\n  }\n  // Defensive fallback by plan name if price is missing\n  if (sub.plan === 'PREMIUM') return SUBSCRIPTION_CREDITS_MAP[2000] || 1000\n  return 0\n}\n\nfunction computeNextResetAt(subscriptionStart: Date | null): string | null {\n  try {\n    const now = new Date()\n    if (!subscriptionStart) {\n      // Calendar‚Äëmonth reset: first day of next month (UTC)\n      const nextReset = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth() + 1, 1, 0, 0, 0))\n      return nextReset.toISOString()\n    }\n\n    // Align reset with subscription billing day (same logic as usage‚Äëbreakdown)\n    const subStartDate = new Date(subscriptionStart)\n    const startYear = subStartDate.getUTCFullYear()\n    const startMonth = subStartDate.getUTCMonth()\n    const startDay = subStartDate.getUTCDate()\n\n    const currentYear = now.getUTCFullYear()\n    const currentMonth = now.getUTCMonth()\n    const currentDay = now.getUTCDate()\n\n    let monthsSinceStart = (currentYear - startYear) * 12 + (currentMonth - startMonth)\n    if (currentDay >= startDay) {\n      monthsSinceStart += 1\n    }\n\n    const nextReset = new Date(Date.UTC(startYear, startMonth + monthsSinceStart, startDay, 0, 0, 0, 0))\n    return nextReset.toISOString()\n  } catch {\n    return null\n  }\n}\n\nexport async function GET(_req: NextRequest) {\n  let debugStage = 'start'\n  try {\n    const url = new URL(_req.url)\n    const featureParam = (url.searchParams.get('feature') || '').trim()\n    // 1) Resolve current user (session or JWT fallback)\n    debugStage = 'resolve-session'\n    let session = await getServerSession(authOptions)\n    let userEmail: string | null = session?.user?.email ?? null\n\n    if (!userEmail) {\n      try {\n        const token = await getToken({\n          req: _req,\n          secret: process.env.NEXTAUTH_SECRET || process.env.AUTH_SECRET || 'helfi-secret-key-production-2024',\n        })\n        if (token?.email) {\n          userEmail = String(token.email)\n        }\n      } catch (tokenError) {\n        console.error('/api/credit/status - JWT fallback failed:', tokenError)\n      }\n    }\n\n    if (!userEmail) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    // 2) Load user with all fields needed for wallet + legacy credits\n    debugStage = 'load-user'\n    const user = await prisma.user.findUnique({\n      where: { email: userEmail },\n      select: {\n        id: true,\n        // Legacy daily/additional credits\n        dailyAnalysisCredits: true,\n        dailyAnalysisUsed: true,\n        additionalCredits: true,\n        // Wallet + subscription\n        walletMonthlyUsedCents: true,\n        subscription: {\n          select: {\n            plan: true,\n            monthlyPriceCents: true,\n            startDate: true,\n            endDate: true,\n          },\n        },\n        // Free credits\n        freeFoodAnalysisRemaining: true,\n        freeSymptomAnalysisRemaining: true,\n        freeMedicalAnalysisRemaining: true,\n        freeInteractionAnalysisRemaining: true,\n        freeHealthIntakeRemaining: true,\n        freeInsightsUpdateRemaining: true,\n        creditTopUps: {\n          select: {\n            id: true,\n            amountCents: true,\n            usedCents: true,\n            expiresAt: true,\n          },\n        },\n      },\n    })\n\n    if (!user) {\n      return NextResponse.json({ error: 'User not found' }, { status: 404 })\n    }\n\n    if (featureParam) {\n      logServerCall({\n        feature: featureParam,\n        endpoint: '/api/credit/status',\n        kind: 'credit_status',\n      }).catch((error) => {\n        console.error('‚ùå Failed to log credit status call:', error)\n      })\n    }\n\n    const now = new Date()\n    const isPremium = isSubscriptionActive(user.subscription)\n\n  // 3) Wallet‚Äëstyle credits (subscription + top‚Äëups + manual additional credits)\n  debugStage = 'wallet-calc'\n  const monthlyCapCents = monthlyCapFromSubscription(user.subscription)\n  const monthlyUsedCents = user.walletMonthlyUsedCents || 0\n  const monthlyRemainingCents = Math.max(0, monthlyCapCents - monthlyUsedCents)\n\n  const activeTopUps = (user.creditTopUps || []).filter((t) => t.expiresAt > now)\n  const topUpsTotalAvailable = activeTopUps.reduce(\n    (sum, t) => sum + Math.max(0, t.amountCents - t.usedCents),\n    0\n  )\n  const topUpsTotalPurchased = activeTopUps.reduce((sum, t) => sum + t.amountCents, 0)\n  const topUpsTotalUsed = activeTopUps.reduce((sum, t) => sum + t.usedCents, 0)\n  const additionalAvailable = Math.max(0, user.additionalCredits || 0)\n\n  const totalAvailableCents = monthlyRemainingCents + topUpsTotalAvailable + additionalAvailable\n\n  let percentUsed = 0\n  if (monthlyCapCents > 0) {\n    percentUsed = Math.min(100, Math.floor((monthlyUsedCents / monthlyCapCents) * 100))\n  } else if (topUpsTotalPurchased > 0) {\n      percentUsed = Math.min(100, Math.floor((topUpsTotalUsed / topUpsTotalPurchased) * 100))\n    }\n\n    // 4) Legacy daily/additional credits (for truly free accounts)\n    debugStage = 'legacy-calc'\n    const dailyRemainingLegacy = Math.max(\n      0,\n      (user.dailyAnalysisCredits || 0) - (user.dailyAnalysisUsed || 0)\n    )\n    const additionalRemainingLegacy = user.additionalCredits || 0\n    const legacyTotal = dailyRemainingLegacy + additionalRemainingLegacy\n\n  // For subscription / wallet users, show wallet credits.\n  // For non‚Äësubscription users without wallet credits, fall back to legacy.\n  const hasWalletCredits = totalAvailableCents > 0\n  const showLegacy = !isPremium && !hasWalletCredits\n\n    const creditsTotal = showLegacy ? legacyTotal : totalAvailableCents\n\n    debugStage = 'compute-reset'\n    const refreshAt = computeNextResetAt(isPremium ? user.subscription?.startDate ?? null : null)\n\n    // Get free credits status\n    const freeCreditsStatus = await getFreeCreditsStatus(user.id)\n    const exhaustedFreeCredits = await hasExhaustedFreeCredits(user.id)\n\n    return NextResponse.json({\n      schemaVersion: 2,\n      debugStage: 'success',\n      percentUsed,\n      refreshAt,\n      plan: isPremium ? user.subscription?.plan ?? null : null,\n      // Any authenticated user can see the meter; billing enforcement happens in\n      // the analyzer APIs.\n      hasAccess: true,\n      monthlyCapCents,\n      monthlyUsedCents,\n      topUps: activeTopUps.map((t) => ({\n        id: t.id,\n        availableCents: Math.max(0, t.amountCents - t.usedCents),\n        expiresAt: t.expiresAt,\n      })),\n      additionalAvailableCents: additionalAvailable,\n      totalAvailableCents,\n      credits: {\n        total: creditsTotal,\n        dailyRemaining: showLegacy ? dailyRemainingLegacy : 0,\n        additionalRemaining: additionalAvailable,\n      },\n      freeCredits: freeCreditsStatus,\n      exhaustedFreeCredits,\n    })\n  } catch (err: any) {\n    console.error('Error in /api/credit/status:', err)\n    // Degrade gracefully: zero credits but keep shape stable so UI can render.\n    return NextResponse.json({\n      schemaVersion: 2,\n      debugStage,\n      percentUsed: 0,\n      refreshAt: null,\n      plan: null,\n      hasAccess: false,\n      monthlyCapCents: 0,\n      monthlyUsedCents: 0,\n      topUps: [],\n      totalAvailableCents: 0,\n      credits: {\n        total: 0,\n        dailyRemaining: 0,\n        additionalRemaining: 0,\n      },\n      degraded: true,\n      errorType: err?.name || 'UnknownError',\n      errorMessage: err?.message || 'Unknown error',\n    })\n  }\n}\n","truncated":false,"size":9383},{"path":"app/api/credit/usage-breakdown/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\nimport { CREDIT_COSTS } from '@/lib/credit-system'\nimport { isSubscriptionActive } from '@/lib/subscription-utils'\n\n// Guard rail: this endpoint is for diagnostics/admin use only. It should not be\n// changed to \"patch over\" wallet bugs; fix the underlying credit logic instead.\n//\n// Usage breakdown reads per-user data and must be dynamic.\nexport const dynamic = 'force-dynamic'\nexport const revalidate = 0\n\nexport async function GET(_req: NextRequest) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.email) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const user = await prisma.user.findUnique({\n      where: { email: session.user.email },\n      select: {\n        id: true,\n        walletMonthlyUsedCents: true,\n        monthlySymptomAnalysisUsed: true,\n        monthlyFoodAnalysisUsed: true,\n        monthlyMedicalImageAnalysisUsed: true,\n        monthlyInteractionAnalysisUsed: true,\n        totalFoodAnalysisCount: true,\n        totalInteractionAnalysisCount: true,\n        subscription: {\n          select: {\n            plan: true,\n            startDate: true,\n            endDate: true,\n          },\n        },\n        creditTopUps: {\n          select: {\n            purchasedAt: true,\n            expiresAt: true,\n          },\n          orderBy: {\n            purchasedAt: 'desc',\n          },\n        },\n      },\n    })\n\n    if (!user) {\n      return NextResponse.json({ error: 'User not found' }, { status: 404 })\n    }\n\n    // Calculate the start date for monthly counting (same logic as feature-usage)\n    let monthlyStartDate: Date | null = null\n    \n    const hasActiveSubscription = isSubscriptionActive(user.subscription)\n    if (hasActiveSubscription && user.subscription?.startDate) {\n      const subStartDate = new Date(user.subscription.startDate)\n      const now = new Date()\n      \n      const startYear = subStartDate.getUTCFullYear()\n      const startMonth = subStartDate.getUTCMonth()\n      const startDay = subStartDate.getUTCDate()\n      \n      const currentYear = now.getUTCFullYear()\n      const currentMonth = now.getUTCMonth()\n      const currentDay = now.getUTCDate()\n      \n      let monthsSinceStart = (currentYear - startYear) * 12 + (currentMonth - startMonth)\n      \n      if (currentDay < startDay) {\n        monthsSinceStart--\n      }\n      \n      monthlyStartDate = new Date(Date.UTC(startYear, startMonth + monthsSinceStart, startDay, 0, 0, 0, 0))\n      \n      if (monthlyStartDate > now) {\n        monthsSinceStart--\n        monthlyStartDate = new Date(Date.UTC(startYear, startMonth + monthsSinceStart, startDay, 0, 0, 0, 0))\n      }\n    } else if (user.creditTopUps && user.creditTopUps.length > 0) {\n      const mostRecentTopUp = user.creditTopUps[0]\n      if (mostRecentTopUp && mostRecentTopUp.expiresAt > new Date()) {\n        const purchaseDate = new Date(mostRecentTopUp.purchasedAt)\n        const now = new Date()\n        \n        const purchaseYear = purchaseDate.getUTCFullYear()\n        const purchaseMonth = purchaseDate.getUTCMonth()\n        const purchaseDay = purchaseDate.getUTCDate()\n        \n        const currentYear = now.getUTCFullYear()\n        const currentMonth = now.getUTCMonth()\n        const currentDay = now.getUTCDate()\n        \n        let monthsSincePurchase = (currentYear - purchaseYear) * 12 + (currentMonth - purchaseMonth)\n        \n        if (currentDay < purchaseDay) {\n          monthsSincePurchase--\n        }\n        \n        monthlyStartDate = new Date(Date.UTC(purchaseYear, purchaseMonth + monthsSincePurchase, purchaseDay, 0, 0, 0, 0))\n        \n        if (monthlyStartDate > now) {\n          monthsSincePurchase--\n          monthlyStartDate = new Date(Date.UTC(purchaseYear, purchaseMonth + monthsSincePurchase, purchaseDay, 0, 0, 0, 0))\n        }\n      }\n    }\n\n    // Query actual usage from database since monthlyStartDate\n    const breakdown: any = {\n      schemaVersion: 1,\n      monthlyStartDate: monthlyStartDate?.toISOString() || null,\n      walletMonthlyUsedCents: user.walletMonthlyUsedCents || 0,\n      features: {},\n    }\n\n    if (monthlyStartDate) {\n      // Count FoodLog entries (food analysis)\n      const foodLogCount = await prisma.foodLog.count({\n        where: {\n          userId: user.id,\n          createdAt: {\n            gte: monthlyStartDate,\n          },\n        },\n      })\n      breakdown.features.foodAnalysis = {\n        count: foodLogCount,\n        costPerUse: CREDIT_COSTS.FOOD_ANALYSIS,\n        totalCredits: foodLogCount * CREDIT_COSTS.FOOD_ANALYSIS,\n      }\n\n      // Count InteractionAnalysis entries\n      const interactionCount = await prisma.interactionAnalysis.count({\n        where: {\n          userId: user.id,\n          createdAt: {\n            gte: monthlyStartDate,\n          },\n        },\n      })\n      breakdown.features.interactionAnalysis = {\n        count: interactionCount,\n        costPerUse: CREDIT_COSTS.INTERACTION_ANALYSIS,\n        totalCredits: interactionCount * CREDIT_COSTS.INTERACTION_ANALYSIS,\n      }\n\n      // For symptom analysis, we need to check if there's a way to track it\n      // Since there's no SymptomAnalysis table, we'll use the monthly counter\n      // but also check if there are any other records\n      breakdown.features.symptomAnalysis = {\n        count: user.monthlySymptomAnalysisUsed || 0,\n        costPerUse: CREDIT_COSTS.SYMPTOM_ANALYSIS,\n        totalCredits: (user.monthlySymptomAnalysisUsed || 0) * CREDIT_COSTS.SYMPTOM_ANALYSIS,\n      }\n\n      // Medical image analysis - check if there's a way to track this\n      breakdown.features.medicalImageAnalysis = {\n        count: user.monthlyMedicalImageAnalysisUsed || 0,\n        costPerUse: CREDIT_COSTS.MEDICAL_IMAGE_ANALYSIS,\n        totalCredits: (user.monthlyMedicalImageAnalysisUsed || 0) * CREDIT_COSTS.MEDICAL_IMAGE_ANALYSIS,\n      }\n    } else {\n      // Fallback to monthly counters\n      breakdown.features.foodAnalysis = {\n        count: user.monthlyFoodAnalysisUsed || 0,\n        costPerUse: CREDIT_COSTS.FOOD_ANALYSIS,\n        totalCredits: (user.monthlyFoodAnalysisUsed || 0) * CREDIT_COSTS.FOOD_ANALYSIS,\n      }\n      breakdown.features.interactionAnalysis = {\n        count: user.monthlyInteractionAnalysisUsed || 0,\n        costPerUse: CREDIT_COSTS.INTERACTION_ANALYSIS,\n        totalCredits: (user.monthlyInteractionAnalysisUsed || 0) * CREDIT_COSTS.INTERACTION_ANALYSIS,\n      }\n      breakdown.features.symptomAnalysis = {\n        count: user.monthlySymptomAnalysisUsed || 0,\n        costPerUse: CREDIT_COSTS.SYMPTOM_ANALYSIS,\n        totalCredits: (user.monthlySymptomAnalysisUsed || 0) * CREDIT_COSTS.SYMPTOM_ANALYSIS,\n      }\n      breakdown.features.medicalImageAnalysis = {\n        count: user.monthlyMedicalImageAnalysisUsed || 0,\n        costPerUse: CREDIT_COSTS.MEDICAL_IMAGE_ANALYSIS,\n        totalCredits: (user.monthlyMedicalImageAnalysisUsed || 0) * CREDIT_COSTS.MEDICAL_IMAGE_ANALYSIS,\n      }\n    }\n\n    // Calculate total expected credits\n    const totalExpectedCredits = Object.values(breakdown.features).reduce(\n      (sum: number, feature: any) => sum + (feature.totalCredits || 0),\n      0\n    )\n\n    // Note: Food reanalyses and insights chat also charge credits but aren't tracked in monthly counters\n    // Food reanalyses: 1 credit each (tracked in dailyFoodReanalysisUsed but not monthly)\n    // Insights chat: Variable cost based on actual API usage\n    \n    breakdown.summary = {\n      totalExpectedCredits,\n      walletMonthlyUsedCents: user.walletMonthlyUsedCents || 0,\n      difference: (user.walletMonthlyUsedCents || 0) - totalExpectedCredits,\n      note: 'Food reanalyses and insights chat also charge credits but are not included in monthly counters above',\n    }\n\n    return NextResponse.json(breakdown)\n  } catch (err) {\n    console.error('Error fetching usage breakdown:', err)\n    return NextResponse.json({ error: 'server_error' }, { status: 500 })\n  }\n}\n","truncated":false,"size":8107},{"path":"app/api/cron/affiliate-payout-run/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\n\nexport const runtime = 'nodejs'\nexport const dynamic = 'force-dynamic'\n\nexport async function GET(request: NextRequest) {\n  const vercelCronHeader = request.headers.get('x-vercel-cron')\n  const isVercelCron = vercelCronHeader !== null\n  const authHeader = request.headers.get('authorization')\n  const expected = process.env.SCHEDULER_SECRET\n\n  if (!(isVercelCron || (expected && authHeader === `Bearer ${expected}`))) {\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  }\n\n  const origin = new URL(request.url).origin\n  const res = await fetch(`${origin}/api/admin/affiliates/payout-run`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      ...(expected ? { Authorization: `Bearer ${expected}` } : {}),\n    },\n    body: JSON.stringify({\n      currency: 'usd',\n      minThresholdCents: 5000,\n      dryRun: false,\n    }),\n  })\n\n  const data = await res.json().catch(() => ({}))\n  if (!res.ok) {\n    return NextResponse.json({ error: data?.error || 'Payout run failed' }, { status: res.status })\n  }\n\n  return NextResponse.json({ ok: true, result: data })\n}\n","truncated":false,"size":1170},{"path":"app/api/cron/food-photo-cleanup/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { del, list } from '@vercel/blob'\nimport { prisma } from '@/lib/prisma'\n\nexport const runtime = 'nodejs'\nexport const dynamic = 'force-dynamic'\n\nconst FOOD_PHOTO_PREFIX = 'food-photos/'\n\nconst getRetentionDays = () => {\n  const raw = Number(process.env.FOOD_PHOTO_RETENTION_DAYS || 90)\n  if (!Number.isFinite(raw) || raw < 1) return 90\n  return Math.min(Math.round(raw), 3650)\n}\n\nconst chunk = <T,>(items: T[], size: number) => {\n  const result: T[][] = []\n  for (let i = 0; i < items.length; i += size) {\n    result.push(items.slice(i, i + size))\n  }\n  return result\n}\n\nexport async function GET(request: NextRequest) {\n  const vercelCronHeader = request.headers.get('x-vercel-cron')\n  const isVercelCron = vercelCronHeader !== null\n  const authHeader = request.headers.get('authorization')\n  const expected = process.env.FOOD_PHOTO_CLEANUP_SECRET || process.env.SCHEDULER_SECRET\n\n  if (!(isVercelCron || (expected && authHeader === `Bearer ${expected}`))) {\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  }\n\n  if (!process.env.BLOB_READ_WRITE_TOKEN) {\n    return NextResponse.json({ error: 'Blob storage not configured' }, { status: 500 })\n  }\n\n  const retentionDays = getRetentionDays()\n  const cutoffMs = Date.now() - retentionDays * 24 * 60 * 60 * 1000\n\n  let cursor: string | undefined = undefined\n  let scanned = 0\n  let deleted = 0\n\n  try {\n    do {\n      const result: Awaited<ReturnType<typeof list>> = await list({\n        prefix: FOOD_PHOTO_PREFIX,\n        limit: 1000,\n        cursor,\n      })\n      cursor = result.cursor\n      const expiredUrls = result.blobs\n        .filter((blob) => {\n          scanned += 1\n          return blob.uploadedAt.getTime() < cutoffMs\n        })\n        .map((blob) => blob.url)\n\n      const batches = chunk(Array.from(new Set(expiredUrls)), 100)\n      for (const batch of batches) {\n        if (batch.length === 0) continue\n        await del(batch)\n        await prisma.foodLog.updateMany({\n          where: { imageUrl: { in: batch } },\n          data: { imageUrl: null },\n        })\n        deleted += batch.length\n      }\n    } while (cursor)\n\n    return NextResponse.json({\n      ok: true,\n      scanned,\n      deleted,\n      retentionDays,\n    })\n  } catch (error) {\n    console.error('‚ùå Food photo cleanup failed', error)\n    return NextResponse.json({ error: 'Cleanup failed' }, { status: 500 })\n  }\n}\n","truncated":false,"size":2447},{"path":"app/api/debug-food-upload/route.ts","content":"import { NextRequest, NextResponse } from 'next/server';\nimport { extractAdminFromHeaders } from '@/lib/admin-auth';\n\nexport async function POST(req: NextRequest) {\n  if (process.env.NODE_ENV !== 'development') {\n    return NextResponse.json({ error: 'Not found' }, { status: 404 });\n  }\n  const authHeader = req.headers.get('authorization');\n  const admin = extractAdminFromHeaders(authHeader);\n  if (!admin) {\n    return NextResponse.json({ error: 'Not found' }, { status: 404 });\n  }\n\n  try {\n    const contentType = req.headers.get('content-type');\n    \n    console.log('=== FOOD UPLOAD DEBUG ===');\n    console.log('Content-Type:', contentType);\n    console.log('OpenAI API Key exists:', !!process.env.OPENAI_API_KEY);\n    \n    if (contentType?.includes('multipart/form-data')) {\n      const formData = await req.formData();\n      const imageFile = formData.get('image') as File;\n      \n      console.log('Image file received:', !!imageFile);\n      console.log('Image file name:', imageFile?.name);\n      console.log('Image file size:', imageFile?.size);\n      console.log('Image file type:', imageFile?.type);\n      \n      return NextResponse.json({\n        success: true,\n        debug: {\n          hasApiKey: !!process.env.OPENAI_API_KEY,\n          imageReceived: !!imageFile,\n          imageName: imageFile?.name,\n          imageSize: imageFile?.size,\n          imageType: imageFile?.type,\n          contentType\n        }\n      });\n    }\n    \n    return NextResponse.json({\n      error: 'No multipart data received',\n      contentType\n    }, { status: 400 });\n    \n  } catch (error) {\n    console.error('Debug error:', error);\n    return NextResponse.json({\n      error: 'Debug failed',\n      message: error instanceof Error ? error.message : 'Unknown error'\n    }, { status: 500 });\n  }\n} \n","truncated":false,"size":1800},{"path":"app/api/debug-upload/route.ts","content":"import { NextRequest, NextResponse } from 'next/server';\nimport { getServerSession } from 'next-auth/next';\nimport { authOptions } from '@/lib/auth';\nimport { prisma } from '@/lib/prisma';\nimport { v2 as cloudinary } from 'cloudinary';\n\n// Configure Cloudinary\ncloudinary.config({\n  cloud_name: process.env.CLOUDINARY_CLOUD_NAME?.trim(),\n  api_key: process.env.CLOUDINARY_API_KEY?.trim(),\n  api_secret: process.env.CLOUDINARY_API_SECRET?.trim(),\n});\n\nexport async function POST(request: NextRequest) {\n  console.log('üß™ DEBUG UPLOAD API - Starting detailed error tracking...');\n  \n  try {\n    // Step 1: Check authentication\n    console.log('üîç Step 1: Checking authentication...');\n    const session = await getServerSession(authOptions);\n    \n    if (!session?.user?.email) {\n      console.log('‚ùå Authentication failed - no session or user email');\n      return NextResponse.json({ \n        success: false, \n        error: 'Not authenticated',\n        debug: { step: 'authentication', session: !!session, userEmail: session?.user?.email }\n      }, { status: 401 });\n    }\n    console.log('‚úÖ Authentication successful for user:', session.user.email);\n\n    // Step 2: Parse form data\n    console.log('üîç Step 2: Parsing form data...');\n    let formData;\n    try {\n      formData = await request.formData();\n      console.log('‚úÖ Form data parsed successfully');\n    } catch (error) {\n      console.log('‚ùå Form data parsing failed:', error);\n      return NextResponse.json({ \n        success: false, \n        error: 'Failed to parse form data',\n        debug: { step: 'formData', error: error instanceof Error ? error.message : 'Unknown error' }\n      }, { status: 400 });\n    }\n\n    const imageFile = formData.get('image') as File;\n    if (!imageFile) {\n      console.log('‚ùå No image file provided in form data');\n      return NextResponse.json({ \n        success: false, \n        error: 'No image file provided',\n        debug: { step: 'fileExtraction', formDataKeys: Array.from(formData.keys()) }\n      }, { status: 400 });\n    }\n    console.log('‚úÖ Image file extracted:', { name: imageFile.name, type: imageFile.type, size: imageFile.size });\n\n    // Step 3: Validate file\n    console.log('üîç Step 3: Validating file...');\n    if (!imageFile.type.startsWith('image/')) {\n      return NextResponse.json({ \n        success: false, \n        error: 'File must be an image',\n        debug: { step: 'fileValidation', actualType: imageFile.type }\n      }, { status: 400 });\n    }\n    if (imageFile.size > 5 * 1024 * 1024) {\n      return NextResponse.json({ \n        success: false, \n        error: 'File size must be less than 5MB',\n        debug: { step: 'fileValidation', actualSize: imageFile.size, maxSize: 5 * 1024 * 1024 }\n      }, { status: 400 });\n    }\n    console.log('‚úÖ File validation passed');\n\n    // Step 4: Convert to buffer\n    console.log('üîç Step 4: Converting file to buffer...');\n    let buffer;\n    try {\n      const imageBuffer = await imageFile.arrayBuffer();\n      buffer = Buffer.from(imageBuffer);\n      console.log('‚úÖ Buffer conversion successful, size:', buffer.length);\n    } catch (error) {\n      console.log('‚ùå Buffer conversion failed:', error);\n      return NextResponse.json({ \n        success: false, \n        error: 'Failed to convert file to buffer',\n        debug: { step: 'bufferConversion', error: error instanceof Error ? error.message : 'Unknown error' }\n      }, { status: 500 });\n    }\n\n    // Step 5: Check Cloudinary configuration\n    console.log('üîç Step 5: Checking Cloudinary configuration...');\n    const cloudinaryConfig = {\n      cloud_name: process.env.CLOUDINARY_CLOUD_NAME,\n      api_key: process.env.CLOUDINARY_API_KEY,\n      api_secret: process.env.CLOUDINARY_API_SECRET,\n    };\n    \n    console.log('üìã Cloudinary config check:', {\n      cloud_name: cloudinaryConfig.cloud_name ? `${cloudinaryConfig.cloud_name.substring(0, 5)}...` : 'MISSING',\n      api_key: cloudinaryConfig.api_key ? `${cloudinaryConfig.api_key.substring(0, 5)}...` : 'MISSING',\n      api_secret: cloudinaryConfig.api_secret ? `${cloudinaryConfig.api_secret.substring(0, 5)}...` : 'MISSING'\n    });\n\n    if (!cloudinaryConfig.cloud_name || !cloudinaryConfig.api_key || !cloudinaryConfig.api_secret) {\n      return NextResponse.json({ \n        success: false, \n        error: 'Missing Cloudinary configuration',\n        debug: { \n          step: 'cloudinaryConfig',\n          missingVars: {\n            cloud_name: !cloudinaryConfig.cloud_name,\n            api_key: !cloudinaryConfig.api_key,\n            api_secret: !cloudinaryConfig.api_secret\n          }\n        }\n      }, { status: 500 });\n    }\n\n    // Step 6: Upload to Cloudinary\n    console.log('üîç Step 6: Uploading to Cloudinary...');\n    let cloudinaryResult;\n    try {\n      cloudinaryResult = await new Promise((resolve, reject) => {\n        cloudinary.uploader.upload_stream(\n          {\n            resource_type: 'image',\n            folder: 'helfi/profile-images',\n            public_id: `user_${session.user.email?.replace(/[^a-zA-Z0-9]/g, '_')}_${Date.now()}`,\n            transformation: [\n              { width: 400, height: 400, crop: 'fill', gravity: 'face' },\n              { quality: 'auto', fetch_format: 'auto' }\n            ],\n            invalidate: true,\n            overwrite: true\n          },\n          (error, result) => {\n            if (error) {\n              console.error('‚ùå Cloudinary upload error:', error);\n              reject(error);\n            } else {\n              console.log('‚úÖ Cloudinary upload successful');\n              resolve(result);\n            }\n          }\n        ).end(buffer);\n      });\n      \n      console.log('‚úÖ Cloudinary upload completed:', {\n        publicId: (cloudinaryResult as any).public_id,\n        secureUrl: (cloudinaryResult as any).secure_url,\n        bytes: (cloudinaryResult as any).bytes\n      });\n    } catch (error) {\n      console.log('‚ùå Cloudinary upload failed:', error);\n      return NextResponse.json({ \n        success: false, \n        error: 'Cloudinary upload failed',\n        debug: { \n          step: 'cloudinaryUpload', \n          error: error instanceof Error ? error.message : 'Unknown error',\n          errorDetails: error\n        }\n      }, { status: 500 });\n    }\n\n    // Step 7: Find user in database\n    console.log('üîç Step 7: Finding user in database...');\n    let user;\n    try {\n      user = await prisma.user.findUnique({\n        where: { email: session.user.email }\n      });\n      \n      if (!user) {\n        console.log('‚ùå User not found in database:', session.user.email);\n        return NextResponse.json({ \n          success: false, \n          error: 'User not found',\n          debug: { step: 'userLookup', email: session.user.email }\n        }, { status: 404 });\n      }\n      \n      console.log('‚úÖ User found in database:', { id: user.id, email: user.email });\n    } catch (error) {\n      console.log('‚ùå Database user lookup failed:', error);\n      return NextResponse.json({ \n        success: false, \n        error: 'Database user lookup failed',\n        debug: { \n          step: 'userLookup', \n          error: error instanceof Error ? error.message : 'Unknown error',\n          errorDetails: error\n        }\n      }, { status: 500 });\n    }\n\n    // Step 8: Create File record\n    console.log('üîç Step 8: Creating File record...');\n    let fileRecord;\n    try {\n      fileRecord = await prisma.file.create({\n        data: {\n          originalName: imageFile.name,\n          fileName: (cloudinaryResult as any).public_id,\n          fileSize: (cloudinaryResult as any).bytes,\n          mimeType: imageFile.type,\n          cloudinaryId: (cloudinaryResult as any).public_id,\n          cloudinaryUrl: (cloudinaryResult as any).url,\n          secureUrl: (cloudinaryResult as any).secure_url,\n          uploadedById: user.id,\n          fileType: 'IMAGE',\n          usage: 'PROFILE_IMAGE',\n          isPublic: false,\n          metadata: {\n            width: (cloudinaryResult as any).width,\n            height: (cloudinaryResult as any).height,\n            format: (cloudinaryResult as any).format,\n            originalSize: imageFile.size,\n            optimizedSize: (cloudinaryResult as any).bytes\n          }\n        }\n      });\n      \n      console.log('‚úÖ File record created:', { id: fileRecord.id });\n    } catch (error) {\n      console.log('‚ùå File record creation failed:', error);\n      return NextResponse.json({ \n        success: false, \n        error: 'File record creation failed',\n        debug: { \n          step: 'fileRecordCreation', \n          error: error instanceof Error ? error.message : 'Unknown error',\n          errorDetails: error\n        }\n      }, { status: 500 });\n    }\n\n    // Step 9: Update user profile image\n    console.log('üîç Step 9: Updating user profile image...');\n    try {\n      await prisma.user.update({\n        where: { id: user.id },\n        data: { \n          image: (cloudinaryResult as any).secure_url,\n          updatedAt: new Date()\n        }\n      });\n      \n      console.log('‚úÖ User profile image updated');\n    } catch (error) {\n      console.log('‚ùå User profile image update failed:', error);\n      return NextResponse.json({ \n        success: false, \n        error: 'User profile image update failed',\n        debug: { \n          step: 'userProfileUpdate', \n          error: error instanceof Error ? error.message : 'Unknown error',\n          errorDetails: error\n        }\n      }, { status: 500 });\n    }\n\n    console.log('üéâ DEBUG UPLOAD API - All steps completed successfully!');\n\n    return NextResponse.json({\n      success: true,\n      imageUrl: (cloudinaryResult as any).secure_url,\n      cloudinaryId: (cloudinaryResult as any).public_id,\n      fileId: fileRecord.id,\n      debug: {\n        allStepsCompleted: true,\n        finalStep: 'userProfileUpdate'\n      }\n    });\n\n  } catch (error) {\n    console.error('‚ùå DEBUG UPLOAD API - Unexpected error:', error);\n    return NextResponse.json({\n      success: false,\n      error: 'Unexpected error in debug API',\n      debug: {\n        step: 'unexpectedError',\n        error: error instanceof Error ? error.message : 'Unknown error',\n        errorDetails: error,\n        stack: error instanceof Error ? error.stack : undefined\n      }\n    }, { status: 500 });\n  }\n} ","truncated":false,"size":10325},{"path":"app/api/exercise-entries/[id]/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\nimport { calculateExerciseCalories } from '@/lib/exercise/calories'\nimport { getHealthProfileForUser } from '@/lib/exercise/health-profile'\nimport { inferMetAndLabel } from '@/lib/exercise/met'\n\ntype RouteParams = {\n  params: { id: string }\n}\n\nexport async function DELETE(_request: NextRequest, { params }: RouteParams) {\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.id) {\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  }\n\n  const id = String(params.id || '')\n  if (!id) {\n    return NextResponse.json({ error: 'Missing id' }, { status: 400 })\n  }\n\n  const existing = await prisma.exerciseEntry.findUnique({ where: { id } })\n  if (!existing || existing.userId !== session.user.id) {\n    return NextResponse.json({ error: 'Not found' }, { status: 404 })\n  }\n\n  await prisma.exerciseEntry.delete({ where: { id } })\n\n  const entries = await prisma.exerciseEntry.findMany({\n    where: { userId: session.user.id, localDate: existing.localDate },\n    orderBy: [{ startTime: 'asc' }, { createdAt: 'asc' }],\n  })\n  const exerciseCalories = entries.reduce((sum, e) => sum + (Number(e.calories) || 0), 0)\n\n  return NextResponse.json({ success: true, date: existing.localDate, exerciseCalories })\n}\n\nexport async function PATCH(request: NextRequest, { params }: RouteParams) {\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.id) {\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  }\n\n  const id = String(params.id || '')\n  if (!id) {\n    return NextResponse.json({ error: 'Missing id' }, { status: 400 })\n  }\n\n  const existing = await prisma.exerciseEntry.findUnique({\n    where: { id },\n    include: { exerciseType: true },\n  })\n  if (!existing || existing.userId !== session.user.id) {\n    return NextResponse.json({ error: 'Not found' }, { status: 404 })\n  }\n  if (existing.source !== 'MANUAL') {\n    return NextResponse.json({ error: 'Only manual exercise entries can be edited.' }, { status: 400 })\n  }\n\n  let body: any\n  try {\n    body = await request.json()\n  } catch {\n    body = null\n  }\n\n  const durationMinutes = body?.durationMinutes !== undefined ? Number(body.durationMinutes) : existing.durationMinutes\n  const hasDistanceKm = body && Object.prototype.hasOwnProperty.call(body, 'distanceKm')\n  const distanceKm = hasDistanceKm\n    ? body.distanceKm === null || body.distanceKm === undefined\n      ? null\n      : Number(body.distanceKm)\n    : existing.distanceKm\n\n  const hasStartTime = body && Object.prototype.hasOwnProperty.call(body, 'startTime')\n  const startTimeRaw = hasStartTime ? body.startTime : undefined\n  const startTime =\n    !hasStartTime ? existing.startTime : startTimeRaw ? new Date(String(startTimeRaw)) : null\n\n  const exerciseTypeId =\n    body?.exerciseTypeId !== undefined && body?.exerciseTypeId !== null ? Number(body.exerciseTypeId) : existing.exerciseTypeId\n\n  if (!Number.isFinite(durationMinutes) || durationMinutes <= 0 || durationMinutes > 24 * 60) {\n    return NextResponse.json({ error: 'Invalid durationMinutes' }, { status: 400 })\n  }\n  if (distanceKm !== null && (!Number.isFinite(distanceKm) || distanceKm <= 0 || distanceKm > 500)) {\n    return NextResponse.json({ error: 'Invalid distanceKm' }, { status: 400 })\n  }\n  if (startTime && Number.isNaN(startTime.getTime())) {\n    return NextResponse.json({ error: 'Invalid startTime' }, { status: 400 })\n  }\n  if (exerciseTypeId !== null && exerciseTypeId !== undefined && (!Number.isFinite(exerciseTypeId) || exerciseTypeId <= 0)) {\n    return NextResponse.json({ error: 'Invalid exerciseTypeId' }, { status: 400 })\n  }\n\n  const type =\n    exerciseTypeId && exerciseTypeId !== existing.exerciseTypeId\n      ? await prisma.exerciseType.findUnique({ where: { id: exerciseTypeId } })\n      : existing.exerciseType\n\n  if (!type) {\n    return NextResponse.json({ error: 'Exercise type not found' }, { status: 404 })\n  }\n\n  const health = await getHealthProfileForUser(session.user.id)\n  const weightToUse = health.weightKg\n  if (!weightToUse) {\n    return NextResponse.json(\n      { error: 'Please update your weight in Health Setup to log exercise calories.' },\n      { status: 400 },\n    )\n  }\n\n  const inferred = inferMetAndLabel({\n    exerciseName: type.name,\n    baseMet: type.met,\n    durationMinutes,\n    distanceKm: distanceKm ?? null,\n  })\n\n  const calories = calculateExerciseCalories({\n    met: inferred.met,\n    weightKg: weightToUse,\n    durationMinutes: inferred.durationMinutes,\n  })\n\n  const updated = await prisma.exerciseEntry.update({\n    where: { id: existing.id },\n    data: {\n      startTime,\n      durationMinutes: inferred.durationMinutes,\n      distanceKm: distanceKm !== null ? distanceKm : null,\n      exerciseTypeId: type.id,\n      label: inferred.label,\n      met: inferred.met,\n      calories,\n    },\n    include: { exerciseType: true },\n  })\n\n  const entries = await prisma.exerciseEntry.findMany({\n    where: { userId: session.user.id, localDate: existing.localDate },\n    orderBy: [{ startTime: 'asc' }, { createdAt: 'asc' }],\n    include: { exerciseType: true },\n  })\n  const exerciseCalories = entries.reduce((sum, e) => sum + (Number(e.calories) || 0), 0)\n\n  return NextResponse.json({ success: true, entry: updated, date: existing.localDate, exerciseCalories, entries })\n}\n","truncated":false,"size":5486},{"path":"app/api/exercise-entries/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\nimport { calculateExerciseCalories } from '@/lib/exercise/calories'\nimport { getHealthProfileForUser } from '@/lib/exercise/health-profile'\nimport { inferMetAndLabel } from '@/lib/exercise/met'\n\nconst DATE_RE = /^\\d{4}-\\d{2}-\\d{2}$/\n\nfunction normalizeLocalDate(input: string) {\n  const trimmed = (input || '').trim()\n  if (!DATE_RE.test(trimmed)) return null\n  return trimmed\n}\n\nexport async function GET(request: NextRequest) {\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.id) {\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  }\n\n  const date = normalizeLocalDate(request.nextUrl.searchParams.get('date') || '')\n  if (!date) {\n    return NextResponse.json({ error: 'Missing or invalid date (YYYY-MM-DD)' }, { status: 400 })\n  }\n\n  const entries = await prisma.exerciseEntry.findMany({\n    where: { userId: session.user.id, localDate: date },\n    orderBy: [{ startTime: 'asc' }, { createdAt: 'asc' }],\n    include: { exerciseType: true },\n  })\n\n  const exerciseCalories = entries.reduce((sum, e) => sum + (Number(e.calories) || 0), 0)\n  return NextResponse.json({ date, exerciseCalories, entries })\n}\n\nexport async function POST(request: NextRequest) {\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.id) {\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  }\n\n  let body: any\n  try {\n    body = await request.json()\n  } catch {\n    body = null\n  }\n\n  const exerciseTypeId = Number(body?.exerciseTypeId)\n  const durationMinutes = Number(body?.durationMinutes)\n  const distanceKmRaw = body?.distanceKm\n  const distanceKm = distanceKmRaw === null || distanceKmRaw === undefined ? null : Number(distanceKmRaw)\n  const date = normalizeLocalDate(body?.date || '')\n  const startTime = body?.startTime ? new Date(String(body.startTime)) : null\n\n  if (!Number.isFinite(exerciseTypeId) || exerciseTypeId <= 0) {\n    return NextResponse.json({ error: 'Invalid exerciseTypeId' }, { status: 400 })\n  }\n  if (!Number.isFinite(durationMinutes) || durationMinutes <= 0 || durationMinutes > 24 * 60) {\n    return NextResponse.json({ error: 'Invalid durationMinutes' }, { status: 400 })\n  }\n  if (distanceKm !== null && (!Number.isFinite(distanceKm) || distanceKm <= 0 || distanceKm > 500)) {\n    return NextResponse.json({ error: 'Invalid distanceKm' }, { status: 400 })\n  }\n  if (!date) {\n    return NextResponse.json({ error: 'Missing or invalid date (YYYY-MM-DD)' }, { status: 400 })\n  }\n  if (startTime && Number.isNaN(startTime.getTime())) {\n    return NextResponse.json({ error: 'Invalid startTime' }, { status: 400 })\n  }\n\n  const type = await prisma.exerciseType.findUnique({ where: { id: exerciseTypeId } })\n  if (!type) {\n    return NextResponse.json({ error: 'Exercise type not found' }, { status: 404 })\n  }\n\n  const health = await getHealthProfileForUser(session.user.id)\n  if (!health.weightKg) {\n    return NextResponse.json(\n      { error: 'Please update your weight in Health Setup to log exercise calories.' },\n      { status: 400 },\n    )\n  }\n\n  const inferred = inferMetAndLabel({\n    exerciseName: type.name,\n    baseMet: type.met,\n    durationMinutes,\n    distanceKm: distanceKm ?? null,\n  })\n\n  const calories = calculateExerciseCalories({\n    met: inferred.met,\n    weightKg: health.weightKg,\n    durationMinutes: inferred.durationMinutes,\n  })\n\n  const entry = await prisma.exerciseEntry.create({\n    data: {\n      userId: session.user.id,\n      localDate: date,\n      startTime,\n      durationMinutes: inferred.durationMinutes,\n      distanceKm: distanceKm !== null ? distanceKm : null,\n      source: 'MANUAL',\n      exerciseTypeId: type.id,\n      label: inferred.label,\n      met: inferred.met,\n      calories,\n    },\n  })\n\n  const entries = await prisma.exerciseEntry.findMany({\n    where: { userId: session.user.id, localDate: date },\n    orderBy: [{ startTime: 'asc' }, { createdAt: 'asc' }],\n    include: { exerciseType: true },\n  })\n  const exerciseCalories = entries.reduce((sum, e) => sum + (Number(e.calories) || 0), 0)\n\n  return NextResponse.json({ entry, date, exerciseCalories })\n}\n","truncated":false,"size":4295},{"path":"app/api/exercise-preview/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\nimport { getHealthProfileForUser } from '@/lib/exercise/health-profile'\nimport { calculateExerciseCalories } from '@/lib/exercise/calories'\nimport { inferMetAndLabel } from '@/lib/exercise/met'\n\nexport async function POST(request: NextRequest) {\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.id) {\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  }\n\n  let body: any\n  try {\n    body = await request.json()\n  } catch {\n    body = null\n  }\n\n  const exerciseTypeId = Number(body?.exerciseTypeId)\n  const durationMinutes = Number(body?.durationMinutes)\n  const distanceKmRaw = body?.distanceKm\n  const distanceKm = distanceKmRaw === null || distanceKmRaw === undefined ? null : Number(distanceKmRaw)\n\n  if (!Number.isFinite(exerciseTypeId) || exerciseTypeId <= 0) {\n    return NextResponse.json({ error: 'Invalid exerciseTypeId' }, { status: 400 })\n  }\n  if (!Number.isFinite(durationMinutes) || durationMinutes <= 0 || durationMinutes > 24 * 60) {\n    return NextResponse.json({ error: 'Invalid durationMinutes' }, { status: 400 })\n  }\n  if (distanceKm !== null && (!Number.isFinite(distanceKm) || distanceKm <= 0 || distanceKm > 500)) {\n    return NextResponse.json({ error: 'Invalid distanceKm' }, { status: 400 })\n  }\n\n  const type = await prisma.exerciseType.findUnique({ where: { id: exerciseTypeId } })\n  if (!type) {\n    return NextResponse.json({ error: 'Exercise type not found' }, { status: 404 })\n  }\n\n  const health = await getHealthProfileForUser(session.user.id)\n  if (!health.weightKg) {\n    return NextResponse.json(\n      { error: 'Please update your weight in Health Setup to log exercise calories.' },\n      { status: 400 },\n    )\n  }\n\n  const inferred = inferMetAndLabel({\n    exerciseName: type.name,\n    baseMet: type.met,\n    durationMinutes,\n    distanceKm: distanceKm ?? null,\n  })\n\n  const calories = calculateExerciseCalories({\n    met: inferred.met,\n    weightKg: health.weightKg,\n    durationMinutes: inferred.durationMinutes,\n  })\n\n  return NextResponse.json({\n    calories,\n    met: inferred.met,\n    label: inferred.label,\n  })\n}\n\n","truncated":false,"size":2296},{"path":"app/api/exercise-types/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\n\nexport async function GET(request: NextRequest) {\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.id) {\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  }\n\n  const searchParams = request.nextUrl.searchParams\n  const search = (searchParams.get('search') || '').trim()\n  const category = (searchParams.get('category') || '').trim()\n  const intensity = (searchParams.get('intensity') || '').trim()\n\n  const limitRaw = Number(searchParams.get('limit') || 30)\n  const offsetRaw = Number(searchParams.get('offset') || 0)\n  const limit = Number.isFinite(limitRaw) ? Math.max(1, Math.min(100, Math.floor(limitRaw))) : 30\n  const offset = Number.isFinite(offsetRaw) ? Math.max(0, Math.floor(offsetRaw)) : 0\n\n  const where: any = {}\n  if (category) where.category = category\n  if (intensity) where.intensity = intensity\n  if (search) {\n    where.OR = [\n      { name: { contains: search, mode: 'insensitive' } },\n      { category: { contains: search, mode: 'insensitive' } },\n    ]\n  }\n\n  const items = await prisma.exerciseType.findMany({\n    where,\n    orderBy: [{ category: 'asc' }, { name: 'asc' }],\n    take: limit,\n    skip: offset,\n  })\n\n  const normalizedSearch = search.toLowerCase()\n  const normalizedCategory = category.toLowerCase()\n  let ordered = items\n\n  // UX: prioritize the most common activities near the top (especially within Cardio).\n  // Prisma ordering is alphabetical, so \"Walking\" otherwise lands near the bottom.\n  if (!normalizedSearch && normalizedCategory === 'cardio') {\n    const rank = (name: string) => {\n      const v = (name || '').toLowerCase()\n      if (v.includes('walking')) return 0\n      if (v.includes('jog')) return 1\n      if (v.includes('run')) return 2\n      if (v.includes('elliptical')) return 3\n      if (v.includes('rowing')) return 4\n      if (v.includes('aerobics')) return 5\n      return 10\n    }\n    ordered = [...items].sort((a: any, b: any) => {\n      const ra = rank(a?.name)\n      const rb = rank(b?.name)\n      if (ra !== rb) return ra - rb\n      return String(a?.name || '').localeCompare(String(b?.name || ''))\n    })\n  }\n\n  return NextResponse.json({ items: ordered, limit, offset })\n}\n","truncated":false,"size":2373},{"path":"app/api/exercise/sync/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\nimport { fitbitApiRequest, getFitbitUserId } from '@/lib/fitbit-api'\nimport { ingestExerciseEntry } from '@/lib/exercise/ingest'\nimport { parseFitbitActivitiesToIngest } from '@/lib/exercise/fitbit-workouts'\nimport { extractGarminWorkouts } from '@/lib/exercise/garmin-workouts'\n\nconst DATE_RE = /^\\d{4}-\\d{2}-\\d{2}$/\n\nfunction normalizeLocalDate(input: string) {\n  const trimmed = (input || '').trim()\n  if (!DATE_RE.test(trimmed)) return null\n  return trimmed\n}\n\nexport async function POST(request: NextRequest) {\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.id) {\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  }\n\n  let body: any\n  try {\n    body = await request.json()\n  } catch {\n    body = null\n  }\n\n  const date = normalizeLocalDate(body?.date || '')\n  if (!date) {\n    return NextResponse.json({ error: 'Missing or invalid date (YYYY-MM-DD)' }, { status: 400 })\n  }\n\n  const sources: string[] = Array.isArray(body?.sources) ? body.sources : []\n  const wantFitbit = sources.length === 0 || sources.includes('FITBIT')\n  const wantGarmin = sources.length === 0 || sources.includes('GARMIN')\n\n  let created = 0\n  let updated = 0\n  const errors: Array<{ source: string; message: string }> = []\n\n  if (wantFitbit) {\n    try {\n      const fitbitUserId = await getFitbitUserId(session.user.id)\n      if (fitbitUserId) {\n        const resp = await fitbitApiRequest(\n          session.user.id,\n          `/1/user/${fitbitUserId}/activities/list.json?afterDate=${date}&sort=asc&offset=0&limit=100`,\n        )\n        if (resp?.ok) {\n          const payload = await resp.json()\n\n          // Store raw payload for debugging/consistency (daily bucket)\n          await prisma.fitbitData.upsert({\n            where: {\n              userId_date_dataType: {\n                userId: session.user.id,\n                date: new Date(date),\n                dataType: 'activity',\n              },\n            },\n            update: { value: payload, syncedAt: new Date() },\n            create: {\n              userId: session.user.id,\n              date: new Date(date),\n              dataType: 'activity',\n              value: payload,\n            },\n          })\n\n          const workouts = parseFitbitActivitiesToIngest({ date, payload })\n          for (const w of workouts as any[]) {\n            const res = await ingestExerciseEntry({\n              userId: session.user.id,\n              source: 'FITBIT',\n              deviceId: `fitbit:${w.deviceId}`,\n              localDate: date,\n              startTime: w.startTime,\n              durationMinutes: w.durationMinutes,\n              calories: w.calories,\n              label: w.label,\n              rawPayload: w.raw,\n            })\n            if (res.entry) {\n              if (res.created) created += 1\n              else updated += 1\n            }\n          }\n        }\n      }\n    } catch (error: any) {\n      errors.push({ source: 'FITBIT', message: error?.message || 'Fitbit sync failed' })\n    }\n  }\n\n  if (wantGarmin) {\n    try {\n      const hasGarmin = await prisma.account.findFirst({\n        where: { userId: session.user.id, provider: 'garmin' },\n        select: { id: true },\n      })\n\n      if (hasGarmin) {\n        const recent = await prisma.garminWebhookLog.findMany({\n          where: { userId: session.user.id },\n          orderBy: { receivedAt: 'desc' },\n          take: 250,\n        })\n\n        for (const row of recent) {\n          const workouts = extractGarminWorkouts(row.payload)\n          for (const w of workouts) {\n            // Best-effort date filter using startTime in UTC.\n            if (w.startTime) {\n              const d = `${w.startTime.getUTCFullYear()}-${String(w.startTime.getUTCMonth() + 1).padStart(2, '0')}-${String(w.startTime.getUTCDate()).padStart(2, '0')}`\n              if (d !== date) continue\n            }\n\n            const res = await ingestExerciseEntry({\n              userId: session.user.id,\n              source: 'GARMIN',\n              deviceId: `garmin:${w.deviceId}`,\n              localDate: date,\n              startTime: w.startTime,\n              durationMinutes: w.durationMinutes,\n              calories: w.calories,\n              label: w.label,\n              rawPayload: w.raw,\n            })\n            if (res.entry) {\n              if (res.created) created += 1\n              else updated += 1\n            }\n          }\n        }\n      }\n    } catch (error: any) {\n      errors.push({ source: 'GARMIN', message: error?.message || 'Garmin import failed' })\n    }\n  }\n\n  const entries = await prisma.exerciseEntry.findMany({\n    where: { userId: session.user.id, localDate: date },\n    orderBy: [{ startTime: 'asc' }, { createdAt: 'asc' }],\n    include: { exerciseType: true },\n  })\n  const exerciseCalories = entries.reduce((sum, e) => sum + (Number(e.calories) || 0), 0)\n\n  return NextResponse.json({\n    date,\n    created,\n    updated,\n    exerciseCalories,\n    entries,\n    errors,\n  })\n}\n","truncated":false,"size":5153},{"path":"app/api/export/pdf/route.ts","content":"export const dynamic = 'force-dynamic';\n\nimport { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth/next'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\nimport { PDFDocument, StandardFonts, rgb } from 'pdf-lib'\n\nexport async function GET(request: NextRequest) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.email) {\n      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 })\n    }\n\n    const { searchParams } = new URL(request.url)\n    const from = searchParams.get('from')\n    const to = searchParams.get('to')\n    const dateFilter: { gte?: Date; lte?: Date } = {}\n    if (from) dateFilter.gte = new Date(from)\n    if (to) dateFilter.lte = new Date(to)\n\n    const hasRange = !!dateFilter.gte || !!dateFilter.lte\n\n    // Load user and related data (limited for MVP)\n    const user = await prisma.user.findUnique({\n      where: { email: session.user.email },\n      include: {\n        healthGoals: true,\n        supplements: true,\n        medications: true,\n        healthLogs: hasRange ? { where: { createdAt: dateFilter } } : true,\n        foodLogs: hasRange ? { where: { createdAt: dateFilter } } : true,\n        exerciseLogs: hasRange ? { where: { createdAt: dateFilter } } : true,\n      },\n    })\n\n    if (!user) {\n      return NextResponse.json({ error: 'User not found' }, { status: 404 })\n    }\n\n    // Build PDF in-memory using pdf-lib (serverless friendly)\n    const fmt = (d?: Date | string | null) => (d ? new Date(d).toLocaleString() : '')\n    const dateRangeText = hasRange\n      ? `${dateFilter.gte ? fmt(dateFilter.gte) : '‚Ä¶'} ‚Üí ${dateFilter.lte ? fmt(dateFilter.lte) : '‚Ä¶'}`\n      : 'All time'\n\n    const doc = await PDFDocument.create()\n    let page = doc.addPage([595.28, 841.89]) // A4 in points\n    const font = await doc.embedFont(StandardFonts.Helvetica)\n    const fontBold = await doc.embedFont(StandardFonts.HelveticaBold)\n    const margin = 40\n    let cursorY = page.getHeight() - margin\n\n    const newPage = () => {\n      page = doc.addPage([595.28, 841.89])\n      cursorY = page.getHeight() - margin\n    }\n\n    const drawText = (text: string, size = 12, bold = false, color = rgb(0.07, 0.09, 0.15)) => {\n      const lines = wrapText(text, bold ? fontBold : font, size, page.getWidth() - margin * 2)\n      lines.forEach((line) => {\n        if (cursorY < margin + 20) { newPage() }\n        page.drawText(line, { x: margin, y: cursorY, size, font: bold ? fontBold : font, color })\n        cursorY -= size + 4\n      })\n    }\n\n    const h1 = (t: string) => { drawText(t, 18, true, rgb(0.02, 0.59, 0.41)); cursorY -= 4 }\n    const h2 = (t: string) => { cursorY -= 6; drawText(t, 14, true, rgb(0.04, 0.37, 0.28)); cursorY -= 2 }\n\n    const wrapText = (text: string, f: any, size: number, maxWidth: number): string[] => {\n      const words = String(text || '').split(/\\s+/)\n      const lines: string[] = []\n      let line = ''\n      words.forEach(w => {\n        const test = line ? line + ' ' + w : w\n        const width = f.widthOfTextAtSize(test, size)\n        if (width > maxWidth && line) { lines.push(line); line = w } else { line = test }\n      })\n      if (line) lines.push(line)\n      return lines\n    }\n\n    h1('Helfi ‚Äî Your Health Summary')\n    drawText(`Generated for ${user.email} ‚Ä¢ Range: ${dateRangeText}`, 10, false, rgb(0.45,0.47,0.50))\n\n    h2('Profile')\n    drawText(`Name: ${user.name || ''}`)\n    drawText(`Gender: ${user.gender || ''}`)\n    drawText(`Height: ${user.height ?? ''}`)\n    drawText(`Weight: ${user.weight ?? ''}`)\n    drawText(`Body Type: ${user.bodyType || ''}`)\n\n    h2('Goals')\n    ;(user.healthGoals || [])\n      .filter((g:any)=> typeof g.name === 'string' && !g.name.startsWith('__'))\n      .slice(0, 12)\n      .forEach((g:any)=> drawText(`‚Ä¢ ${g.name}${g.category?` (${g.category})`:''}${Number.isFinite(g.currentRating)?` ‚Äî rating ${g.currentRating}`:''}`))\n\n    h2('Medications & Supplements')\n    ;(user.medications || []).slice(0, 12).forEach((m:any)=> drawText(`‚Ä¢ Medication: ${m.name || ''}${m.dosage?` ‚Äî ${m.dosage}`:''}${(m.timing&&m.timing.length)?` ‚Äî ${(m.timing||[]).join(', ')}`:''}`))\n    ;(user.supplements || []).slice(0, 12).forEach((s:any)=> drawText(`‚Ä¢ Supplement: ${s.name || ''}${s.dosage?` ‚Äî ${s.dosage}`:''}${(s.timing&&s.timing.length)?` ‚Äî ${(s.timing||[]).join(', ')}`:''}`))\n\n    h2('Daily Metrics (Health Logs)')\n    ;(user.healthLogs || [])\n      .sort((a:any,b:any)=> new Date(b.createdAt).getTime()-new Date(a.createdAt).getTime())\n      .slice(0, 15)\n      .forEach((h:any)=> drawText(`${fmt(h.createdAt)} ‚Äî rating ${h.rating}${(h.notes && typeof h.notes==='string' && h.notes.length<120)?` ‚Äî ${h.notes}`:''}`))\n\n    h2('Food Diary (Highlights)')\n    ;(user.foodLogs || [])\n      .sort((a:any,b:any)=> new Date(b.createdAt).getTime()-new Date(a.createdAt).getTime())\n      .slice(0, 15)\n      .forEach((f:any)=> {\n        const cal = f?.nutrients && (f.nutrients as any).calories\n        drawText(`${fmt(f.createdAt)} ‚Äî ${f.name || 'Food'}${Number.isFinite(cal)?` ‚Äî ${cal} kcal`:''}`)\n      })\n\n    h2('Activity')\n    const ex = (user.exerciseLogs || [])\n      .sort((a:any,b:any)=> new Date(b.createdAt).getTime()-new Date(a.createdAt).getTime())\n      .slice(0, 15)\n    if (ex.length === 0) {\n      drawText('No activity logged in this period.')\n    } else {\n      ex.forEach((e:any)=> drawText(`${fmt(e.createdAt)} ‚Äî ${e.type || 'Activity'}${Number.isFinite(e.duration)?` ‚Äî ${e.duration} min`:''}${e.intensity?` ‚Äî ${e.intensity}`:''}`))\n    }\n\n    const pdfBuffer = await doc.save()\n\n    return new NextResponse(pdfBuffer, {\n      status: 200,\n      headers: {\n        'Content-Type': 'application/pdf',\n        'Content-Disposition': `attachment; filename=\"helfi-health-summary.pdf\"`\n      }\n    })\n  } catch (e: any) {\n    console.error('PDF export failed:', e)\n    return NextResponse.json({ error: 'Export failed' }, { status: 500 })\n  }\n}\n\n","truncated":false,"size":6013},{"path":"app/api/fitbit/data/route.ts","content":"export const dynamic = 'force-dynamic';\n\nimport { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\nimport { ensureFitbitDataSchema } from '@/lib/fitbit-db'\n\ntype DataType = 'steps' | 'heartrate' | 'sleep' | 'weight'\n\nfunction parseDate(input: string | null): Date | null {\n  if (!input) return null\n  // Expecting YYYY-MM-DD\n  const [y, m, d] = input.split('-').map((v) => parseInt(v, 10))\n  if (!y || !m || !d) return null\n  const dt = new Date(Date.UTC(y, (m || 1) - 1, d || 1))\n  return isNaN(dt.getTime()) ? null : dt\n}\n\nfunction formatYmd(d: Date): string {\n  const y = d.getUTCFullYear()\n  const m = String(d.getUTCMonth() + 1).padStart(2, '0')\n  const day = String(d.getUTCDate()).padStart(2, '0')\n  return `${y}-${m}-${day}`\n}\n\n/**\n * Get aggregated Fitbit data for a date range.\n * GET /api/fitbit/data?start=YYYY-MM-DD&end=YYYY-MM-DD&dataTypes=steps,heartrate,sleep,weight\n * Defaults: last 30 days, all data types.\n *\n * Response:\n * {\n *   success: true,\n *   range: { start: 'YYYY-MM-DD', end: 'YYYY-MM-DD' },\n *   series: {\n *     steps: [{ date: 'YYYY-MM-DD', steps: number, calories?: number, distanceKm?: number }],\n *     heartrate: [{ date: 'YYYY-MM-DD', restingHeartRate?: number, zones?: any }],\n *     sleep: [{ date: 'YYYY-MM-DD', minutes?: number, efficiency?: number, stages?: any }],\n *     weight: [{ date: 'YYYY-MM-DD', weightKg?: number }]\n *   }\n * }\n */\nexport async function GET(request: NextRequest) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const searchParams = request.nextUrl.searchParams\n    const dataTypesParam = (searchParams.get('dataTypes') || '').trim()\n    const requestedTypes = dataTypesParam\n      ? dataTypesParam.split(',').map((s) => s.trim().toLowerCase()) as DataType[]\n      : (['steps', 'heartrate', 'sleep', 'weight'] as DataType[])\n\n    const endParam = parseDate(searchParams.get('end'))\n    const startParam = parseDate(searchParams.get('start'))\n\n    // Default to last 30 days if not supplied\n    const endDate = endParam || new Date()\n    const startDate =\n      startParam ||\n      new Date(Date.UTC(endDate.getUTCFullYear(), endDate.getUTCMonth(), endDate.getUTCDate() - 29))\n\n    // Build inclusive window\n    const start = new Date(Date.UTC(startDate.getUTCFullYear(), startDate.getUTCMonth(), startDate.getUTCDate()))\n    const end = new Date(Date.UTC(endDate.getUTCFullYear(), endDate.getUTCMonth(), endDate.getUTCDate()))\n\n    let data\n    try {\n      data = await prisma.fitbitData.findMany({\n        where: {\n          userId: session.user.id,\n          date: { gte: start, lte: end },\n          dataType: { in: requestedTypes },\n        },\n        orderBy: [{ date: 'asc' }, { dataType: 'asc' }],\n      })\n    } catch (dbError: any) {\n      // If table doesn't exist, create it and retry\n      if (dbError?.code === 'P2021' || dbError?.message?.includes('does not exist') || dbError?.message?.includes('relation')) {\n        console.log('FitbitData table not found, creating it...')\n        await ensureFitbitDataSchema()\n        // Retry the query\n        data = await prisma.fitbitData.findMany({\n          where: {\n            userId: session.user.id,\n            date: { gte: start, lte: end },\n            dataType: { in: requestedTypes },\n          },\n          orderBy: [{ date: 'asc' }, { dataType: 'asc' }],\n        })\n      } else {\n        throw dbError\n      }\n    }\n\n    // Initialize series scaffolding by date\n    const series: {\n      steps: Array<{ date: string; steps?: number; calories?: number; distanceKm?: number }>\n      heartrate: Array<{ date: string; restingHeartRate?: number; zones?: any }>\n      sleep: Array<{ date: string; minutes?: number; efficiency?: number; stages?: any }>\n      weight: Array<{ date: string; weightKg?: number }>\n    } = { steps: [], heartrate: [], sleep: [], weight: [] }\n\n    // Map to quick lookup by date+type\n    const byKey = new Map<string, any>()\n    data.forEach((row) => {\n      try {\n        // Ensure row.date is a Date object\n        const dateObj = row.date instanceof Date ? row.date : new Date(row.date)\n        const key = `${formatYmd(dateObj)}|${row.dataType}`\n        byKey.set(key, row.value)\n      } catch (dateError) {\n        console.error('‚ùå Error processing row date:', dateError, 'Row:', row)\n        // Skip malformed rows\n      }\n    })\n\n    // Walk the range and extract values per day\n    const cursor = new Date(start)\n    while (cursor <= end) {\n      const ymd = formatYmd(cursor)\n\n      if (requestedTypes.includes('steps')) {\n        const val = byKey.get(`${ymd}|steps`)\n        // Steps can come from activities summary or daily totals\n        let steps: number | undefined\n        let calories: number | undefined\n        let distanceKm: number | undefined\n        if (val?.steps != null) steps = Number(val.steps)\n        if (val?.summary?.steps != null) steps = Number(val.summary.steps)\n        if (val?.summary?.caloriesOut != null) calories = Number(val.summary.caloriesOut)\n        const distArray = val?.summary?.distances\n        if (Array.isArray(distArray)) {\n          const total = distArray.find((d: any) => d.activity === 'total')\n          distanceKm = total ? Number(total.distance) : undefined\n        }\n        series.steps.push({ date: ymd, steps, calories, distanceKm })\n      }\n\n      if (requestedTypes.includes('heartrate')) {\n        const val = byKey.get(`${ymd}|heartrate`)\n        let restingHeartRate: number | undefined\n        let zones: any\n        if (Array.isArray(val?.['activities-heart'])) {\n          const day = val['activities-heart'][0]\n          restingHeartRate = day?.value?.restingHeartRate\n          zones = day?.value?.heartRateZones\n        }\n        series.heartrate.push({ date: ymd, restingHeartRate, zones })\n      }\n\n      if (requestedTypes.includes('sleep')) {\n        const val = byKey.get(`${ymd}|sleep`)\n        // Fitbit sleep endpoint returns arrays; aggregate minutes\n        let minutes: number | undefined\n        let efficiency: number | undefined\n        let stages: any\n        if (Array.isArray(val?.sleep) && val.sleep.length > 0) {\n          minutes = val.sleep.reduce((sum: number, s: any) => sum + (s.minutesAsleep || s.duration / 60000 || 0), 0)\n          // pick the first for efficiency if present\n          efficiency = val.sleep[0]?.efficiency\n          stages = val.summary?.stages || undefined\n        }\n        series.sleep.push({ date: ymd, minutes, efficiency, stages })\n      }\n\n      if (requestedTypes.includes('weight')) {\n        const val = byKey.get(`${ymd}|weight`)\n        // Weight logs array; use latest entry of the day if exists\n        let weightKg: number | undefined\n        const logs = Array.isArray(val?.weight) ? val.weight : []\n        if (logs.length > 0) {\n          const last = logs[logs.length - 1]\n          weightKg = last?.weight\n        }\n        series.weight.push({ date: ymd, weightKg })\n      }\n\n      cursor.setUTCDate(cursor.getUTCDate() + 1)\n    }\n\n    return NextResponse.json({\n      success: true,\n      range: { start: formatYmd(start), end: formatYmd(end) },\n      series,\n    })\n  } catch (error: any) {\n    console.error('‚ùå Fitbit data range error:', error)\n    console.error('Error message:', error?.message)\n    console.error('Error stack:', error?.stack)\n    console.error('Error code:', error?.code)\n    console.error('Error name:', error?.name)\n    \n    // Try to create table if it's a missing table error\n    if (error?.code === 'P2021' || error?.message?.includes('does not exist') || error?.message?.includes('relation') || error?.message?.includes('table')) {\n      try {\n        console.log('Attempting to create FitbitData table...')\n        await ensureFitbitDataSchema()\n        // Return empty data instead of error - table will be ready for next request\n        // Parse dates from request params again since they're not in scope\n        const searchParams = request.nextUrl.searchParams\n        const endParam = parseDate(searchParams.get('end'))\n        const startParam = parseDate(searchParams.get('start'))\n        const endDate = endParam || new Date()\n        const startDate = startParam || new Date(Date.UTC(endDate.getUTCFullYear(), endDate.getUTCMonth(), endDate.getUTCDate() - 29))\n        return NextResponse.json({\n          success: true,\n          range: { start: formatYmd(startDate), end: formatYmd(endDate) },\n          series: { steps: [], heartrate: [], sleep: [], weight: [] },\n        })\n      } catch (schemaError: any) {\n        console.error('‚ùå Failed to create FitbitData schema:', schemaError)\n        return NextResponse.json(\n          { \n            error: 'Failed to load Fitbit data',\n            details: `Schema creation failed: ${schemaError?.message || 'Unknown error'}`\n          }, \n          { status: 500 }\n        )\n      }\n    }\n    \n    const errorMessage = error?.message || 'Unknown error'\n    const errorDetails = process.env.NODE_ENV === 'development' \n      ? `${errorMessage} (Code: ${error?.code || 'no code'})`\n      : 'Failed to load Fitbit data'\n    \n    return NextResponse.json(\n      { \n        error: 'Failed to load Fitbit data',\n        details: errorDetails\n      }, \n      { status: 500 }\n    )\n  }\n}\n\n","truncated":false,"size":9435},{"path":"app/api/fitbit/demo/seed/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\nimport { extractAdminFromHeaders } from '@/lib/admin-auth'\nimport { ensureFitbitDataSchema } from '@/lib/fitbit-db'\n\n/**\n * Seed demo Fitbit data for testing\n * POST /api/fitbit/demo/seed\n * Requires admin authentication\n */\nexport async function POST(request: NextRequest) {\n  try {\n    // Ensure FitbitData schema exists (idempotent)\n    await ensureFitbitDataSchema()\n\n    // Check admin authentication\n    const authHeader = request.headers.get('authorization')\n    const admin = extractAdminFromHeaders(authHeader)\n    \n    if (!admin) {\n      return NextResponse.json(\n        { error: 'Unauthorized - Admin access required' },\n        { status: 401 }\n      )\n    }\n\n    // Get current user session\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) {\n      return NextResponse.json(\n        { error: 'User session required' },\n        { status: 401 }\n      )\n    }\n\n    const userId = session.user.id\n\n    // Check if user already has Fitbit account connected\n    const existingAccount = await prisma.account.findFirst({\n      where: {\n        userId,\n        provider: 'fitbit',\n      },\n    })\n\n    // If no Fitbit account exists, create a demo one\n    if (!existingAccount) {\n      try {\n        await prisma.account.create({\n          data: {\n            userId,\n            type: 'oauth',\n            provider: 'fitbit',\n            providerAccountId: 'demo-user-' + userId.substring(0, 8),\n            access_token: 'demo-token',\n            refresh_token: 'demo-refresh-token',\n            expires_at: Math.floor(Date.now() / 1000) + 86400 * 365, // 1 year from now\n            token_type: 'Bearer',\n            scope: 'activity heartrate sleep profile weight',\n          },\n        })\n      } catch (accountError: any) {\n        console.error('‚ùå Error creating demo Fitbit account:', accountError)\n        // If account creation fails but it's a unique constraint error, continue\n        // (account might have been created between check and create)\n        if (!accountError?.code?.includes('P2002')) {\n          throw accountError\n        }\n      }\n    }\n\n    // Generate 30 days of demo data\n    const today = new Date()\n    today.setHours(0, 0, 0, 0) // Normalize today to midnight\n    const dataTypes = ['steps', 'heartrate', 'sleep', 'weight']\n    const created: string[] = []\n\n    for (let i = 0; i < 30; i++) {\n      const date = new Date(today)\n      date.setDate(date.getDate() - i)\n      const dateStr = date.toISOString().split('T')[0]\n      const dateForDb = new Date(dateStr + 'T00:00:00.000Z') // Ensure UTC midnight\n      \n      try {\n\n      // Steps data - varies between 5000-15000 steps\n      const steps = Math.floor(Math.random() * 10000) + 5000\n      await prisma.fitbitData.upsert({\n        where: {\n          userId_date_dataType: {\n            userId,\n            date: dateForDb,\n            dataType: 'steps',\n          },\n        },\n        update: {\n          value: {\n            summary: {\n              steps: steps,\n              'caloriesOut': Math.floor(steps * 0.04),\n              'distance': [\n                { activity: 'total', distance: Math.round((steps * 0.0008) * 100) / 100 }\n              ],\n              'floors': Math.floor(steps / 200),\n              'elevation': Math.floor(steps / 100),\n            },\n          },\n          syncedAt: new Date(),\n        },\n        create: {\n          userId,\n          date: dateForDb,\n          dataType: 'steps',\n          value: {\n            summary: {\n              steps: steps,\n              'caloriesOut': Math.floor(steps * 0.04),\n              'distance': [\n                { activity: 'total', distance: Math.round((steps * 0.0008) * 100) / 100 }\n              ],\n              'floors': Math.floor(steps / 200),\n              'elevation': Math.floor(steps / 100),\n            },\n          },\n        },\n      })\n      created.push(`steps-${dateStr}`)\n\n      // Heart rate data - resting HR between 55-75 bpm\n      const restingHR = Math.floor(Math.random() * 20) + 55\n      await prisma.fitbitData.upsert({\n        where: {\n          userId_date_dataType: {\n            userId,\n            date: dateForDb,\n            dataType: 'heartrate',\n          },\n        },\n        update: {\n          value: {\n            'activities-heart': [\n              {\n                dateTime: dateStr,\n                value: {\n                  restingHeartRate: restingHR,\n                  heartRateZones: [\n                    { name: 'Out of Range', min: 30, max: 102, minutes: Math.floor(Math.random() * 200) + 400 },\n                    { name: 'Fat Burn', min: 102, max: 138, minutes: Math.floor(Math.random() * 60) + 20 },\n                    { name: 'Cardio', min: 138, max: 170, minutes: Math.floor(Math.random() * 30) },\n                    { name: 'Peak', min: 170, max: 220, minutes: Math.floor(Math.random() * 10) },\n                  ],\n                },\n              },\n            ],\n          },\n          syncedAt: new Date(),\n        },\n        create: {\n          userId,\n          date: dateForDb,\n          dataType: 'heartrate',\n          value: {\n            'activities-heart': [\n              {\n                dateTime: dateStr,\n                value: {\n                  restingHeartRate: restingHR,\n                  heartRateZones: [\n                    { name: 'Out of Range', min: 30, max: 102, minutes: Math.floor(Math.random() * 200) + 400 },\n                    { name: 'Fat Burn', min: 102, max: 138, minutes: Math.floor(Math.random() * 60) + 20 },\n                    { name: 'Cardio', min: 138, max: 170, minutes: Math.floor(Math.random() * 30) },\n                    { name: 'Peak', min: 170, max: 220, minutes: Math.floor(Math.random() * 10) },\n                  ],\n                },\n              },\n            ],\n          },\n        },\n      })\n      created.push(`heartrate-${dateStr}`)\n\n      // Sleep data - 6-9 hours of sleep\n      const sleepMinutes = Math.floor(Math.random() * 180) + 360 // 6-9 hours\n      const sleepStart = new Date(date)\n      sleepStart.setHours(22 + Math.floor(Math.random() * 2), Math.floor(Math.random() * 60), 0)\n      const sleepEnd = new Date(sleepStart)\n      sleepEnd.setMinutes(sleepEnd.getMinutes() + sleepMinutes)\n\n      await prisma.fitbitData.upsert({\n        where: {\n          userId_date_dataType: {\n            userId,\n            date: dateForDb,\n            dataType: 'sleep',\n          },\n        },\n        update: {\n          value: {\n            sleep: [\n              {\n                dateOfSleep: dateStr,\n                duration: sleepMinutes * 60000, // milliseconds\n                efficiency: Math.floor(Math.random() * 15) + 85, // 85-100%\n                minutesAsleep: sleepMinutes - Math.floor(Math.random() * 30),\n                minutesAwake: Math.floor(Math.random() * 30),\n                startTime: sleepStart.toISOString(),\n                endTime: sleepEnd.toISOString(),\n                timeInBed: sleepMinutes,\n                type: 'stages',\n                levels: {\n                  summary: {\n                    deep: { minutes: Math.floor(sleepMinutes * 0.2), thirtyDayAvgMinutes: Math.floor(sleepMinutes * 0.2) },\n                    light: { minutes: Math.floor(sleepMinutes * 0.5), thirtyDayAvgMinutes: Math.floor(sleepMinutes * 0.5) },\n                    rem: { minutes: Math.floor(sleepMinutes * 0.2), thirtyDayAvgMinutes: Math.floor(sleepMinutes * 0.2) },\n                    wake: { minutes: Math.floor(sleepMinutes * 0.1), thirtyDayAvgMinutes: Math.floor(sleepMinutes * 0.1) },\n                  },\n                },\n              },\n            ],\n            summary: {\n              totalSleepRecords: 1,\n              totalMinutesAsleep: sleepMinutes,\n              totalTimeInBed: sleepMinutes,\n            },\n          },\n          syncedAt: new Date(),\n        },\n        create: {\n          userId,\n          date: dateForDb,\n          dataType: 'sleep',\n          value: {\n            sleep: [\n              {\n                dateOfSleep: dateStr,\n                duration: sleepMinutes * 60000,\n                efficiency: Math.floor(Math.random() * 15) + 85,\n                minutesAsleep: sleepMinutes - Math.floor(Math.random() * 30),\n                minutesAwake: Math.floor(Math.random() * 30),\n                startTime: sleepStart.toISOString(),\n                endTime: sleepEnd.toISOString(),\n                timeInBed: sleepMinutes,\n                type: 'stages',\n                levels: {\n                  summary: {\n                    deep: { minutes: Math.floor(sleepMinutes * 0.2), thirtyDayAvgMinutes: Math.floor(sleepMinutes * 0.2) },\n                    light: { minutes: Math.floor(sleepMinutes * 0.5), thirtyDayAvgMinutes: Math.floor(sleepMinutes * 0.5) },\n                    rem: { minutes: Math.floor(sleepMinutes * 0.2), thirtyDayAvgMinutes: Math.floor(sleepMinutes * 0.2) },\n                    wake: { minutes: Math.floor(sleepMinutes * 0.1), thirtyDayAvgMinutes: Math.floor(sleepMinutes * 0.1) },\n                  },\n                },\n              },\n            ],\n            summary: {\n              totalSleepRecords: 1,\n              totalMinutesAsleep: sleepMinutes,\n              totalTimeInBed: sleepMinutes,\n            },\n          },\n        },\n      })\n      created.push(`sleep-${dateStr}`)\n\n      // Weight data - varies slightly around 70kg (154 lbs)\n      if (i % 2 === 0) { // Every other day\n        const weight = Math.round((70 + (Math.random() * 2 - 1)) * 10) / 10 // 69-71 kg\n        await prisma.fitbitData.upsert({\n          where: {\n            userId_date_dataType: {\n              userId,\n              date: dateForDb,\n              dataType: 'weight',\n            },\n          },\n          update: {\n            value: {\n              weight: [\n                {\n                  bmi: Math.round((weight / (1.75 * 1.75)) * 10) / 10,\n                  date: dateStr,\n                  logId: Date.now(),\n                  time: '08:00:00',\n                  weight: weight,\n                  source: 'API',\n                },\n              ],\n            },\n            syncedAt: new Date(),\n          },\n          create: {\n            userId,\n            date: dateForDb,\n            dataType: 'weight',\n            value: {\n              weight: [\n                {\n                  bmi: Math.round((weight / (1.75 * 1.75)) * 10) / 10,\n                  date: dateStr,\n                  logId: Date.now(),\n                  time: '08:00:00',\n                  weight: weight,\n                  source: 'API',\n                },\n              ],\n            },\n          },\n        })\n        created.push(`weight-${dateStr}`)\n      }\n      } catch (dayError: any) {\n        console.error(`‚ùå Error creating demo data for date ${dateStr}:`, dayError)\n        // Continue with other days even if one fails\n        // But log the error for debugging\n        throw new Error(`Failed to create demo data for ${dateStr}: ${dayError?.message || 'Unknown error'}`)\n      }\n    }\n\n    return NextResponse.json({\n      success: true,\n      message: `Demo data seeded successfully - ${created.length} records created`,\n      recordsCreated: created.length,\n      dateRange: {\n        start: new Date(today.getTime() - 29 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],\n        end: today.toISOString().split('T')[0],\n      },\n    })\n  } catch (error: any) {\n    console.error('‚ùå Error seeding demo Fitbit data:', error)\n    const errorMessage = error?.message || 'Unknown error'\n    const errorCode = error?.code || 'UNKNOWN'\n    const errorDetails = error?.stack || String(error)\n    console.error('Error code:', errorCode)\n    console.error('Error message:', errorMessage)\n    console.error('Error details:', errorDetails)\n    \n    // Return detailed error in development, generic in production\n    const details = process.env.NODE_ENV === 'development' \n      ? `${errorMessage} (Code: ${errorCode})`\n      : errorMessage.includes('Unique constraint') \n        ? 'Data already exists. Try clearing demo data first.'\n        : 'Failed to seed demo data'\n    \n    return NextResponse.json(\n      { \n        error: 'Failed to seed demo data',\n        details\n      },\n      { status: 500 }\n    )\n  }\n}\n\n/**\n * Clear demo Fitbit data\n * DELETE /api/fitbit/demo/seed\n * Requires admin authentication\n */\nexport async function DELETE(request: NextRequest) {\n  try {\n    // Ensure FitbitData schema exists (idempotent)\n    await ensureFitbitDataSchema()\n\n    // Check admin authentication\n    const authHeader = request.headers.get('authorization')\n    const admin = extractAdminFromHeaders(authHeader)\n    \n    if (!admin) {\n      return NextResponse.json(\n        { error: 'Unauthorized - Admin access required' },\n        { status: 401 }\n      )\n    }\n\n    // Get current user session\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) {\n      return NextResponse.json(\n        { error: 'User session required' },\n        { status: 401 }\n      )\n    }\n\n    const userId = session.user.id\n\n    // Delete all Fitbit data for this user\n    const deleted = await prisma.fitbitData.deleteMany({\n      where: { userId },\n    })\n\n    // Optionally delete the demo Fitbit account\n    const demoAccount = await prisma.account.findFirst({\n      where: {\n        userId,\n        provider: 'fitbit',\n        providerAccountId: { startsWith: 'demo-user-' },\n      },\n    })\n\n    if (demoAccount) {\n      await prisma.account.delete({\n        where: { id: demoAccount.id },\n      })\n    }\n\n    return NextResponse.json({\n      success: true,\n      message: 'Demo data cleared successfully',\n      recordsDeleted: deleted.count,\n      accountDeleted: !!demoAccount,\n    })\n  } catch (error) {\n    console.error('Error clearing demo Fitbit data:', error)\n    return NextResponse.json(\n      { error: 'Failed to clear demo data' },\n      { status: 500 }\n    )\n  }\n}\n","truncated":false,"size":14105},{"path":"app/api/fitbit/status/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\n\n/**\n * Check Fitbit connection status\n * GET /api/fitbit/status\n */\nexport async function GET(request: NextRequest) {\n  try {\n    const session = await getServerSession(authOptions)\n    \n    if (!session?.user?.id) {\n      return NextResponse.json(\n        { error: 'Unauthorized' },\n        { status: 401 }\n      )\n    }\n\n    const fitbitAccount = await prisma.account.findFirst({\n      where: {\n        userId: session.user.id,\n        provider: 'fitbit',\n      },\n    })\n\n    return NextResponse.json({\n      connected: !!fitbitAccount,\n      fitbitUserId: fitbitAccount?.providerAccountId || null,\n    })\n  } catch (error) {\n    console.error('‚ùå Error checking Fitbit status:', error)\n    return NextResponse.json(\n      { error: 'Failed to check Fitbit status' },\n      { status: 500 }\n    )\n  }\n}\n\n/**\n * Disconnect Fitbit account\n * DELETE /api/fitbit/disconnect\n */\nexport async function DELETE(request: NextRequest) {\n  try {\n    const session = await getServerSession(authOptions)\n    \n    if (!session?.user?.id) {\n      return NextResponse.json(\n        { error: 'Unauthorized' },\n        { status: 401 }\n      )\n    }\n\n    // Delete Fitbit account\n    await prisma.account.deleteMany({\n      where: {\n        userId: session.user.id,\n        provider: 'fitbit',\n      },\n    })\n\n    // Optionally delete synced Fitbit data\n    await prisma.fitbitData.deleteMany({\n      where: {\n        userId: session.user.id,\n      },\n    })\n\n    return NextResponse.json({\n      success: true,\n      message: 'Fitbit account disconnected',\n    })\n  } catch (error) {\n    console.error('‚ùå Error disconnecting Fitbit:', error)\n    return NextResponse.json(\n      { error: 'Failed to disconnect Fitbit account' },\n      { status: 500 }\n    )\n  }\n}\n\n","truncated":false,"size":1931},{"path":"app/api/fitbit/sync/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\nimport { fitbitApiRequest, getFitbitUserId } from '@/lib/fitbit-api'\nimport { ingestExerciseEntry } from '@/lib/exercise/ingest'\nimport { parseFitbitActivitiesToIngest } from '@/lib/exercise/fitbit-workouts'\n\n/**\n * Sync Fitbit data for the authenticated user\n * POST /api/fitbit/sync\n */\nexport async function POST(request: NextRequest) {\n  try {\n    const session = await getServerSession(authOptions)\n    \n    if (!session?.user?.id) {\n      return NextResponse.json(\n        { error: 'Unauthorized' },\n        { status: 401 }\n      )\n    }\n\n    const fitbitUserId = await getFitbitUserId(session.user.id)\n    if (!fitbitUserId) {\n      return NextResponse.json(\n        { error: 'Fitbit account not connected' },\n        { status: 400 }\n      )\n    }\n\n    const body = await request.json()\n    const date = body.date || new Date().toISOString().split('T')[0] // Default to today\n    const dataTypes = body.dataTypes || ['steps', 'heartrate', 'sleep', 'weight'] // Default to all\n\n    const syncedData: any = {}\n\n    // Sync steps\n    if (dataTypes.includes('steps')) {\n      const stepsResponse = await fitbitApiRequest(\n        session.user.id,\n        `/1/user/${fitbitUserId}/activities/date/${date}.json`\n      )\n\n      if (stepsResponse?.ok) {\n        const stepsData = await stepsResponse.json()\n        await prisma.fitbitData.upsert({\n          where: {\n            userId_date_dataType: {\n              userId: session.user.id,\n              date: new Date(date),\n              dataType: 'steps',\n            },\n          },\n          update: {\n            value: stepsData.summary || stepsData,\n            syncedAt: new Date(),\n          },\n          create: {\n            userId: session.user.id,\n            date: new Date(date),\n            dataType: 'steps',\n            value: stepsData.summary || stepsData,\n          },\n        })\n        syncedData.steps = stepsData.summary || stepsData\n      }\n    }\n\n    // Sync heart rate\n    if (dataTypes.includes('heartrate')) {\n      const hrResponse = await fitbitApiRequest(\n        session.user.id,\n        `/1/user/${fitbitUserId}/activities/heart/date/${date}/1d.json`\n      )\n\n      if (hrResponse?.ok) {\n        const hrData = await hrResponse.json()\n        await prisma.fitbitData.upsert({\n          where: {\n            userId_date_dataType: {\n              userId: session.user.id,\n              date: new Date(date),\n              dataType: 'heartrate',\n            },\n          },\n          update: {\n            value: hrData,\n            syncedAt: new Date(),\n          },\n          create: {\n            userId: session.user.id,\n            date: new Date(date),\n            dataType: 'heartrate',\n            value: hrData,\n          },\n        })\n        syncedData.heartrate = hrData\n      }\n    }\n\n    // Sync sleep\n    if (dataTypes.includes('sleep')) {\n      const sleepResponse = await fitbitApiRequest(\n        session.user.id,\n        `/1.2/user/${fitbitUserId}/sleep/date/${date}.json`\n      )\n\n      if (sleepResponse?.ok) {\n        const sleepData = await sleepResponse.json()\n        await prisma.fitbitData.upsert({\n          where: {\n            userId_date_dataType: {\n              userId: session.user.id,\n              date: new Date(date),\n              dataType: 'sleep',\n            },\n          },\n          update: {\n            value: sleepData,\n            syncedAt: new Date(),\n          },\n          create: {\n            userId: session.user.id,\n            date: new Date(date),\n            dataType: 'sleep',\n            value: sleepData,\n          },\n        })\n        syncedData.sleep = sleepData\n      }\n    }\n\n    // Sync weight\n    if (dataTypes.includes('weight')) {\n      const weightResponse = await fitbitApiRequest(\n        session.user.id,\n        `/1/user/${fitbitUserId}/body/log/weight/date/${date}.json`\n      )\n\n      if (weightResponse?.ok) {\n        const weightData = await weightResponse.json()\n        await prisma.fitbitData.upsert({\n          where: {\n            userId_date_dataType: {\n              userId: session.user.id,\n              date: new Date(date),\n              dataType: 'weight',\n            },\n          },\n          update: {\n            value: weightData,\n            syncedAt: new Date(),\n          },\n          create: {\n            userId: session.user.id,\n            date: new Date(date),\n            dataType: 'weight',\n            value: weightData,\n          },\n        })\n        syncedData.weight = weightData\n      }\n    }\n\n    // Sync activity/workouts (and ingest into Food Diary exercise log)\n    if (dataTypes.includes('activity')) {\n      const activityResponse = await fitbitApiRequest(\n        session.user.id,\n        `/1/user/${fitbitUserId}/activities/list.json?afterDate=${date}&sort=asc&offset=0&limit=100`\n      )\n\n      if (activityResponse?.ok) {\n        const activityData = await activityResponse.json()\n        await prisma.fitbitData.upsert({\n          where: {\n            userId_date_dataType: {\n              userId: session.user.id,\n              date: new Date(date),\n              dataType: 'activity',\n            },\n          },\n          update: {\n            value: activityData,\n            syncedAt: new Date(),\n          },\n          create: {\n            userId: session.user.id,\n            date: new Date(date),\n            dataType: 'activity',\n            value: activityData,\n          },\n        })\n        syncedData.activity = activityData\n\n        const workouts = parseFitbitActivitiesToIngest({ date, payload: activityData })\n        for (const w of workouts as any[]) {\n          await ingestExerciseEntry({\n            userId: session.user.id,\n            source: 'FITBIT',\n            deviceId: `fitbit:${w.deviceId}`,\n            localDate: date,\n            startTime: w.startTime,\n            durationMinutes: w.durationMinutes,\n            calories: w.calories,\n            label: w.label,\n            rawPayload: w.raw,\n          })\n        }\n      }\n    }\n\n    return NextResponse.json({\n      success: true,\n      synced: syncedData,\n      date,\n    })\n  } catch (error) {\n    console.error('‚ùå Fitbit sync error:', error)\n    return NextResponse.json(\n      { error: 'Failed to sync Fitbit data' },\n      { status: 500 }\n    )\n  }\n}\n\n/**\n * Get synced Fitbit data for the authenticated user\n * GET /api/fitbit/data\n */\nexport async function GET(request: NextRequest) {\n  try {\n    const session = await getServerSession(authOptions)\n    \n    if (!session?.user?.id) {\n      return NextResponse.json(\n        { error: 'Unauthorized' },\n        { status: 401 }\n      )\n    }\n\n    const searchParams = request.nextUrl.searchParams\n    const date = searchParams.get('date') || new Date().toISOString().split('T')[0]\n    const dataType = searchParams.get('dataType') // Optional filter\n\n    const where: any = {\n      userId: session.user.id,\n      date: new Date(date),\n    }\n\n    if (dataType) {\n      where.dataType = dataType\n    }\n\n    const data = await prisma.fitbitData.findMany({\n      where,\n      orderBy: {\n        syncedAt: 'desc',\n      },\n    })\n\n    return NextResponse.json({\n      success: true,\n      data,\n      date,\n    })\n  } catch (error) {\n    console.error('‚ùå Error fetching Fitbit data:', error)\n    return NextResponse.json(\n      { error: 'Failed to fetch Fitbit data' },\n      { status: 500 }\n    )\n  }\n}\n","truncated":false,"size":7534},{"path":"app/api/food-analysis-feedback/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\n\nexport async function POST(req: NextRequest) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const body = await req.json()\n    const rating = Number(body?.rating)\n    const scope = String(body?.scope || '').toLowerCase()\n    const scanId = typeof body?.analysisId === 'string' ? body.analysisId : null\n    const analysisMode = typeof body?.analysisMode === 'string' ? body.analysisMode : null\n    const analysisHint = typeof body?.analysisHint === 'string' ? body.analysisHint : null\n\n    if (!Number.isFinite(rating) || ![1, -1].includes(rating)) {\n      return NextResponse.json({ error: 'Invalid rating' }, { status: 400 })\n    }\n    if (scope !== 'overall' && scope !== 'item') {\n      return NextResponse.json({ error: 'Invalid scope' }, { status: 400 })\n    }\n\n    const reasons = Array.isArray(body?.reasons)\n      ? body.reasons.map((r: any) => String(r || '')).filter(Boolean)\n      : []\n\n    const comment = typeof body?.comment === 'string' ? body.comment.trim() : null\n    const itemIndex = Number.isFinite(Number(body?.itemIndex)) ? Number(body.itemIndex) : null\n    const itemName = typeof body?.itemName === 'string' ? body.itemName.trim() : null\n    const itemServingSize = typeof body?.itemServingSize === 'string' ? body.itemServingSize.trim() : null\n    const itemBrand = typeof body?.itemBrand === 'string' ? body.itemBrand.trim() : null\n\n    await prisma.foodAnalysisFeedback.create({\n      data: {\n        userId: session.user.id,\n        scanId,\n        analysisMode,\n        analysisHint,\n        scope,\n        rating,\n        reasons: reasons.length ? reasons : null,\n        comment: comment && comment.length ? comment : null,\n        itemIndex,\n        itemName,\n        itemServingSize,\n        itemBrand,\n      },\n    })\n\n    return NextResponse.json({ ok: true })\n  } catch (error) {\n    console.error('food-analysis-feedback error', error)\n    return NextResponse.json({ error: 'Failed to save feedback' }, { status: 500 })\n  }\n}\n","truncated":false,"size":2278},{"path":"app/api/food-analyzer-model/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth/next'\nimport { getToken } from 'next-auth/jwt'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\n\nexport const runtime = 'nodejs'\nexport const dynamic = 'force-dynamic'\n\nconst FOOD_MODEL_GOAL_NAME = '__FOOD_ANALYZER_MODEL__'\nconst ALLOWED_MODELS = new Set(['gpt-4o', 'gpt-5.2'])\n\nfunction normalizeModel(model: unknown): string | null {\n  if (typeof model !== 'string') return null\n  const trimmed = model.trim()\n  if (!trimmed) return null\n  if (ALLOWED_MODELS.has(trimmed)) return trimmed\n  return null\n}\n\nasync function getAuthedUserId(req: NextRequest): Promise<string | null> {\n  let session = await getServerSession(authOptions)\n  let userEmail: string | null = session?.user?.email ?? null\n\n  if (!userEmail) {\n    try {\n      const token = await getToken({\n        req,\n        secret: process.env.NEXTAUTH_SECRET || process.env.AUTH_SECRET || 'helfi-secret-key-production-2024',\n      })\n      if (token?.email) userEmail = String(token.email)\n    } catch {\n      // ignore\n    }\n  }\n\n  if (!userEmail) return null\n  const user = await prisma.user.findUnique({ where: { email: userEmail }, select: { id: true } })\n  return user?.id || null\n}\n\nexport async function GET(req: NextRequest) {\n  try {\n    const userId = await getAuthedUserId(req)\n    if (!userId) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n\n    const existing = await prisma.healthGoal.findFirst({\n      where: { userId, name: FOOD_MODEL_GOAL_NAME },\n      select: { id: true, category: true },\n    })\n\n    let model: string | null = null\n    if (existing?.category) {\n      try {\n        const parsed = JSON.parse(existing.category)\n        model = normalizeModel(parsed?.model)\n      } catch {}\n    }\n\n    return NextResponse.json({\n      model: model || 'gpt-4o',\n      source: model ? 'user_override' : 'default',\n    })\n  } catch (err) {\n    console.error('[food-analyzer-model] GET error', err)\n    return NextResponse.json({ error: 'Failed to load model' }, { status: 500 })\n  }\n}\n\nexport async function POST(req: NextRequest) {\n  try {\n    const userId = await getAuthedUserId(req)\n    if (!userId) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n\n    const body = await req.json().catch(() => ({}))\n    const model = normalizeModel(body?.model)\n    if (!model) {\n      return NextResponse.json({ error: 'Invalid model (use gpt-4o or gpt-5.2)' }, { status: 400 })\n    }\n\n    const payload = JSON.stringify({ model })\n    const existing = await prisma.healthGoal.findFirst({\n      where: { userId, name: FOOD_MODEL_GOAL_NAME },\n      select: { id: true },\n    })\n\n    if (existing?.id) {\n      await prisma.healthGoal.update({\n        where: { id: existing.id },\n        data: { category: payload, currentRating: 0 },\n      })\n    } else {\n      await prisma.healthGoal.create({\n        data: {\n          userId,\n          name: FOOD_MODEL_GOAL_NAME,\n          category: payload,\n          currentRating: 0,\n        },\n      })\n    }\n\n    return NextResponse.json({ ok: true, model })\n  } catch (err) {\n    console.error('[food-analyzer-model] POST error', err)\n    return NextResponse.json({ error: 'Failed to save model' }, { status: 500 })\n  }\n}\n","truncated":false,"size":3304},{"path":"app/api/food-data/route.ts","content":"export const dynamic = 'force-dynamic';\n\nimport { NextRequest, NextResponse } from 'next/server'\nimport { searchOpenFoodFactsByQuery, searchUsdaFoods, searchFatSecretFoods, lookupFoodNutrition } from '@/lib/food-data'\n\n// Lightweight read-only endpoint that proxies to external food databases\n// and returns a normalized list of items in a format compatible with the\n// Food Diary `items[]` structure (name, brand, serving_size, macros).\n//\n// Query parameters:\n// - source: \"openfoodfacts\" | \"usda\" | \"fatsecret\" | \"auto\" (tries all with fallback)\n// - q: search query (product name, brand, or keywords)\nexport async function GET(request: NextRequest) {\n  try {\n    const { searchParams } = new URL(request.url)\n    const source = (searchParams.get('source') || '').toLowerCase()\n    const query = (searchParams.get('q') || '').trim()\n    const kind = (searchParams.get('kind') || '').toLowerCase()\n    const limitRaw = searchParams.get('limit')\n    const limitParsed = limitRaw ? Number.parseInt(limitRaw, 10) : NaN\n    const limit = Number.isFinite(limitParsed) ? Math.min(Math.max(limitParsed, 1), 50) : 20\n\n    if (!query) {\n      return NextResponse.json(\n        { success: false, error: 'Missing required parameter: q' },\n        { status: 400 },\n      )\n    }\n\n    let items: any[] = []\n    let actualSource = source\n\n    const normalizeForMatch = (value: any) =>\n      String(value || '')\n        .toLowerCase()\n        .replace(/[^a-z0-9]+/g, ' ')\n        .trim()\n        .replace(/\\s+/g, ' ')\n\n    const queryNorm = normalizeForMatch(query)\n    const queryTokens = queryNorm ? queryNorm.split(' ').filter(Boolean) : []\n\n    const scoreNameMatch = (name: any) => {\n      if (!queryNorm) return 0\n      const n = normalizeForMatch(name)\n      if (!n) return 0\n      if (n === queryNorm) return 1000\n      if (n.startsWith(queryNorm)) return 800\n      if (n.includes(queryNorm)) return 500\n      if (queryTokens.length > 0) {\n        const hitCount = queryTokens.filter((t) => n.includes(t)).length\n        if (hitCount === queryTokens.length) return 350\n        return hitCount * 40\n      }\n      return 0\n    }\n\n    if (source === 'auto' || !source) {\n      const usdaDataType =\n        kind === 'packaged' ? 'branded' : kind === 'single' ? 'generic' : 'all'\n\n      const perSource = Math.min(Math.max(Math.ceil(limit / 2), 10), 25)\n\n      const scoredServing = (serving: string | null | undefined) => {\n        const s = (serving || '').toLowerCase()\n        if (!s) return 0\n        // Prefer real package servings over \"100 g\" defaults.\n        if (s.includes('100 g') || s.includes('100g')) return -5\n        if (s.includes('serving')) return 2\n        if (s.includes('piece') || s.includes('biscuit') || s.includes('cookie') || s.includes('slice')) return 3\n        return 1\n      }\n\n      const scoreItem = (it: any) => {\n        let score = 0\n        score += scoreNameMatch(it?.name)\n        if (it?.source === 'fatsecret') score += 3\n        if (it?.source === 'openfoodfacts') score += 2\n        if (it?.source === 'usda') score += 1\n        if (it?.brand) score += 2\n        if (Number.isFinite(Number(it?.calories)) && Number(it.calories) > 0) score += 1\n        score += scoredServing(it?.serving_size)\n        return score\n      }\n\n      const [usdaRes, fatRes, offRes] = await Promise.allSettled([\n        searchUsdaFoods(query, { pageSize: perSource, dataType: usdaDataType }),\n        searchFatSecretFoods(query, { pageSize: perSource }),\n        searchOpenFoodFactsByQuery(query, { pageSize: perSource }),\n      ])\n\n      const pooled: any[] = []\n      for (const res of [usdaRes, fatRes, offRes]) {\n        if (res.status === 'fulfilled' && Array.isArray(res.value)) {\n          pooled.push(...res.value)\n        }\n      }\n\n      // De-dupe by (name + brand) to avoid showing the same item multiple times across sources.\n      const normalized = (value: any) => String(value || '').trim().toLowerCase()\n      const byNameBrand = new Map<string, any>()\n      pooled\n        .sort((a, b) => scoreItem(b) - scoreItem(a))\n        .forEach((it) => {\n          const key = `${normalized(it?.name)}|${normalized(it?.brand)}`\n          if (!key || key === '|') return\n          if (!byNameBrand.has(key)) byNameBrand.set(key, it)\n        })\n\n      items = Array.from(byNameBrand.values()).slice(0, limit)\n      actualSource = 'auto'\n    } else if (source === 'openfoodfacts') {\n      items = await searchOpenFoodFactsByQuery(query, { pageSize: limit })\n    } else if (source === 'usda') {\n      const dataType =\n        kind === 'packaged' ? 'branded' : kind === 'single' ? 'generic' : 'all'\n      items = await searchUsdaFoods(query, { pageSize: limit, dataType })\n    } else if (source === 'fatsecret') {\n      items = await searchFatSecretFoods(query, { pageSize: limit })\n    } else {\n      return NextResponse.json(\n        { success: false, error: 'Invalid source. Expected \"openfoodfacts\", \"usda\", \"fatsecret\", or \"auto\".' },\n        { status: 400 },\n      )\n    }\n\n    // For non-auto sources, apply the same name-match ranking so exact matches come first.\n    if (actualSource !== 'auto' && Array.isArray(items) && items.length > 1) {\n      items = [...items].sort((a, b) => scoreNameMatch(b?.name) - scoreNameMatch(a?.name))\n    }\n\n    return NextResponse.json({ success: true, source: actualSource, items })\n  } catch (error) {\n    console.error('GET /api/food-data error', error)\n    return NextResponse.json({ success: false, error: 'Failed to fetch food data' }, { status: 500 })\n  }\n}\n","truncated":false,"size":5522},{"path":"app/api/food-data/servings/route.ts","content":"export const dynamic = 'force-dynamic'\n\nimport { NextRequest, NextResponse } from 'next/server'\nimport { fetchFatSecretServingOptions, fetchUsdaServingOptions } from '@/lib/food-data'\n\nexport async function GET(request: NextRequest) {\n  try {\n    const { searchParams } = new URL(request.url)\n    const source = (searchParams.get('source') || '').toLowerCase()\n    const id = (searchParams.get('id') || '').trim()\n\n    if (!source || !id) {\n      return NextResponse.json(\n        { success: false, error: 'Missing required parameters: source, id' },\n        { status: 400 },\n      )\n    }\n\n    if (source === 'usda') {\n      const options = await fetchUsdaServingOptions(id)\n      return NextResponse.json({ success: true, source: 'usda', options })\n    }\n\n    if (source === 'fatsecret') {\n      const options = await fetchFatSecretServingOptions(id)\n      return NextResponse.json({ success: true, source: 'fatsecret', options })\n    }\n\n    return NextResponse.json(\n      { success: false, error: 'Unsupported source. Expected usda or fatsecret.' },\n      { status: 400 },\n    )\n  } catch (error) {\n    console.error('GET /api/food-data/servings error', error)\n    return NextResponse.json({ success: false, error: 'Failed to fetch serving options' }, { status: 500 })\n  }\n}\n","truncated":false,"size":1279},{"path":"app/api/food-log/delete-atomic/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { getToken } from 'next-auth/jwt'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\nimport { normalizeMealCategory } from '../route'\nimport { deleteFoodPhotosIfUnused } from '@/lib/food-photo-storage'\n\n// Atomic delete endpoint (Food Diary ghost-entry hardening)\n//\n// Goal: delete DB rows (including conservative duplicate sweeps) AND update the server\n// todaysFoods snapshot (__TODAYS_FOODS_DATA__) in the same request so iOS PWA background/resume\n// can't resurrect stale cards after refresh.\n//\n// This endpoint is designed to be idempotent-ish: if the row is already gone, it still succeeds\n// and will apply the snapshot update if provided.\nexport async function POST(request: NextRequest) {\n  try {\n    let userEmail: string | null = null\n    try {\n      const session = await getServerSession(authOptions)\n      userEmail = session?.user?.email ?? null\n    } catch (sessionError) {\n      console.error('POST /api/food-log/delete-atomic - getServerSession failed (will try JWT fallback):', sessionError)\n    }\n\n    // Match /api/food-log patterns: JWT fallback because getServerSession can be unreliable on some clients.\n    if (!userEmail) {\n      try {\n        const token = await getToken({\n          req: request,\n          secret: process.env.NEXTAUTH_SECRET || process.env.AUTH_SECRET || 'helfi-secret-key-production-2024',\n        })\n        if (token?.email) {\n          userEmail = String(token.email)\n        }\n      } catch (tokenError) {\n        console.error('POST /api/food-log/delete-atomic - JWT fallback failed:', tokenError)\n      }\n    }\n\n    if (!userEmail) {\n      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 })\n    }\n\n    const user = await prisma.user.findUnique({ where: { email: userEmail } })\n    if (!user) {\n      return NextResponse.json({ error: 'User not found' }, { status: 404 })\n    }\n\n    const body = await request.json().catch(() => ({} as any))\n\n    const requestedIdRaw = (body as any)?.id\n    const requestedId = typeof requestedIdRaw === 'string' ? requestedIdRaw.trim() : requestedIdRaw ? String(requestedIdRaw) : ''\n\n    const rawDesc = typeof (body as any)?.description === 'string' ? String((body as any).description).trim() : ''\n    const rawCategory = typeof (body as any)?.category === 'string' ? String((body as any).category).trim() : ''\n    const category = rawCategory ? normalizeMealCategory(rawCategory) : null\n\n    const datePattern = /^\\d{4}-\\d{2}-\\d{2}$/\n    const snapshotDateRaw = typeof (body as any)?.snapshotDate === 'string' ? String((body as any).snapshotDate).slice(0, 10) : ''\n    const snapshotDate = datePattern.test(snapshotDateRaw) ? snapshotDateRaw : ''\n\n    const datesRaw = Array.isArray((body as any)?.dates) ? ((body as any).dates as any[]) : []\n    const dates = Array.from(\n      new Set(\n        datesRaw\n          .map((d) => (typeof d === 'string' ? d.slice(0, 10) : ''))\n          .filter((d) => datePattern.test(d)),\n      ),\n    ).slice(0, 12)\n\n    const snapshotFoodsRaw = Array.isArray((body as any)?.snapshotFoods) ? ((body as any).snapshotFoods as any[]) : null\n\n    const deletedIds = new Set<string>()\n    let deletedCount = 0\n    const imageUrlsToCheck = new Set<string>()\n\n    // 1) Delete by id + conservative duplicate sweep (fast path + anti-ghost).\n    if (requestedId) {\n      try {\n        const existing = await prisma.foodLog.findUnique({ where: { id: requestedId as any } })\n        if (existing && existing.userId === user.id) {\n          if (typeof existing.imageUrl === 'string' && existing.imageUrl.trim()) {\n            imageUrlsToCheck.add(existing.imageUrl.trim())\n          }\n          const rawText = String(existing.description || existing.name || '').trim()\n          const needle = rawText.split('\\n')[0].trim().slice(0, 140)\n          const createdAt = existing.createdAt instanceof Date ? existing.createdAt : new Date(existing.createdAt as any)\n          const createdAtMs = createdAt && !Number.isNaN(createdAt.getTime()) ? createdAt.getTime() : NaN\n\n          const shouldSweep = needle.length >= 12 && Number.isFinite(createdAtMs)\n          if (shouldSweep) {\n            const WINDOW_HOURS = 6\n            const windowStart = new Date(createdAtMs - WINDOW_HOURS * 60 * 60 * 1000)\n            const windowEnd = new Date(createdAtMs + WINDOW_HOURS * 60 * 60 * 1000)\n\n            const addDays = (dateStr: string, delta: number) => {\n              const m = /^(\\d{4})-(\\d{2})-(\\d{2})$/.exec(dateStr)\n              if (!m) return ''\n              const y = parseInt(m[1], 10)\n              const mo = parseInt(m[2], 10)\n              const d = parseInt(m[3], 10)\n              if (!Number.isFinite(y) || !Number.isFinite(mo) || !Number.isFinite(d)) return ''\n              const dt = new Date(Date.UTC(y, mo - 1, d))\n              dt.setUTCDate(dt.getUTCDate() + delta)\n              return dt.toISOString().slice(0, 10)\n            }\n\n            const baseLocalDate = typeof (existing as any).localDate === 'string' ? String((existing as any).localDate) : ''\n            const candidateDates = Array.from(\n              new Set(\n                [\n                  baseLocalDate,\n                  baseLocalDate ? addDays(baseLocalDate, -1) : '',\n                  baseLocalDate ? addDays(baseLocalDate, 1) : '',\n                  baseLocalDate ? addDays(baseLocalDate, -2) : '',\n                  baseLocalDate ? addDays(baseLocalDate, 2) : '',\n                ].filter((d) => typeof d === 'string' && d.length >= 8),\n              ),\n            )\n\n            const duplicates = await prisma.foodLog.findMany({\n              where: {\n                userId: user.id,\n                OR: [\n                  { id: requestedId as any },\n                  {\n                    createdAt: { gte: windowStart, lte: windowEnd },\n                    OR: [\n                      { description: { contains: needle, mode: 'insensitive' } },\n                      { name: { contains: needle, mode: 'insensitive' } },\n                    ],\n                  },\n                  candidateDates.length > 0\n                    ? {\n                        localDate: { in: candidateDates },\n                        OR: [\n                          { description: { contains: needle, mode: 'insensitive' } },\n                          { name: { contains: needle, mode: 'insensitive' } },\n                        ],\n                      }\n                    : undefined,\n                ].filter(Boolean) as any,\n              },\n              select: { id: true, imageUrl: true },\n            })\n\n            duplicates.forEach((row) => {\n              if (typeof row.imageUrl === 'string' && row.imageUrl.trim()) {\n                imageUrlsToCheck.add(row.imageUrl.trim())\n              }\n            })\n            const ids = Array.from(new Set(duplicates.map((d) => d.id))).slice(0, 50)\n            if (ids.length > 0) {\n              const result = await prisma.foodLog.deleteMany({\n                where: { userId: user.id, id: { in: ids } },\n              })\n              deletedCount += result.count\n              ids.forEach((id) => deletedIds.add(String(id)))\n            }\n          } else {\n            await prisma.foodLog.delete({ where: { id: requestedId as any } })\n            deletedCount += 1\n            deletedIds.add(String(requestedId))\n          }\n        }\n      } catch (err) {\n        // Best-effort: if id delete fails, fall through to description delete + snapshot update.\n        console.warn('AGENT_DEBUG', JSON.stringify({ hypothesisId: 'A', location: 'app/api/food-log/delete-atomic/route.ts:POST:id', message: 'Delete-by-id/sweep failed (best-effort)', data: { idPrefix: String(requestedId).slice(0, 8) }, timestamp: Date.now() }))\n      }\n    }\n\n    // 2) Delete by description/category across dates (server-side sweep, safer than client multi-fetch).\n    // Caller provides `dates` (usually selected day + nearby days). We also support a conservative\n    // uncategorized sweep on the target day only, because some server rows may miss meal/category.\n    const descForServer = rawDesc ? rawDesc.slice(0, 220) : ''\n    const targetDay = snapshotDate || (dates[0] || '')\n    if (descForServer) {\n      try {\n        const categoriesToTry: (string | null)[] = []\n        if (category) {\n          categoriesToTry.push(category)\n          if (category !== 'uncategorized' && targetDay) {\n            categoriesToTry.push('uncategorized')\n          }\n        } else {\n          categoriesToTry.push(null)\n        }\n\n        for (const cat of categoriesToTry) {\n          const whereClause: any = {\n            userId: user.id,\n            OR: [\n              { description: { contains: descForServer, mode: 'insensitive' } },\n              { name: { contains: descForServer, mode: 'insensitive' } },\n            ],\n          }\n          if (cat) {\n            whereClause.AND = whereClause.AND || []\n            whereClause.AND.push({ meal: normalizeMealCategory(cat) })\n          }\n          if (dates.length > 0) {\n            whereClause.AND = whereClause.AND || []\n            whereClause.AND.push({ localDate: { in: cat === 'uncategorized' && targetDay ? [targetDay] : dates } })\n          }\n\n          const matches = await prisma.foodLog.findMany({\n            where: whereClause,\n            select: { id: true, imageUrl: true },\n            take: 50,\n          })\n\n          matches.forEach((row) => {\n            if (typeof row.imageUrl === 'string' && row.imageUrl.trim()) {\n              imageUrlsToCheck.add(row.imageUrl.trim())\n            }\n          })\n          const ids = Array.from(new Set(matches.map((m) => String(m.id)))).filter(Boolean).slice(0, 50)\n          if (ids.length > 0) {\n            const result = await prisma.foodLog.deleteMany({\n              where: { userId: user.id, id: { in: ids } },\n            })\n            deletedCount += result.count\n            ids.forEach((id) => deletedIds.add(id))\n          }\n        }\n      } catch (err) {\n        console.warn('AGENT_DEBUG', JSON.stringify({ hypothesisId: 'A', location: 'app/api/food-log/delete-atomic/route.ts:POST:desc', message: 'Delete-by-description sweep failed (best-effort)', timestamp: Date.now() }))\n      }\n    }\n\n    // 3) Snapshot sync: if client provided snapshotFoods, write them now; otherwise attempt to\n    // remove deleted ids from the existing snapshot record.\n    let snapshotUpdated = false\n    let snapshotCount: number | null = null\n    try {\n      const snapshotKeyName = '__TODAYS_FOODS_DATA__'\n\n      const writeSnapshotFoods = async (foods: any[]) => {\n        await prisma.healthGoal.deleteMany({\n          where: { userId: user.id, name: snapshotKeyName },\n        })\n        if (foods.length > 0) {\n          await prisma.healthGoal.create({\n            data: {\n              userId: user.id,\n              name: snapshotKeyName,\n              category: JSON.stringify({ foods }),\n              currentRating: 0,\n            },\n          })\n        }\n      }\n\n      if (snapshotFoodsRaw && snapshotFoodsRaw.length >= 0 && snapshotDate) {\n        // Trust client to have already minimized/limited; we only ensure date scoping + cap.\n        const scoped = snapshotFoodsRaw\n          .filter((e) => e && typeof e === 'object')\n          .map((e) => ({\n            ...e,\n            localDate:\n              typeof (e as any)?.localDate === 'string' && (e as any).localDate.length >= 8\n                ? String((e as any).localDate).slice(0, 10)\n                : snapshotDate,\n          }))\n          .filter((e) => String((e as any).localDate || '') === snapshotDate)\n        const capped = scoped.slice(0, 300)\n        await writeSnapshotFoods(capped)\n        snapshotUpdated = true\n        snapshotCount = capped.length\n      } else if (deletedIds.size > 0) {\n        const existing = await prisma.healthGoal.findFirst({\n          where: { userId: user.id, name: snapshotKeyName },\n          select: { id: true, category: true },\n        })\n        if (existing?.category) {\n          let parsed: any = null\n          try {\n            parsed = JSON.parse(String(existing.category))\n          } catch {}\n          const foods = Array.isArray(parsed?.foods) ? parsed.foods : []\n          const filtered = foods.filter((f: any) => {\n            const dbId = f && (f.dbId || f.id) ? String(f.dbId || '') : ''\n            if (dbId && deletedIds.has(dbId)) return false\n            return true\n          })\n          await writeSnapshotFoods(filtered)\n          snapshotUpdated = true\n          snapshotCount = filtered.length\n        }\n      }\n    } catch (err) {\n      console.warn('AGENT_DEBUG', JSON.stringify({ hypothesisId: 'A', location: 'app/api/food-log/delete-atomic/route.ts:POST:snapshot', message: 'Snapshot sync failed (best-effort)', timestamp: Date.now() }))\n    }\n\n    try {\n      await deleteFoodPhotosIfUnused(Array.from(imageUrlsToCheck))\n    } catch (cleanupError) {\n      console.warn('AGENT_DEBUG', JSON.stringify({ hypothesisId: 'PHOTO_CLEAN', location: 'app/api/food-log/delete-atomic/route.ts:POST:cleanup', message: 'Food photo cleanup failed (non-blocking)', timestamp: Date.now() }))\n      console.warn(cleanupError)\n    }\n\n    return NextResponse.json({\n      success: true,\n      deleted: deletedCount,\n      deletedIds: Array.from(deletedIds),\n      snapshotUpdated,\n      snapshotCount,\n    })\n  } catch (error) {\n    console.error('POST /api/food-log/delete-atomic error', error)\n    return NextResponse.json({ error: 'Failed to delete log' }, { status: 500 })\n  }\n}\n","truncated":false,"size":13630},{"path":"app/api/food-log/delete-by-description/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { getToken } from 'next-auth/jwt'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\nimport { normalizeMealCategory } from '../route'\nimport { deleteFoodPhotosIfUnused } from '@/lib/food-photo-storage'\n\n// Danger zone endpoint: delete matching food logs by description + category for the authenticated user.\n// Used as a last-resort cleaner when client-side deletes fail due to mismatched IDs or dates.\nexport async function POST(request: NextRequest) {\n  try {\n    let session\n    let userEmail: string | null = null\n    try {\n      session = await getServerSession(authOptions)\n      userEmail = session?.user?.email ?? null\n    } catch (sessionError) {\n      console.error('POST /api/food-log/delete-by-description - getServerSession failed (will try JWT fallback):', sessionError)\n    }\n\n    if (!userEmail) {\n      try {\n        const token = await getToken({\n          req: request,\n          secret: process.env.NEXTAUTH_SECRET || process.env.AUTH_SECRET || 'helfi-secret-key-production-2024',\n        })\n        if (token?.email) {\n          userEmail = String(token.email)\n        }\n      } catch (tokenError) {\n        console.error('POST /api/food-log/delete-by-description - JWT fallback failed:', tokenError)\n      }\n    }\n\n    if (!userEmail) {\n      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 })\n    }\n\n    const user = await prisma.user.findUnique({ where: { email: userEmail } })\n    if (!user) {\n      return NextResponse.json({ error: 'User not found' }, { status: 404 })\n    }\n\n    const body = await request.json().catch(() => ({} as any))\n    const rawDesc = String((body as any)?.description || '').trim()\n    const rawCategory = String((body as any)?.category || '').trim()\n    const targetDates = Array.isArray((body as any)?.dates)\n      ? ((body as any).dates as string[]).filter((d) => typeof d === 'string' && d.length >= 8)\n      : []\n\n    if (!rawDesc) {\n      return NextResponse.json({ error: 'Missing description' }, { status: 400 })\n    }\n\n    const category = rawCategory ? normalizeMealCategory(rawCategory) : null\n    const descLower = rawDesc.toLowerCase()\n\n    const whereClause: any = {\n      userId: user.id,\n      OR: [\n        { description: { contains: rawDesc, mode: 'insensitive' } },\n        { name: { contains: rawDesc, mode: 'insensitive' } },\n      ],\n    }\n\n    if (category) {\n      whereClause.AND = [{ meal: normalizeMealCategory(category) }]\n    }\n\n    if (targetDates.length > 0) {\n      whereClause.AND = whereClause.AND || []\n      whereClause.AND.push({ localDate: { in: targetDates } })\n    }\n\n    const matches = await prisma.foodLog.findMany({\n      where: whereClause,\n      select: { id: true, description: true, meal: true, localDate: true, imageUrl: true },\n    })\n\n    // #region agent log\n    try {\n      console.log('AGENT_DEBUG', JSON.stringify({hypothesisId:'D',location:'app/api/food-log/delete-by-description/route.ts:POST',message:'Delete-by-description match summary',data:{rawDescLen:rawDesc.length,category,datesCount:targetDates.length,matchesCount:matches.length,sample:matches.slice(0,3).map(m=>({idPrefix:String(m.id).slice(0,8),meal:m.meal||null,localDate:m.localDate||null}))},timestamp:Date.now()}));\n    } catch {}\n    // #endregion agent log\n\n    if (!matches.length) {\n      return NextResponse.json({ success: true, deleted: 0 })\n    }\n\n    const ids = matches.map((m) => m.id)\n    const result = await prisma.foodLog.deleteMany({\n      where: { id: { in: ids }, userId: user.id },\n    })\n\n    try {\n      await deleteFoodPhotosIfUnused(matches.map((row) => row.imageUrl))\n    } catch (cleanupError) {\n      console.warn('AGENT_DEBUG', JSON.stringify({ hypothesisId: 'PHOTO_CLEAN', location: 'app/api/food-log/delete-by-description/route.ts:POST:cleanup', message: 'Food photo cleanup failed (non-blocking)', timestamp: Date.now() }))\n      console.warn(cleanupError)\n    }\n\n    return NextResponse.json({ success: true, deleted: result.count, ids })\n  } catch (error) {\n    console.error('POST /api/food-log/delete-by-description error', error)\n    return NextResponse.json({ error: 'Failed to delete logs' }, { status: 500 })\n  }\n}\n","truncated":false,"size":4287},{"path":"app/api/food-log/delete/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { getToken } from 'next-auth/jwt'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\nimport { deleteFoodPhotosIfUnused } from '@/lib/food-photo-storage'\n\n// Delete a specific food log (by id) for the authenticated user\nexport async function POST(request: NextRequest) {\n  try {\n    let session\n    let userEmail: string | null = null\n    try {\n      session = await getServerSession(authOptions)\n      userEmail = session?.user?.email ?? null\n    } catch (sessionError) {\n      console.error('POST /api/food-log/delete - getServerSession failed (will try JWT fallback):', sessionError)\n    }\n\n    // Match /api/food-log GET: JWT fallback because getServerSession can be unreliable on some clients.\n    if (!userEmail) {\n      try {\n        const token = await getToken({\n          req: request,\n          secret: process.env.NEXTAUTH_SECRET || process.env.AUTH_SECRET || 'helfi-secret-key-production-2024',\n        })\n        if (token?.email) {\n          userEmail = String(token.email)\n        }\n      } catch (tokenError) {\n        console.error('POST /api/food-log/delete - JWT fallback failed:', tokenError)\n      }\n    }\n\n    if (!userEmail) {\n      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 })\n    }\n\n    const user = await prisma.user.findUnique({ where: { email: userEmail } })\n    if (!user) {\n      return NextResponse.json({ error: 'User not found' }, { status: 404 })\n    }\n\n    const body = await request.json().catch(() => ({} as any))\n    const id = String((body as any)?.id || '').trim()\n    if (!id) {\n      return NextResponse.json({ error: 'Missing id' }, { status: 400 })\n    }\n\n    console.log('AGENT_DEBUG', JSON.stringify({hypothesisId:'E',location:'app/api/food-log/delete/route.ts:POST',message:'Delete-by-id requested',data:{idLen:id.length,idPrefix:id.slice(0,8)},timestamp:Date.now()}));\n\n    // Ensure the log belongs to the user\n    const existing = await prisma.foodLog.findUnique({ where: { id: id as any } })\n    if (!existing || existing.userId !== user.id) {\n      return NextResponse.json({ error: 'Not found' }, { status: 404 })\n    }\n    const imageUrlsToCheck = new Set<string>()\n    if (typeof existing.imageUrl === 'string' && existing.imageUrl.trim()) {\n      imageUrlsToCheck.add(existing.imageUrl.trim())\n    }\n\n    // Many users have duplicate FoodLog rows that represent one visible \"meal card\".\n    // Deleting a single row can appear to work, but the \"ghost\" resurfaces after refresh\n    // because other near-identical rows still exist. To prevent resurrection, do a\n    // conservative duplicate sweep around the deleted row.\n    let deletedCount = 0\n    try {\n      const rawText = String(existing.description || existing.name || '').trim()\n      const needle = rawText.split('\\n')[0].trim().slice(0, 140)\n      const createdAt = existing.createdAt instanceof Date ? existing.createdAt : new Date(existing.createdAt as any)\n      const createdAtMs = createdAt && !Number.isNaN(createdAt.getTime()) ? createdAt.getTime() : NaN\n\n      // Only do a sweep when we have a meaningful text seed (avoid nuking short placeholder rows like \"0\").\n      const shouldSweep = needle.length >= 12 && Number.isFinite(createdAtMs)\n      if (shouldSweep) {\n        const WINDOW_HOURS = 6\n        const windowStart = new Date(createdAtMs - WINDOW_HOURS * 60 * 60 * 1000)\n        const windowEnd = new Date(createdAtMs + WINDOW_HOURS * 60 * 60 * 1000)\n\n        const addDays = (dateStr: string, delta: number) => {\n          const m = /^(\\d{4})-(\\d{2})-(\\d{2})$/.exec(dateStr)\n          if (!m) return ''\n          const y = parseInt(m[1], 10)\n          const mo = parseInt(m[2], 10)\n          const d = parseInt(m[3], 10)\n          if (!Number.isFinite(y) || !Number.isFinite(mo) || !Number.isFinite(d)) return ''\n          const dt = new Date(Date.UTC(y, mo - 1, d))\n          dt.setUTCDate(dt.getUTCDate() + delta)\n          return dt.toISOString().slice(0, 10)\n        }\n\n        const baseLocalDate = typeof (existing as any).localDate === 'string' ? String((existing as any).localDate) : ''\n        const candidateDates = Array.from(\n          new Set(\n            [\n              baseLocalDate,\n              baseLocalDate ? addDays(baseLocalDate, -1) : '',\n              baseLocalDate ? addDays(baseLocalDate, 1) : '',\n              baseLocalDate ? addDays(baseLocalDate, -2) : '',\n              baseLocalDate ? addDays(baseLocalDate, 2) : '',\n            ].filter((d) => typeof d === 'string' && d.length >= 8),\n          ),\n        )\n\n        const duplicates = await prisma.foodLog.findMany({\n          where: {\n            userId: user.id,\n            OR: [\n              // Always include the requested id\n              { id: id as any },\n              // Time-window match (handles wrong/missing localDate rows that leak across days)\n              {\n                createdAt: { gte: windowStart, lte: windowEnd },\n                OR: [\n                  { description: { contains: needle, mode: 'insensitive' } },\n                  { name: { contains: needle, mode: 'insensitive' } },\n                ],\n              },\n              // LocalDate match (handles rows with correct localDate but slightly different createdAt)\n              candidateDates.length > 0\n                ? {\n                    localDate: { in: candidateDates },\n                    OR: [\n                      { description: { contains: needle, mode: 'insensitive' } },\n                      { name: { contains: needle, mode: 'insensitive' } },\n                    ],\n                  }\n                : undefined,\n            ].filter(Boolean) as any,\n          },\n          select: { id: true, imageUrl: true },\n        })\n\n        duplicates.forEach((row) => {\n          if (typeof row.imageUrl === 'string' && row.imageUrl.trim()) {\n            imageUrlsToCheck.add(row.imageUrl.trim())\n          }\n        })\n        const ids = Array.from(new Set(duplicates.map((d) => d.id))).slice(0, 50)\n        const result = await prisma.foodLog.deleteMany({\n          where: { userId: user.id, id: { in: ids } },\n        })\n        deletedCount = result.count\n\n        console.log(\n          'AGENT_DEBUG',\n          JSON.stringify({\n            hypothesisId: 'A',\n            location: 'app/api/food-log/delete/route.ts:POST:sweep',\n            message: 'Delete-by-id duplicate sweep executed',\n            data: { requestedIdPrefix: id.slice(0, 8), needleLen: needle.length, candidateDatesCount: candidateDates.length, deletedCount },\n            timestamp: Date.now(),\n          }),\n        )\n      } else {\n        await prisma.foodLog.delete({ where: { id: id as any } })\n        deletedCount = 1\n        console.log(\n          'AGENT_DEBUG',\n          JSON.stringify({\n            hypothesisId: 'A',\n            location: 'app/api/food-log/delete/route.ts:POST:sweep',\n            message: 'Delete-by-id duplicate sweep skipped (insufficient seed); deleted single row',\n            data: { requestedIdPrefix: id.slice(0, 8), needleLen: needle.length, deletedCount },\n            timestamp: Date.now(),\n          }),\n        )\n      }\n    } catch (sweepErr) {\n      // Fall back to single-row delete if sweep fails for any reason.\n      try {\n        await prisma.foodLog.delete({ where: { id: id as any } })\n        deletedCount = Math.max(deletedCount, 1)\n      } catch {}\n      console.warn('AGENT_DEBUG', JSON.stringify({ hypothesisId: 'A', location: 'app/api/food-log/delete/route.ts:POST:sweep', message: 'Duplicate sweep failed; fell back to single-row delete', data: { requestedIdPrefix: id.slice(0, 8) }, timestamp: Date.now() }))\n    }\n\n    try {\n      await deleteFoodPhotosIfUnused(Array.from(imageUrlsToCheck))\n    } catch (cleanupError) {\n      console.warn('AGENT_DEBUG', JSON.stringify({ hypothesisId: 'PHOTO_CLEAN', location: 'app/api/food-log/delete/route.ts:POST:cleanup', message: 'Food photo cleanup failed (non-blocking)', timestamp: Date.now() }))\n      console.warn(cleanupError)\n    }\n\n    return NextResponse.json({ success: true, deleted: deletedCount })\n  } catch (error) {\n    console.error('POST /api/food-log/delete error', error)\n    return NextResponse.json({ error: 'Failed to delete log' }, { status: 500 })\n  }\n}\n","truncated":false,"size":8341},{"path":"app/api/food-log/health/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth/next'\nimport { getToken } from 'next-auth/jwt'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\n\nexport const dynamic = 'force-dynamic'\n\n// Health check endpoint to quickly verify food diary consistency for the\n// authenticated user. Returns counts of FoodLog rows for a date, todaysFoods\n// snapshot length, favorites length, and a short list of recent FoodLog entries.\n// Usage: GET /api/food-log/health?date=YYYY-MM-DD\nexport async function GET(request: NextRequest) {\n  let userEmail: string | null = null\n  try {\n    let session = await getServerSession(authOptions)\n    userEmail = session?.user?.email ?? null\n    let usedTokenFallback = false\n\n    if (!userEmail) {\n      try {\n        const token = await getToken({\n          req: request,\n          secret: process.env.NEXTAUTH_SECRET || process.env.AUTH_SECRET || 'helfi-secret-key-production-2024',\n        })\n        if (token?.email) {\n          userEmail = String(token.email)\n          usedTokenFallback = true\n        }\n      } catch (tokenError) {\n        console.error('food-log health JWT fallback failed', tokenError)\n      }\n    }\n\n    if (!userEmail) {\n      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 })\n    }\n\n    const user = await prisma.user.findUnique({ where: { email: userEmail } })\n    if (!user) return NextResponse.json({ error: 'User not found' }, { status: 404 })\n\n    const { searchParams } = new URL(request.url)\n    const dateStr = searchParams.get('date') || ''\n    const datePattern = /^\\d{4}-\\d{2}-\\d{2}$/\n    const targetDate = datePattern.test(dateStr) ? dateStr : null\n\n    // Pull favorites count\n    let favoritesCount = 0\n    try {\n      const favGoal = await prisma.healthGoal.findFirst({\n        where: { userId: user.id, name: '__FOOD_FAVORITES__' },\n      })\n      if (favGoal?.category) {\n        const parsed = JSON.parse(favGoal.category)\n        const favs = Array.isArray(parsed?.favorites) ? parsed.favorites : Array.isArray(parsed) ? parsed : []\n        favoritesCount = favs.length\n      }\n    } catch (favErr) {\n      console.warn('health check: failed to load favorites', favErr)\n    }\n\n    // Pull todaysFoods snapshot count\n    let todaysFoodsCount = 0\n    try {\n      const tfGoal = await prisma.healthGoal.findFirst({\n        where: { userId: user.id, name: '__TODAYS_FOODS_DATA__' },\n      })\n      if (tfGoal?.category) {\n        const parsed = JSON.parse(tfGoal.category)\n        const foods = Array.isArray(parsed?.foods) ? parsed.foods : []\n        todaysFoodsCount = foods.length\n      }\n    } catch (tfErr) {\n      console.warn('health check: failed to load todaysFoods snapshot', tfErr)\n    }\n\n    let foodLogCount = 0\n    if (targetDate) {\n      foodLogCount = await prisma.foodLog.count({\n        where: { userId: user.id, localDate: targetDate },\n      })\n    }\n\n    // Recent entries (regardless of date) for quick inspection\n    const recent = await prisma.foodLog.findMany({\n      where: { userId: user.id },\n      orderBy: { createdAt: 'desc' },\n      take: 10,\n      select: {\n        id: true,\n        localDate: true,\n        createdAt: true,\n        description: true,\n        meal: true,\n        category: true,\n      },\n    })\n\n    return NextResponse.json({\n      ok: true,\n      userId: user.id,\n      email: userEmail,\n      date: targetDate,\n      counts: {\n        favorites: favoritesCount,\n        todaysFoodsSnapshot: todaysFoodsCount,\n        foodLogForDate: foodLogCount,\n      },\n      recent,\n    })\n  } catch (error) {\n    console.error('food-log health check failed', error)\n    return NextResponse.json({ error: 'Health check failed' }, { status: 500 })\n  }\n}\n","truncated":false,"size":3770},{"path":"app/api/food-log/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { getToken } from 'next-auth/jwt'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\nimport { triggerBackgroundRegeneration } from '@/lib/insights/regeneration-service'\nimport { Prisma } from '@prisma/client'\nimport { put } from '@vercel/blob'\nimport { deleteFoodPhotosIfUnused } from '@/lib/food-photo-storage'\n\nconst FOOD_PHOTO_PREFIX = 'food-photos'\n\nconst isDataUrl = (value: string) => /^data:image\\/[a-zA-Z0-9.+-]+;base64,/.test(value)\nconst isRemoteUrl = (value: string) => /^https?:\\/\\//i.test(value)\n\nconst dataUrlToBuffer = (value: string) => {\n  const match = /^data:(image\\/[a-zA-Z0-9.+-]+);base64,(.+)$/.exec(value)\n  if (!match) return null\n  const contentType = match[1]\n  const buffer = Buffer.from(match[2], 'base64')\n  return { contentType, buffer }\n}\n\nconst contentTypeToExt = (contentType: string) => {\n  if (contentType === 'image/png') return 'png'\n  if (contentType === 'image/webp') return 'webp'\n  if (contentType === 'image/gif') return 'gif'\n  return 'jpg'\n}\n\nconst uploadFoodPhoto = async (userId: string, imageDataUrl: string) => {\n  if (!process.env.BLOB_READ_WRITE_TOKEN) {\n    console.warn('‚ö†Ô∏è Food photo upload skipped: BLOB_READ_WRITE_TOKEN missing')\n    return imageDataUrl\n  }\n  const parsed = dataUrlToBuffer(imageDataUrl)\n  if (!parsed) return imageDataUrl\n  const ext = contentTypeToExt(parsed.contentType)\n  const filename = `${Date.now()}.${ext}`\n  const pathname = `${FOOD_PHOTO_PREFIX}/${userId}/${filename}`\n  try {\n    const blob = await put(pathname, parsed.buffer, {\n      access: 'public',\n      contentType: parsed.contentType,\n      addRandomSuffix: true,\n    })\n    return blob.url\n  } catch (error) {\n    console.error('‚ùå Food photo upload failed, keeping original imageUrl', error)\n    return imageDataUrl\n  }\n}\n\nexport const normalizeMealCategory = (raw: any): string | null => {\n  const value = typeof raw === 'string' ? raw.toLowerCase() : ''\n  if (/breakfast/.test(value)) return 'breakfast'\n  if (/lunch/.test(value)) return 'lunch'\n  if (/dinner/.test(value)) return 'dinner'\n  if (/snack/.test(value)) return 'snacks'\n  if (/uncat/.test(value) || /other/.test(value)) return 'uncategorized'\n  if (typeof raw === 'string' && raw.trim()) return raw.trim()\n  return null\n}\n\n// Fetch logs for a specific date (YYYY-MM-DD)\nexport async function GET(request: NextRequest) {\n  let dateStr: string | null = null;\n  let tzOffsetMinRaw: string | null = null;\n  let userEmail: string | null = null;\n  \n  try {\n    console.log('üì• GET /api/food-log - Starting request handler');\n    \n    // Ensure localDate column exists (forward-compatible migration)\n    // This prevents \"column does not exist\" errors if migration hasn't run\n    // try {\n    //   await prisma.$executeRawUnsafe('ALTER TABLE \"FoodLog\" ADD COLUMN IF NOT EXISTS \"localDate\" TEXT')\n    //   console.log('‚úÖ GET /api/food-log - Verified localDate column exists');\n    // } catch (migrationError) {\n    //   // Safe to ignore if column already exists or other migration issues\n    //   console.warn('‚ö†Ô∏è GET /api/food-log - localDate column check (safe to ignore if exists):', migrationError)\n    // }\n    \n    console.log('üîê GET /api/food-log - Getting session...');\n    let session;\n    try {\n      session = await getServerSession(authOptions);\n      userEmail = session?.user?.email ?? null;\n      console.log('‚úÖ GET /api/food-log - Session retrieved:', session ? 'authenticated' : 'not authenticated');\n    } catch (sessionError) {\n      console.error('‚ùå GET /api/food-log - Error getting session (will try JWT fallback):', sessionError);\n    }\n\n    // Fallback to reading JWT directly if getServerSession was unreliable (same pattern as /api/analyze-food)\n    let usedTokenFallback = false;\n    if (!userEmail) {\n      try {\n        const token = await getToken({\n          req: request,\n          secret: process.env.NEXTAUTH_SECRET || process.env.AUTH_SECRET || 'helfi-secret-key-production-2024',\n        });\n        if (token?.email) {\n          userEmail = String(token.email);\n          usedTokenFallback = true;\n        }\n      } catch (tokenError) {\n        console.error('‚ùå GET /api/food-log - Error reading JWT token for auth fallback:', tokenError);\n      }\n    }\n\n    if (!userEmail) {\n      console.error('‚ùå GET /api/food-log - Authentication failed: no session or email (after JWT fallback)');\n      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 })\n    }\n\n    const { searchParams } = new URL(request.url)\n    const idParam = searchParams.get('id')\n    dateStr = searchParams.get('date') // YYYY-MM-DD (local date)\n    tzOffsetMinRaw = searchParams.get('tz') // minutes: same as new Date().getTimezoneOffset()\n    console.log(`üì• GET /api/food-log - Request: date=${dateStr}, tz=${tzOffsetMinRaw}, user=${userEmail}`);\n    \n    // Support fetching a single log row by id (used by Build-a-meal edit routing).\n    if (idParam && typeof idParam === 'string' && idParam.trim().length > 0) {\n      const logId = idParam.trim()\n      console.log(`üì• GET /api/food-log - Fetching by id=${logId}`)\n\n      let user\n      try {\n        user = await prisma.user.findUnique({ where: { email: userEmail } })\n      } catch (userError) {\n        console.error('‚ùå GET /api/food-log - Error looking up user for id fetch:', userError)\n        return NextResponse.json(\n          { error: 'Database error', details: userError instanceof Error ? userError.message : String(userError) },\n          { status: 500 },\n        )\n      }\n      if (!user) return NextResponse.json({ error: 'User not found' }, { status: 404 })\n\n      const log = await prisma.foodLog.findUnique({ where: { id: logId as any } })\n      if (!log || log.userId !== user.id) {\n        return NextResponse.json({ error: 'Not found' }, { status: 404 })\n      }\n      return NextResponse.json({ success: true, log })\n    }\n\n    if (!dateStr) {\n      console.error('‚ùå GET /api/food-log - Missing date parameter');\n      return NextResponse.json({ error: 'Missing date' }, { status: 400 })\n    }\n\n    // At this point, dateStr is guaranteed to be non-null\n    const validatedDateStr: string = dateStr;\n\n    // Validate date format (YYYY-MM-DD)\n    const datePattern = /^\\d{4}-\\d{2}-\\d{2}$/;\n    if (!datePattern.test(validatedDateStr)) {\n      console.error(`‚ùå GET /api/food-log - Invalid date format: ${validatedDateStr}`);\n      return NextResponse.json({ error: 'Invalid date format. Expected YYYY-MM-DD' }, { status: 400 })\n    }\n\n    console.log('üë§ GET /api/food-log - Looking up user:', userEmail);\n    let user;\n    try {\n      user = await prisma.user.findUnique({ where: { email: userEmail } });\n      console.log('‚úÖ GET /api/food-log - User lookup result:', user ? 'found' : 'not found');\n    } catch (userError) {\n      console.error('‚ùå GET /api/food-log - Error looking up user:', userError);\n      return NextResponse.json({ \n        error: 'Database error',\n        details: userError instanceof Error ? userError.message : String(userError)\n      }, { status: 500 })\n    }\n    \n    if (!user) {\n      console.error(`‚ùå GET /api/food-log - User not found: ${userEmail}`);\n      return NextResponse.json({ error: 'User not found' }, { status: 404 })\n    }\n\n    // Build a UTC window that corresponds to the user's local day\n    // tz is minutes difference between local time and UTC (Date.getTimezoneOffset()).\n    // To get the correct UTC window for the local date, we ADD the offset.\n    const [y, m, d] = validatedDateStr.split('-').map((v) => parseInt(v, 10))\n    \n    // Validate parsed date values\n    if (!Number.isFinite(y) || !Number.isFinite(m) || !Number.isFinite(d) || m < 1 || m > 12 || d < 1 || d > 31) {\n      console.error(`‚ùå GET /api/food-log - Invalid date values: y=${y}, m=${m}, d=${d}`);\n      return NextResponse.json({ error: 'Invalid date values' }, { status: 400 })\n    }\n    \n    const tzMin = Number.isFinite(parseInt(tzOffsetMinRaw || ''))\n      ? parseInt(tzOffsetMinRaw || '0', 10)\n      : 0\n    \n    // CRITICAL FIX: Use a wider window to catch entries that might be on the boundary\n    // Query from start of requested day to end of next day, then filter precisely\n    // This ensures we don't miss entries due to timezone or timing issues\n    const startUtcMs = Date.UTC(y, (m || 1) - 1, d || 1, 0, 0, 0, 0) + tzMin * 60 * 1000\n    const endUtcMs = Date.UTC(y, (m || 1) - 1, d || 1, 23, 59, 59, 999) + tzMin * 60 * 1000\n    \n    // Also create a wider query window (extend by 12 hours on each side to catch boundary cases)\n    const queryStartMs = startUtcMs - (12 * 60 * 60 * 1000) // 12 hours before\n    const queryEndMs = endUtcMs + (12 * 60 * 60 * 1000) // 12 hours after\n    \n    const start = new Date(startUtcMs)\n    const end = new Date(endUtcMs)\n    const queryStart = new Date(queryStartMs)\n    const queryEnd = new Date(queryEndMs)\n\n    // üõ°Ô∏è GUARD RAIL: Food Diary Entry Query (CRITICAL - DO NOT MODIFY WITHOUT READING GUARD_RAILS.md)\n    // \n    // This query prevents entries from disappearing due to date filtering issues.\n    // See GUARD_RAILS.md section 3 for full documentation of the bug and fix.\n    //\n    // DO NOT:\n    // - Remove any of the OR conditions below\n    // - Filter by localDate alone without checking createdAt\n    // - Make the query more restrictive\n    // - Remove the filtering/deduplication steps below\n    //\n    // DO:\n    // - Query broadly to catch entries with missing/incorrect localDate\n    // - Filter precisely after querying to ensure correct date\n    // - Always deduplicate results\n    //\n    // Prefer the explicit localDate column when present so entries never drift to the wrong day.\n    // For older rows that predate localDate, fall back to the createdAt time-window.\n    // CRITICAL FIX: Query more broadly to catch entries that might have incorrect localDate\n    // We'll filter them properly below\n    console.log('üîç GET /api/food-log - Querying database for entries...');\n    let logs;\n    try {\n      logs = await prisma.foodLog.findMany({\n        where: {\n          userId: user.id,\n          OR: [\n            { localDate: validatedDateStr },\n            {\n              localDate: null,\n              createdAt: { gte: queryStart, lte: queryEnd },\n            },\n            // Include entries created within the wider query window (even if localDate is set incorrectly)\n            // This ensures we don't lose entries due to date mismatches or timezone issues\n            // DO NOT REMOVE THIS CONDITION - it prevents entries from disappearing\n            {\n              createdAt: { gte: queryStart, lte: queryEnd },\n            },\n          ],\n        },\n        orderBy: { createdAt: 'desc' },\n      });\n      console.log(`‚úÖ GET /api/food-log - Database query returned ${logs.length} entries`);\n    } catch (queryError) {\n      console.error('‚ùå GET /api/food-log - Database query error:', queryError);\n      return NextResponse.json({ \n        error: 'Database query failed',\n        details: queryError instanceof Error ? queryError.message : String(queryError)\n      }, { status: 500 })\n    }\n    \n    // üõ°Ô∏è GUARD RAIL: Post-Query Filtering (REQUIRED)\n    // Filter to ensure we only return entries for the requested date\n    // This handles entries that might have incorrect localDate values\n    // DO NOT remove this filtering step - it ensures accuracy after broad query\n    const filteredLogs = logs.filter((log) => {\n      try {\n        // If localDate matches exactly, include it\n        if (log.localDate === validatedDateStr) return true;\n        \n        // If localDate is null or doesn't match, check the actual calendar date of createdAt\n        // CRITICAL: Use the user's timezone to determine the calendar date, not UTC\n        // This ensures entries are matched to the correct day regardless of timezone issues\n        if (!log.localDate || log.localDate !== validatedDateStr) {\n          // Safety check: createdAt must exist and be a valid date\n          if (!log.createdAt) {\n            console.warn(`‚ö†Ô∏è Entry ${log.id} has no createdAt, skipping date check`);\n            return false;\n          }\n          \n          // Ensure createdAt is a Date object\n          const createdAtDate = log.createdAt instanceof Date ? log.createdAt : new Date(log.createdAt);\n          if (isNaN(createdAtDate.getTime())) {\n            console.warn(`‚ö†Ô∏è Entry ${log.id} has invalid createdAt: ${log.createdAt}, skipping date check`);\n            return false;\n          }\n          \n          // Convert createdAt to user's local date using their timezone offset\n          const logDate = new Date(createdAtDate.getTime() - (tzMin * 60 * 1000));\n          const logYear = logDate.getUTCFullYear();\n          const logMonth = logDate.getUTCMonth();\n          const logDay = logDate.getUTCDate();\n          \n          // Compare with requested date\n          const [reqYear, reqMonth, reqDay] = validatedDateStr.split('-').map((v) => parseInt(v, 10));\n          const matchesDate = logYear === reqYear && logMonth === (reqMonth - 1) && logDay === reqDay;\n          \n          // Also check UTC window as fallback (for entries created exactly at boundaries)\n          const logTime = createdAtDate.getTime();\n          const isInWindow = logTime >= start.getTime() && logTime <= end.getTime();\n          \n          // Include if either the calendar date matches OR it's within the UTC window\n          const shouldInclude = matchesDate || isInWindow;\n          \n          // Debug logging for entries that might be filtered out incorrectly\n          if (!shouldInclude && log.localDate && log.localDate !== validatedDateStr) {\n            const logDateStr = `${logYear}-${String(logMonth + 1).padStart(2, '0')}-${String(logDay).padStart(2, '0')}`;\n            console.log(`‚ö†Ô∏è Entry filtered out: localDate=${log.localDate}, createdAt date=${logDateStr}, requested=${validatedDateStr}, matchesDate=${matchesDate}, inWindow=${isInWindow}`);\n          }\n          \n          return shouldInclude;\n        }\n        \n        return false;\n      } catch (error) {\n        console.error(`‚ùå Error filtering log entry ${log.id}:`, error);\n        // On error, exclude the entry to prevent breaking the entire response\n        return false;\n      }\n    })\n    \n    // üõ°Ô∏è GUARD RAIL: Deduplication (REQUIRED)\n    // Remove duplicates (in case an entry matches multiple OR conditions)\n    // DO NOT remove this step - multiple OR conditions can return same entry multiple times\n    const uniqueLogs = filteredLogs.filter((log, index, self) => \n      index === self.findIndex((l) => l.id === log.id)\n    )\n\n    console.log(`üìä GET /api/food-log - Found ${uniqueLogs.length} entries for date ${validatedDateStr} (from ${logs.length} total matches)`)\n    \n    // Debug: Log entries that were filtered out to help diagnose missing entries\n    if (logs.length > uniqueLogs.length) {\n      const filteredOut = logs.filter((log) => {\n        const inUnique = uniqueLogs.some((u) => u.id === log.id);\n        return !inUnique;\n      });\n      console.log(`‚ö†Ô∏è Filtered out ${filteredOut.length} entries that didn't match date ${validatedDateStr}:`, \n        filteredOut.map((l) => ({\n          id: l.id,\n          localDate: l.localDate,\n          createdAt: l.createdAt.toISOString(),\n          name: l.name?.substring(0, 30)\n        }))\n      );\n    }\n\n    // Auto-heal: if an entry matches this requested date by createdAt but its stored localDate differs,\n    // correct the localDate so it stops leaking across adjacent days in future queries.\n    try {\n      const mismatchIds = uniqueLogs\n        .filter((l) => l.localDate !== validatedDateStr)\n        .map((l) => l.id as string);\n      if (mismatchIds.length > 0) {\n        prisma.foodLog\n          .updateMany({\n            where: { id: { in: mismatchIds } },\n            data: { localDate: validatedDateStr },\n          })\n          .catch((err) =>\n            console.warn('‚ö†Ô∏è GET /api/food-log - Failed to auto-heal localDate for ids', mismatchIds, err),\n          );\n      }\n    } catch (healErr) {\n      console.warn('‚ö†Ô∏è GET /api/food-log - Auto-heal localDate guard failed', healErr);\n    }\n    \n    console.log(`‚úÖ GET /api/food-log - Success: Returning ${uniqueLogs.length} entries for date ${validatedDateStr}`);\n    return NextResponse.json({ success: true, logs: uniqueLogs })\n  } catch (error) {\n    console.error('‚ùå GET /api/food-log - Error:', {\n      error,\n      message: error instanceof Error ? error.message : String(error),\n      stack: error instanceof Error ? error.stack : undefined,\n      dateStr: dateStr || 'null',\n      tzOffsetMinRaw: tzOffsetMinRaw || 'null'\n    });\n    return NextResponse.json({ \n      error: 'Failed to load logs',\n      details: error instanceof Error ? error.message : String(error)\n    }, { status: 500 })\n  }\n}\n\n// Append a log entry (non-blocking usage recommended)\nexport async function POST(request: NextRequest) {\n  const startTime = Date.now()\n  let userId: string | null = null\n  let userEmail: string | null = null\n  \n  try {\n    console.log('üì• POST /api/food-log - Request received')\n    \n    // Ensure localDate column exists (forward-compatible migration)\n    // This prevents \"column does not exist\" errors if migration hasn't run\n    // try {\n    //   await prisma.$executeRawUnsafe('ALTER TABLE \"FoodLog\" ADD COLUMN IF NOT EXISTS \"localDate\" TEXT')\n    //   console.log('‚úÖ POST /api/food-log - Verified localDate column exists')\n    // } catch (migrationError) {\n    //   // Safe to ignore if column already exists or other migration issues\n    //   console.warn('‚ö†Ô∏è POST /api/food-log - localDate column check (safe to ignore if exists):', migrationError)\n    // }\n    \n    // Robust auth: try session first, then JWT token (same pattern as /api/analyze-food)\n    let session = await getServerSession(authOptions)\n    userEmail = session?.user?.email ?? null\n    let usedTokenFallback = false\n\n    if (!userEmail) {\n      try {\n        const token = await getToken({\n          req: request,\n          secret: process.env.NEXTAUTH_SECRET || process.env.AUTH_SECRET || 'helfi-secret-key-production-2024',\n        })\n        if (token?.email) {\n          userEmail = String(token.email)\n          usedTokenFallback = true\n        }\n      } catch (tokenError) {\n        console.error('‚ùå POST /api/food-log - JWT auth fallback failed:', tokenError)\n      }\n    }\n\n    console.log('POST /api/food-log auth result:', {\n      hasSession: !!session,\n      sessionEmail: session?.user?.email ?? null,\n      resolvedEmail: userEmail,\n      usedTokenFallback,\n    })\n\n    if (!userEmail) {\n      console.error('‚ùå POST /api/food-log - Authentication failed: no session or token email')\n      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 })\n    }\n    \n    console.log('‚úÖ POST /api/food-log - Authenticated user:', userEmail)\n    \n    const user = await prisma.user.findUnique({ where: { email: userEmail } })\n    if (!user) {\n      console.error('‚ùå POST /api/food-log - User not found:', userEmail)\n      return NextResponse.json({ error: 'User not found' }, { status: 404 })\n    }\n    \n    userId = user.id\n    console.log('‚úÖ POST /api/food-log - Found user:', { userId, email: userEmail })\n\n    const body = await request.json()\n    const { description, nutrition, imageUrl, items, localDate, meal, category, createdAt } = body || {}\n\n    const normalizedMeal = normalizeMealCategory(meal ?? category)\n    const storedCategory = normalizedMeal ?? (typeof category === 'string' ? category.trim() : null)\n    \n    // Validate and normalize localDate - must be YYYY-MM-DD format\n    let normalizedLocalDate: string | null = null\n    if (localDate && typeof localDate === 'string' && localDate.length >= 8) {\n      // Check if it matches YYYY-MM-DD format\n      const datePattern = /^\\d{4}-\\d{2}-\\d{2}$/\n      if (datePattern.test(localDate)) {\n        normalizedLocalDate = localDate\n      } else {\n        console.warn('‚ö†Ô∏è POST /api/food-log - Invalid localDate format, attempting to parse:', localDate)\n        // Try to parse and reformat\n        try {\n          const parsed = new Date(localDate)\n          if (!isNaN(parsed.getTime())) {\n            const y = parsed.getFullYear()\n            const m = String(parsed.getMonth() + 1).padStart(2, '0')\n            const d = String(parsed.getDate()).padStart(2, '0')\n            normalizedLocalDate = `${y}-${m}-${d}`\n            console.log('‚úÖ POST /api/food-log - Normalized localDate:', normalizedLocalDate)\n          }\n        } catch (e) {\n          console.error('‚ùå POST /api/food-log - Failed to parse localDate:', localDate, e)\n        }\n      }\n    }\n    \n    if (!normalizedLocalDate) {\n      console.warn('‚ö†Ô∏è POST /api/food-log - No valid localDate provided, entry will not be queryable by date:', {\n        providedLocalDate: localDate,\n        type: typeof localDate,\n      })\n    }\n    \n    // Optional createdAt override so the saved timestamp matches the intended local day/time\n    let normalizedCreatedAt: Date | null = null\n    if (createdAt) {\n      try {\n        const candidate =\n          createdAt instanceof Date\n            ? createdAt\n            : typeof createdAt === 'number'\n            ? new Date(createdAt)\n            : new Date(createdAt)\n        if (!isNaN(candidate.getTime())) {\n          normalizedCreatedAt = candidate\n        } else {\n          console.warn('‚ö†Ô∏è POST /api/food-log - Invalid createdAt, ignoring:', createdAt)\n        }\n      } catch (e) {\n        console.warn('‚ö†Ô∏è POST /api/food-log - Failed to parse createdAt override, ignoring:', e)\n      }\n    }\n\n    console.log('üì¶ POST /api/food-log - Request body:', {\n      hasDescription: !!description,\n      descriptionLength: description?.toString().length || 0,\n      descriptionPreview: description?.toString().substring(0, 100) || '',\n      hasNutrition: !!nutrition,\n      hasImageUrl: !!imageUrl,\n      hasItems: Array.isArray(items) && items.length > 0,\n      itemCount: Array.isArray(items) ? items.length : 0,\n      providedLocalDate: localDate || 'MISSING',\n      normalizedLocalDate: normalizedLocalDate || 'NULL',\n      localDateType: typeof localDate,\n      normalizedMeal,\n      normalizedCreatedAt: normalizedCreatedAt ? normalizedCreatedAt.toISOString() : 'server default',\n    })\n    \n    let storedImageUrl = typeof imageUrl === 'string' ? imageUrl.trim() : ''\n    if (storedImageUrl && isDataUrl(storedImageUrl)) {\n      storedImageUrl = await uploadFoodPhoto(user.id, storedImageUrl)\n    }\n    if (storedImageUrl && !isRemoteUrl(storedImageUrl)) {\n      storedImageUrl = ''\n    }\n\n    const name = (description || '')\n      .toString()\n      .split('\\n')[0]\n      .split('Calories:')[0]\n      .split(',')[0]\n      .split('.')[0]\n      .trim() || 'Food item'\n\n    console.log('üíæ POST /api/food-log - Creating FoodLog entry:', {\n      userId,\n      name,\n      localDate: normalizedLocalDate,\n      hasDescription: !!description,\n      hasNutrition: !!nutrition,\n      hasImageUrl: !!imageUrl,\n      hasItems: Array.isArray(items) && items.length > 0,\n      normalizedMeal,\n    })\n\n    // Guard: prevent near-identical duplicates within a short window\n    try {\n      const dedupeWindowMs = 5 * 60 * 1000 // 5 minutes\n      const fallbackDate = normalizedLocalDate || (() => {\n        const d = normalizedCreatedAt || new Date()\n        const y = d.getFullYear()\n        const m = String(d.getMonth() + 1).padStart(2, '0')\n        const day = String(d.getDate()).padStart(2, '0')\n        return `${y}-${m}-${day}`\n      })()\n      const windowStart = new Date((normalizedCreatedAt || new Date()).getTime() - dedupeWindowMs)\n      const windowEnd = new Date((normalizedCreatedAt || new Date()).getTime() + dedupeWindowMs)\n      const normalizedDesc = (description || '').toString().trim().toLowerCase()\n      const existing = await prisma.foodLog.findMany({\n        where: {\n          userId: user.id,\n          OR: [\n            { localDate: normalizedLocalDate ?? undefined },\n            { localDate: fallbackDate },\n            { localDate: null },\n          ],\n          createdAt: { gte: windowStart, lte: windowEnd },\n        },\n        orderBy: { createdAt: 'desc' },\n        take: 5,\n      })\n      const duplicate = existing.find((e) => {\n        const descMatch = (e.description || '').toString().trim().toLowerCase() === normalizedDesc\n        const catMatch = normalizeMealCategory(e.meal ?? e.category) === normalizedMeal\n        return descMatch && catMatch\n      })\n      if (duplicate) {\n        console.log('AGENT_DEBUG dedupe: reused existing FoodLog instead of creating new', {\n          duplicateId: duplicate.id,\n          localDate: duplicate.localDate,\n          createdAt: duplicate.createdAt,\n          normalizedMeal,\n        })\n        return NextResponse.json({ success: true, id: duplicate.id, deduped: true })\n      }\n    } catch (dedupeErr) {\n      console.warn('AGENT_DEBUG dedupe check failed (non-blocking)', dedupeErr)\n    }\n\n    const created = await prisma.foodLog.create({\n      data: {\n        userId: user.id,\n        name,\n        description: description || null,\n        imageUrl: storedImageUrl || null,\n        nutrients: nutrition || null,\n        items: Array.isArray(items) && items.length > 0 ? items : Prisma.JsonNull,\n        localDate: normalizedLocalDate,\n        meal: normalizedMeal,\n        category: storedCategory,\n        createdAt: normalizedCreatedAt || undefined,\n      },\n    })\n\n    const duration = Date.now() - startTime\n    console.log('‚úÖ POST /api/food-log - Successfully created FoodLog entry:', {\n      foodLogId: created.id,\n      userId,\n      localDate: created.localDate,\n      createdAt: created.createdAt.toISOString(),\n      durationMs: duration,\n    })\n\n    // Trigger background regeneration of nutrition insights\n    // This happens asynchronously - user doesn't wait\n    triggerBackgroundRegeneration({\n      userId: user.id,\n      changeType: 'food',\n      timestamp: new Date(),\n    }).catch((error) => {\n      console.warn('‚ö†Ô∏è Failed to trigger nutrition insights regeneration', error)\n    })\n\n    console.log('üîÑ Triggered background regeneration for nutrition insights')\n\n    return NextResponse.json({ success: true, id: created.id })\n  } catch (error) {\n    const duration = Date.now() - startTime\n    console.error('‚ùå POST /api/food-log - Error:', {\n      error,\n      message: error instanceof Error ? error.message : String(error),\n      stack: error instanceof Error ? error.stack : undefined,\n      userId,\n      userEmail,\n      durationMs: duration,\n    })\n    \n    // Provide more detailed error information\n    if (error instanceof Error) {\n      console.error('‚ùå Error details:', {\n        name: error.name,\n        message: error.message,\n        stack: error.stack,\n      })\n    }\n    \n    return NextResponse.json({ \n      error: 'Failed to save log',\n      details: error instanceof Error ? error.message : String(error)\n    }, { status: 500 })\n  }\n}\n\n// Update an existing log entry\nexport async function PUT(request: NextRequest) {\n  const startTime = Date.now()\n  let userEmail: string | null = null\n\n  try {\n    let session = await getServerSession(authOptions)\n    userEmail = session?.user?.email ?? null\n    let usedTokenFallback = false\n\n    if (!userEmail) {\n      try {\n        const token = await getToken({\n          req: request,\n          secret: process.env.NEXTAUTH_SECRET || process.env.AUTH_SECRET || 'helfi-secret-key-production-2024',\n        })\n        if (token?.email) {\n          userEmail = String(token.email)\n          usedTokenFallback = true\n        }\n      } catch (tokenError) {\n        console.error('‚ùå PUT /api/food-log - JWT auth fallback failed:', tokenError)\n      }\n    }\n\n    if (!userEmail) {\n      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 })\n    }\n\n    const user = await prisma.user.findUnique({ where: { email: userEmail } })\n    if (!user) {\n      return NextResponse.json({ error: 'User not found' }, { status: 404 })\n    }\n\n    const body = await request.json()\n    const { id, description, nutrition, imageUrl, items, localDate, meal, category, createdAt } = body || {}\n\n    const logId = typeof id === 'string' && id.trim().length > 0 ? id.trim() : null\n    if (!logId) {\n      return NextResponse.json({ error: 'Missing id' }, { status: 400 })\n    }\n\n    const existing = await prisma.foodLog.findUnique({ where: { id: logId as any } })\n    if (!existing || existing.userId !== user.id) {\n      return NextResponse.json({ error: 'Not found' }, { status: 404 })\n    }\n\n    const normalizedMeal = normalizeMealCategory(meal ?? category ?? existing.meal ?? existing.category)\n    const storedCategory = normalizedMeal ?? (typeof category === 'string' ? category.trim() : existing.category)\n\n    let normalizedLocalDate: string | null = existing.localDate || null\n    if (localDate && typeof localDate === 'string' && localDate.length >= 8) {\n      const datePattern = /^\\d{4}-\\d{2}-\\d{2}$/\n      if (datePattern.test(localDate)) {\n        normalizedLocalDate = localDate\n      } else {\n        try {\n          const parsed = new Date(localDate)\n          if (!isNaN(parsed.getTime())) {\n            const y = parsed.getFullYear()\n            const m = String(parsed.getMonth() + 1).padStart(2, '0')\n            const d = String(parsed.getDate()).padStart(2, '0')\n            normalizedLocalDate = `${y}-${m}-${d}`\n          }\n        } catch (e) {\n          console.error('‚ùå PUT /api/food-log - Failed to parse localDate:', localDate, e)\n        }\n      }\n    }\n\n    let storedImageUrl = typeof imageUrl === 'string' ? imageUrl.trim() : ''\n    if (storedImageUrl && isDataUrl(storedImageUrl)) {\n      storedImageUrl = await uploadFoodPhoto(user.id, storedImageUrl)\n    }\n    if (storedImageUrl && !isRemoteUrl(storedImageUrl)) {\n      storedImageUrl = ''\n    }\n\n    const name = (description || existing.description || existing.name || '')\n      .toString()\n      .split('\\n')[0]\n      .split('Calories:')[0]\n      .split(',')[0]\n      .split('.')[0]\n      .trim() || existing.name || 'Food item'\n\n    // Optional createdAt override\n    let normalizedCreatedAt: Date | undefined = undefined\n    if (createdAt) {\n      try {\n        const candidate =\n          createdAt instanceof Date\n            ? createdAt\n            : typeof createdAt === 'number'\n            ? new Date(createdAt)\n            : new Date(createdAt)\n        if (!isNaN(candidate.getTime())) {\n          normalizedCreatedAt = candidate\n        }\n      } catch (e) {\n        console.warn('‚ö†Ô∏è PUT /api/food-log - Failed to parse createdAt override, ignoring:', e)\n      }\n    }\n\n    const updated = await prisma.foodLog.update({\n      where: { id: logId as any },\n      data: {\n        name,\n        description: description || null,\n        imageUrl: storedImageUrl || null,\n        nutrients: nutrition || null,\n        items: Array.isArray(items) && items.length > 0 ? items : Prisma.JsonNull,\n        localDate: normalizedLocalDate,\n        meal: normalizedMeal,\n        category: storedCategory,\n        createdAt: normalizedCreatedAt,\n      },\n    })\n\n    triggerBackgroundRegeneration({\n      userId: user.id,\n      changeType: 'food',\n      timestamp: new Date(),\n    }).catch((error) => {\n      console.warn('‚ö†Ô∏è Failed to trigger nutrition insights regeneration after update', error)\n    })\n\n    return NextResponse.json({ success: true, id: updated.id })\n  } catch (error) {\n    const duration = Date.now() - startTime\n    console.error('‚ùå PUT /api/food-log - Error:', {\n      error,\n      message: error instanceof Error ? error.message : String(error),\n      durationMs: duration,\n    })\n    return NextResponse.json({ error: 'Failed to update log' }, { status: 500 })\n  }\n}\n\n// Legacy DELETE handler kept for compatibility with older clients\n// Newer clients can use POST /api/food-log/delete, but both share the same logic.\nexport async function DELETE(request: NextRequest) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.email) {\n      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 })\n    }\n    const user = await prisma.user.findUnique({ where: { email: session.user.email } })\n    if (!user) {\n      return NextResponse.json({ error: 'User not found' }, { status: 404 })\n    }\n\n    const body = await request.json().catch(() => ({} as any))\n    const id = String((body as any)?.id || '').trim()\n    if (!id) {\n      return NextResponse.json({ error: 'Missing id' }, { status: 400 })\n    }\n\n    // Ensure the log belongs to the user\n    const existing = await prisma.foodLog.findUnique({ where: { id: id as any } })\n    if (!existing || existing.userId !== user.id) {\n      return NextResponse.json({ error: 'Not found' }, { status: 404 })\n    }\n\n    const imageUrl = typeof existing.imageUrl === 'string' ? existing.imageUrl : null\n    await prisma.foodLog.delete({ where: { id: id as any } })\n    try {\n      await deleteFoodPhotosIfUnused([imageUrl])\n    } catch (cleanupError) {\n      console.warn('AGENT_DEBUG', JSON.stringify({ hypothesisId: 'PHOTO_CLEAN', location: 'app/api/food-log/route.ts:DELETE:cleanup', message: 'Food photo cleanup failed (non-blocking)', timestamp: Date.now() }))\n      console.warn(cleanupError)\n    }\n    return NextResponse.json({ success: true })\n  } catch (error) {\n    console.error('DELETE /api/food-log error', error)\n    return NextResponse.json({ error: 'Failed to delete log' }, { status: 500 })\n  }\n}\n","truncated":false,"size":33698},{"path":"app/api/garmin/data/route.ts","content":"export const dynamic = 'force-dynamic'\n\nimport { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\nimport { ensureGarminSchema } from '@/lib/garmin-db'\n\ntype DataType = 'steps' | 'heartrate' | 'sleep' | 'weight'\n\nfunction parseDate(input: string | null): Date | null {\n  if (!input) return null\n  const [y, m, d] = input.split('-').map((v) => parseInt(v, 10))\n  if (!y || !m || !d) return null\n  const dt = new Date(Date.UTC(y, (m || 1) - 1, d || 1))\n  return Number.isNaN(dt.getTime()) ? null : dt\n}\n\nfunction formatYmd(d: Date): string {\n  const y = d.getUTCFullYear()\n  const m = String(d.getUTCMonth() + 1).padStart(2, '0')\n  const day = String(d.getUTCDate()).padStart(2, '0')\n  return `${y}-${m}-${day}`\n}\n\nfunction unwrapPayload(payload: any) {\n  if (!payload) return payload\n  if (typeof payload === 'object' && payload.data && typeof payload.data === 'object') return payload.data\n  return payload\n}\n\nfunction payloadHasUserId(payload: any, expectedUserId: string) {\n  const stack: any[] = [payload]\n  while (stack.length) {\n    const node = stack.pop()\n    if (!node) continue\n    if (Array.isArray(node)) {\n      for (const item of node) stack.push(item)\n      continue\n    }\n    if (typeof node !== 'object') continue\n\n    const possible = (node.userId ?? node.userid ?? node.user_id) as unknown\n    if (typeof possible === 'string' && possible === expectedUserId) return true\n\n    for (const v of Object.values(node)) stack.push(v)\n  }\n  return false\n}\n\nfunction toNumber(value: unknown): number | null {\n  if (value == null) return null\n  const n = typeof value === 'number' ? value : Number(value)\n  return Number.isFinite(n) ? n : null\n}\n\nfunction extractDateYmd(record: any): string | null {\n  if (!record || typeof record !== 'object') return null\n\n  const dateLike = [\n    record.calendarDate,\n    record.summaryDate,\n    record.date,\n    record.day,\n    record.localDate,\n    record.startDate,\n  ].find((v: any) => typeof v === 'string' && /^\\d{4}-\\d{2}-\\d{2}/.test(v))\n\n  if (typeof dateLike === 'string') return dateLike.slice(0, 10)\n\n  const epochSeconds = toNumber(record.startTimeInSeconds ?? record.startTimestampInSeconds ?? record.startTimeSeconds)\n  if (epochSeconds && epochSeconds > 0) {\n    const dt = new Date(epochSeconds * 1000)\n    return Number.isNaN(dt.getTime()) ? null : formatYmd(dt)\n  }\n\n  const epochMillis = toNumber(record.startTimeInMillis ?? record.startTimestampInMillis ?? record.startTimeMilliseconds)\n  if (epochMillis && epochMillis > 0) {\n    const dt = new Date(epochMillis)\n    return Number.isNaN(dt.getTime()) ? null : formatYmd(dt)\n  }\n\n  return null\n}\n\nfunction findCandidateArrays(payload: any, baseType: string) {\n  const candidates: any[][] = []\n  if (!payload || typeof payload !== 'object') return candidates\n\n  const keysToTry = [\n    baseType,\n    baseType.replace(/-/g, '_'),\n    baseType.replace(/-/g, ''),\n    baseType.endsWith('s') ? baseType.slice(0, -1) : `${baseType}s`,\n  ]\n\n  for (const key of keysToTry) {\n    const v = (payload as any)[key]\n    if (Array.isArray(v)) candidates.push(v)\n  }\n\n  if (candidates.length) return candidates\n\n  for (const v of Object.values(payload)) {\n    if (Array.isArray(v) && v.some((x) => x && typeof x === 'object')) {\n      candidates.push(v as any[])\n    }\n  }\n\n  return candidates\n}\n\nfunction extractMetricsFromRecord(baseType: string, record: any) {\n  const ymd = extractDateYmd(record)\n  if (!ymd) return null\n\n  const normalizedType = baseType.toLowerCase()\n  const out: {\n    date: string\n    steps?: number\n    calories?: number\n    distanceKm?: number\n    restingHeartRate?: number\n    sleepMinutes?: number\n    weightKg?: number\n  } = { date: ymd }\n\n  // Steps / Daily summaries often carry steps, calories, distance, RHR.\n  const steps =\n    toNumber(record.steps ?? record.stepCount ?? record.totalSteps ?? record.stepsInDay) ??\n    null\n  if (steps != null && steps >= 0) out.steps = Math.round(steps)\n\n  const calories =\n    toNumber(record.activeKilocalories ?? record.totalKilocalories ?? record.kilocalories ?? record.calories) ??\n    null\n  if (calories != null && calories >= 0) out.calories = Math.round(calories)\n\n  const distMeters =\n    toNumber(record.distanceInMeters ?? record.distanceMeters ?? record.totalDistanceInMeters) ?? null\n  if (distMeters != null && distMeters >= 0) out.distanceKm = distMeters / 1000\n\n  const rhr =\n    toNumber(\n      record.restingHeartRateInBeatsPerMinute ??\n        record.restingHeartRate ??\n        record.restingHr ??\n        record.rhr\n    ) ?? null\n  if (rhr != null && rhr > 0) out.restingHeartRate = Math.round(rhr)\n\n  // Sleep endpoints usually carry a duration in seconds.\n  if (normalizedType.includes('sleep')) {\n    const sleepSeconds =\n      toNumber(\n        record.sleepTimeInSeconds ??\n          record.totalSleepTimeInSeconds ??\n          record.durationInSeconds ??\n          record.sleepSeconds ??\n          record.totalSleepSeconds\n      ) ?? null\n    if (sleepSeconds != null && sleepSeconds > 0) out.sleepMinutes = Math.round(sleepSeconds / 60)\n  }\n\n  // Body comps often carry weight in grams.\n  if (normalizedType.includes('body') || normalizedType.includes('comp') || normalizedType.includes('weight')) {\n    const grams = toNumber(record.weightInGrams) ?? null\n    const kg =\n      toNumber(record.weightInKiloGrams ?? record.weightKg) ??\n      (grams != null ? grams / 1000 : null) ??\n      null\n    if (kg != null && kg > 0) out.weightKg = kg\n  }\n\n  // If we don‚Äôt know the endpoint, still accept common fields.\n  if (!normalizedType.includes('sleep') && out.sleepMinutes == null) {\n    const sleepSeconds = toNumber(record.sleepTimeInSeconds ?? record.totalSleepTimeInSeconds ?? record.durationInSeconds)\n    if (sleepSeconds != null && sleepSeconds > 0) out.sleepMinutes = Math.round(sleepSeconds / 60)\n  }\n\n  return out\n}\n\nexport async function GET(request: NextRequest) {\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.id) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n\n  // Defensive: this repo doesn‚Äôt automatically run migrations on deploy.\n  // Ensure Garmin tables exist before we query them.\n  try {\n    await ensureGarminSchema()\n  } catch {}\n\n  const account = await prisma.account.findFirst({\n    where: { userId: session.user.id, provider: 'garmin' },\n    select: { providerAccountId: true },\n  })\n\n  const searchParams = request.nextUrl.searchParams\n  const dataTypesParam = (searchParams.get('dataTypes') || '').trim()\n  const requestedTypes = dataTypesParam\n    ? (dataTypesParam.split(',').map((s) => s.trim().toLowerCase()) as DataType[])\n    : (['steps', 'heartrate', 'sleep', 'weight'] as DataType[])\n\n  const endParam = parseDate(searchParams.get('end'))\n  const startParam = parseDate(searchParams.get('start'))\n\n  const endDate = endParam || new Date()\n  const startDate =\n    startParam ||\n    new Date(Date.UTC(endDate.getUTCFullYear(), endDate.getUTCMonth(), endDate.getUTCDate() - 29))\n\n  const start = new Date(Date.UTC(startDate.getUTCFullYear(), startDate.getUTCMonth(), startDate.getUTCDate()))\n  const end = new Date(Date.UTC(endDate.getUTCFullYear(), endDate.getUTCMonth(), endDate.getUTCDate()))\n\n  const series: {\n    steps: Array<{ date: string; steps?: number; calories?: number; distanceKm?: number }>\n    heartrate: Array<{ date: string; restingHeartRate?: number }>\n    sleep: Array<{ date: string; minutes?: number }>\n    weight: Array<{ date: string; weightKg?: number }>\n  } = { steps: [], heartrate: [], sleep: [], weight: [] }\n\n  // Scaffold inclusive date range\n  const dayCount = Math.max(1, Math.floor((end.getTime() - start.getTime()) / (24 * 60 * 60 * 1000)) + 1)\n  const dates: string[] = []\n  for (let i = 0; i < dayCount; i++) {\n    const dt = new Date(start.getTime() + i * 24 * 60 * 60 * 1000)\n    dates.push(formatYmd(dt))\n  }\n  for (const d of dates) {\n    series.steps.push({ date: d })\n    series.heartrate.push({ date: d })\n    series.sleep.push({ date: d })\n    series.weight.push({ date: d })\n  }\n\n  // Pull recent logs and derive daily metrics.\n  const rawLogs = await prisma.garminWebhookLog.findMany({\n    where: account?.providerAccountId\n      ? {\n          OR: [{ userId: session.user.id }, { userId: null }],\n        }\n      : { userId: session.user.id },\n    orderBy: { receivedAt: 'desc' },\n    take: 1500,\n    select: { id: true, userId: true, dataType: true, payload: true, receivedAt: true },\n  })\n\n  // If we have a Garmin user id, attach any recent unassigned logs that obviously belong to this user.\n  const extraIdsToAttach: string[] = []\n  const logs = rawLogs.filter((l) => {\n    if (l.userId === session.user.id) return true\n    if (!account?.providerAccountId) return false\n    if (l.userId != null) return false\n    const ok = payloadHasUserId(l.payload, account.providerAccountId)\n    if (ok) extraIdsToAttach.push(l.id)\n    return ok\n  })\n\n  if (extraIdsToAttach.length) {\n    await prisma.garminWebhookLog.updateMany({\n      where: { id: { in: extraIdsToAttach.slice(0, 100) } },\n      data: { userId: session.user.id },\n    })\n  }\n\n  const byDate = new Map<string, ReturnType<typeof extractMetricsFromRecord>>()\n\n  for (const log of logs) {\n    const baseType = (log.dataType || 'default').split('/')[0]\n    const payload = unwrapPayload(log.payload)\n    const arrays = findCandidateArrays(payload, baseType)\n\n    const considerRecords = (records: any[]) => {\n      for (const record of records) {\n        const extracted = extractMetricsFromRecord(baseType, record)\n        if (!extracted) continue\n        const date = extracted.date\n        if (date < dates[0] || date > dates[dates.length - 1]) continue\n\n        // We process newest logs first; only fill missing values so ‚Äúlatest wins‚Äù.\n        const current = byDate.get(date) || ({ date } as any)\n        const next: any = { ...current }\n\n        if (next.steps == null && extracted.steps != null) next.steps = extracted.steps\n        if (next.calories == null && extracted.calories != null) next.calories = extracted.calories\n        if (next.distanceKm == null && extracted.distanceKm != null) next.distanceKm = extracted.distanceKm\n        if (next.restingHeartRate == null && extracted.restingHeartRate != null) next.restingHeartRate = extracted.restingHeartRate\n        if (next.sleepMinutes == null && extracted.sleepMinutes != null) next.sleepMinutes = extracted.sleepMinutes\n        if (next.weightKg == null && extracted.weightKg != null) next.weightKg = extracted.weightKg\n\n        byDate.set(date, next)\n      }\n    }\n\n    if (arrays.length) {\n      for (const arr of arrays) considerRecords(arr)\n    } else if (payload && typeof payload === 'object') {\n      considerRecords([payload])\n    }\n  }\n\n  // Apply extracted metrics into series\n  for (let i = 0; i < dates.length; i++) {\n    const d = dates[i]\n    const row: any = byDate.get(d)\n    if (!row) continue\n\n    if (requestedTypes.includes('steps')) {\n      series.steps[i] = {\n        date: d,\n        steps: row.steps ?? undefined,\n        calories: row.calories ?? undefined,\n        distanceKm: row.distanceKm ?? undefined,\n      }\n    }\n    if (requestedTypes.includes('heartrate')) {\n      series.heartrate[i] = { date: d, restingHeartRate: row.restingHeartRate ?? undefined }\n    }\n    if (requestedTypes.includes('sleep')) {\n      series.sleep[i] = { date: d, minutes: row.sleepMinutes ?? undefined }\n    }\n    if (requestedTypes.includes('weight')) {\n      series.weight[i] = { date: d, weightKg: row.weightKg ?? undefined }\n    }\n  }\n\n  return NextResponse.json({\n    success: true,\n    provider: 'garmin',\n    range: { start: dates[0], end: dates[dates.length - 1] },\n    series,\n  })\n}\n","truncated":false,"size":11789},{"path":"app/api/garmin/process/route.ts","content":"export const runtime = 'nodejs'\nexport const dynamic = 'force-dynamic'\n\nimport { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\nimport { assertGarminConfigured } from '@/lib/garmin-oauth'\nimport { extractGarminWorkouts } from '@/lib/exercise/garmin-workouts'\nimport { ingestExerciseEntry } from '@/lib/exercise/ingest'\nimport { ensureGarminSchema } from '@/lib/garmin-db'\nimport { isSchedulerAuthorized } from '@/lib/scheduler-auth'\n\nfunction collectGarminUserIdsAndCallbacks(payload: unknown) {\n  const userIds = new Set<string>()\n  const callbacks: Array<{ url: string; userId?: string }> = []\n\n  const visit = (node: any) => {\n    if (!node) return\n    if (Array.isArray(node)) {\n      for (const item of node) visit(item)\n      return\n    }\n    if (typeof node !== 'object') return\n\n    const possibleUserId = (node.userId ?? node.userid ?? node.user_id) as unknown\n    if (typeof possibleUserId === 'string' && possibleUserId.trim()) {\n      userIds.add(possibleUserId.trim())\n    }\n\n    const callbackRaw = (node.callbackURL ?? node.callbackUrl) as unknown\n    if (typeof callbackRaw === 'string' && callbackRaw.trim()) {\n      callbacks.push({\n        url: callbackRaw.trim(),\n        userId: typeof possibleUserId === 'string' && possibleUserId.trim() ? possibleUserId.trim() : undefined,\n      })\n    }\n\n    for (const value of Object.values(node)) visit(value)\n  }\n\n  visit(payload)\n  return { userIds: Array.from(userIds), callbacks }\n}\n\nasync function pullGarminCallbackUrl(callbackUrl: string, garminClientId: string, timeoutMs: number) {\n  const controller = new AbortController()\n  const timeout = setTimeout(() => controller.abort(), timeoutMs)\n  try {\n    const resp = await fetch(callbackUrl, {\n      method: 'GET',\n      headers: {\n        Accept: 'application/json',\n        'garmin-client-id': garminClientId,\n      },\n      signal: controller.signal,\n    })\n\n    const text = await resp.text()\n    let parsed: any = null\n    try {\n      parsed = text ? JSON.parse(text) : {}\n    } catch {\n      parsed = { raw: text }\n    }\n\n    return { ok: resp.ok, status: resp.status, payload: parsed }\n  } finally {\n    clearTimeout(timeout)\n  }\n}\n\nexport async function POST(req: NextRequest) {\n  try {\n    try {\n      await ensureGarminSchema()\n    } catch {}\n\n    if (!isSchedulerAuthorized(req)) {\n      return NextResponse.json({ error: 'unauthorized' }, { status: 401 })\n    }\n\n    const body = (await req.json().catch(() => ({}))) as { logId?: string }\n    const logId = String(body.logId || '')\n    if (!logId) return NextResponse.json({ error: 'missing_log_id' }, { status: 400 })\n\n    const log = await prisma.garminWebhookLog.findFirst({\n      where: { id: logId },\n      select: { id: true, userId: true, oauthToken: true, dataType: true, payload: true, receivedAt: true },\n    })\n    if (!log) return NextResponse.json({ error: 'log_not_found' }, { status: 404 })\n\n    const { clientId } = assertGarminConfigured()\n    const { userIds, callbacks } = collectGarminUserIdsAndCallbacks(log.payload)\n    const primaryGarminUserId = userIds[0] || null\n\n    // Ensure the log is linked to the correct Helfi user when possible.\n    let resolvedUserId: string | null = log.userId || null\n    if (!resolvedUserId && primaryGarminUserId) {\n      const account = await prisma.account.findFirst({\n        where: { provider: 'garmin', providerAccountId: primaryGarminUserId },\n        select: { userId: true },\n      })\n      resolvedUserId = account?.userId || null\n      if (resolvedUserId) {\n        await prisma.garminWebhookLog.update({ where: { id: log.id }, data: { userId: resolvedUserId } })\n      }\n    }\n\n    // Pull callback URLs (PING/PULL model) and store results as additional logs.\n    const pulledPayloads: any[] = []\n    for (const cb of callbacks.slice(0, 10)) {\n      let cbUserId: string | null = resolvedUserId\n      if (!cbUserId && cb.userId) {\n        const account = await prisma.account.findFirst({\n          where: { provider: 'garmin', providerAccountId: cb.userId },\n          select: { userId: true },\n        })\n        cbUserId = account?.userId || null\n      }\n\n      try {\n        const pulled = await pullGarminCallbackUrl(cb.url, clientId, 10_000)\n        pulledPayloads.push(pulled.payload)\n        await prisma.garminWebhookLog.create({\n          data: {\n            userId: cbUserId,\n            oauthToken: log.oauthToken,\n            dataType: `${log.dataType || 'default'}/pulled`,\n            payload: {\n              callbackUrl: cb.url,\n              ok: pulled.ok,\n              status: pulled.status,\n              data: pulled.payload,\n            },\n          },\n        })\n      } catch (error) {\n        await prisma.garminWebhookLog.create({\n          data: {\n            userId: cbUserId,\n            oauthToken: log.oauthToken,\n            dataType: `${log.dataType || 'default'}/pull_error`,\n            payload: {\n              callbackUrl: cb.url,\n              error: (error as Error)?.message || String(error),\n            },\n          },\n        })\n      }\n    }\n\n    // Best-effort exercise ingestion (from the original payload + any pulled payloads).\n    if (resolvedUserId) {\n      try {\n        const combined = [log.payload, ...pulledPayloads]\n        for (const payload of combined) {\n          const workouts = extractGarminWorkouts(payload).slice(0, 25)\n          for (const w of workouts) {\n            if (!w.startTime) continue\n            const localDate = `${w.startTime.getUTCFullYear()}-${String(w.startTime.getUTCMonth() + 1).padStart(2, '0')}-${String(w.startTime.getUTCDate()).padStart(2, '0')}`\n            await ingestExerciseEntry({\n              userId: resolvedUserId,\n              source: 'GARMIN',\n              deviceId: `garmin:${w.deviceId}`,\n              localDate,\n              startTime: w.startTime,\n              durationMinutes: w.durationMinutes,\n              calories: w.calories,\n              label: w.label,\n              rawPayload: w.raw,\n            })\n          }\n        }\n      } catch (error) {\n        console.warn('‚ö†Ô∏è Garmin process exercise ingest failed:', error)\n      }\n    }\n\n    return NextResponse.json({ ok: true, pulled: callbacks.length })\n  } catch (error: any) {\n    console.error('[GARMIN_PROCESS] error', error?.stack || error)\n    return NextResponse.json({ error: 'process_error', message: error?.message || String(error) }, { status: 500 })\n  }\n}\n","truncated":false,"size":6429},{"path":"app/api/garmin/status/route.ts","content":"import { NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\nimport { deregisterGarminUser } from '@/lib/garmin-oauth'\nimport { ensureGarminSchema } from '@/lib/garmin-db'\n\nexport const dynamic = 'force-dynamic'\nexport const runtime = 'nodejs'\n\nexport async function GET() {\n  const session = await getServerSession(authOptions)\n\n  if (!session?.user?.id) {\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  }\n\n  const account = await prisma.account.findFirst({\n    where: {\n      userId: session.user.id,\n      provider: 'garmin',\n    },\n    select: { providerAccountId: true, access_token: true, userId: true },\n  })\n\n  let webhookCount = 0\n  let lastWebhookAt: string | null = null\n  let lastDataType: string | null = null\n\n  try {\n    // Backfill: older Garmin deliveries may have been stored before we correctly mapped them to a Helfi user.\n    // If we know the Garmin user id for this Helfi user, we can retro-attach recent logs.\n    if (account?.providerAccountId) {\n      const recentUnassigned = await prisma.garminWebhookLog.findMany({\n        where: { userId: null },\n        orderBy: { receivedAt: 'desc' },\n        take: 200,\n        select: { id: true, payload: true },\n      })\n\n      const matches: string[] = []\n      for (const row of recentUnassigned) {\n        const payload: any = row.payload\n        const stack: any[] = [payload]\n        let found = false\n        while (stack.length && !found) {\n          const node = stack.pop()\n          if (!node) continue\n          if (Array.isArray(node)) {\n            for (const item of node) stack.push(item)\n            continue\n          }\n          if (typeof node !== 'object') continue\n\n          const possible = (node.userId ?? node.userid ?? node.user_id) as unknown\n          if (typeof possible === 'string' && possible === account.providerAccountId) {\n            found = true\n            break\n          }\n          for (const v of Object.values(node)) stack.push(v)\n        }\n        if (found) matches.push(row.id)\n        if (matches.length >= 50) break\n      }\n\n      if (matches.length) {\n        await prisma.garminWebhookLog.updateMany({\n          where: { id: { in: matches } },\n          data: { userId: session.user.id },\n        })\n      }\n    }\n\n    const [count, lastWebhook] = await Promise.all([\n      prisma.garminWebhookLog.count({ where: { userId: session.user.id } }),\n      prisma.garminWebhookLog.findFirst({\n        where: { userId: session.user.id },\n        orderBy: { receivedAt: 'desc' },\n        select: { receivedAt: true, dataType: true },\n      }),\n    ])\n\n    webhookCount = count\n    lastWebhookAt = lastWebhook?.receivedAt?.toISOString() || null\n    lastDataType = lastWebhook?.dataType || null\n  } catch (error: any) {\n    // If Garmin tables aren‚Äôt present yet in prod, create them and return a minimal status.\n    const message = String(error?.message || '')\n    if (error?.code === 'P2021' || message.includes('does not exist') || message.includes('relation')) {\n      try {\n        await ensureGarminSchema()\n      } catch {}\n    } else {\n      console.warn('‚ö†Ô∏è Garmin status enrichment failed:', error)\n    }\n  }\n\n  return NextResponse.json({\n    connected: !!account,\n    garminUserId: account?.providerAccountId || null,\n    webhookCount,\n    lastWebhookAt,\n    lastDataType,\n  })\n}\n\nexport async function DELETE() {\n  const session = await getServerSession(authOptions)\n\n  if (!session?.user?.id) {\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  }\n\n  const account = await prisma.account.findFirst({\n    where: {\n      userId: session.user.id,\n      provider: 'garmin',\n    },\n  })\n\n  if (!account) {\n    return NextResponse.json({ success: true, message: 'Not connected' })\n  }\n\n  try {\n    if (account.access_token) {\n      const resp = await deregisterGarminUser(account.access_token)\n      if (!resp.ok) {\n        console.warn('‚ö†Ô∏è Failed to deregister Garmin user:', resp.status, await resp.text())\n      }\n    }\n  } catch (error) {\n    console.warn('‚ö†Ô∏è Garmin deregistration error:', error)\n  }\n\n  await prisma.account.delete({ where: { id: account.id } })\n  await prisma.garminWebhookLog.deleteMany({ where: { userId: session.user.id } })\n\n  return NextResponse.json({ success: true })\n}\n","truncated":false,"size":4389},{"path":"app/api/garmin/webhook/[[...dataType]]/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\nimport { assertGarminConfigured, parseBearerToken, parseOAuthHeader } from '@/lib/garmin-oauth'\nimport { publishWithQStash } from '@/lib/qstash'\nimport { ensureGarminSchema } from '@/lib/garmin-db'\n\nexport const dynamic = 'force-dynamic'\nexport const runtime = 'nodejs'\n\ntype RouteParams = {\n  params: {\n    dataType?: string[]\n  }\n}\n\nfunction collectGarminUserIdsAndCallbacks(payload: unknown) {\n  const userIds = new Set<string>()\n  const callbacks: Array<{ url: string; userId?: string }> = []\n\n  const visit = (node: any) => {\n    if (!node) return\n    if (Array.isArray(node)) {\n      for (const item of node) visit(item)\n      return\n    }\n    if (typeof node !== 'object') return\n\n    const possibleUserId = (node.userId ?? node.userid ?? node.user_id) as unknown\n    if (typeof possibleUserId === 'string' && possibleUserId.trim()) {\n      userIds.add(possibleUserId.trim())\n    }\n\n    const callbackRaw = (node.callbackURL ?? node.callbackUrl) as unknown\n    if (typeof callbackRaw === 'string' && callbackRaw.trim()) {\n      callbacks.push({\n        url: callbackRaw.trim(),\n        userId: typeof possibleUserId === 'string' && possibleUserId.trim() ? possibleUserId.trim() : undefined,\n      })\n    }\n\n    for (const value of Object.values(node)) visit(value)\n  }\n\n  visit(payload)\n  return { userIds: Array.from(userIds), callbacks }\n}\n\nexport async function POST(request: NextRequest, { params }: RouteParams) {\n  const rawBody = await request.text()\n  const oauthHeader = request.headers.get('authorization')\n  const oauthParams = parseOAuthHeader(oauthHeader)\n  const bearerToken = parseBearerToken(oauthHeader)\n\n  const dataType = params?.dataType?.length ? params.dataType.join('/') : 'default'\n\n  let payload: any\n  try {\n    payload = rawBody ? JSON.parse(rawBody) : {}\n  } catch {\n    payload = { raw: rawBody }\n  }\n\n  try {\n    assertGarminConfigured()\n  } catch (error) {\n    console.error('Garmin webhook received but credentials missing:', error)\n    return NextResponse.json({ error: 'Garmin not configured' }, { status: 500 })\n  }\n\n  // Defensive: ensure tables exist before we start receiving live Garmin deliveries.\n  // (This repo doesn‚Äôt automatically run migrations on deploy.)\n  try {\n    await ensureGarminSchema()\n  } catch {}\n\n  const oauthToken = oauthParams?.oauth_token || null\n  const tokenToMatch = bearerToken || oauthToken || null\n  let userId: string | null = null\n\n  const { userIds: garminUserIds, callbacks } = collectGarminUserIdsAndCallbacks(payload)\n  const primaryGarminUserId = garminUserIds[0] || null\n\n  try {\n    if (primaryGarminUserId) {\n      const account = await prisma.account.findFirst({\n        where: { provider: 'garmin', providerAccountId: primaryGarminUserId },\n        select: { userId: true },\n      })\n      userId = account?.userId || null\n    }\n\n    if (!userId && tokenToMatch) {\n      const account = await prisma.account.findFirst({\n        where: {\n          provider: 'garmin',\n          OR: [{ access_token: tokenToMatch }, { providerAccountId: tokenToMatch }],\n        },\n        select: { userId: true },\n      })\n      userId = account?.userId || null\n    }\n  } catch (error) {\n    console.warn('‚ö†Ô∏è Garmin webhook user mapping failed:', error)\n    userId = null\n  }\n\n  try {\n    const created = await prisma.garminWebhookLog.create({\n      data: {\n        userId,\n        oauthToken,\n        dataType,\n        payload,\n      },\n    })\n\n    // Garmin production requirement: respond HTTP 200 quickly (within 30 seconds).\n    // Queue any heavier processing (PING/PULL callback pulls + ingestion) to a background job.\n    if (callbacks.length || primaryGarminUserId || userId) {\n      publishWithQStash('/api/garmin/process', { logId: created.id }).catch(() => {})\n    }\n  } catch (error) {\n    console.warn('‚ö†Ô∏è Garmin webhook logging failed:', error)\n  }\n\n  return new NextResponse('OK', { status: 200 })\n}\n\n// Optional health check / verification endpoint\nexport async function GET() {\n  return NextResponse.json({ status: 'ok' })\n}\n","truncated":false,"size":4118},{"path":"app/api/health-setup-status/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth/next'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\n\n// ‚ö†Ô∏è HEALTH SETUP GUARD RAIL\n// This endpoint is the single source of truth for lightweight Health Setup\n// status checks (used by the 5-minute reminder). It MUST:\n// - Use the same \"onboarding complete\" definition as HEALTH_SETUP_PROTECTION.md.\n// - Respect the account-wide \"__HEALTH_SETUP_REMINDER_DISABLED__\" flag.\n// - Only control reminders, NOT actual access gates (Insights gating lives in\n//   lib/insights/issue-engine.ts and app/insights/page.tsx).\n// Do NOT repurpose this endpoint for other auth/redirect logic without\n// reading HEALTH_SETUP_PROTECTION.md and getting explicit user approval.\n\n// This endpoint provides a lightweight view of a user's health setup status\n// so that the UI can decide when to show reminders without loading the full\n// onboarding payload.\n\nexport async function GET() {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.email) {\n      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 })\n    }\n\n    const user = await prisma.user.findUnique({\n      where: { email: session.user.email },\n      include: {\n        healthGoals: {\n          select: {\n            name: true,\n          },\n        },\n        supplements: {\n          select: { id: true },\n        },\n        medications: {\n          select: { id: true },\n        },\n      },\n    })\n\n    if (!user) {\n      return NextResponse.json({ error: 'User not found' }, { status: 404 })\n    }\n\n    const visibleGoals = user.healthGoals.filter((goal) => !goal.name.startsWith('__'))\n    const hasBasicProfile = !!(user.gender && user.weight && user.height)\n    const hasGoals = visibleGoals.length > 0\n    const hasOtherHealthData = user.supplements.length > 0 || user.medications.length > 0\n\n    const complete = hasBasicProfile && hasGoals\n    const partial = !complete && (hasBasicProfile || hasGoals || hasOtherHealthData)\n\n    const reminderRecord = user.healthGoals.find(\n      (goal) => goal.name === '__HEALTH_SETUP_REMINDER_DISABLED__'\n    )\n    const reminderDisabled = !!reminderRecord\n\n    return NextResponse.json({\n      complete,\n      partial,\n      reminderDisabled,\n    })\n  } catch (error) {\n    console.error('Error in GET /api/health-setup-status:', error)\n    return NextResponse.json({ error: 'Server error' }, { status: 500 })\n  }\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.email) {\n      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 })\n    }\n\n    const body = await request.json().catch(() => ({}))\n    const disableReminder = body?.disableReminder === true\n\n    const user = await prisma.user.findUnique({\n      where: { email: session.user.email },\n      select: { id: true },\n    })\n\n    if (!user) {\n      return NextResponse.json({ error: 'User not found' }, { status: 404 })\n    }\n\n    if (disableReminder) {\n      const existing = await prisma.healthGoal.findFirst({\n        where: { userId: user.id, name: '__HEALTH_SETUP_REMINDER_DISABLED__' },\n      })\n\n      const payload = {\n        disabled: true,\n        updatedAt: new Date().toISOString(),\n      }\n\n      if (existing) {\n        await prisma.healthGoal.update({\n          where: { id: existing.id },\n          data: { category: JSON.stringify(payload) },\n        })\n      } else {\n        await prisma.healthGoal.create({\n          data: {\n            userId: user.id,\n            name: '__HEALTH_SETUP_REMINDER_DISABLED__',\n            category: JSON.stringify(payload),\n            currentRating: 0,\n          },\n        })\n      }\n    }\n\n    return NextResponse.json({ success: true })\n  } catch (error) {\n    console.error('Error in POST /api/health-setup-status:', error)\n    return NextResponse.json({ error: 'Server error' }, { status: 500 })\n  }\n}\n\n\n","truncated":false,"size":4020},{"path":"app/api/health-tips/history/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\n\nexport async function GET(req: NextRequest) {\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.email) {\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  }\n\n  const user = await prisma.user.findUnique({ where: { email: session.user.email } })\n  if (!user) {\n    return NextResponse.json({ error: 'User not found' }, { status: 404 })\n  }\n\n  const { searchParams } = new URL(req.url)\n\n  // Ensure table exists\n  await prisma.$executeRawUnsafe(`\n    CREATE TABLE IF NOT EXISTS HealthTips (\n      id TEXT PRIMARY KEY,\n      userId TEXT NOT NULL,\n      tipDate DATE NOT NULL,\n      sentAt TIMESTAMP NOT NULL DEFAULT NOW(),\n      title TEXT NOT NULL,\n      body TEXT NOT NULL,\n      category TEXT NOT NULL,\n      metadata JSONB,\n      costCents INTEGER,\n      chargeCents INTEGER\n    )\n  `)\n\n  // Work out the effective timezone for this user (match scheduling)\n  let effectiveTimezone =\n    Intl.DateTimeFormat().resolvedOptions().timeZone || 'Australia/Melbourne'\n  try {\n    await prisma.$executeRawUnsafe(`\n      CREATE TABLE IF NOT EXISTS HealthTipSettings (\n        userId TEXT PRIMARY KEY,\n        enabled BOOLEAN NOT NULL DEFAULT true,\n        time1 TEXT NOT NULL,\n        time2 TEXT NOT NULL,\n        time3 TEXT NOT NULL,\n        timezone TEXT NOT NULL,\n        frequency INTEGER NOT NULL DEFAULT 1,\n        focusFood BOOLEAN NOT NULL DEFAULT true,\n        focusSupplements BOOLEAN NOT NULL DEFAULT true,\n        focusLifestyle BOOLEAN NOT NULL DEFAULT true\n      )\n    `)\n    const rows: Array<{ timezone: string }> = await prisma.$queryRawUnsafe(\n      `SELECT timezone FROM HealthTipSettings WHERE userId = $1`,\n      user.id\n    )\n    if (rows.length > 0 && rows[0].timezone) {\n      effectiveTimezone = rows[0].timezone\n    }\n  } catch {\n    // ignore ‚Äì fall back to environment timezone above\n  }\n\n  // Default to the last 30 local days when no explicit range is provided\n  const now = new Date()\n  const localFormatter = new Intl.DateTimeFormat('en-GB', {\n    timeZone: effectiveTimezone,\n    year: 'numeric',\n    month: '2-digit',\n    day: '2-digit',\n  })\n\n  const endParam = searchParams.get('end')\n  const startParam = searchParams.get('start')\n\n  const endParts = localFormatter.formatToParts(now)\n  const todayStr = `${endParts.find((p) => p.type === 'year')?.value}-${endParts\n    .find((p) => p.type === 'month')\n    ?.value}-${endParts.find((p) => p.type === 'day')?.value}`\n\n  const startDate = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000)\n  const startParts = localFormatter.formatToParts(startDate)\n  const defaultStartStr = `${startParts.find((p) => p.type === 'year')?.value}-${startParts\n    .find((p) => p.type === 'month')\n    ?.value}-${startParts.find((p) => p.type === 'day')?.value}`\n\n  const start = startParam || defaultStartStr\n  const end = endParam || todayStr\n\n  const tips: Array<{\n    id: string\n    tipDate: string\n    sentAt: Date\n    title: string\n    body: string\n    category: string\n    costCents: number | null\n    chargeCents: number | null\n    suggestedQuestions: any\n  }> = await prisma.$queryRawUnsafe(\n    `SELECT \n       id,\n       tipDate AS \"tipDate\",\n       sentAt AS \"sentAt\",\n       title,\n       body,\n       category,\n       costCents,\n       chargeCents,\n       metadata->'suggestedQuestions' AS \"suggestedQuestions\"\n     FROM HealthTips\n     WHERE userId = $1 AND tipDate BETWEEN $2::date AND $3::date\n     ORDER BY tipDate DESC, sentAt DESC`,\n    user.id,\n    start,\n    end\n  )\n\n  const tipsWithSuggestions = tips.map((tip) => {\n    const raw = tip.suggestedQuestions\n    const suggestions =\n      Array.isArray(raw) && raw.length > 0\n        ? raw.filter((q) => typeof q === 'string' && q.trim().length > 0).slice(0, 3)\n        : []\n    return {\n      ...tip,\n      suggestedQuestions: suggestions,\n    }\n  })\n\n  return NextResponse.json({ tips: tipsWithSuggestions })\n}\n\n\n","truncated":false,"size":4077},{"path":"app/api/health-tips/settings/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\nimport { scheduleHealthTipWithQStash } from '@/lib/qstash'\n\nasync function ensureHealthTipSettingsTable() {\n  await prisma.$executeRawUnsafe(`\n    CREATE TABLE IF NOT EXISTS HealthTipSettings (\n      userId TEXT PRIMARY KEY,\n      enabled BOOLEAN NOT NULL DEFAULT true,\n      time1 TEXT NOT NULL,\n      time2 TEXT NOT NULL,\n      time3 TEXT NOT NULL,\n      timezone TEXT NOT NULL,\n      frequency INTEGER NOT NULL DEFAULT 1,\n      focusFood BOOLEAN NOT NULL DEFAULT true,\n      focusSupplements BOOLEAN NOT NULL DEFAULT true,\n      focusLifestyle BOOLEAN NOT NULL DEFAULT true\n    )\n  `)\n\n  // Defensive migrations in case the table was created before new columns were added\n  await prisma.$executeRawUnsafe(\n    `ALTER TABLE HealthTipSettings ADD COLUMN IF NOT EXISTS enabled BOOLEAN NOT NULL DEFAULT true`\n  ).catch(() => {})\n  await prisma.$executeRawUnsafe(\n    `ALTER TABLE HealthTipSettings ADD COLUMN IF NOT EXISTS time2 TEXT NOT NULL DEFAULT '15:30'`\n  ).catch(() => {})\n  await prisma.$executeRawUnsafe(\n    `ALTER TABLE HealthTipSettings ADD COLUMN IF NOT EXISTS time3 TEXT NOT NULL DEFAULT '20:30'`\n  ).catch(() => {})\n  await prisma.$executeRawUnsafe(\n    `ALTER TABLE HealthTipSettings ADD COLUMN IF NOT EXISTS frequency INTEGER NOT NULL DEFAULT 1`\n  ).catch(() => {})\n  await prisma.$executeRawUnsafe(\n    `ALTER TABLE HealthTipSettings ADD COLUMN IF NOT EXISTS focusFood BOOLEAN NOT NULL DEFAULT true`\n  ).catch(() => {})\n  await prisma.$executeRawUnsafe(\n    `ALTER TABLE HealthTipSettings ADD COLUMN IF NOT EXISTS focusSupplements BOOLEAN NOT NULL DEFAULT true`\n  ).catch(() => {})\n  await prisma.$executeRawUnsafe(\n    `ALTER TABLE HealthTipSettings ADD COLUMN IF NOT EXISTS focusLifestyle BOOLEAN NOT NULL DEFAULT true`\n  ).catch(() => {})\n}\n\n/**\n * Health Tip Settings\n *\n * Lets users control:\n * - enabled: whether AI health tips are active\n * - frequency: 1‚Äì3 tips per day\n * - time1, time2, time3: local reminder times (HH:MM, 24h)\n * - timezone: IANA timezone string\n * - focus flags: which categories to prioritise (food, supplements, lifestyle)\n */\n\nexport async function GET() {\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.email) {\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  }\n\n  const user = await prisma.user.findUnique({ where: { email: session.user.email } })\n  if (!user) {\n    return NextResponse.json({ error: 'User not found' }, { status: 404 })\n  }\n\n  await ensureHealthTipSettingsTable()\n\n  // Ensure table exists with full schema\n  // await prisma.$executeRawUnsafe(`\n  //   CREATE TABLE IF NOT EXISTS HealthTipSettings (\n  //     userId TEXT PRIMARY KEY,\n  //     enabled BOOLEAN NOT NULL DEFAULT true,\n  //     time1 TEXT NOT NULL,\n  //     time2 TEXT NOT NULL,\n  //     time3 TEXT NOT NULL,\n  //     timezone TEXT NOT NULL,\n  //     frequency INTEGER NOT NULL DEFAULT 1,\n  //     focusFood BOOLEAN NOT NULL DEFAULT true,\n  //     focusSupplements BOOLEAN NOT NULL DEFAULT true,\n  //     focusLifestyle BOOLEAN NOT NULL DEFAULT true\n  //   )\n  // `)\n\n  // // Defensive migrations for new columns in case table was created with an older shape\n  // await prisma.$executeRawUnsafe(\n  //   `ALTER TABLE HealthTipSettings ADD COLUMN IF NOT EXISTS enabled BOOLEAN NOT NULL DEFAULT true`\n  // ).catch(() => {})\n  // await prisma.$executeRawUnsafe(\n  //   `ALTER TABLE HealthTipSettings ADD COLUMN IF NOT EXISTS time2 TEXT NOT NULL DEFAULT '15:30'`\n  // ).catch(() => {})\n  // await prisma.$executeRawUnsafe(\n  //   `ALTER TABLE HealthTipSettings ADD COLUMN IF NOT EXISTS time3 TEXT NOT NULL DEFAULT '20:30'`\n  // ).catch(() => {})\n  // await prisma.$executeRawUnsafe(\n  //   `ALTER TABLE HealthTipSettings ADD COLUMN IF NOT EXISTS frequency INTEGER NOT NULL DEFAULT 1`\n  // ).catch(() => {})\n  // await prisma.$executeRawUnsafe(\n  //   `ALTER TABLE HealthTipSettings ADD COLUMN IF NOT EXISTS focusFood BOOLEAN NOT NULL DEFAULT true`\n  // ).catch(() => {})\n  // await prisma.$executeRawUnsafe(\n  //   `ALTER TABLE HealthTipSettings ADD COLUMN IF NOT EXISTS focusSupplements BOOLEAN NOT NULL DEFAULT true`\n  // ).catch(() => {})\n  // await prisma.$executeRawUnsafe(\n  //   `ALTER TABLE HealthTipSettings ADD COLUMN IF NOT EXISTS focusLifestyle BOOLEAN NOT NULL DEFAULT true`\n  // ).catch(() => {})\n\n  // Explicit column aliases to preserve camelCase keys in the JSON result (Postgres lowercases names by default).\n  const rows: Array<{\n    enabled: boolean\n    time1: string\n    time2: string\n    time3: string\n    timezone: string\n    frequency: number\n    focusFood: boolean\n    focusSupplements: boolean\n    focusLifestyle: boolean\n  }> = await prisma.$queryRawUnsafe(\n    `SELECT\n        enabled AS \"enabled\",\n        time1 AS \"time1\",\n        time2 AS \"time2\",\n        time3 AS \"time3\",\n        timezone AS \"timezone\",\n        frequency AS \"frequency\",\n        focusFood AS \"focusFood\",\n        focusSupplements AS \"focusSupplements\",\n        focusLifestyle AS \"focusLifestyle\"\n     FROM HealthTipSettings\n     WHERE userId = $1`,\n    user.id\n  )\n\n  if (rows.length > 0) {\n    return NextResponse.json(rows[0])\n  }\n\n  // Default settings when user has never configured health tips\n  const defaultTimezone =\n    Intl.DateTimeFormat().resolvedOptions().timeZone || 'Australia/Melbourne'\n\n  return NextResponse.json({\n    enabled: false,\n    time1: '11:30',\n    time2: '15:30',\n    time3: '20:30',\n    timezone: defaultTimezone,\n    frequency: 1,\n    focusFood: true,\n    focusSupplements: true,\n    focusLifestyle: true,\n  })\n}\n\nexport async function POST(req: NextRequest) {\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.email) {\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  }\n  const user = await prisma.user.findUnique({ where: { email: session.user.email } })\n  if (!user) {\n    return NextResponse.json({ error: 'User not found' }, { status: 404 })\n  }\n\n  const body = await req.json().catch(() => ({}))\n  let {\n    enabled,\n    time1,\n    time2,\n    time3,\n    timezone,\n    frequency,\n    focusFood,\n    focusSupplements,\n    focusLifestyle,\n  } = body as any\n\n  const normalizeTime = (input?: string, defaultValue = '11:30'): string => {\n    if (!input) return defaultValue\n    const s = String(input).trim().toLowerCase()\n    // 24h HH:MM\n    const m24 = s.match(/^([01]?\\d|2[0-3]):([0-5]\\d)$/)\n    if (m24) return `${m24[1].padStart(2, '0')}:${m24[2]}`\n    // 12h like 7:30 pm\n    const m12 = s.match(/^([0-1]?\\d):([0-5]\\d)\\s*(am|pm)$/)\n    if (m12) {\n      let h = parseInt(m12[1], 10)\n      const mm = m12[2]\n      const ap = m12[3]\n      if (ap === 'pm' && h !== 12) h += 12\n      if (ap === 'am' && h === 12) h = 0\n      return `${String(h).padStart(2, '0')}:${mm}`\n    }\n    // Fallback: strip non-digits and interpret as HHMM\n    const digits = s.replace(/[^0-9]/g, '')\n    if (digits.length >= 3) {\n      const h = parseInt(digits.slice(0, digits.length - 2), 10)\n      const mm = parseInt(digits.slice(-2), 10)\n      const hhClamped = Math.max(0, Math.min(23, h))\n      const mmClamped = Math.max(0, Math.min(59, mm))\n      return `${String(hhClamped).padStart(2, '0')}:${String(mmClamped).padStart(\n        2,\n        '0'\n      )}`\n    }\n    return defaultValue\n  }\n\n  enabled = !!enabled\n  time1 = normalizeTime(time1, '11:30')\n  time2 = normalizeTime(time2, '15:30')\n  time3 = normalizeTime(time3, '20:30')\n  timezone =\n    (timezone && String(timezone).trim()) ||\n    Intl.DateTimeFormat().resolvedOptions().timeZone ||\n    'Australia/Melbourne'\n  frequency = Math.max(1, Math.min(3, parseInt(String(frequency || 1), 10)))\n  // Convert to boolean explicitly, handling both string and boolean inputs\n  focusFood = focusFood === false || focusFood === 'false' ? false : Boolean(focusFood ?? true)\n  focusSupplements = focusSupplements === false || focusSupplements === 'false' ? false : Boolean(focusSupplements ?? true)\n  focusLifestyle = focusLifestyle === false || focusLifestyle === 'false' ? false : Boolean(focusLifestyle ?? true)\n\n  try {\n    await ensureHealthTipSettingsTable()\n\n    // await prisma.$executeRawUnsafe(`\n    //   CREATE TABLE IF NOT EXISTS HealthTipSettings (\n    //     userId TEXT PRIMARY KEY,\n    //     enabled BOOLEAN NOT NULL DEFAULT true,\n    //     time1 TEXT NOT NULL,\n    //     time2 TEXT NOT NULL,\n    //     time3 TEXT NOT NULL,\n    //     timezone TEXT NOT NULL,\n    //     frequency INTEGER NOT NULL DEFAULT 1,\n    //     focusFood BOOLEAN NOT NULL DEFAULT true,\n    //     focusSupplements BOOLEAN NOT NULL DEFAULT true,\n    //     focusLifestyle BOOLEAN NOT NULL DEFAULT true\n    //   )\n    // `)\n\n    // // Defensive migrations\n    // await prisma.$executeRawUnsafe(\n    //   `ALTER TABLE HealthTipSettings ADD COLUMN IF NOT EXISTS enabled BOOLEAN NOT NULL DEFAULT true`\n    // ).catch(() => {})\n    // await prisma.$executeRawUnsafe(\n    //   `ALTER TABLE HealthTipSettings ADD COLUMN IF NOT EXISTS time2 TEXT NOT NULL DEFAULT '15:30'`\n    // ).catch(() => {})\n    // await prisma.$executeRawUnsafe(\n    //   `ALTER TABLE HealthTipSettings ADD COLUMN IF NOT EXISTS time3 TEXT NOT NULL DEFAULT '20:30'`\n    // ).catch(() => {})\n    // await prisma.$executeRawUnsafe(\n    //   `ALTER TABLE HealthTipSettings ADD COLUMN IF NOT EXISTS frequency INTEGER NOT NULL DEFAULT 1`\n    // ).catch(() => {})\n    // await prisma.$executeRawUnsafe(\n    //   `ALTER TABLE HealthTipSettings ADD COLUMN IF NOT EXISTS focusFood BOOLEAN NOT NULL DEFAULT true`\n    // ).catch(() => {})\n    // await prisma.$executeRawUnsafe(\n    //   `ALTER TABLE HealthTipSettings ADD COLUMN IF NOT EXISTS focusSupplements BOOLEAN NOT NULL DEFAULT true`\n    // ).catch(() => {})\n    // await prisma.$executeRawUnsafe(\n    //   `ALTER TABLE HealthTipSettings ADD COLUMN IF NOT EXISTS focusLifestyle BOOLEAN NOT NULL DEFAULT true`\n    // ).catch(() => {})\n\n    await prisma.$queryRawUnsafe(\n      `INSERT INTO HealthTipSettings (userId, enabled, time1, time2, time3, timezone, frequency, focusFood, focusSupplements, focusLifestyle)\n       VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10)\n       ON CONFLICT (userId) DO UPDATE SET\n         enabled          = EXCLUDED.enabled,\n         time1            = EXCLUDED.time1,\n         time2            = EXCLUDED.time2,\n         time3            = EXCLUDED.time3,\n         timezone         = EXCLUDED.timezone,\n         frequency        = EXCLUDED.frequency,\n         focusFood        = EXCLUDED.focusFood,\n         focusSupplements = EXCLUDED.focusSupplements,\n         focusLifestyle   = EXCLUDED.focusLifestyle`,\n      user.id,\n      enabled,\n      time1,\n      time2,\n      time3,\n      timezone,\n      frequency,\n      focusFood,\n      focusSupplements,\n      focusLifestyle\n    )\n\n    // Schedule AI health tip notifications only when enabled\n    let scheduleResults: any[] = []\n    if (enabled && frequency > 0) {\n      const times: string[] = []\n      if (frequency >= 1) times.push(time1)\n      if (frequency >= 2) times.push(time2)\n      if (frequency >= 3) times.push(time3)\n\n      const tasks = times.map((t) =>\n        scheduleHealthTipWithQStash(user.id, t, timezone).then((result) => ({\n          reminderTime: t,\n          ...result,\n        }))\n      )\n      scheduleResults = await Promise.all(tasks).catch((error) => {\n        console.error('[HEALTH_TIPS] Failed to schedule tips via QStash', error)\n        return []\n      })\n    }\n\n    return NextResponse.json({ success: true, scheduleResults })\n  } catch (e) {\n    console.error('health tips settings save error', e)\n    const message = e instanceof Error ? e.message : 'Unknown error'\n    return NextResponse.json(\n      { error: 'Failed to save health tip settings', detail: message },\n      { status: 500 }\n    )\n  }\n}\n","truncated":false,"size":11895},{"path":"app/api/health-tips/today/route.ts","content":"import { NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\n\nexport async function GET() {\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.email) {\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  }\n\n  const user = await prisma.user.findUnique({ where: { email: session.user.email } })\n  if (!user) {\n    return NextResponse.json({ error: 'User not found' }, { status: 404 })\n  }\n\n  // Ensure tips table exists\n  // await prisma.$executeRawUnsafe(`\n  //   CREATE TABLE IF NOT EXISTS HealthTips (\n  //     id TEXT PRIMARY KEY,\n  //     userId TEXT NOT NULL,\n  //     tipDate DATE NOT NULL,\n  //     sentAt TIMESTAMP NOT NULL DEFAULT NOW(),\n  //     title TEXT NOT NULL,\n  //     body TEXT NOT NULL,\n  //     category TEXT NOT NULL,\n  //     metadata JSONB,\n  //     costCents INTEGER,\n  //     chargeCents INTEGER\n  //   )\n  // `)\n\n  // Try to align \"today\" with the same timezone used for scheduling health tips\n  let effectiveTimezone =\n    Intl.DateTimeFormat().resolvedOptions().timeZone || 'Australia/Melbourne'\n\n  try {\n    // Ensure settings table exists so we can safely query the timezone\n    // await prisma.$executeRawUnsafe(`\n    //   CREATE TABLE IF NOT EXISTS HealthTipSettings (\n    //     userId TEXT PRIMARY KEY,\n    //     enabled BOOLEAN NOT NULL DEFAULT true,\n    //     time1 TEXT NOT NULL,\n    //     time2 TEXT NOT NULL,\n    //     time3 TEXT NOT NULL,\n    //     timezone TEXT NOT NULL,\n    //     frequency INTEGER NOT NULL DEFAULT 1,\n    //     focusFood BOOLEAN NOT NULL DEFAULT true,\n    //     focusSupplements BOOLEAN NOT NULL DEFAULT true,\n    //     focusLifestyle BOOLEAN NOT NULL DEFAULT true\n    //   )\n    // `)\n\n    const rows: Array<{ timezone: string }> = await prisma.$queryRawUnsafe(\n      `SELECT timezone FROM HealthTipSettings WHERE userId = $1`,\n      user.id\n    )\n    if (rows.length > 0 && rows[0].timezone) {\n      effectiveTimezone = rows[0].timezone\n    }\n  } catch {\n    // If anything goes wrong, fall back to environment timezone above.\n  }\n\n  // Compute \"today\" in the user's health tip timezone so it matches tipDate written by dispatch\n  const now = new Date()\n  const parts = new Intl.DateTimeFormat('en-GB', {\n    timeZone: effectiveTimezone,\n    year: 'numeric',\n    month: '2-digit',\n    day: '2-digit',\n  }).formatToParts(now)\n  const day = `${parts.find((p) => p.type === 'year')?.value}-${parts\n    .find((p) => p.type === 'month')\n    ?.value}-${parts.find((p) => p.type === 'day')?.value}`\n\n  const tips: Array<{\n    id: string\n    tipDate: string\n    sentAt: Date\n    title: string\n    body: string\n    category: string\n    costCents: number | null\n    chargeCents: number | null\n    suggestedQuestions: any\n  }> = await prisma.$queryRawUnsafe(\n    `SELECT \n       id,\n       tipDate AS \"tipDate\",\n       sentAt AS \"sentAt\",\n       title,\n       body,\n       category,\n       costCents,\n       chargeCents,\n       metadata->'suggestedQuestions' AS \"suggestedQuestions\"\n     FROM HealthTips\n     WHERE userId = $1 AND tipDate = $2::date\n     ORDER BY sentAt ASC`,\n    user.id,\n    day\n  )\n\n  // Normalise suggestedQuestions to a simple string array on the wire\n  const tipsWithSuggestions = tips.map((tip) => {\n    const raw = tip.suggestedQuestions\n    const suggestions =\n      Array.isArray(raw) && raw.length > 0\n        ? raw.filter((q) => typeof q === 'string' && q.trim().length > 0).slice(0, 3)\n        : []\n    return {\n      ...tip,\n      suggestedQuestions: suggestions,\n    }\n  })\n\n  return NextResponse.json({ tips: tipsWithSuggestions })\n}\n\n\n","truncated":false,"size":3682},{"path":"app/api/insights/ask/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\nimport { logAIUsage } from '@/lib/ai-usage-logger'\nimport { CreditManager } from '@/lib/credit-system'\nimport { capMaxTokensToBudget } from '@/lib/cost-meter'\nimport { chatCompletionWithCost } from '@/lib/metered-openai'\nimport { consumeFreeCredit, hasFreeCredits } from '@/lib/free-credits'\nimport { isSubscriptionActive } from '@/lib/subscription-utils'\n\n// Lazy OpenAI import to avoid build-time env requirements\nlet _openai: any = null\nfunction getOpenAI() {\n  if (_openai) return _openai\n  const apiKey = process.env.OPENAI_API_KEY\n  if (!apiKey) return null\n  const OpenAI = require('openai').default\n  _openai = new OpenAI({ apiKey })\n  return _openai\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) {\n      return NextResponse.json({ error: 'not_authenticated' }, { status: 401 })\n    }\n\n    const {\n      section,\n      question,\n      messages: clientMessages,\n      issue,\n    } = await request.json().catch(() => ({ section: 'safety', question: '', messages: null, issue: '' }))\n    const sec = String(section || 'safety').toLowerCase()\n    const userId = session.user.id\n\n    // Load a narrow, privacy-conscious slice of recent data for better answers\n    const user = await prisma.user.findUnique({\n      where: { id: userId },\n      include: {\n        healthGoals: true,\n        supplements: true,\n        medications: true,\n        healthLogs: { orderBy: { createdAt: 'desc' }, take: 14 },\n        foodLogs: { orderBy: { createdAt: 'desc' }, take: 10 },\n        subscription: true,\n        creditTopUps: true,\n      },\n    })\n\n    if (!user) return NextResponse.json({ error: 'user_not_found' }, { status: 404 })\n\n    const isPremium = isSubscriptionActive(user.subscription)\n    const now = new Date()\n    const hasPurchasedCredits = user.creditTopUps?.some(\n      (topUp: any) => topUp.expiresAt > now && (topUp.amountCents - topUp.usedCents) > 0\n    )\n    const hasFreeChatCredits = await hasFreeCredits(userId, 'INSIGHTS_CHAT')\n    const allowViaFreeUse = !isPremium && !hasPurchasedCredits && hasFreeChatCredits\n    if (!isPremium && !hasPurchasedCredits && !hasFreeChatCredits) {\n      return NextResponse.json(\n        {\n          error: 'Payment required',\n          message: 'You\\'ve used all your free insights chat uses. Subscribe to a monthly plan or purchase credits to continue.',\n          requiresPayment: true,\n          exhaustedFreeCredits: true,\n        },\n        { status: 402 }\n      )\n    }\n\n    const profile = {\n      gender: user.gender,\n      height: user.height,\n      weight: user.weight,\n      goals: (user.healthGoals || []).filter((g: any) => !g.name?.startsWith('__')).map((g: any) => g.name),\n      supplements: (user.supplements || []).map((s: any) => ({ name: s.name, dosage: s.dosage, timing: s.timing })),\n      medications: (user.medications || []).map((m: any) => ({ name: m.name, dosage: m.dosage, timing: m.timing })),\n      recentHealthLogs: (user.healthLogs || []).map((h: any) => ({ rating: h.rating, createdAt: h.createdAt })),\n      recentFood: (user.foodLogs || []).map((f: any) => ({ name: f.name, nutrients: f.nutrients, createdAt: f.createdAt })),\n    }\n\n    // Fallback answer if OpenAI is not configured\n    const fallback = () => {\n      const hasIron = profile.supplements.some((s) => /iron/i.test(s.name || '')) || profile.medications.some((m) => /iron/i.test(m.name || ''))\n      const hasCalcium = profile.supplements.some((s) => /calcium/i.test(s.name || '')) || profile.medications.some((m) => /calcium/i.test(m.name || ''))\n      const hasMagnesium = profile.supplements.some((s) => /magnesium/i.test(s.name || ''))\n      const tips: string[] = []\n      if (hasIron && hasCalcium) tips.push('Separate iron and calcium by ~2 hours to support absorption (check with your clinician).')\n      if (hasMagnesium) tips.push('Magnesium is often better in the evening, 1‚Äì2 hours before sleep; avoid pairing with high‚Äëfiber meals.')\n      if (tips.length === 0) tips.push('Log your current supplements/medications and daily symptoms; I will tailor specific safety/timing guidance next refresh.')\n      const answer = `Here are practical safety pointers based on your current entries:\\n- ${tips.join('\\n- ')}`\n      // Return a threaded shape for the client even in fallback\n      const history = Array.isArray(clientMessages) && clientMessages.length\n        ? clientMessages.map((m: any) => ({ role: String(m.role || 'user'), content: String(m.content || '') })).slice(-12)\n        : (question ? [{ role: 'user', content: String(question) }] : [])\n      return { messages: [...history, { role: 'assistant', content: answer }], preview: true }\n    }\n\n    const openai = getOpenAI()\n    if (!openai) return NextResponse.json(fallback(), { status: 200 })\n\n    // Build threaded chat messages\n    const baseSystem = {\n      role: 'system',\n      content: [\n        'You are a careful, non-alarming clinical assistant.',\n        `SECTION: ${sec}`,\n        'RULES:',\n        '- Never diagnose; avoid certainty; suggest to check with clinician for changes.',\n        '- Use ONLY the JSON profile provided; be specific, short, and actionable.',\n        '- Your reply should be concise and structured with short bullets where helpful.',\n        '',\n        `PROFILE JSON: ${JSON.stringify(profile)}`,\n        issue ? `ISSUE: ${String(issue)}` : '',\n      ].filter(Boolean).join('\\n'),\n    }\n\n    const history = Array.isArray(clientMessages) && clientMessages.length\n      ? clientMessages.map((m: any) => ({ role: String(m.role || 'user'), content: String(m.content || '') })).slice(-12)\n      : (question ? [{ role: 'user', content: String(question) }] : [])\n\n    const model = 'gpt-4o-mini'\n    const promptText = [baseSystem, ...history].map((m) => m.content).join('\\n')\n    let maxTokens = 400\n    if (!allowViaFreeUse) {\n      const cm = new CreditManager(userId)\n      const wallet = await cm.getWalletStatus()\n      const cappedMaxTokens = capMaxTokensToBudget(model, promptText, maxTokens, wallet.totalAvailableCents)\n      if (cappedMaxTokens <= 0) {\n        return NextResponse.json({ error: 'Insufficient credits' }, { status: 402 })\n      }\n      maxTokens = cappedMaxTokens\n    }\n\n    const wrapped = await chatCompletionWithCost(openai, {\n      model,\n      messages: [baseSystem, ...history],\n      temperature: 0.2,\n      max_tokens: maxTokens,\n    } as any)\n\n    if (!allowViaFreeUse) {\n      const cm = new CreditManager(userId)\n      const ok = await cm.chargeCents(wrapped.costCents)\n      if (!ok) {\n        return NextResponse.json({ error: 'Insufficient credits' }, { status: 402 })\n      }\n    } else {\n      await consumeFreeCredit(userId, 'INSIGHTS_CHAT')\n    }\n\n    try {\n      await logAIUsage({\n        context: { feature: 'insights:ask', userId },\n        model,\n        promptTokens: wrapped.promptTokens,\n        completionTokens: wrapped.completionTokens,\n        costCents: wrapped.costCents,\n      })\n    } catch {\n      // Ignore logging failures\n    }\n\n    const text = wrapped.completion.choices?.[0]?.message?.content || ''\n    return NextResponse.json({ messages: [...history, { role: 'assistant', content: text }], preview: false }, { status: 200 })\n  } catch (e) {\n    return NextResponse.json({ error: 'server_error' }, { status: 500 })\n  }\n}\n","truncated":false,"size":7529},{"path":"app/api/insights/detail/route.ts","content":"import { NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\n\nfunction clean(s?: string) { return (s || '').trim() }\n\nexport async function GET(request: Request) {\n  const url = new URL(request.url)\n  const issue = clean(url.searchParams.get('issue') || '')\n  const supplement = clean(url.searchParams.get('supplement') || '')\n\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) return NextResponse.json({ error: 'not_authenticated' }, { status: 401 })\n\n    // Collect minimal context\n    const user = await prisma.user.findUnique({\n      where: { id: session.user.id },\n      include: { supplements: true, medications: true, healthGoals: true }\n    })\n\n    // Build a lightweight recommendation object now (stub without OpenAI)\n    const title = issue ? issue : (supplement ? supplement : 'Insight')\n    const reason = issue\n      ? `Based on your selected issue \"${issue}\" and your current profile.`\n      : `Based on your supplement \"${supplement}\" and your current profile.`\n    const actions: string[] = []\n    if (issue) {\n      actions.push('Review daily habits that impact this issue.')\n      actions.push('Track changes for 7 days to see patterns.')\n    }\n    if (supplement) {\n      actions.push('Take with appropriate meal timing if applicable.')\n      actions.push('Check for interactions with current medications (confirm with your clinician).')\n    }\n\n    const payload = {\n      title,\n      what: issue ? `Recommendations for ${issue}.` : `Recommendations for ${supplement}.`,\n      reason,\n      actions,\n      timing: supplement ? 'Common timing: morning with food or evening as tolerated.' : undefined,\n      safety: 'This is general information. Always confirm with your clinician before changes.'\n    }\n\n    return NextResponse.json({ ok: true, data: payload }, { status: 200 })\n  } catch (e) {\n    return NextResponse.json({ error: 'server_error' }, { status: 500 })\n  }\n}\n\n\n","truncated":false,"size":2044},{"path":"app/api/insights/generate/route.ts","content":"import { NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\nimport { logAIUsage } from '@/lib/ai-usage-logger'\nimport { consumeRateLimit } from '@/lib/rate-limit'\nimport { CreditManager } from '@/lib/credit-system'\nimport { capMaxTokensToBudget } from '@/lib/cost-meter'\nimport { chatCompletionWithCost } from '@/lib/metered-openai'\n\nconst INSIGHTS_RATE_WINDOW_MS = 5 * 60 * 1000 // 5 minutes\nconst INSIGHTS_RATE_MAX = 2\n\n// Lazy OpenAI import to avoid build-time env requirements\nlet _openai: any = null\nfunction getOpenAI() {\n  if (_openai) return _openai\n  const apiKey = process.env.OPENAI_API_KEY\n  if (!apiKey) return null\n  const OpenAI = require('openai').default\n  _openai = new OpenAI({ apiKey })\n  return _openai\n}\n\nexport async function POST(request: Request) {\n  const url = new URL(request.url)\n  const preview = url.searchParams.get('preview') === '1'\n  const enabled = process.env.NEXT_PUBLIC_INSIGHTS_ENABLED === 'true'\n  if (!enabled && !preview) {\n    return NextResponse.json({ enabled: false, items: [] }, { status: 200 })\n  }\n\n  // Personalize from current user's data when available\n  let profile: any = null\n  let recentFood: any[] = []\n  let recentHealthLogs: any[] = []\n  // Aggregated nutrition snapshot for the last 7 days (best-effort, safe fallbacks)\n  let weeklyNutritionSummary: any = null\n  try {\n    const session = await getServerSession(authOptions)\n    if (session?.user?.id) {\n      profile = await prisma.user.findUnique({\n        where: { id: session.user.id },\n        include: {\n          healthGoals: true,\n          supplements: true,\n          medications: true,\n          foodLogs: {\n            orderBy: { createdAt: 'desc' },\n            take: 30,\n          },\n          healthLogs: {\n            orderBy: { createdAt: 'desc' },\n            take: 10,\n            include: { goal: true }\n          },\n        },\n      })\n      // Include nutrients when available so the AI can be specific\n      recentFood = (profile?.foodLogs || []).map((f: any) => ({ name: f.name, nutrients: f.nutrients || null, createdAt: f.createdAt }))\n      recentHealthLogs = (profile?.healthLogs || []).map((h: any) => ({ goal: h.goal?.name, rating: h.rating, createdAt: h.createdAt }))\n    }\n  } catch {\n    // non-blocking\n  }\n\n  // Compute a 7-day nutrition summary from recent food logs (best-effort)\n  try {\n    const cutoff = Date.now() - 7 * 24 * 60 * 60 * 1000\n    const last7 = recentFood.filter((f: any) => new Date(f.createdAt).getTime() >= cutoff)\n    const sums = {\n      calories: 0,\n      protein_g: 0,\n      carbs_g: 0,\n      fat_g: 0,\n      fiber_g: 0,\n      sugar_g: 0,\n      sodium_mg: 0,\n    }\n    let counted = 0\n    const foodCount: Record<string, number> = {}\n    for (const f of last7) {\n      const n = (f && f.nutrients) || {}\n      // Accept multiple possible keys commonly returned by analyzers\n      const cals = Number(n.calories ?? n.kcal ?? 0) || 0\n      const protein = Number(n.protein_g ?? n.protein ?? 0) || 0\n      const carbs = Number(n.carbs_g ?? n.carbohydrates_g ?? n.carbohydrates ?? 0) || 0\n      const fat = Number(n.fat_g ?? n.total_fat_g ?? 0) || 0\n      const fiber = Number(n.fiber_g ?? n.dietary_fiber_g ?? 0) || 0\n      const sugar = Number(n.sugar_g ?? n.sugars_g ?? 0) || 0\n      const sodium = Number(n.sodium_mg ?? n.salt_mg ?? 0) || 0\n      // Only count entries that have at least one nutrient value\n      if (cals || protein || carbs || fat || fiber || sugar || sodium) {\n        sums.calories += cals\n        sums.protein_g += protein\n        sums.carbs_g += carbs\n        sums.fat_g += fat\n        sums.fiber_g += fiber\n        sums.sugar_g += sugar\n        sums.sodium_mg += sodium\n        counted += 1\n      }\n      const key = String(f.name || '').trim().toLowerCase()\n      if (key) foodCount[key] = (foodCount[key] || 0) + 1\n    }\n    const topFoods = Object.entries(foodCount)\n      .sort((a, b) => b[1] - a[1])\n      .slice(0, 5)\n      .map(([name, count]) => ({ name, count }))\n\n    weeklyNutritionSummary = {\n      daysAnalyzed: Math.min(7, Math.max(1, Math.ceil((Date.now() - cutoff) / (24 * 60 * 60 * 1000)))),\n      entriesWithNutrients: counted,\n      totals: sums,\n      dailyAverages: {\n        calories: counted ? Math.round(sums.calories / 7) : 0,\n        protein_g: counted ? +(sums.protein_g / 7).toFixed(1) : 0,\n        carbs_g: counted ? +(sums.carbs_g / 7).toFixed(1) : 0,\n        fat_g: counted ? +(sums.fat_g / 7).toFixed(1) : 0,\n        fiber_g: counted ? +(sums.fiber_g / 7).toFixed(1) : 0,\n        sugar_g: counted ? +(sums.sugar_g / 7).toFixed(1) : 0,\n        sodium_mg: counted ? Math.round(sums.sodium_mg / 7) : 0,\n      },\n      topFoods,\n    }\n  } catch {\n    weeklyNutritionSummary = null\n  }\n\n  // Simple personalized fallback insights (used when AI call not available)\n  const fallback = () => {\n    const goals = profile?.healthGoals?.filter((g: any) => !g.name?.startsWith('__')) || []\n    const supplements = profile?.supplements || []\n    const meds = profile?.medications || []\n    const hasMagnesium = supplements.some((s: any) => /magnesium/i.test(s?.name || ''))\n    const hasIron = supplements.some((s: any) => /iron/i.test(s?.name || ''))\n    const hasCalcium = supplements.some((s: any) => /calcium/i.test(s?.name || ''))\n    const hasOmega3 = supplements.some((s: any) => /(omega|fish\\s*oil)/i.test(s?.name || ''))\n\n    const items = [\n      {\n        id: 'pf1',\n        title: goals.length ? `Weekly focus: ${goals[0].name}` : 'Set a clear weekly focus',\n        summary: goals.length ? `Prioritize ‚Äú${goals[0].name}‚Äù. Define one measurable action for this week.` : 'Choose 1‚Äì2 goals to focus on and define one measurable action.',\n        tags: ['goals'],\n        confidence: 0.7,\n        createdAt: new Date().toISOString(),\n      },\n      {\n        id: 'pf2',\n        title: hasMagnesium ? 'Optimize magnesium timing' : 'Start with simple sleep support',\n        summary: hasMagnesium ? 'You already take magnesium ‚Äî try 1‚Äì2 hours before bed and avoid pairing with high‚Äëfiber meals for absorption.' : 'If appropriate, consider evening magnesium to support sleep quality.',\n        tags: ['supplement','timing','sleep'],\n        confidence: 0.72,\n        createdAt: new Date().toISOString(),\n      },\n      {\n        id: 'pf3',\n        title: hasIron && hasCalcium ? 'Separate iron and calcium' : 'Medication/supplement spacing check',\n        summary: hasIron && hasCalcium ? 'Take iron and calcium at least 2 hours apart for absorption (check with your clinician).' : 'Review timing to avoid conflicts; spacing doses by ~2 hours can help (check with your clinician).',\n        tags: ['safety','timing'],\n        confidence: 0.66,\n        createdAt: new Date().toISOString(),\n      },\n      {\n        id: 'pf4',\n        title: 'Protein‚Äëforward breakfast',\n        summary: 'Aim for 25‚Äì35g protein at breakfast to stabilize morning energy and appetite.',\n        tags: ['nutrition','energy'],\n        confidence: 0.64,\n        createdAt: new Date().toISOString(),\n      },\n      {\n        id: 'pf5',\n        title: hasOmega3 ? 'Keep omega‚Äë3 consistent' : 'Consider omega‚Äë3 intake',\n        summary: hasOmega3 ? 'Take omega‚Äë3 with a meal containing fat for better absorption.' : 'Consider omega‚Äë3 rich foods or a supplement (discuss with your clinician).',\n        tags: ['supplement','nutrition'],\n        confidence: 0.61,\n        createdAt: new Date().toISOString(),\n      },\n      {\n        id: 'pf6',\n        title: 'Hydration + fiber baseline',\n        summary: 'Target ~2‚Äì3L fluids daily and include fiber at each meal for digestion.',\n        tags: ['hydration','nutrition'],\n        confidence: 0.6,\n        createdAt: new Date().toISOString(),\n      },\n    ]\n    return items\n  }\n\n  // Real AI generation (also allowed in preview to bypass flag safely)\n  if (preview) {\n    return NextResponse.json({ enabled: enabled || preview, items: fallback(), preview: true }, { status: 200 })\n  }\n\n  const clientIp = (request.headers.get('x-forwarded-for') || '').split(',')[0]?.trim() || 'unknown'\n  const rateKey = profile?.id ? `user:${profile.id}` : `ip:${clientIp}`\n  const rateCheck = await consumeRateLimit('insights-generate', rateKey, INSIGHTS_RATE_MAX, INSIGHTS_RATE_WINDOW_MS)\n  if (!rateCheck.allowed) {\n    const retryAfter = Math.max(1, Math.ceil(rateCheck.retryAfterMs / 1000))\n    return NextResponse.json(\n      { enabled: enabled || preview, items: fallback(), rateLimited: true },\n      { status: 429, headers: { 'Retry-After': String(retryAfter) } }\n    )\n  }\n\n  {\n    try {\n      const openai = getOpenAI()\n      if (openai && profile) {\n        const profileText = JSON.stringify({\n          gender: profile.gender,\n          weight: profile.weight,\n          height: profile.height,\n          goals: (profile.healthGoals || []).map((g: any) => g.name),\n          supplements: (profile.supplements || []).map((s: any) => ({ name: s.name, timing: s.timing })),\n          medications: (profile.medications || []).map((m: any) => ({ name: m.name, timing: m.timing })),\n          recentFood,\n          recentHealthLogs,\n          weeklyNutritionSummary,\n        })\n\n        const prompt = `You are a careful, data-driven health coach. Based ONLY on the JSON profile below, generate 6 high-value, personalized insights. Avoid generic advice. Use the user's goals, supplements, medications, recent foods (with nutrients), health logs, and the 7-day nutrition summary.\n\nReturn a JSON array of items where each item has:\n  id (string),\n  title (string),\n  summary (2‚Äì3 sentences, specific, quantified when possible),\n  tags (array of strings like ['goals','supplement','medication','nutrition','timing','safety','energy','sleep']),\n  confidence (0‚Äì1),\n  reason (string, explain the \"why\" using the provided data, cite specific numbers like grams/day or averages if available),\n  actions (array of 3‚Äì5 concrete steps tailored to the user; include amounts/timing/examples; where relevant say \"check with your clinician\").\n\nNutrition guidance rules:\n- Use weeklyNutritionSummary.dailyAverages to reference protein_g, fiber_g, sugar_g, sodium_mg, calories when available.\n- If protein appears low (< 70 g/day for average adult unless height/weight suggests otherwise), propose specific breakfast/lunch/dinner examples with grams.\n- If fiber is low (< 25 g/day), suggest concrete swaps to reach ~25‚Äì35 g/day with food examples.\n- If sugar is high (> 50 g/day) or sodium high (> 2300 mg/day), suggest reductions with practical substitutions.\n- Use recentFood to cite examples (e.g., \"based on frequent item: greek yogurt\").\n- Cross-link supplements/medications with timing and interactions (advice as \"check with your clinician\").\n\nKeep each insight skimmable but substantive. Do not return prose outside of the JSON array.\n\nProfile: ${profileText}`\n        const model = 'gpt-4o-mini'\n        const cm = new CreditManager(profile.id)\n        const wallet = await cm.getWalletStatus()\n        const maxTokens = capMaxTokensToBudget(model, prompt, 1000, wallet.totalAvailableCents)\n        if (maxTokens <= 0) {\n          return NextResponse.json({ enabled: true, items: fallback(), ai: false, requiresPayment: true }, { status: 200 })\n        }\n\n        const wrapped = await chatCompletionWithCost(openai, {\n          model,\n          messages: [{ role: 'user', content: prompt }],\n          temperature: 0.2,\n          max_tokens: maxTokens,\n        } as any)\n\n        const ok = await cm.chargeCents(wrapped.costCents)\n        if (!ok) {\n          return NextResponse.json({ enabled: true, items: fallback(), ai: false, requiresPayment: true }, { status: 200 })\n        }\n\n        try {\n          await logAIUsage({\n            context: { feature: 'insights:landing-generate', userId: profile.id },\n            model,\n            promptTokens: wrapped.promptTokens,\n            completionTokens: wrapped.completionTokens,\n            costCents: wrapped.costCents,\n          })\n        } catch {\n          // Ignore logging failures\n        }\n\n        const text = wrapped.completion.choices?.[0]?.message?.content || ''\n        // Try to extract JSON array\n        const jsonMatch = text.match(/\\[([\\s\\S]*?)\\]/)\n        const items = jsonMatch ? JSON.parse(jsonMatch[0]) : fallback()\n        try {\n          // Save to cache for faster subsequent loads\n          await prisma.$executeRawUnsafe(\n            'CREATE TABLE IF NOT EXISTS \"InsightsCache\" (\"userId\" TEXT PRIMARY KEY, \"items\" JSONB NOT NULL, \"updatedAt\" TIMESTAMPTZ NOT NULL DEFAULT NOW())'\n          )\n          await prisma.$executeRawUnsafe(\n            'INSERT INTO \"InsightsCache\" (\"userId\", \"items\", \"updatedAt\") VALUES ($1, $2::jsonb, NOW())\\n             ON CONFLICT (\"userId\") DO UPDATE SET \"items\" = EXCLUDED.\"items\", \"updatedAt\" = NOW()',\n            profile.id,\n            JSON.stringify(items)\n          )\n        } catch {}\n        return NextResponse.json({ enabled: true, items, ai: true }, { status: 200 })\n      }\n    } catch (e) {\n      // fall back below\n    }\n  }\n\n  return NextResponse.json({ enabled: true, items: fallback(), preview: true }, { status: 200 })\n}\n","truncated":false,"size":13230},{"path":"app/api/insights/issues/[slug]/regenerate-all/route.ts","content":"/**\n * ‚ö†Ô∏è CRITICAL: DO NOT MODIFY THIS FILE WITHOUT EXTREME CAUTION ‚ö†Ô∏è\n * \n * This endpoint handles regeneration of ALL insight sections for a given issue.\n * It was broken multiple times and took days to fix. The current implementation is WORKING.\n * \n * CRITICAL REQUIREMENTS THAT MUST NOT BE CHANGED:\n * \n * 1. **waitUntil is REQUIRED**: Vercel serverless functions terminate when response is sent.\n *    Without waitUntil, background promises get killed before they can update database status.\n *    This causes the progress bar to stay at 0/7 forever. DO NOT REMOVE waitUntil.\n * \n * 2. **force: true is REQUIRED**: This uses the original working approach. Previous attempts\n *    to \"optimize\" with precomputeQuickSectionsForUser broke the functionality. DO NOT CHANGE.\n * \n * 3. **Incremental status updates**: Each section MUST update status immediately after completion.\n *    This allows the progress bar to show real-time progress (1/7, 2/7, etc.). DO NOT batch updates.\n * \n * 4. **Same fingerprint**: The fingerprint computed at the start MUST be used when marking sections\n *    as 'fresh'. If fingerprints don't match, checkInsightsStatus will mark sections as 'stale'\n *    even though they're fresh, breaking the progress bar.\n * \n * 5. **Promise.all with waitUntil**: The Promise.all pattern with waitUntil ensures all sections\n *    regenerate in parallel while Vercel waits for completion. DO NOT change this pattern.\n * \n * IF YOU NEED TO MODIFY THIS FILE:\n * - Test thoroughly with the actual progress bar UI\n * - Verify status updates happen incrementally (check database after each section completes)\n * - Ensure waitUntil is still being used\n * - Do NOT \"optimize\" unless you have a proven working alternative\n * - If regeneration breaks again, REVERT IMMEDIATELY to this version\n * \n * LAST WORKING VERSION: Commit 5c3fd22 (CRITICAL FIX: Use waitUntil to prevent Vercel from killing background promises)\n * \n * @author Original fix: 2024-11-13\n * @warning DO NOT MODIFY WITHOUT USER APPROVAL\n */\n\nimport { NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { ISSUE_SECTION_ORDER, type IssueSectionKey, precomputeQuickSectionsForUser } from '@/lib/insights/issue-engine'\nimport { getIssueSection } from '@/lib/insights/issue-engine'\nimport { prisma } from '@/lib/prisma'\n\n// Lightweight fingerprint generator (mirrors logic in regeneration-service)\nfunction createDataFingerprint(data: any): string {\n  const json = JSON.stringify(data)\n  let hash = 0\n  for (let i = 0; i < json.length; i += 1) {\n    const char = json.charCodeAt(i)\n    hash = (hash << 5) - hash + char\n    hash = hash & hash\n  }\n  return hash.toString(36)\n}\n\nasync function getCurrentDataFingerprint(userId: string): Promise<string> {\n  try {\n    const user = await prisma.user.findUnique({\n      where: { id: userId },\n      include: {\n        healthGoals: { select: { name: true, currentRating: true } },\n        supplements: { select: { name: true, dosage: true, timing: true } },\n        medications: { select: { name: true, dosage: true, timing: true } },\n        foodLogs: {\n          where: {\n            createdAt: { gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) },\n          },\n          select: { name: true, nutrients: true },\n        },\n        exerciseLogs: {\n          where: {\n            createdAt: { gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) },\n          },\n          select: { type: true, duration: true },\n        },\n      },\n    })\n    if (!user) return ''\n    const relevantData = {\n      profile: {\n        gender: user.gender,\n        weight: user.weight,\n        height: user.height,\n        bodyType: user.bodyType,\n        exerciseFrequency: user.exerciseFrequency,\n      },\n      goals: user.healthGoals.map((g) => ({ name: g.name, rating: g.currentRating })),\n      supplements: user.supplements.map((s) => ({ name: s.name, dosage: s.dosage, timing: s.timing })),\n      medications: user.medications.map((m) => ({ name: m.name, dosage: m.dosage, timing: m.timing })),\n      recentFoods: user.foodLogs.length,\n      recentExercise: user.exerciseLogs.length,\n    }\n    return createDataFingerprint(relevantData)\n  } catch {\n    return ''\n  }\n}\n\nexport async function POST(\n  _request: Request,\n  context: { params: { slug: string } }\n) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const sections = ISSUE_SECTION_ORDER.filter((s) => s !== 'overview') as IssueSectionKey[]\n    \n    // Mark all sections as generating\n    try {\n      for (const section of sections) {\n        await prisma.$executeRawUnsafe(`\n          INSERT INTO \"InsightsMetadata\" (\"userId\", \"issueSlug\", \"section\", \"status\", \"updatedAt\")\n          VALUES ($1, $2, $3, 'generating', NOW())\n          ON CONFLICT (\"userId\", \"issueSlug\", \"section\")\n          DO UPDATE SET \"status\" = 'generating', \"updatedAt\" = NOW()\n        `, session.user.id, context.params.slug, section)\n      }\n    } catch (error) {\n      console.warn('[insights.api] Failed to mark sections as generating', error)\n    }\n    \n    // Compute fingerprint once\n    const fingerprint = await getCurrentDataFingerprint(session.user.id)\n    \n    // Clear all caches first to force fresh generation\n    try {\n      for (const section of sections) {\n        await prisma.$executeRawUnsafe(`\n          DELETE FROM \"InsightsCache\" \n          WHERE \"userId\" = $1 AND \"slug\" = $2 AND \"section\" = $3\n        `, session.user.id, context.params.slug, section)\n      }\n    } catch (error) {\n      console.warn('[insights.api] Failed to clear cache', error)\n    }\n    \n    // ‚ö†Ô∏è CRITICAL: waitUntil is REQUIRED - DO NOT REMOVE OR MODIFY\n    // Vercel serverless functions terminate when response is sent.\n    // Without waitUntil, background promises get killed before updating database status.\n    // This causes progress bar to stay at 0/7 forever.\n    const waitUntil = (globalThis as any).waitUntil || ((promise: Promise<any>) => {\n      // Fallback: keep promise alive by attaching error handler\n      promise.catch(() => {})\n    })\n    \n    // ‚ö†Ô∏è CRITICAL: Use force: true - this is the WORKING approach\n    // Previous attempts to \"optimize\" with precomputeQuickSectionsForUser broke functionality.\n    // DO NOT CHANGE THIS PATTERN without extensive testing.\n    const regenerationPromises = sections.map(async (section) => {\n      try {\n        console.log(`[insights.api] Starting regeneration for ${section}`)\n        \n        // Use force: true - this was working before and is still working\n        const result = await getIssueSection(session.user.id, context.params.slug, section, {\n          mode: 'latest',\n          force: true, // ‚ö†Ô∏è DO NOT CHANGE - this is what works\n        })\n        \n        if (result) {\n          // ‚ö†Ô∏è CRITICAL: Update status IMMEDIATELY after each section completes\n          // This allows progress bar to show real-time progress (1/7, 2/7, etc.)\n          // DO NOT batch these updates - they must happen incrementally\n          // ‚ö†Ô∏è CRITICAL: Use the SAME fingerprint computed at start\n          // If fingerprints don't match, checkInsightsStatus will mark sections as 'stale'\n          // even though they're fresh, breaking the progress bar\n          await prisma.$executeRawUnsafe(`\n            INSERT INTO \"InsightsMetadata\" (\"userId\", \"issueSlug\", \"section\", \"status\", \"dataFingerprint\", \"lastGeneratedAt\", \"updatedAt\")\n            VALUES ($1, $2, $3, 'fresh', $4, NOW(), NOW())\n            ON CONFLICT (\"userId\", \"issueSlug\", \"section\")\n            DO UPDATE SET \"status\" = 'fresh', \"dataFingerprint\" = $4, \"lastGeneratedAt\" = NOW(), \"updatedAt\" = NOW()\n          `, session.user.id, context.params.slug, section, fingerprint)\n          \n          console.log(`[insights.api] ‚úÖ Regenerated and marked ${section} as fresh`)\n        } else {\n          throw new Error(`No result returned for ${section}`)\n        }\n      } catch (error) {\n        console.error(`[insights.api] ‚ùå Failed to regenerate ${section}:`, error)\n        // Mark as stale on error\n        try {\n          await prisma.$executeRawUnsafe(`\n            UPDATE \"InsightsMetadata\" SET \"status\" = 'stale', \"updatedAt\" = NOW()\n            WHERE \"userId\" = $1 AND \"issueSlug\" = $2 AND \"section\" = $3\n          `, session.user.id, context.params.slug, section)\n        } catch {}\n      }\n    })\n    \n    // ‚ö†Ô∏è CRITICAL: Promise.all with waitUntil ensures all sections regenerate in parallel\n    // while Vercel waits for completion. DO NOT change this pattern.\n    const allRegenerations = Promise.all(regenerationPromises)\n    waitUntil(allRegenerations) // ‚ö†Ô∏è DO NOT REMOVE - this prevents Vercel from killing the function\n    allRegenerations.catch((error) => {\n      console.error('[insights.api] Regeneration error:', error)\n    })\n    \n    return NextResponse.json({ \n      success: true,\n      sections: sections.length,\n      message: 'Regeneration started for all sections'\n    }, { status: 200 })\n  } catch (error) {\n    console.error('POST /api/insights/issues/[slug]/regenerate-all error', error)\n    return NextResponse.json({ error: 'Failed to start regeneration' }, { status: 500 })\n  }\n}\n\n","truncated":false,"size":9332},{"path":"app/api/insights/issues/[slug]/sections/[section]/chat/route.ts","content":"import { NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport {\n  ensureChatTables,\n  getOrCreateThread,\n  listMessages,\n  appendMessage,\n  getOpenAIClient,\n  buildSystemPrompt,\n  listThreads,\n  createThread,\n  updateThreadTitle,\n} from '@/lib/insights/chat-store'\nimport type { IssueSectionKey } from '@/lib/insights/issue-engine'\nimport { prisma } from '@/lib/prisma'\nimport { CreditManager } from '@/lib/credit-system'\nimport { capMaxTokensToBudget, estimateTokensFromText } from '@/lib/cost-meter'\nimport { logAIUsage } from '@/lib/ai-usage-logger'\nimport { chatCompletionWithCost } from '@/lib/metered-openai'\nimport { consumeFreeCredit, hasFreeCredits } from '@/lib/free-credits'\nimport { isSubscriptionActive } from '@/lib/subscription-utils'\n\nconst rateMap = new Map<string, number>()\nconst MIN_INTERVAL_MS = 1500\n\nexport async function GET(\n  _request: Request,\n  context: { params: { slug: string; section: string } }\n) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n    const section = context.params.section as IssueSectionKey\n    await ensureChatTables()\n    const url = new URL(_request.url)\n    const threadId = url.searchParams.get('threadId')\n    \n    if (threadId) {\n      // Get specific thread messages\n      const messages = await listMessages(threadId, 60)\n      return NextResponse.json({ threadId, messages }, { status: 200 })\n    } else {\n      // Get or create default thread (backward compatibility)\n      const thread = await getOrCreateThread(session.user.id, context.params.slug, section)\n      const messages = await listMessages(thread.id, 60)\n      return NextResponse.json({ threadId: thread.id, messages }, { status: 200 })\n    }\n  } catch (error) {\n    console.error('[chat.GET] error', error)\n    return NextResponse.json({ error: 'server_error' }, { status: 500 })\n  }\n}\n\nexport async function DELETE(\n  _request: Request,\n  context: { params: { slug: string; section: string } }\n) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n    const section = context.params.section as IssueSectionKey\n    await ensureChatTables()\n    const thread = await getOrCreateThread(session.user.id, context.params.slug, section)\n    const { prisma } = await import('@/lib/prisma')\n    await prisma.$executeRawUnsafe('DELETE FROM \"InsightsChatMessage\" WHERE \"threadId\" = $1', thread.id)\n    return NextResponse.json({ ok: true })\n  } catch (error) {\n    console.error('[chat.DELETE] error', error)\n    return NextResponse.json({ error: 'server_error' }, { status: 500 })\n  }\n}\n\nexport async function POST(\n  request: Request,\n  context: { params: { slug: string; section: string } }\n) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n    const contentType = request.headers.get('content-type') || ''\n    let body: { message?: string; threadId?: string; newThread?: boolean } = {}\n    if (contentType.includes('application/json')) {\n      try {\n        body = await request.json()\n      } catch {}\n    }\n    const question = String(body?.message || '').trim()\n    const section = context.params.section as IssueSectionKey\n    await ensureChatTables()\n    \n    // Get or create thread\n    let thread: { id: string }\n    if (body.newThread) {\n      // Create new thread only if explicitly requested\n      thread = await createThread(session.user.id, context.params.slug, section)\n    } else if (body.threadId) {\n      // Use existing thread\n      thread = { id: body.threadId }\n    } else {\n      // Get most recent thread or create new one ONLY if no threads exist\n      const existingThreads = await listThreads(session.user.id, context.params.slug, section)\n      if (existingThreads.length > 0) {\n        thread = { id: existingThreads[0].id }\n      } else {\n        // Only create if truly no threads exist\n        thread = await getOrCreateThread(session.user.id, context.params.slug, section)\n      }\n    }\n    \n    if (question) {\n      await appendMessage(thread.id, 'user', question)\n      // Auto-generate title from first message if thread has no title\n      const threads = await listThreads(session.user.id, context.params.slug, section)\n      const currentThread = threads.find(t => t.id === thread.id)\n      if (currentThread && !currentThread.title) {\n        const title = question.length > 50 ? question.substring(0, 47) + '...' : question\n        await updateThreadTitle(thread.id, title)\n      }\n    }\n\n    const accept = (request.headers.get('accept') || '').toLowerCase()\n    const wantsStream = accept.includes('text/event-stream')\n    const openai = getOpenAIClient()\n    const system = await buildSystemPrompt(session.user.id, context.params.slug, section)\n    const user = await prisma.user.findUnique({\n      where: { id: session.user.id },\n      include: { subscription: true, creditTopUps: true },\n    })\n    if (!user) {\n      return NextResponse.json({ error: 'User not found' }, { status: 404 })\n    }\n\n    const isPremium = isSubscriptionActive(user.subscription)\n    const now = new Date()\n    const hasPurchasedCredits = user.creditTopUps?.some(\n      (topUp: any) => topUp.expiresAt > now && (topUp.amountCents - topUp.usedCents) > 0\n    )\n    const hasFreeChatCredits = await hasFreeCredits(user.id, 'INSIGHTS_CHAT')\n    const allowViaFreeUse = !isPremium && !hasPurchasedCredits && hasFreeChatCredits\n    if (!isPremium && !hasPurchasedCredits && !hasFreeChatCredits) {\n      return NextResponse.json(\n        {\n          error: 'Payment required',\n          message: 'You\\'ve used all your free insights chat uses. Subscribe to a monthly plan or purchase credits to continue.',\n          requiresPayment: true,\n          exhaustedFreeCredits: true,\n        },\n        { status: 402 }\n      )\n    }\n\n    if (!openai) {\n      // Fallback without OpenAI: echo guidance\n      const fallback = `I can help summarize and explain this section (\"${context.params.slug}\" ‚Üí ${section}). Please provide a specific question.`\n      await appendMessage(thread.id, 'assistant', fallback)\n      if (wantsStream) {\n        const stream = new ReadableStream({\n          start(controller) {\n            const enc = new TextEncoder()\n            controller.enqueue(enc.encode(`data: ${fallback}\\n\\n`))\n            controller.enqueue(enc.encode('event: end\\n\\n'))\n            controller.close()\n          },\n        })\n        return new Response(stream, { headers: { 'Content-Type': 'text/event-stream' } })\n      }\n      return NextResponse.json({ assistant: fallback })\n    }\n\n    // Load last messages for context\n    const history = await listMessages(thread.id, 30)\n    const chatMessages = [\n      { role: 'system' as const, content: system },\n      ...history.map((m) => ({ role: m.role, content: m.content })),\n    ]\n\n    if (wantsStream) {\n      // Wallet pre-check using conservative estimate (max_tokens)\n      const model = process.env.OPENAI_INSIGHTS_MODEL || 'gpt-4o-mini'\n      const promptText = [system, ...history.map((m) => m.content)].join('\\n')\n      let maxTokens = 500\n      if (!allowViaFreeUse) {\n        const cm = new CreditManager(session.user.id)\n        const wallet = await cm.getWalletStatus()\n        const cappedMaxTokens = capMaxTokensToBudget(model, promptText, maxTokens, wallet.totalAvailableCents)\n        if (cappedMaxTokens <= 0) {\n          return NextResponse.json({ error: 'Insufficient credits' }, { status: 402 })\n        }\n        maxTokens = cappedMaxTokens\n      }\n\n      const wrapped = await chatCompletionWithCost(openai, {\n        model,\n        temperature: 0.2,\n        max_tokens: maxTokens,\n        messages: chatMessages as any,\n      } as any)\n\n      if (!allowViaFreeUse) {\n        const cm = new CreditManager(session.user.id)\n        const ok = await cm.chargeCents(wrapped.costCents)\n        if (!ok) {\n          return NextResponse.json({ error: 'Insufficient credits' }, { status: 402 })\n        }\n      } else {\n        await consumeFreeCredit(session.user.id, 'INSIGHTS_CHAT')\n      }\n\n      try {\n        await logAIUsage({\n          context: { feature: `insights:section-chat:${section}`, userId: session.user.id, issueSlug: context.params.slug },\n          model,\n          promptTokens: wrapped.promptTokens,\n          completionTokens: wrapped.completionTokens,\n          costCents: wrapped.costCents,\n        })\n      } catch {\n        // Ignore logging failures\n      }\n\n      const text = wrapped.completion.choices?.[0]?.message?.content || ''\n      await appendMessage(thread.id, 'assistant', text)\n\n      const enc = new TextEncoder()\n      const chunks = text.match(/[\\s\\S]{1,200}/g) || ['']\n      const stream = new ReadableStream({\n        start(controller) {\n          for (const chunk of chunks) {\n            controller.enqueue(enc.encode(`data: ${chunk}\\n\\n`))\n          }\n          controller.enqueue(enc.encode('event: end\\n\\n'))\n          controller.close()\n        },\n      })\n      return new Response(stream, { headers: { 'Content-Type': 'text/event-stream' } })\n    }\n\n    // Non-streaming fallback\n  {\n    const model = process.env.OPENAI_INSIGHTS_MODEL || 'gpt-4o-mini'\n    const promptText = [system, ...history.map((m) => m.content)].join('\\n')\n    let maxTokens = 500\n    if (!allowViaFreeUse) {\n      const cm = new CreditManager(session.user.id)\n      const wallet = await cm.getWalletStatus()\n      const cappedMaxTokens = capMaxTokensToBudget(model, promptText, maxTokens, wallet.totalAvailableCents)\n      if (cappedMaxTokens <= 0) {\n        return NextResponse.json({ error: 'Insufficient credits' }, { status: 402 })\n      }\n      maxTokens = cappedMaxTokens\n    }\n    const wrapped = await chatCompletionWithCost(openai, {\n      model,\n      temperature: 0.2,\n      max_tokens: maxTokens,\n      messages: chatMessages as any,\n    } as any)\n    if (!allowViaFreeUse) {\n      const cm = new CreditManager(session.user.id)\n      const ok = await cm.chargeCents(wrapped.costCents)\n      if (!ok) {\n        return NextResponse.json({ error: 'Insufficient credits' }, { status: 402 })\n      }\n    } else {\n      await consumeFreeCredit(session.user.id, 'INSIGHTS_CHAT')\n    }\n\n    // Log AI usage for non-streaming section chat\n    try {\n      await logAIUsage({\n        context: {\n          feature: `insights:section-chat:${section}`,\n          userId: session.user.id,\n          issueSlug: context.params.slug,\n        },\n        model,\n        promptTokens: wrapped.promptTokens,\n        completionTokens: wrapped.completionTokens,\n        costCents: wrapped.costCents,\n      })\n    } catch {\n      // Ignore logging failures\n    }\n\n    const text = wrapped.completion.choices?.[0]?.message?.content || ''\n    await appendMessage(thread.id, 'assistant', text)\n    return NextResponse.json({ assistant: text })\n  }\n  } catch (error) {\n    console.error('[chat.POST] error', error)\n    return NextResponse.json({ error: 'server_error' }, { status: 500 })\n  }\n}\n","truncated":false,"size":11262},{"path":"app/api/insights/issues/[slug]/sections/[section]/route.ts","content":"import { NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { getIssueSection, ISSUE_SECTION_ORDER, type IssueSectionKey, getCachedIssueSection } from '@/lib/insights/issue-engine'\nimport { checkInsightsStatus, getStatusMessage } from '@/lib/insights/regeneration-service'\nimport { prisma } from '@/lib/prisma'\n\nexport async function GET(\n  _request: Request,\n  context: { params: { slug: string; section: string } }\n) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const sectionParam = context.params.section as IssueSectionKey\n    if (!ISSUE_SECTION_ORDER.includes(sectionParam)) {\n      return NextResponse.json({ error: 'Invalid section' }, { status: 400 })\n    }\n\n    // Check insights status for user-friendly messaging\n    const statusInfo = await checkInsightsStatus(session.user.id, context.params.slug, sectionParam)\n    const statusMessage = getStatusMessage(statusInfo.status, statusInfo.lastGenerated)\n\n    const result = await getIssueSection(session.user.id, context.params.slug, sectionParam)\n    if (!result) {\n      return NextResponse.json({ error: 'Not found' }, { status: 404 })\n    }\n    \n    // Debug headers when INSIGHTS_DEBUG=1\n    const headers: Record<string, string> = {}\n    if (process.env.INSIGHTS_DEBUG === '1') {\n      try {\n        const extras = (result as any)?.extras ?? {}\n        const pipelineVersion = extras.pipelineVersion ?? 'unknown'\n        const responseType = extras.quickUsed ? 'quick' : extras.cacheHit ? 'cached' : 'validated'\n        \n        headers['X-Debug-ResponseType'] = responseType\n        headers['X-Debug-PipelineVersion'] = String(pipelineVersion)\n        \n        if (sectionParam === 'supplements') {\n          const supplements = extras.supportiveDetails ?? []\n          const supplementNames = supplements.map((s: any) => s?.name).filter(Boolean)\n          headers['X-Debug-Supplements'] = supplementNames.slice(0, 10).join(',')\n          headers['X-Debug-WorkingCount'] = String(supplements.length)\n        } else if (sectionParam === 'exercise') {\n          const wa = Array.isArray(extras.workingActivities) ? extras.workingActivities : []\n          headers['X-Debug-WorkingCount'] = String(wa.length)\n          headers['X-Debug-WorkingTitles'] = wa.map((x: any) => x?.title).filter(Boolean).slice(0, 10).join(',')\n          // eslint-disable-next-line no-console\n          console.log('[insights.api] GET exercise section', {\n            slug: context.params.slug,\n            workingCount: wa.length,\n            workingTitles: wa.map((x: any) => x?.title).filter(Boolean),\n          })\n        }\n      } catch {}\n    }\n\n    // Add status information to the response\n    const enrichedResult = {\n      ...result,\n      _meta: {\n        status: statusInfo.status,\n        lastGenerated: statusInfo.lastGenerated,\n        statusMessage: statusMessage.message,\n        statusTone: statusMessage.tone,\n        needsUpdate: statusInfo.needsUpdate,\n      },\n    }\n\n    return NextResponse.json(enrichedResult, { status: 200, headers })\n  } catch (error) {\n    console.error('GET /api/insights/issues/[slug]/sections/[section] error', error)\n    return NextResponse.json({ error: 'Failed to load section' }, { status: 500 })\n  }\n}\n\nexport async function POST(\n  _request: Request,\n  context: { params: { slug: string; section: string } }\n) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const sectionParam = context.params.section as IssueSectionKey\n    if (!ISSUE_SECTION_ORDER.includes(sectionParam)) {\n      return NextResponse.json({ error: 'Invalid section' }, { status: 400 })\n    }\n\n    let body: { mode?: string; range?: { from?: string; to?: string }; force?: boolean } = {}\n    try {\n      body = await _request.json()\n    } catch {}\n\n    const mode = (body?.mode === 'weekly' || body?.mode === 'daily' || body?.mode === 'custom') ? body.mode : 'latest'\n    const range = body?.range && (body.range.from || body.range.to) ? body.range : undefined\n    const forceRefresh = body?.force === true\n\n    // If force refresh requested, skip cache and regenerate\n    if (forceRefresh) {\n      // Mark as generating in background (non-blocking)\n      try {\n        await prisma.$executeRawUnsafe(`\n          INSERT INTO \"InsightsMetadata\" (\"userId\", \"issueSlug\", \"section\", \"status\", \"updatedAt\")\n          VALUES ($1, $2, $3, 'generating', NOW())\n          ON CONFLICT (\"userId\", \"issueSlug\", \"section\")\n          DO UPDATE SET \"status\" = 'generating', \"updatedAt\" = NOW()\n        `, session.user.id, context.params.slug, sectionParam)\n      } catch (error) {\n        // Non-blocking - continue even if metadata update fails\n        console.warn('[insights.api] Failed to mark as generating', error)\n      }\n      \n      // Start regeneration in background (non-blocking)\n      // Return immediately so user sees progress bar\n      setTimeout(async () => {\n        try {\n          const result = await getIssueSection(session.user.id, context.params.slug, sectionParam, {\n            mode,\n            range,\n            force: true,\n          })\n          // Mark as fresh after completion\n          if (result) {\n            try {\n              await prisma.$executeRawUnsafe(`\n                INSERT INTO \"InsightsMetadata\" (\"userId\", \"issueSlug\", \"section\", \"status\", \"dataFingerprint\", \"lastGeneratedAt\", \"updatedAt\")\n                VALUES ($1, $2, $3, 'fresh', '', NOW(), NOW())\n                ON CONFLICT (\"userId\", \"issueSlug\", \"section\")\n                DO UPDATE SET \"status\" = 'fresh', \"lastGeneratedAt\" = NOW(), \"updatedAt\" = NOW()\n              `, session.user.id, context.params.slug, sectionParam)\n            } catch (error) {\n              console.warn('[insights.api] Failed to mark as fresh', error)\n            }\n          }\n        } catch (error) {\n          console.error('[insights.api] Background regeneration failed', error)\n          // Mark as stale on error so it can retry\n          try {\n            await prisma.$executeRawUnsafe(`\n              UPDATE \"InsightsMetadata\" SET \"status\" = 'stale', \"updatedAt\" = NOW()\n              WHERE \"userId\" = $1 AND \"issueSlug\" = $2 AND \"section\" = $3\n            `, session.user.id, context.params.slug, sectionParam)\n          } catch {}\n        }\n      })\n      \n      // Return immediately with current cached result (if available) or empty response\n      const quickResult = await getIssueSection(session.user.id, context.params.slug, sectionParam, {\n        mode,\n        range,\n        force: false, // Try to get cached/quick result for immediate display\n      })\n      \n      return NextResponse.json({ \n        result: quickResult || null, \n        upgraded: false, \n        forceRefreshed: true,\n        generating: true \n      }, { status: 200 })\n    }\n\n    // Fast path: Return quick result immediately, then upgrade in background\n    // This prevents users from waiting a minute for generation\n    const quickResult = await getIssueSection(session.user.id, context.params.slug, sectionParam, {\n      mode,\n      range,\n      force: false, // Don't force - use quick if available\n    })\n    \n    if (quickResult) {\n      // Return quick result immediately\n      // Background upgrade will happen automatically via computeIssueSection\n      return NextResponse.json({ result: quickResult, upgraded: false }, { status: 200 })\n    }\n\n    // Fallback: If no quick result available, do full build (but this should be rare)\n    const result = await getIssueSection(session.user.id, context.params.slug, sectionParam, {\n      mode,\n      range,\n      force: true,\n    })\n    if (!result) {\n      return NextResponse.json({ error: 'Not found' }, { status: 404 })\n    }\n    return NextResponse.json({ result, upgraded: true }, { status: 200 })\n  } catch (error) {\n    console.error('POST /api/insights/issues/[slug]/sections/[section] error', error)\n    return NextResponse.json({ error: 'Failed to generate section' }, { status: 500 })\n  }\n}\n","truncated":false,"size":8233},{"path":"app/api/insights/issues/[slug]/sections/[section]/threads/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { ensureChatTables, listThreads, createThread, updateThreadTitle, deleteThread } from '@/lib/insights/chat-store'\n\nexport async function GET(\n  _request: Request,\n  context: { params: { slug: string; section: string } }\n) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n    await ensureChatTables()\n    const threads = await listThreads(session.user.id, context.params.slug, context.params.section)\n    return NextResponse.json({ threads }, { status: 200 })\n  } catch (error) {\n    console.error('[threads.GET] error', error)\n    return NextResponse.json({ error: 'server_error' }, { status: 500 })\n  }\n}\n\nexport async function POST(\n  request: NextRequest,\n  context: { params: { slug: string; section: string } }\n) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n    const body = await request.json().catch(() => ({}))\n    const title = String(body?.title || '').trim() || null\n    await ensureChatTables()\n    const thread = await createThread(session.user.id, context.params.slug, context.params.section, title || undefined)\n    return NextResponse.json({ threadId: thread.id }, { status: 200 })\n  } catch (error) {\n    console.error('[threads.POST] error', error)\n    return NextResponse.json({ error: 'server_error' }, { status: 500 })\n  }\n}\n\nexport async function PATCH(\n  request: NextRequest,\n  context: { params: { slug: string; section: string } }\n) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n    const body = await request.json().catch(() => ({}))\n    const threadId = String(body?.threadId || '')\n    const title = String(body?.title || '').trim()\n    if (!threadId || !title) {\n      return NextResponse.json({ error: 'threadId and title required' }, { status: 400 })\n    }\n    await ensureChatTables()\n    await updateThreadTitle(threadId, title)\n    return NextResponse.json({ success: true }, { status: 200 })\n  } catch (error) {\n    console.error('[threads.PATCH] error', error)\n    return NextResponse.json({ error: 'server_error' }, { status: 500 })\n  }\n}\n\nexport async function DELETE(\n  request: NextRequest,\n  context: { params: { slug: string; section: string } }\n) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n    const body = await request.json().catch(() => ({}))\n    const threadId = String(body?.threadId || '')\n    if (!threadId) {\n      return NextResponse.json({ error: 'threadId required' }, { status: 400 })\n    }\n    await ensureChatTables()\n    await deleteThread(threadId)\n    return NextResponse.json({ success: true }, { status: 200 })\n  } catch (error) {\n    console.error('[threads.DELETE] error', error)\n    return NextResponse.json({ error: 'server_error' }, { status: 500 })\n  }\n}\n\n","truncated":false,"size":3299},{"path":"app/api/insights/issues/[slug]/sections/prefetch/route.ts","content":"'use server'\n\nimport { NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport {\n  ISSUE_SECTION_ORDER,\n  type IssueSectionKey,\n  type ReportMode,\n} from '@/lib/insights/issue-engine'\nimport { prisma } from '@/lib/prisma'\nimport { precomputeQuickSectionsForUser } from '@/lib/insights/issue-engine'\n\ninterface PrefetchBody {\n  sections?: IssueSectionKey[]\n  mode?: ReportMode\n  concurrency?: number\n  range?: { from?: string; to?: string }\n  forceAllIssues?: boolean\n}\n\nexport async function POST(request: Request, context: { params: { slug: string } }) {\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.id) {\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  }\n\n  let body: PrefetchBody = {}\n  try {\n    body = await request.json()\n  } catch {\n    body = {}\n  }\n\n  const requestedSections = Array.isArray(body.sections)\n    ? body.sections.filter((section): section is IssueSectionKey => ISSUE_SECTION_ORDER.includes(section))\n    : undefined\n\n  const mode: ReportMode = body.mode === 'weekly' || body.mode === 'daily' || body.mode === 'custom' ? body.mode : 'latest'\n\n  const startedAt = Date.now()\n  const concurrency = body.concurrency ?? 4\n  const forceAll = body.forceAllIssues === true\n\n  const targetSections = (requestedSections ?? ISSUE_SECTION_ORDER.filter((s) => s !== 'overview'))\n    .filter((s) => s !== 'interactions')\n\n  // Write quick results to DB cache so section pages can read instantly\n  if (forceAll) {\n    const rows = await prisma.$queryRawUnsafe<Array<{ name: string }>>(\n      'SELECT name FROM \"CheckinIssues\" WHERE \"userId\" = $1',\n      session.user.id\n    ).catch(() => []) as Array<{ name: string }>\n    const slugs = rows.map((r) => r.name.toLowerCase().trim().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, ''))\n    await precomputeQuickSectionsForUser(session.user.id, { slugs, sections: targetSections, concurrency })\n  } else {\n    await precomputeQuickSectionsForUser(session.user.id, { slugs: [context.params.slug], sections: targetSections, concurrency })\n  }\n\n  const durationMs = Date.now() - startedAt\n\n  return NextResponse.json({ ok: true, sections: targetSections, durationMs, concurrency, scope: forceAll ? 'all-issues' : 'single-issue' }, { status: 202 })\n}\n","truncated":false,"size":2331},{"path":"app/api/insights/issues/[slug]/status/route.ts","content":"import { NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { checkInsightsStatus } from '@/lib/insights/regeneration-service'\nimport { ISSUE_SECTION_ORDER, type IssueSectionKey } from '@/lib/insights/issue-engine'\n\nexport async function GET(\n  _request: Request,\n  context: { params: { slug: string } }\n) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const issueSlug = context.params.slug\n    const sections = ISSUE_SECTION_ORDER.filter((s) => s !== 'overview') as IssueSectionKey[]\n    \n    // Check status for all sections\n    const statusPromises = sections.map(async (section) => {\n      const status = await checkInsightsStatus(session.user.id, issueSlug, section)\n      return {\n        section,\n        ...status,\n      }\n    })\n    \n    const statuses = await Promise.all(statusPromises)\n    \n    // Determine overall status\n    const hasStale = statuses.some(s => s.status === 'stale' || s.needsUpdate)\n    const hasMissing = statuses.some(s => s.status === 'missing')\n    const hasGenerating = statuses.some(s => s.status === 'generating')\n    const allFresh = statuses.every(s => s.status === 'fresh' && !s.needsUpdate)\n    \n    const needsRegeneration = hasStale || hasMissing || (hasGenerating && !allFresh)\n    \n    return NextResponse.json({\n      needsRegeneration,\n      statuses: statuses.reduce((acc, s) => {\n        acc[s.section] = {\n          status: s.status,\n          needsUpdate: s.needsUpdate,\n          lastGenerated: s.lastGenerated?.toISOString() || null,\n        }\n        return acc\n      }, {} as Record<string, { status: string; needsUpdate: boolean; lastGenerated: string | null }>),\n    })\n  } catch (error) {\n    console.error('[insights.api] Error checking insights status', error)\n    return NextResponse.json({ error: 'Failed to check insights status' }, { status: 500 })\n  }\n}\n\n","truncated":false,"size":2032},{"path":"app/api/insights/issues/route.ts","content":"export const dynamic = 'force-dynamic';\n\nimport { NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { getIssueLandingPayload } from '@/lib/insights/issue-engine'\n\nexport async function GET() {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n    const payload = await getIssueLandingPayload(session.user.id)\n    return NextResponse.json(payload, { status: 200 })\n  } catch (error) {\n    console.error('GET /api/insights/issues error', error)\n    return NextResponse.json({ error: 'Failed to load issues' }, { status: 500 })\n  }\n}\n","truncated":false,"size":733},{"path":"app/api/insights/list/route.ts","content":"import { NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\n\nexport async function GET(request: Request) {\n  const url = new URL(request.url)\n  const preview = url.searchParams.get('preview') === '1'\n  const regen = url.searchParams.get('regen') === '1'\n  const enabled = process.env.NEXT_PUBLIC_INSIGHTS_ENABLED === 'true'\n  if (!enabled && !preview) {\n    return NextResponse.json({ enabled: false, items: [] }, { status: 200 })\n  }\n\n  // Try fast path: serve from cache if available and fresh, and respect user pin/dismiss\n  try {\n    const session = await getServerSession(authOptions)\n    const userId = session?.user?.id\n    if (userId) {\n      // Ensure cache table exists\n      await prisma.$executeRawUnsafe(\n        'CREATE TABLE IF NOT EXISTS \"InsightsCache\" (\"userId\" TEXT PRIMARY KEY, \"items\" JSONB NOT NULL, \"updatedAt\" TIMESTAMPTZ NOT NULL DEFAULT NOW())'\n      )\n      await prisma.$executeRawUnsafe(\n        'CREATE TABLE IF NOT EXISTS \"InsightsUserState\" (\"userId\" TEXT PRIMARY KEY, \"pinned\" JSONB NOT NULL DEFAULT \\\"[]\\\", \"dismissed\" JSONB NOT NULL DEFAULT \\\"[]\\\", \"updatedAt\" TIMESTAMPTZ NOT NULL DEFAULT NOW())'\n      )\n      const rows: any[] = await prisma.$queryRawUnsafe(\n        'SELECT \"items\", \"updatedAt\" FROM \"InsightsCache\" WHERE \"userId\" = $1',\n        userId\n      )\n      const stateRows: any[] = await prisma.$queryRawUnsafe(\n        'SELECT \"pinned\", \"dismissed\" FROM \"InsightsUserState\" WHERE \"userId\" = $1',\n        userId\n      )\n      const pinned: string[] = stateRows?.[0]?.pinned || []\n      const dismissed: string[] = stateRows?.[0]?.dismissed || []\n      if (rows && rows[0]) {\n        const updatedAt = new Date(rows[0].updatedAt)\n        const ageMs = Date.now() - updatedAt.getTime()\n        const freshMs = 6 * 60 * 60 * 1000 // 6 hours\n        if (ageMs < freshMs) {\n          // Apply pin/dismiss ordering\n          const items = Array.isArray(rows[0].items) ? rows[0].items : []\n          const filtered = items.filter((it: any) => !dismissed.includes(it.id))\n          const pinnedItems = filtered.filter((it: any) => pinned.includes(it.id))\n          const rest = filtered.filter((it: any) => !pinned.includes(it.id))\n          return NextResponse.json({ enabled: true, items: [...pinnedItems, ...rest], cached: true }, { status: 200 })\n        }\n      }\n    }\n  } catch {}\n\n  // Kick off background regeneration only when explicitly requested\n  if (regen) {\n    try {\n      const origin = new URL(request.url).origin\n      fetch(`${origin}/api/insights/generate?preview=1&t=${Date.now()}`, {\n        method: 'POST',\n        cache: 'no-cache',\n        headers: { cookie: request.headers.get('cookie') || '' },\n      }).catch(() => {})\n    } catch {}\n  }\n\n  // Secondary fallback: derive personalized preview from stored onboarding data\n  try {\n    const origin = new URL(request.url).origin\n    const ud = await fetch(`${origin}/api/user-data?t=${Date.now()}`, {\n      cache: 'no-cache',\n      headers: { cookie: request.headers.get('cookie') || '' },\n    }).then(r => r.json()).catch(() => null)\n    const d = ud?.data || {}\n    const goals: string[] = Array.isArray(d.goals) ? d.goals : []\n    const supplements: any[] = Array.isArray(d.supplements) ? d.supplements : []\n    const medications: any[] = Array.isArray(d.medications) ? d.medications : []\n    const todaysFoods: any[] = Array.isArray(d.todaysFoods) ? d.todaysFoods : []\n\n    const hasMagnesium = supplements.some(s => /magnesium/i.test(s.name || ''))\n    const hasIron = supplements.some(s => /iron/i.test(s.name || ''))\n    const hasCalcium = supplements.some(s => /calcium/i.test(s.name || ''))\n    const hasOmega3 = supplements.some(s => /(omega|fish\\s*oil)/i.test(s.name || ''))\n\n    const items = [\n      {\n        id: 'pf1',\n        title: goals.length ? `Weekly focus: ${goals[0]}` : 'Set a clear weekly focus',\n        summary: goals.length ? `Prioritize progress on ‚Äú${goals[0]}‚Äù. Define one measurable action for this week.` : 'Choose 1‚Äì2 goals to focus on and define one measurable action.',\n        tags: ['goals'],\n        confidence: 0.7,\n        createdAt: new Date().toISOString(),\n      },\n      {\n        id: 'pf2',\n        title: hasMagnesium ? 'Move magnesium to evening' : 'Start with simple sleep support',\n        summary: hasMagnesium ? 'Magnesium is often best 1‚Äì2 hours before bed; avoid pairing with high-fiber meals.' : 'If appropriate, consider magnesium in the evening to support sleep quality.',\n        tags: ['supplement','timing','sleep'],\n        confidence: 0.72,\n        createdAt: new Date().toISOString(),\n      },\n      {\n        id: 'pf3',\n        title: hasIron && hasCalcium ? 'Separate iron and calcium' : 'Medication/supplement spacing check',\n        summary: hasIron && hasCalcium ? 'Take iron and calcium at least 2 hours apart for better absorption (confirm with your clinician).' : 'Review timing to avoid conflicts; spacing doses by 2 hours can help (check with your clinician).',\n        tags: ['safety','timing'],\n        confidence: 0.66,\n        createdAt: new Date().toISOString(),\n      },\n      {\n        id: 'pf4',\n        title: 'Protein-forward breakfast',\n        summary: 'Aim for 25‚Äì35g protein at breakfast to stabilize morning energy and appetite.',\n        tags: ['nutrition','energy'],\n        confidence: 0.64,\n        createdAt: new Date().toISOString(),\n      },\n      {\n        id: 'pf5',\n        title: hasOmega3 ? 'Keep omega‚Äë3 consistent' : 'Consider omega‚Äë3 intake',\n        summary: hasOmega3 ? 'Take omega‚Äë3 with a meal containing fat for better absorption.' : 'Discuss adding omega‚Äë3 rich foods or a supplement with your clinician for cardio‚Äëmetabolic support.',\n        tags: ['supplement','nutrition'],\n        confidence: 0.61,\n        createdAt: new Date().toISOString(),\n      },\n      {\n        id: 'pf6',\n        title: todaysFoods.length ? 'Balance carbs + fiber' : 'Hydration and fiber baseline',\n        summary: todaysFoods.length ? 'Pair carbs with protein and fiber to steady energy; add veggies or legumes to meals.' : 'Target ~2‚Äì3L fluids daily and include fiber at each meal for digestion.',\n        tags: ['nutrition','hydration'],\n        confidence: 0.6,\n        createdAt: new Date().toISOString(),\n      },\n    ]\n    return NextResponse.json({ enabled: true, items, preview: true, regenerating: true }, { status: 200 })\n  } catch {}\n\n  // Final static fallback\n  const items = [\n    { id: 'i1', title: 'Hydration may be low', summary: 'Increase water intake to ~2‚Äì3L/day.', tags: ['hydration'], confidence: 0.72, createdAt: new Date().toISOString() },\n    { id: 'i2', title: 'Magnesium timing', summary: 'Consider magnesium 1‚Äì2 hours before sleep.', tags: ['supplement'], confidence: 0.81, createdAt: new Date().toISOString() },\n    { id: 'i3', title: 'Sodium and BP', summary: 'Watch sodium if BP is elevated; prefer low‚Äësodium options.', tags: ['nutrition','bp'], confidence: 0.65, createdAt: new Date().toISOString() },\n  ]\n  return NextResponse.json({ enabled: true, items, preview: true }, { status: 200 })\n}\n\n","truncated":false,"size":7170},{"path":"app/api/insights/regenerate-targeted/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { randomUUID } from 'crypto'\nimport { authOptions } from '@/lib/auth'\nimport { triggerManualSectionRegeneration, getAffectedSections } from '@/lib/insights/regeneration-service'\nimport { CreditManager } from '@/lib/credit-system'\nimport { prisma } from '@/lib/prisma'\nimport { getRunCostCents } from '@/lib/ai-usage-runs'\nimport { getBillingMarkupMultiplier, getModelPriceInfo } from '@/lib/cost-meter'\nimport type { RunContext } from '@/lib/run-context'\nimport { getInsightsLlmStatus } from '@/lib/insights/llm'\nimport { consumeFreeCredit, hasFreeCredits } from '@/lib/free-credits'\nimport { isSubscriptionActive } from '@/lib/subscription-utils'\n\n// Allow longer runtime so the full regeneration completes without a gateway timeout\nexport const maxDuration = 120\n\nconst VALID_CHANGE_TYPES = [\n  'supplements',\n  'medications',\n  'food',\n  'exercise',\n  'health_goals',\n  'health_situations',\n  'profile',\n  'blood_results',\n] as const\n\ntype ChangeType = (typeof VALID_CHANGE_TYPES)[number]\n\nconst SUB_CREDIT_VALUE = 0.0143 // $/credit for subscriptions\nconst TOPUP_CREDIT_VALUE = 0.02 // $/credit for top-ups\nconst SUB_COST_SHARE = 0.4 // 60% margin target (cost = 40% of revenue)\nconst TOPUP_COST_SHARE = 0.3 // 70% margin target (cost = 30% of revenue)\n\ntype WalletStatus = Awaited<ReturnType<CreditManager['getWalletStatus']>>\n\nfunction calculateChargePlan(costCents: number, wallet: WalletStatus) {\n  const costUsd = Math.max(0, costCents) / 100\n  if (costUsd === 0) {\n    return {\n      subscriptionCredits: 0,\n      topUpCredits: 0,\n      totalCredits: 0,\n      remainingCostUsd: 0,\n      canAfford: true,\n    }\n  }\n\n  const monthlyAvailable = Math.max(0, wallet.monthlyRemainingCents || 0)\n  const topUpAvailable = (wallet.topUps || []).reduce(\n    (sum, tu) => sum + Math.max(0, tu.availableCents || 0),\n    0\n  )\n\n  const subRevenueAvailable = monthlyAvailable * SUB_CREDIT_VALUE\n  const subCoverageUsd = subRevenueAvailable * SUB_COST_SHARE\n\n  let remainingCost = costUsd\n  let subscriptionCredits = 0\n\n  if (monthlyAvailable > 0) {\n    const neededSubRevenue = remainingCost / SUB_COST_SHARE\n    const neededSubCredits = Math.ceil(neededSubRevenue / SUB_CREDIT_VALUE)\n    if (neededSubCredits <= monthlyAvailable) {\n      subscriptionCredits = neededSubCredits\n      remainingCost = 0\n    } else {\n      subscriptionCredits = monthlyAvailable\n      remainingCost = Math.max(0, remainingCost - subCoverageUsd)\n    }\n  }\n\n  let topUpCredits = 0\n  if (remainingCost > 0) {\n    const neededTopUpRevenue = remainingCost / TOPUP_COST_SHARE\n    topUpCredits = Math.ceil(neededTopUpRevenue / TOPUP_CREDIT_VALUE)\n  }\n\n  const totalCredits = subscriptionCredits + topUpCredits\n  const canAfford = monthlyAvailable + topUpAvailable >= totalCredits\n\n  return {\n    subscriptionCredits,\n    topUpCredits,\n    totalCredits,\n    remainingCostUsd: remainingCost,\n    canAfford,\n  }\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const body = await request.json().catch(() => ({}))\n    const changeTypesInput: unknown = body?.changeTypes\n    const changeTypes = Array.isArray(changeTypesInput)\n      ? changeTypesInput.filter((t): t is ChangeType => VALID_CHANGE_TYPES.includes(t as ChangeType))\n      : []\n\n    // If the client didn‚Äôt specify, default to a minimal set so we never fan out accidentally.\n    // NOTE: This should rarely happen because the client always sends changeTypes, but this keeps\n    // the call bounded to avoid long-running jobs/504s.\n    const effectiveChangeTypes = changeTypes.length ? changeTypes : (['profile'] as ChangeType[])\n\n    const runId: string =\n      typeof body?.runId === 'string' && body.runId.trim().length > 0\n        ? body.runId\n        : randomUUID()\n\n    const user = await prisma.user.findUnique({\n      where: { id: session.user.id },\n      include: { subscription: true, creditTopUps: true },\n    })\n    if (!user) {\n      return NextResponse.json({ error: 'User not found' }, { status: 404 })\n    }\n\n    const isPremium = isSubscriptionActive(user.subscription)\n    const now = new Date()\n    const hasPurchasedCredits = user.creditTopUps?.some(\n      (topUp: any) => topUp.expiresAt > now && (topUp.amountCents - topUp.usedCents) > 0\n    )\n    const hasFreeInsightsCredits = await hasFreeCredits(session.user.id, 'INSIGHTS_UPDATE')\n    const allowViaFreeUse = !isPremium && !hasPurchasedCredits && hasFreeInsightsCredits\n    if (!isPremium && !hasPurchasedCredits && !hasFreeInsightsCredits) {\n      return NextResponse.json({\n        success: false,\n        message: 'You\\'ve used all your free insights updates. Please purchase credits or subscribe.',\n        exhaustedFreeCredits: true,\n      }, { status: 402 })\n    }\n\n    // Log visible goals to diagnose missing-goal cases without blocking the request\n    const goals = await prisma.healthGoal.findMany({\n      where: {\n        userId: session.user.id,\n        name: { not: { startsWith: '__' } },\n      },\n      select: { name: true },\n      take: 10,\n    })\n    console.log('[insights.regenerate-targeted] goals detected', {\n      runId,\n      userId: session.user.id,\n      goalCount: goals.length,\n      goalNames: goals.map((g) => g.name),\n      changeTypes: effectiveChangeTypes,\n    })\n\n    const llmStatus = getInsightsLlmStatus()\n\n    if (changeTypes.length === 0) {\n      return NextResponse.json({\n        success: false,\n        message: 'No valid change types provided; nothing to regenerate.',\n        sectionsTriggered: [],\n        llmStatus,\n      }, { status: 400 })\n    }\n\n    let sections: string[] = []\n    const affected = effectiveChangeTypes.reduce<string[]>((acc, type) => {\n      const mapped = getAffectedSections(type)\n      mapped.forEach((s) => acc.push(s))\n      return acc\n    }, [])\n    const affectedUnique = Array.from(new Set(affected))\n\n    if (affectedUnique.length === 0) {\n      console.log('[insights.regenerate-targeted] no sections triggered for change types', {\n        runId,\n        userId: session.user.id,\n        changeTypes: effectiveChangeTypes,\n      })\n      return NextResponse.json(\n        {\n          success: true,\n          message: 'No insight sections need regeneration for these changes.',\n          runId,\n          sectionsTriggered: [],\n          affectedSections: [],\n          llmStatus,\n        },\n        { status: 200 }\n      )\n    }\n\n    const runContext: RunContext = {\n      runId,\n      feature: 'insights:targeted',\n      meta: {\n        userId: session.user.id,\n        changeTypes: Array.from(new Set(effectiveChangeTypes)),\n        sections: affectedUnique,\n      },\n    }\n    console.log('[insights.regenerate-targeted] start', {\n      runId,\n      userId: session.user.id,\n      changeTypes: effectiveChangeTypes,\n    })\n\n    const preferQuickProfile = effectiveChangeTypes.length === 1 && effectiveChangeTypes[0] === 'profile'\n\n    const finalizeCharge = async (overrideSections?: string[]) => {\n      const sectionsForCharge =\n        Array.isArray(overrideSections) && overrideSections.length ? overrideSections : (sections.length ? sections : affectedUnique)\n      const { costCents, count, promptTokens, completionTokens } = await getRunCostCents(runId, session.user.id)\n      const modelPrice = getModelPriceInfo(llmStatus.model)\n      const markupMultiplier = getBillingMarkupMultiplier()\n      const cm = new CreditManager(session.user.id)\n      const walletStatus = await cm.getWalletStatus()\n      const plan = calculateChargePlan(costCents, walletStatus)\n\n      if (!allowViaFreeUse && !plan.canAfford) {\n        return {\n          success: false as const,\n          status: 402 as const,\n          body: {\n            success: false,\n            message: 'Not enough credits to cover this insights refresh.',\n            runId,\n            sectionsTriggered: sectionsForCharge,\n            affectedSections: affectedUnique,\n            costCents,\n            usageEvents: count,\n          promptTokens,\n          completionTokens,\n          },\n        }\n      }\n\n      if (costCents === 0 || count === 0) {\n        console.error('[insights.regenerate-targeted] zero cost/usage recorded ‚Äì failing run', {\n          runId,\n          userId: session.user.id,\n          changeTypes: Array.from(new Set(effectiveChangeTypes)),\n          costCents,\n          usageEvents: count,\n          sectionsTriggered: sectionsForCharge,\n        })\n        return {\n          success: false as const,\n          status: 500 as const,\n          body: {\n            success: false,\n            message: 'Insights update failed because no AI usage was recorded. Please retry.',\n            runId,\n            sectionsTriggered: sectionsForCharge,\n            affectedSections: affectedUnique,\n            costCents,\n            usageEvents: count,\n            promptTokens,\n            completionTokens,\n            llmStatus,\n            modelPrice,\n            markupMultiplier,\n          },\n        }\n      }\n\n      let chargedCredits = 0\n      if (!allowViaFreeUse) {\n        if (plan.totalCredits > 0) {\n          const chargedOk = await cm.chargeSplitCredits(plan.subscriptionCredits, plan.topUpCredits)\n          if (!chargedOk) {\n            return {\n              success: false as const,\n              status: 402 as const,\n              body: {\n                success: false,\n                message: 'Unable to charge credits for this insights refresh.',\n                runId,\n                sectionsTriggered: sectionsForCharge,\n                affectedSections: affectedUnique,\n                costCents,\n                usageEvents: count,\n                promptTokens,\n                completionTokens,\n              },\n            }\n          }\n          chargedCredits = plan.totalCredits\n        }\n      }\n\n      if (allowViaFreeUse) {\n        await consumeFreeCredit(session.user.id, 'INSIGHTS_UPDATE')\n      }\n\n      await prisma.user.update({\n        where: { id: session.user.id },\n        data: {\n          monthlyInsightsGenerationUsed: { increment: 1 },\n        } as any,\n      })\n\n      console.log('[insights.regenerate-targeted] charge summary', {\n        runId,\n        userId: session.user.id,\n        changeTypes: Array.from(new Set(effectiveChangeTypes)),\n        costCents,\n        usageEvents: count,\n        chargedCredits,\n        sectionsTriggered: sectionsForCharge,\n      })\n\n      return {\n        success: true as const,\n        status: 200 as const,\n        body: {\n          success: true,\n          message:\n            chargedCredits > 0\n              ? `Charged ${chargedCredits} credits based on actual AI usage.`\n              : allowViaFreeUse\n              ? 'Used a free insights update.'\n              : 'Targeted insights regeneration completed.',\n          changeTypes: Array.from(new Set(effectiveChangeTypes)),\n          sectionsTriggered: sectionsForCharge,\n          affectedSections: affectedUnique,\n          runId,\n          costCents,\n          usageEvents: count,\n          promptTokens,\n          completionTokens,\n          chargedCredits,\n          subscriptionCreditsCharged: allowViaFreeUse ? 0 : plan.subscriptionCredits,\n          topUpCreditsCharged: allowViaFreeUse ? 0 : plan.topUpCredits,\n          modelPrice,\n          markupMultiplier,\n        },\n      }\n    }\n\n    try {\n      sections = await triggerManualSectionRegeneration(session.user.id, effectiveChangeTypes, {\n        inline: true,\n        runContext,\n        preferQuick: preferQuickProfile,\n        slugs: changeTypes.includes('health_goals') && Array.isArray(body?.goalSlugs) ? body.goalSlugs : undefined,\n      })\n    } catch (error) {\n      console.error('[insights.regenerate-targeted] regeneration failed', { runId, error })\n      return NextResponse.json(\n        {\n          success: false,\n          message: 'Failed to regenerate insights. Please retry.',\n          runId,\n          llmStatus,\n        },\n        { status: 500 }\n      )\n    }\n\n    const chargeResult = await finalizeCharge(sections)\n    if (!chargeResult.success) {\n      return NextResponse.json(chargeResult.body, { status: chargeResult.status })\n    }\n\n    return NextResponse.json(\n      {\n        ...chargeResult.body,\n        background: false,\n        llmStatus,\n      },\n      { status: chargeResult.status }\n    )\n  } catch (error) {\n    console.error('[insights.regenerate-targeted] Failed to trigger regeneration', error)\n    return NextResponse.json({ error: 'Failed to start regeneration' }, { status: 500 })\n  }\n}\n","truncated":false,"size":12721},{"path":"app/api/insights/regenerate/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\nimport { precomputeIssueSectionsForUser, precomputeQuickSectionsForUser } from '@/lib/insights/issue-engine'\nimport { CreditManager, CREDIT_COSTS } from '@/lib/credit-system'\nimport { withRunContext } from '@/lib/run-context'\nimport { randomUUID } from 'crypto'\nimport { consumeFreeCredit, hasFreeCredits } from '@/lib/free-credits'\nimport { isSubscriptionActive } from '@/lib/subscription-utils'\n\nexport async function POST(request: NextRequest) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const userId = session.user.id\n\n    const user = await prisma.user.findUnique({\n      where: { id: userId },\n      include: { subscription: true, creditTopUps: true },\n    })\n    if (!user) {\n      return NextResponse.json({ error: 'User not found' }, { status: 404 })\n    }\n\n    const isPremium = isSubscriptionActive(user.subscription)\n    const now = new Date()\n    const hasPurchasedCredits = user.creditTopUps?.some(\n      (topUp: any) => topUp.expiresAt > now && (topUp.amountCents - topUp.usedCents) > 0\n    )\n    const hasFreeInsightsCredits = await hasFreeCredits(userId, 'INSIGHTS_UPDATE')\n    const allowViaFreeUse = !isPremium && !hasPurchasedCredits && hasFreeInsightsCredits\n    if (!isPremium && !hasPurchasedCredits && !hasFreeInsightsCredits) {\n      return NextResponse.json({\n        error: 'Insufficient credits',\n        message: 'You\\'ve used all your free insights updates. Please purchase credits or subscribe.',\n        exhaustedFreeCredits: true,\n      }, { status: 402 })\n    }\n\n    if (!allowViaFreeUse) {\n      // Check if user has credits\n      const cm = new CreditManager(userId)\n      const hasCredits = await cm.checkCredits('INSIGHTS_GENERATION')\n      \n      if (!hasCredits.hasCredits) {\n        return NextResponse.json({ \n          error: 'Insufficient credits',\n          message: 'You need credits to regenerate insights. Please purchase credits or subscribe.'\n        }, { status: 402 })\n      }\n\n      // Charge credits for insights regeneration\n      const costCents = CREDIT_COSTS.INSIGHTS_GENERATION\n      const charged = await cm.chargeCents(costCents)\n      \n      if (!charged) {\n        return NextResponse.json({ \n          error: 'Failed to charge credits',\n          message: 'Unable to process payment. Please try again.'\n        }, { status: 402 })\n      }\n    } else {\n      await consumeFreeCredit(userId, 'INSIGHTS_UPDATE')\n    }\n\n    // Update monthly counter\n    await prisma.user.update({\n      where: { id: userId },\n      data: {\n        monthlyInsightsGenerationUsed: { increment: 1 },\n      } as any,\n    })\n\n    // Trigger FULL regeneration for all issues (not just quick cache)\n    // Start quick regeneration first, then full regeneration\n    setImmediate(async () => {\n      try {\n        const runId = randomUUID()\n        console.log('üöÄ Starting FULL insights regeneration for user:', userId)\n        \n        // Generate full insights for all issues\n        await withRunContext(\n          { runId, feature: 'insights:regenerate', meta: { userId } },\n          () => precomputeIssueSectionsForUser(userId, { concurrency: 2 })\n        )\n        \n        console.log('‚úÖ FULL insights regeneration complete for user:', userId)\n      } catch (error) {\n        console.error('‚ùå FULL insights regeneration failed:', error)\n      }\n    })\n\n    return NextResponse.json({ \n      success: true,\n      message: 'Insights regeneration started. This may take a few minutes.',\n      creditsCharged: allowViaFreeUse ? 0 : CREDIT_COSTS.INSIGHTS_GENERATION\n    }, { status: 202 }) // 202 Accepted - processing in background\n\n  } catch (error) {\n    console.error('Error regenerating insights:', error)\n    return NextResponse.json({ \n      error: 'Failed to regenerate insights',\n      details: error instanceof Error ? error.message : 'Unknown error'\n    }, { status: 500 })\n  }\n}\n","truncated":false,"size":4154},{"path":"app/api/insights/safety/analyze/route.ts","content":"import { NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\n\ntype InsightCard = {\n  id: string\n  title: string\n  summary: string\n  reason: string\n  actions: string[]\n  tags: string[]\n  confidence: number\n}\n\nexport async function GET() {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) return NextResponse.json({ items: [] }, { status: 200 })\n\n    const user = await prisma.user.findUnique({\n      where: { id: session.user.id },\n      include: {\n        supplements: true,\n        medications: true,\n        foodLogs: { orderBy: { createdAt: 'desc' }, take: 30 },\n        healthLogs: { orderBy: { createdAt: 'desc' }, take: 30 },\n        healthGoals: true,\n      },\n    })\n\n    if (!user) return NextResponse.json({ items: [] }, { status: 200 })\n\n    const supps = (user.supplements || []).map((s: any) => ({ name: String(s.name || ''), timing: s.timing || [], dosage: s.dosage || '' }))\n    const meds = (user.medications || []).map((m: any) => ({ name: String(m.name || ''), timing: m.timing || [], dosage: m.dosage || '' }))\n    const foods = (user.foodLogs || []).map((f: any) => ({ name: String(f.name || ''), nutrients: f.nutrients || {} }))\n\n    const has = <T extends { name: string }>(list: T[], re: RegExp) => list.some(i => re.test(i.name))\n    const find = <T extends { name: string }>(list: T[], re: RegExp): T[] => list.filter(i => re.test(i.name))\n\n    const items: InsightCard[] = []\n\n    // Rule: Separate iron and calcium\n    if ((has(supps, /iron/i) || has(meds, /iron/i)) && (has(supps, /calcium/i) || has(meds, /calcium/i))) {\n      const ironCount = find([...supps, ...meds], /iron/i).length\n      const calciumCount = find([...supps, ...meds], /calcium/i).length\n      items.push({\n        id: 'safety-iron-calcium',\n        title: 'Separate iron and calcium',\n        summary: 'Taking iron and calcium close together can reduce iron absorption.',\n        reason: `You logged iron (${ironCount}) and calcium (${calciumCount}).`,\n        actions: [\n          'Take iron and calcium at least 2 hours apart.',\n          'Take iron away from high‚Äëfiber meals if possible.',\n          'Confirm timing with your clinician if dosing is medically necessary.',\n        ],\n        tags: ['safety','timing','medication','supplement'],\n        confidence: 0.8,\n      })\n    }\n\n    // Rule: Magnesium timing towards evening\n    if (has(supps, /magnesium/i)) {\n      const mag = find(supps, /magnesium/i) as Array<{ name: string; timing?: string[] }>\n      const hasMorning = mag.some(m => Array.isArray(m.timing) && m.timing.some((t: string) => /am|morn/i.test(t)))\n      items.push({\n        id: 'safety-magnesium-evening',\n        title: 'Consider magnesium in the evening',\n        summary: 'Magnesium is often better tolerated 1‚Äì2 hours before sleep.',\n        reason: hasMorning ? 'Your magnesium timing includes morning doses.' : 'You take magnesium; evening timing can support sleep quality.',\n        actions: [\n          'Try moving magnesium to 1‚Äì2 hours before sleep.',\n          'Avoid pairing with very high‚Äëfiber meals to support absorption.',\n        ],\n        tags: ['supplement','timing','sleep'],\n        confidence: 0.65,\n      })\n    }\n\n    // Rule: Low average protein ‚Üí fatigue/energy\n    const proteinVals: number[] = foods.map(f => Number((f.nutrients || {}).protein)).filter(v => Number.isFinite(v))\n    if (proteinVals.length >= 3) {\n      const avgProtein = proteinVals.reduce((a,b)=>a+b,0) / proteinVals.length\n      if (avgProtein < 60) {\n        items.push({\n          id: 'nutrition-protein-low',\n          title: 'Protein may be low on average',\n          summary: 'Low daily protein can contribute to low energy and poor appetite control.',\n          reason: `Your recent foods average about ${Math.round(avgProtein)}g protein per entry.`,\n          actions: [\n            'Aim for 25‚Äì35g protein at breakfast.',\n            'Include a protein source in each meal (eggs, dairy, fish, poultry, legumes).',\n          ],\n          tags: ['nutrition','energy','safety'],\n          confidence: 0.6,\n        })\n      }\n    }\n\n    // Rule: Sodium awareness if BP-related (simple heuristic)\n    const sodiumVals: number[] = foods.map(f => Number((f.nutrients || {}).sodium)).filter(v => Number.isFinite(v))\n    if (sodiumVals.length >= 3) {\n      const avgNa = sodiumVals.reduce((a,b)=>a+b,0) / sodiumVals.length\n      if (avgNa > 800) {\n        items.push({\n          id: 'nutrition-sodium-awareness',\n          title: 'Sodium may be high',\n          summary: 'Higher sodium intake can affect blood pressure in some people.',\n          reason: `Average sodium per entry is ~${Math.round(avgNa)} mg across recent meals.`,\n          actions: [\n            'Choose lower‚Äësodium options (broths, sauces, deli meats).',\n            'Pair higher‚Äësodium meals with potassium‚Äërich foods (vegetables, legumes).',\n          ],\n          tags: ['nutrition','bp','safety'],\n          confidence: 0.55,\n        })\n      }\n    }\n\n    // Rule: Tadalafil + ginger ‚Üí potential additive BP lowering (informational)\n    if ((has(meds, /tadalafil|cialis/i)) && (has(supps, /ginger|zingiber/i) || foods.some(f => /ginger/i.test(f.name)))) {\n      items.push({\n        id: 'interaction-tadalafil-ginger',\n        title: 'Possible additive blood pressure lowering (tadalafil + ginger)',\n        summary: 'Both tadalafil and ginger may lower blood pressure. Together they could increase the effect in some people.',\n        reason: 'You logged tadalafil and ginger (supplement or food).',\n        actions: [\n          'Avoid taking ginger around the time you use tadalafil if you notice dizziness or light‚Äëheadedness.',\n          'Stand up slowly; hydrate well on those days.',\n          'Discuss with your clinician if you experience symptoms.',\n        ],\n        tags: ['safety','interaction','bp'],\n        confidence: 0.55,\n      })\n    }\n\n    return NextResponse.json({ items }, { status: 200 })\n  } catch (e) {\n    return NextResponse.json({ items: [] }, { status: 200 })\n  }\n}\n\n\n","truncated":false,"size":6173},{"path":"app/api/insights/state/route.ts","content":"import { NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\n\nasync function ensureTable() {\n  await prisma.$executeRawUnsafe(\n    'CREATE TABLE IF NOT EXISTS \"InsightsUserState\" (\"userId\" TEXT PRIMARY KEY, \"pinned\" JSONB NOT NULL DEFAULT \\'[]\\', \"dismissed\" JSONB NOT NULL DEFAULT \\'[]\\', \"updatedAt\" TIMESTAMPTZ NOT NULL DEFAULT NOW())'\n  )\n}\n\nexport async function GET() {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) return NextResponse.json({ pinned: [], dismissed: [] }, { status: 200 })\n    await ensureTable()\n    const rows: any[] = await prisma.$queryRawUnsafe(\n      'SELECT \"pinned\", \"dismissed\" FROM \"InsightsUserState\" WHERE \"userId\" = $1',\n      session.user.id,\n    )\n    const state = rows?.[0] || { pinned: [], dismissed: [] }\n    return NextResponse.json(state, { status: 200 })\n  } catch (e) {\n    return NextResponse.json({ pinned: [], dismissed: [] }, { status: 200 })\n  }\n}\n\nexport async function POST(request: Request) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) return NextResponse.json({ error: 'not_authenticated' }, { status: 401 })\n    await ensureTable()\n    const body = await request.json().catch(() => ({}))\n    const { action, id } = body || {}\n    if (!id || !action) return NextResponse.json({ error: 'bad_request' }, { status: 400 })\n\n    const rows: any[] = await prisma.$queryRawUnsafe(\n      'SELECT \"pinned\", \"dismissed\" FROM \"InsightsUserState\" WHERE \"userId\" = $1',\n      session.user.id,\n    )\n    const current = rows?.[0] || { pinned: [], dismissed: [] }\n    let pinned: string[] = Array.isArray(current.pinned) ? current.pinned : []\n    let dismissed: string[] = Array.isArray(current.dismissed) ? current.dismissed : []\n\n    switch (action) {\n      case 'pin':\n        if (!pinned.includes(id)) pinned = [id, ...pinned].slice(0, 50)\n        dismissed = dismissed.filter((x) => x !== id)\n        break\n      case 'unpin':\n        pinned = pinned.filter((x) => x !== id)\n        break\n      case 'dismiss':\n        if (!dismissed.includes(id)) dismissed = [id, ...dismissed].slice(0, 200)\n        pinned = pinned.filter((x) => x !== id)\n        break\n      case 'undismiss':\n        dismissed = dismissed.filter((x) => x !== id)\n        break\n      default:\n        return NextResponse.json({ error: 'bad_action' }, { status: 400 })\n    }\n\n    await prisma.$executeRawUnsafe(\n      'INSERT INTO \"InsightsUserState\" (\"userId\", \"pinned\", \"dismissed\", \"updatedAt\") VALUES ($1, $2::jsonb, $3::jsonb, NOW())\\n       ON CONFLICT (\"userId\") DO UPDATE SET \"pinned\" = EXCLUDED.\"pinned\", \"dismissed\" = EXCLUDED.\"dismissed\", \"updatedAt\" = NOW()',\n      session.user.id,\n      JSON.stringify(pinned),\n      JSON.stringify(dismissed),\n    )\n\n    return NextResponse.json({ pinned, dismissed }, { status: 200 })\n  } catch (e) {\n    return NextResponse.json({ error: 'server_error' }, { status: 500 })\n  }\n}\n\n\n","truncated":false,"size":3044},{"path":"app/api/interaction-history/[id]/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\n\nexport async function DELETE(\n  request: NextRequest,\n  { params }: { params: { id: string } }\n) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.email) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n\n    const user = await prisma.user.findUnique({ where: { email: session.user.email } })\n    if (!user) return NextResponse.json({ error: 'User not found' }, { status: 404 })\n\n    const id = params.id\n    if (!id) return NextResponse.json({ error: 'Missing id' }, { status: 400 })\n\n    const deleted = await prisma.interactionAnalysis.deleteMany({ where: { id, userId: user.id } })\n    if (deleted.count === 0) return NextResponse.json({ error: 'Not found' }, { status: 404 })\n\n    return NextResponse.json({ success: true })\n  } catch (e) {\n    return NextResponse.json({ error: 'Failed to delete' }, { status: 500 })\n  }\n}\n\n\n","truncated":false,"size":1071},{"path":"app/api/interaction-history/route.ts","content":"import { NextRequest, NextResponse } from 'next/server';\nimport { getServerSession } from 'next-auth';\nimport { authOptions } from '@/lib/auth';\nimport { prisma } from '@/lib/prisma';\n\nexport async function GET(request: NextRequest) {\n  try {\n    // Check authentication\n    const session = await getServerSession(authOptions);\n    if (!session?.user?.email) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n    }\n\n    // Find user in database\n    const user = await prisma.user.findUnique({\n      where: { email: session.user.email }\n    });\n\n    if (!user) {\n      return NextResponse.json({ error: 'User not found' }, { status: 404 });\n    }\n\n    // Fetch user's interaction analyses, ordered by most recent first\n    const analyses = await prisma.interactionAnalysis.findMany({\n      where: { userId: user.id },\n      orderBy: { createdAt: 'desc' },\n      select: {\n        id: true,\n        analysisName: true,\n        overallRisk: true,\n        supplementCount: true,\n        medicationCount: true,\n        createdAt: true,\n        analysisData: true, // Include the full analysis data\n        supplementsAnalyzed: true,\n        medicationsAnalyzed: true,\n      }\n    });\n\n    return NextResponse.json({ \n      success: true, \n      analyses \n    });\n\n  } catch (error) {\n    console.error('Error fetching interaction history:', error);\n    return NextResponse.json({ \n      error: 'Failed to fetch interaction history',\n      details: error instanceof Error ? error.message : 'Unknown error'\n    }, { status: 500 });\n  }\n}\n\nexport async function DELETE(request: NextRequest) {\n  try {\n    // Check authentication\n    const session = await getServerSession(authOptions);\n    if (!session?.user?.email) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n    }\n\n    // Find user in database\n    const user = await prisma.user.findUnique({\n      where: { email: session.user.email }\n    });\n\n    if (!user) {\n      return NextResponse.json({ error: 'User not found' }, { status: 404 });\n    }\n\n    // Delete all analyses for the user\n    const deletedCount = await prisma.interactionAnalysis.deleteMany({\n      where: { userId: user.id }\n    });\n\n    return NextResponse.json({ \n      success: true, \n      message: `Deleted ${deletedCount.count} analyses`,\n      deletedCount: deletedCount.count\n    });\n\n  } catch (error) {\n    console.error('Error deleting interaction history:', error);\n    return NextResponse.json({ \n      error: 'Failed to delete interaction history',\n      details: error instanceof Error ? error.message : 'Unknown error'\n    }, { status: 500 });\n  }\n} ","truncated":false,"size":2638},{"path":"app/api/medical-images/chat/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport OpenAI from 'openai'\nimport { prisma } from '@/lib/prisma'\nimport { CreditManager } from '@/lib/credit-system'\nimport { capMaxTokensToBudget } from '@/lib/cost-meter'\nimport { chatCompletionWithCost } from '@/lib/metered-openai'\nimport { logAIUsage } from '@/lib/ai-usage-logger'\nimport { consumeFreeCredit, hasFreeCredits } from '@/lib/free-credits'\nimport { isSubscriptionActive } from '@/lib/subscription-utils'\n\nfunction getOpenAIClient(): OpenAI | null {\n  if (!process.env.OPENAI_API_KEY) return null\n  return new OpenAI({ apiKey: process.env.OPENAI_API_KEY })\n}\n\nexport async function POST(req: NextRequest) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.email) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const contentType = req.headers.get('content-type') || ''\n    let body: {\n      message?: string\n      analysisResult?: any\n    } = {}\n    if (contentType.includes('application/json')) {\n      try {\n        body = await req.json()\n      } catch {}\n    }\n\n    const question = String(body?.message || '').trim()\n    if (!question) {\n      return NextResponse.json({ error: 'Message required' }, { status: 400 })\n    }\n\n    const analysisResult = body.analysisResult || {}\n\n    const openai = getOpenAIClient()\n    if (!openai) {\n      return NextResponse.json({ error: 'OpenAI API key not configured' }, { status: 500 })\n    }\n    const user = await prisma.user.findUnique({\n      where: { email: session.user.email },\n      include: { subscription: true, creditTopUps: true },\n    })\n    if (!user) {\n      return NextResponse.json({ error: 'User not found' }, { status: 404 })\n    }\n\n    const isPremium = isSubscriptionActive(user.subscription)\n    const now = new Date()\n    const hasPurchasedCredits = user.creditTopUps?.some(\n      (topUp: any) => topUp.expiresAt > now && (topUp.amountCents - topUp.usedCents) > 0\n    )\n    const hasFreeChatCredits = await hasFreeCredits(user.id, 'MEDICAL_CHAT')\n    const allowViaFreeUse = !isPremium && !hasPurchasedCredits && hasFreeChatCredits\n    if (!isPremium && !hasPurchasedCredits && !hasFreeChatCredits) {\n      return NextResponse.json(\n        {\n          error: 'Payment required',\n          message: 'You\\'ve used all your free medical image chat uses. Subscribe to a monthly plan or purchase credits to continue.',\n          requiresPayment: true,\n          exhaustedFreeCredits: true,\n        },\n        { status: 402 }\n      )\n    }\n\n    // Build system prompt with medical image analysis context\n    const systemPrompt = [\n      'You are a careful, patient-friendly assistant helping users understand and ask follow-up questions about a recent medical image analysis.',\n      'You already have the analysis result from their Medical Image Analyzer. Treat that as background context that you silently keep in mind ‚Äì the user has already seen those results above, so you do NOT need to repeat the whole analysis each time.',\n      '',\n      analysisResult.summary ? `Analysis summary: ${analysisResult.summary}` : '',\n      Array.isArray(analysisResult.possibleCauses) && analysisResult.possibleCauses.length\n        ? `Likely conditions (from highest to lowest confidence):\\n${analysisResult.possibleCauses\n            .map(\n              (c: any, index: number) =>\n                `- ${index === 0 ? '[highest]' : ''}${c.name} (${c.confidence || 'unknown'}): ${\n                  c.whyLikely || ''\n                }`.trim()\n            )\n            .join('\\n')}`\n        : '',\n      Array.isArray(analysisResult.redFlags) && analysisResult.redFlags.length\n        ? `Red-flag signs mentioned in the analysis:\\n${analysisResult.redFlags\n            .map((rf: string) => `- ${rf}`)\n            .join('\\n')}`\n        : '',\n      Array.isArray(analysisResult.nextSteps) && analysisResult.nextSteps.length\n        ? `Suggested next steps from the analysis:\\n${analysisResult.nextSteps\n            .map((ns: string) => `- ${ns}`)\n            .join('\\n')}`\n        : '',\n      analysisResult.analysisText\n        ? `Full analysis text (for your reference only):\\n${String(analysisResult.analysisText).slice(\n            0,\n            1200\n          )}`\n        : '',\n      '',\n      'When you answer, focus on the user‚Äôs specific question, not on re-stating the full analysis.',\n      '',\n      'Always use the following section layout with the bold headings written exactly as shown, each on its own line with a blank line after it:',\n      '',\n      '**Short answer**',\n      '- 2‚Äì4 sentences that directly answer the user‚Äôs question in plain language.',\n      '',\n      '**Why this matters**',\n      '- 2‚Äì4 short bullet points explaining why this information is important for them (for example: what it could mean for their health, how it might change over time, or why monitoring is useful).',\n      '',\n      '**When to see a doctor**',\n      '- Bullet points explaining when it is sensible to book a routine appointment and when it is important to seek urgent or emergency care, tailored to their question.',\n      '',\n      '**What you can do at home**',\n      '- Simple, practical self-care steps or monitoring tips that are appropriate for their situation and consistent with the analysis.',\n      '',\n      'Only pull in details from the original analysis when they help answer the question; do NOT dump or repeat the full report. Use short sentences and bullet points so the reply is easy to scan in the chat bubble.',\n      '',\n      'Safety rules:',\n      '- Do NOT provide a formal diagnosis or treatment plan.',\n      '- Do NOT say that a doctor is unnecessary; instead, explain when medical review would be sensible.',\n      '- Always remind the user that this information does not replace a real doctor‚Äôs examination.',\n    ]\n      .filter(Boolean)\n      .join('\\n')\n\n    const accept = (req.headers.get('accept') || '').toLowerCase()\n    const wantsStream = accept.includes('text/event-stream')\n\n    const chatMessages = [\n      { role: 'system' as const, content: systemPrompt },\n      { role: 'user' as const, content: question },\n    ]\n\n    if (wantsStream) {\n      const model = process.env.OPENAI_INSIGHTS_MODEL || 'gpt-4o-mini'\n      const promptText = `${systemPrompt}\\n${question}`\n      let maxTokens = 800\n      if (!allowViaFreeUse) {\n        const cm = new CreditManager(user.id)\n        const wallet = await cm.getWalletStatus()\n        const cappedMaxTokens = capMaxTokensToBudget(model, promptText, maxTokens, wallet.totalAvailableCents)\n        if (cappedMaxTokens <= 0) {\n          return NextResponse.json({ error: 'Insufficient credits' }, { status: 402 })\n        }\n        maxTokens = cappedMaxTokens\n      }\n\n      const wrapped = await chatCompletionWithCost(openai, {\n        model,\n        temperature: 0.2,\n        max_tokens: maxTokens,\n        messages: chatMessages as any,\n      } as any)\n\n      if (!allowViaFreeUse) {\n        const cm = new CreditManager(user.id)\n        const ok = await cm.chargeCents(wrapped.costCents)\n        if (!ok) {\n          return NextResponse.json({ error: 'Insufficient credits' }, { status: 402 })\n        }\n      } else {\n        await consumeFreeCredit(user.id, 'MEDICAL_CHAT')\n      }\n\n      try {\n        await logAIUsage({\n          context: { feature: 'medical-image:chat', userId: user.id },\n          model,\n          promptTokens: wrapped.promptTokens,\n          completionTokens: wrapped.completionTokens,\n          costCents: wrapped.costCents,\n        })\n      } catch {\n        // Ignore logging failures\n      }\n\n      const text = wrapped.completion.choices?.[0]?.message?.content || ''\n      const enc = new TextEncoder()\n      const chunks = text.match(/[\\s\\S]{1,200}/g) || ['']\n      const stream = new ReadableStream({\n        start(controller) {\n          for (const chunk of chunks) {\n            controller.enqueue(enc.encode(`data: ${chunk}\\n\\n`))\n          }\n          controller.enqueue(enc.encode('event: end\\n\\n'))\n          controller.close()\n        },\n      })\n      return new Response(stream, { headers: { 'Content-Type': 'text/event-stream' } })\n    }\n\n    // Non-streaming fallback\n    {\n      const model = process.env.OPENAI_INSIGHTS_MODEL || 'gpt-4o-mini'\n      let maxTokens = 800\n      // Pre-check\n      if (!allowViaFreeUse) {\n        const cm = new CreditManager(user.id)\n        const wallet = await cm.getWalletStatus()\n        const cappedMaxTokens = capMaxTokensToBudget(\n          model,\n          `${systemPrompt}\\n${question}`,\n          maxTokens,\n          wallet.totalAvailableCents\n        )\n        if (cappedMaxTokens <= 0) {\n          return NextResponse.json({ error: 'Insufficient credits' }, { status: 402 })\n        }\n        maxTokens = cappedMaxTokens\n      }\n      const wrapped = await chatCompletionWithCost(openai, {\n        model,\n        temperature: 0.2,\n        max_tokens: maxTokens,\n        messages: chatMessages as any,\n      } as any)\n      if (!allowViaFreeUse) {\n        const cm = new CreditManager(user.id)\n        const ok = await cm.chargeCents(wrapped.costCents)\n        if (!ok) {\n          return NextResponse.json({ error: 'Insufficient credits' }, { status: 402 })\n        }\n      } else {\n        await consumeFreeCredit(user.id, 'MEDICAL_CHAT')\n      }\n\n      // Log AI usage for non-streaming medical image chat\n      try {\n        await logAIUsage({\n          context: { feature: 'medical-image:chat', userId: user.id },\n          model,\n          promptTokens: wrapped.promptTokens,\n          completionTokens: wrapped.completionTokens,\n          costCents: wrapped.costCents,\n        })\n      } catch {\n        // Ignore logging failures\n      }\n\n      const text = wrapped.completion.choices?.[0]?.message?.content || ''\n      return NextResponse.json({ assistant: text })\n    }\n  } catch (error) {\n    console.error('[medical-images.chat.POST] error', error)\n    return NextResponse.json({ error: 'server_error' }, { status: 500 })\n  }\n}\n","truncated":false,"size":10128},{"path":"app/api/medical-images/file/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\nimport { del, head, put } from '@vercel/blob'\nimport { decryptBuffer, encryptBuffer } from '@/lib/file-encryption'\nimport { verifySignedFileToken } from '@/lib/signed-file'\n\nconst CACHE_TTL_SECONDS = 60\n\nexport async function GET(request: NextRequest) {\n  try {\n    const { searchParams } = new URL(request.url)\n    const token = (searchParams.get('token') || '').trim()\n    if (!token) {\n      return NextResponse.json({ error: 'Missing token' }, { status: 400 })\n    }\n\n    const payload = verifySignedFileToken(token)\n    if (!payload || payload.usage !== 'MEDICAL_IMAGE') {\n      return NextResponse.json({ error: 'Invalid token' }, { status: 401 })\n    }\n\n    const fileRecord = await prisma.file.findUnique({\n      where: { id: payload.fileId },\n    })\n\n    if (!fileRecord || fileRecord.usage !== 'MEDICAL_IMAGE') {\n      return NextResponse.json({ error: 'File not found' }, { status: 404 })\n    }\n\n    if (payload.userId !== fileRecord.uploadedById) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 403 })\n    }\n\n    const metadata = (fileRecord.metadata || {}) as any\n    const blobPathname = metadata.blobPathname || fileRecord.cloudinaryId || fileRecord.fileName\n    if (!blobPathname) {\n      return NextResponse.json({ error: 'File is unavailable' }, { status: 404 })\n    }\n\n    const blobInfo = await head(blobPathname)\n    if (!blobInfo?.url) {\n      return NextResponse.json({ error: 'File is unavailable' }, { status: 404 })\n    }\n\n    const blobResponse = await fetch(blobInfo.url, {\n      headers: process.env.BLOB_READ_WRITE_TOKEN\n        ? { Authorization: `Bearer ${process.env.BLOB_READ_WRITE_TOKEN}` }\n        : undefined,\n    })\n\n    if (!blobResponse.ok) {\n      return NextResponse.json({ error: 'File is unavailable' }, { status: 404 })\n    }\n\n    let buffer: Buffer = Buffer.from(await blobResponse.arrayBuffer())\n    const isEncrypted = metadata?.encrypted === true\n\n    if (isEncrypted) {\n      buffer = decryptBuffer(buffer, metadata?.encryption?.iv, metadata?.encryption?.tag)\n    } else {\n      try {\n        const encryptedPayload = encryptBuffer(buffer)\n        const upgradedPath = `medical-images/${fileRecord.uploadedById}/${Date.now()}-${fileRecord.id}.bin`\n        const upgradedBlob = await put(upgradedPath, encryptedPayload.encrypted, {\n          access: 'public',\n          contentType: 'application/octet-stream',\n          addRandomSuffix: true,\n        })\n\n        await prisma.file.update({\n          where: { id: fileRecord.id },\n          data: {\n            fileName: upgradedBlob.pathname,\n            cloudinaryId: upgradedBlob.pathname,\n            cloudinaryUrl: upgradedBlob.url,\n            secureUrl: upgradedBlob.url,\n            isPublic: false,\n            metadata: {\n              ...(metadata || {}),\n              blobPathname: upgradedBlob.pathname,\n              blobUrl: upgradedBlob.url,\n              encrypted: true,\n              encryption: {\n                algorithm: 'aes-256-gcm',\n                iv: encryptedPayload.iv,\n                tag: encryptedPayload.tag,\n              },\n            },\n          },\n        })\n\n        await del(blobPathname).catch(() => {})\n      } catch (upgradeError) {\n        console.warn('Medical image encryption upgrade failed:', upgradeError)\n      }\n    }\n\n    return new NextResponse(buffer, {\n      headers: {\n        'Content-Type': fileRecord.mimeType || 'application/octet-stream',\n        'Cache-Control': `private, max-age=${CACHE_TTL_SECONDS}`,\n      },\n    })\n  } catch (error) {\n    console.error('Secure medical image fetch failed:', error)\n    return NextResponse.json({ error: 'Failed to load file' }, { status: 500 })\n  }\n}\n\nexport const runtime = 'nodejs'\n","truncated":false,"size":3803},{"path":"app/api/medical-images/history/[id]/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\nimport { del } from '@vercel/blob'\n\nexport async function DELETE(\n  request: NextRequest,\n  { params }: { params: { id: string } }\n) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.email) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const user = await prisma.user.findUnique({ where: { email: session.user.email } })\n    if (!user) {\n      return NextResponse.json({ error: 'User not found' }, { status: 404 })\n    }\n\n    const analysisId = params.id\n    if (!analysisId) {\n      return NextResponse.json({ error: 'Missing id' }, { status: 400 })\n    }\n\n    const analysis = await prisma.medicalImageAnalysis.findFirst({\n      where: { id: analysisId, userId: user.id },\n      include: { imageFile: true },\n    })\n\n    if (!analysis) {\n      return NextResponse.json({ error: 'Not found' }, { status: 404 })\n    }\n\n    const blobTarget = analysis.imageFile?.cloudinaryId || analysis.imageFile?.secureUrl || null\n    if (blobTarget && process.env.BLOB_READ_WRITE_TOKEN) {\n      try {\n        await del(blobTarget)\n      } catch (deleteError) {\n        console.warn('Failed to delete medical image blob:', deleteError)\n      }\n    }\n\n    await prisma.$transaction([\n      prisma.medicalImageAnalysis.delete({ where: { id: analysis.id } }),\n      analysis.imageFileId\n        ? prisma.file.deleteMany({ where: { id: analysis.imageFileId } })\n        : prisma.file.deleteMany({ where: { id: { in: [] } } }),\n    ])\n\n    return NextResponse.json({ success: true })\n  } catch (error) {\n    console.error('Error deleting medical image history item:', error)\n    return NextResponse.json(\n      {\n        error: 'Failed to delete history item',\n        details: error instanceof Error ? error.message : 'Unknown error',\n      },\n      { status: 500 }\n    )\n  }\n}\n","truncated":false,"size":2020},{"path":"app/api/medical-images/history/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\nimport { del, put } from '@vercel/blob'\nimport { encryptBuffer } from '@/lib/file-encryption'\nimport { createSignedFileToken } from '@/lib/signed-file'\n\nconst contentTypeToExt = (contentType: string) => {\n  if (contentType === 'image/png') return 'png'\n  if (contentType === 'image/webp') return 'webp'\n  if (contentType === 'image/gif') return 'gif'\n  return 'jpg'\n}\n\nexport async function GET(request: NextRequest) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.email) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const user = await prisma.user.findUnique({\n      where: { email: session.user.email },\n    })\n\n    if (!user) {\n      return NextResponse.json({ error: 'User not found' }, { status: 404 })\n    }\n\n    const analyses = await prisma.medicalImageAnalysis.findMany({\n      where: { userId: user.id },\n      orderBy: { createdAt: 'desc' },\n      select: {\n        id: true,\n        summary: true,\n        analysisText: true,\n        analysisData: true,\n        createdAt: true,\n        imageFile: {\n          select: {\n            id: true,\n            uploadedById: true,\n          },\n        },\n      },\n    })\n\n    const history = analyses.map((item) => {\n      const fileId = item.imageFile?.id\n      const ownerId = item.imageFile?.uploadedById || user.id\n      const imageUrl = fileId\n        ? `/api/medical-images/file?token=${encodeURIComponent(\n            createSignedFileToken({ fileId, userId: ownerId, usage: 'MEDICAL_IMAGE' })\n          )}`\n        : null\n\n      return {\n      id: item.id,\n      summary: item.summary,\n      analysisText: item.analysisText,\n      analysisData: item.analysisData,\n      createdAt: item.createdAt,\n      imageUrl,\n    }\n  })\n\n    return NextResponse.json({ success: true, history })\n  } catch (error) {\n    console.error('Error fetching medical image history:', error)\n    return NextResponse.json(\n      {\n        error: 'Failed to fetch medical image history',\n        details: error instanceof Error ? error.message : 'Unknown error',\n      },\n      { status: 500 }\n    )\n  }\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.email) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const user = await prisma.user.findUnique({\n      where: { email: session.user.email },\n    })\n\n    if (!user) {\n      return NextResponse.json({ error: 'User not found' }, { status: 404 })\n    }\n\n    if (!process.env.BLOB_READ_WRITE_TOKEN) {\n      return NextResponse.json({ error: 'Image storage is not configured' }, { status: 500 })\n    }\n\n    const formData = await request.formData()\n    const imageFile = formData.get('image')\n    const analysisRaw = formData.get('analysis')\n\n    if (!imageFile || typeof imageFile === 'string') {\n      return NextResponse.json({ error: 'No image provided' }, { status: 400 })\n    }\n    if (!analysisRaw || typeof analysisRaw !== 'string') {\n      return NextResponse.json({ error: 'No analysis provided' }, { status: 400 })\n    }\n\n    let analysisPayload: any\n    try {\n      analysisPayload = JSON.parse(analysisRaw)\n    } catch {\n      return NextResponse.json({ error: 'Invalid analysis payload' }, { status: 400 })\n    }\n\n    const ext = contentTypeToExt(imageFile.type || 'image/jpeg')\n    const filename = `${Date.now()}.${ext}`\n    const pathname = `medical-images/${user.id}/${filename}`\n    const buffer = Buffer.from(await imageFile.arrayBuffer())\n    const encryptedPayload = encryptBuffer(buffer)\n\n    const blob = await put(pathname, encryptedPayload.encrypted, {\n      access: 'public',\n      contentType: 'application/octet-stream',\n      addRandomSuffix: true,\n    })\n\n    const fileRecord = await prisma.file.create({\n      data: {\n        originalName: imageFile.name || filename,\n        fileName: blob.pathname,\n        fileSize: imageFile.size || buffer.length,\n        mimeType: imageFile.type || 'image/jpeg',\n        cloudinaryId: blob.pathname,\n        cloudinaryUrl: blob.url,\n        secureUrl: blob.url,\n        uploadedById: user.id,\n        fileType: 'IMAGE',\n        usage: 'MEDICAL_IMAGE',\n        isPublic: false,\n        metadata: {\n          storage: 'vercel-blob',\n          blobPathname: blob.pathname,\n          blobUrl: blob.url,\n          encrypted: true,\n          encryption: {\n            algorithm: 'aes-256-gcm',\n            iv: encryptedPayload.iv,\n            tag: encryptedPayload.tag,\n          },\n          format: ext,\n          originalSize: imageFile.size || buffer.length,\n        },\n      },\n    })\n\n    const analysisData = {\n      summary: analysisPayload?.summary ?? null,\n      possibleCauses: Array.isArray(analysisPayload?.possibleCauses)\n        ? analysisPayload.possibleCauses\n        : [],\n      redFlags: Array.isArray(analysisPayload?.redFlags) ? analysisPayload.redFlags : [],\n      nextSteps: Array.isArray(analysisPayload?.nextSteps) ? analysisPayload.nextSteps : [],\n      disclaimer: analysisPayload?.disclaimer ?? null,\n    }\n\n    const saved = await prisma.medicalImageAnalysis.create({\n      data: {\n        userId: user.id,\n        imageFileId: fileRecord.id,\n        summary: analysisPayload?.summary ?? null,\n        analysisText: analysisPayload?.analysisText ?? null,\n        analysisData,\n      },\n    })\n\n    return NextResponse.json({\n      success: true,\n      historyItem: {\n        id: saved.id,\n        summary: saved.summary,\n        analysisText: saved.analysisText,\n        analysisData: saved.analysisData,\n        createdAt: saved.createdAt,\n        imageUrl: `/api/medical-images/file?token=${encodeURIComponent(\n          createSignedFileToken({ fileId: fileRecord.id, userId: user.id, usage: 'MEDICAL_IMAGE' })\n        )}`,\n      },\n    })\n  } catch (error) {\n    console.error('Error saving medical image history:', error)\n    return NextResponse.json(\n      {\n        error: 'Failed to save medical image history',\n        details: error instanceof Error ? error.message : 'Unknown error',\n      },\n      { status: 500 }\n    )\n  }\n}\n\nexport async function DELETE(request: NextRequest) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.email) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const user = await prisma.user.findUnique({\n      where: { email: session.user.email },\n    })\n\n    if (!user) {\n      return NextResponse.json({ error: 'User not found' }, { status: 404 })\n    }\n\n    const analyses = await prisma.medicalImageAnalysis.findMany({\n      where: { userId: user.id },\n      select: {\n        id: true,\n        imageFileId: true,\n        imageFile: {\n          select: {\n            cloudinaryId: true,\n            secureUrl: true,\n          },\n        },\n      },\n    })\n\n    const blobTargets = analyses\n      .map((item) => item.imageFile?.cloudinaryId || item.imageFile?.secureUrl)\n      .filter((value): value is string => typeof value === 'string' && value.length > 0)\n\n    if (process.env.BLOB_READ_WRITE_TOKEN && blobTargets.length > 0) {\n      try {\n        await del(blobTargets)\n      } catch (deleteError) {\n        console.warn('Failed to delete medical image blobs:', deleteError)\n      }\n    }\n\n    const fileIds = analyses\n      .map((item) => item.imageFileId)\n      .filter((value): value is string => typeof value === 'string' && value.length > 0)\n\n    const deletedCount = await prisma.$transaction([\n      prisma.medicalImageAnalysis.deleteMany({ where: { userId: user.id } }),\n      fileIds.length > 0\n        ? prisma.file.deleteMany({ where: { id: { in: fileIds } } })\n        : prisma.file.deleteMany({ where: { id: { in: [] } } }),\n    ])\n\n    return NextResponse.json({\n      success: true,\n      message: `Deleted ${deletedCount[0].count} analyses`,\n      deletedCount: deletedCount[0].count,\n    })\n  } catch (error) {\n    console.error('Error deleting medical image history:', error)\n    return NextResponse.json(\n      {\n        error: 'Failed to delete medical image history',\n        details: error instanceof Error ? error.message : 'Unknown error',\n      },\n      { status: 500 }\n    )\n  }\n}\n","truncated":false,"size":8406},{"path":"app/api/mood/_db.ts","content":"import { prisma } from '@/lib/prisma'\n\nexport async function ensureMoodTables() {\n  // Keep Mood Tracker storage isolated to avoid touching Prisma migrations.\n  // Uses JSONB for flexible optional context and tags.\n  await prisma.$executeRawUnsafe(`\n    CREATE TABLE IF NOT EXISTS MoodEntries (\n      id TEXT PRIMARY KEY,\n      userId TEXT NOT NULL,\n      localDate TEXT NOT NULL,\n      timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n      mood INTEGER NOT NULL,\n      tags JSONB NOT NULL DEFAULT '[]'::jsonb,\n      note TEXT NOT NULL DEFAULT '',\n      context JSONB NOT NULL DEFAULT '{}'::jsonb\n    )\n  `)\n\n  await prisma.$executeRawUnsafe(`CREATE INDEX IF NOT EXISTS idx_moodentries_user_timestamp ON MoodEntries(userId, timestamp DESC)`).catch(() => {})\n  await prisma.$executeRawUnsafe(`CREATE INDEX IF NOT EXISTS idx_moodentries_user_localdate ON MoodEntries(userId, localDate)`).catch(() => {})\n\n  await prisma.$executeRawUnsafe(`\n    CREATE TABLE IF NOT EXISTS MoodJournalEntries (\n      id TEXT PRIMARY KEY,\n      userId TEXT NOT NULL,\n      localDate TEXT NOT NULL,\n      title TEXT NOT NULL DEFAULT '',\n      content TEXT NOT NULL DEFAULT '',\n      images JSONB NOT NULL DEFAULT '[]'::jsonb,\n      tags JSONB NOT NULL DEFAULT '[]'::jsonb,\n      audio JSONB NOT NULL DEFAULT '[]'::jsonb,\n      prompt TEXT NOT NULL DEFAULT '',\n      template TEXT NOT NULL DEFAULT '',\n      createdAt TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n      updatedAt TIMESTAMPTZ NOT NULL DEFAULT NOW()\n    )\n  `)\n\n  await prisma.$executeRawUnsafe(`CREATE INDEX IF NOT EXISTS idx_moodjournal_user_created ON MoodJournalEntries(userId, createdAt DESC)`).catch(() => {})\n  await prisma.$executeRawUnsafe(`CREATE INDEX IF NOT EXISTS idx_moodjournal_user_localdate ON MoodJournalEntries(userId, localDate)`).catch(() => {})\n\n  await prisma.$executeRawUnsafe(`ALTER TABLE MoodJournalEntries ADD COLUMN IF NOT EXISTS tags JSONB NOT NULL DEFAULT '[]'::jsonb`).catch(() => {})\n  await prisma.$executeRawUnsafe(`ALTER TABLE MoodJournalEntries ADD COLUMN IF NOT EXISTS audio JSONB NOT NULL DEFAULT '[]'::jsonb`).catch(() => {})\n  await prisma.$executeRawUnsafe(`ALTER TABLE MoodJournalEntries ADD COLUMN IF NOT EXISTS prompt TEXT NOT NULL DEFAULT ''`).catch(() => {})\n  await prisma.$executeRawUnsafe(`ALTER TABLE MoodJournalEntries ADD COLUMN IF NOT EXISTS template TEXT NOT NULL DEFAULT ''`).catch(() => {})\n\n  // Mood reminder preferences (push notifications) and delivery log.\n  await prisma.$executeRawUnsafe(`\n    CREATE TABLE IF NOT EXISTS MoodReminderSettings (\n      userId TEXT PRIMARY KEY,\n      enabled BOOLEAN NOT NULL DEFAULT FALSE,\n      time1 TEXT NOT NULL DEFAULT '20:00',\n      time2 TEXT NOT NULL DEFAULT '12:00',\n      time3 TEXT NOT NULL DEFAULT '18:00',\n      timezone TEXT NOT NULL DEFAULT 'UTC',\n      frequency INTEGER NOT NULL DEFAULT 1\n    )\n  `)\n\n  await prisma.$executeRawUnsafe(`\n    CREATE TABLE IF NOT EXISTS MoodReminderDeliveryLog (\n      userId TEXT NOT NULL,\n      reminderTime TEXT NOT NULL,\n      sentDate DATE NOT NULL,\n      sentAt TIMESTAMP NOT NULL DEFAULT NOW(),\n      PRIMARY KEY (userId, reminderTime, sentDate)\n    )\n  `)\n}\n","truncated":false,"size":3136},{"path":"app/api/mood/context/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\nimport { ensureMoodTables } from '@/app/api/mood/_db'\n\nexport const dynamic = 'force-dynamic'\n\nfunction clampInt(value: unknown, min: number, max: number): number | null {\n  if (value === null || value === undefined) return null\n  const n = Number(value)\n  if (!Number.isFinite(n)) return null\n  return Math.max(min, Math.min(max, Math.round(n)))\n}\n\nfunction asLocalDate(value: string | null): string | null {\n  if (!value) return null\n  const trimmed = value.trim()\n  if (!/^\\d{4}-\\d{2}-\\d{2}$/.test(trimmed)) return null\n  return trimmed\n}\n\nfunction dateFromLocalDate(localDate: string): Date {\n  // Date-only columns in Postgres + Prisma map cleanly from a Date instance at UTC midnight.\n  return new Date(`${localDate}T00:00:00.000Z`)\n}\n\nexport async function GET(req: NextRequest) {\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.email) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  const user = await prisma.user.findUnique({ where: { email: session.user.email } })\n  if (!user) return NextResponse.json({ error: 'User not found' }, { status: 404 })\n\n  const { searchParams } = new URL(req.url)\n  const localDate = asLocalDate(searchParams.get('localDate')) ?? new Date().toISOString().slice(0, 10)\n\n  try {\n    await ensureMoodTables().catch(() => {})\n\n    const mealsTodayCount = await prisma.foodLog.count({\n      where: { userId: user.id, localDate },\n    }).catch(() => 0)\n\n    const lastMeal = await prisma.foodLog.findFirst({\n      where: { userId: user.id },\n      orderBy: { createdAt: 'desc' },\n      select: { id: true, name: true, createdAt: true, meal: true },\n    }).catch(() => null)\n\n    const supplementsCount = await prisma.supplement.count({\n      where: { userId: user.id },\n    }).catch(() => 0)\n\n    const exerciseToday = await prisma.exerciseEntry.aggregate({\n      where: { userId: user.id, localDate },\n      _sum: { durationMinutes: true, calories: true },\n    }).catch(() => ({ _sum: { durationMinutes: null, calories: null } }))\n\n    const stepsToday = await prisma.fitbitData.findUnique({\n      where: { userId_date_dataType: { userId: user.id, date: dateFromLocalDate(localDate), dataType: 'steps' } },\n      select: { value: true },\n    }).catch(() => null)\n\n    const sleepRecent = await prisma.fitbitData.findFirst({\n      where: {\n        userId: user.id,\n        dataType: 'sleep',\n        date: { gte: dateFromLocalDate(new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString().slice(0, 10)) },\n      },\n      orderBy: { date: 'desc' },\n      select: { date: true, value: true },\n    }).catch(() => null)\n\n    const stepsCount = (() => {\n      const raw = (stepsToday as any)?.value\n      if (!raw) return null\n      if (typeof raw === 'number') return clampInt(raw, 0, 500_000)\n      if (typeof raw === 'object' && raw && 'steps' in raw) return clampInt((raw as any).steps, 0, 500_000)\n      return null\n    })()\n\n    const sleepMinutes = (() => {\n      const raw = (sleepRecent as any)?.value\n      if (!raw) return null\n      if (typeof raw === 'number') return clampInt(raw, 0, 24 * 60)\n      if (typeof raw === 'object' && raw) {\n        const maybe = (raw as any).minutes ?? (raw as any).totalMinutesAsleep ?? (raw as any).sleepMinutes\n        return clampInt(maybe, 0, 24 * 60)\n      }\n      return null\n    })()\n\n    return NextResponse.json({\n      localDate,\n      meals: {\n        todayCount: mealsTodayCount,\n        last: lastMeal\n          ? {\n              id: lastMeal.id,\n              name: lastMeal.name,\n              meal: lastMeal.meal,\n              at: lastMeal.createdAt,\n            }\n          : null,\n      },\n      supplements: { count: supplementsCount },\n      activity: {\n        stepsToday: stepsCount,\n        exerciseMinutesToday: clampInt(exerciseToday._sum.durationMinutes, 0, 24 * 60),\n        exerciseCaloriesToday: clampInt(exerciseToday._sum.calories, 0, 50_000),\n      },\n      sleep: {\n        minutes: sleepMinutes,\n        date: sleepRecent?.date ?? null,\n      },\n    })\n  } catch (e) {\n    console.error('mood context error', e)\n    return NextResponse.json({ error: 'Failed to load context' }, { status: 500 })\n  }\n}\n\n","truncated":false,"size":4345},{"path":"app/api/mood/dispatch/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\nimport webpush from 'web-push'\nimport { ensureMoodTables } from '@/app/api/mood/_db'\nimport { scheduleAllMoodReminders, scheduleMoodReminderWithQStash } from '@/lib/qstash'\nimport { normalizeSubscriptionList, removeSubscriptionsByEndpoint, sendToSubscriptions } from '@/lib/push-subscriptions'\nimport { isSchedulerAuthorized } from '@/lib/scheduler-auth'\n\nexport const runtime = 'nodejs'\nexport const dynamic = 'force-dynamic'\n\ntype DispatchPayload = {\n  userId: string\n  reminderTime: string\n  timezone: string\n}\n\nfunction safeTimezone(input: string) {\n  const tz = (input || 'UTC').trim()\n  if (!tz) return 'UTC'\n  try {\n    new Intl.DateTimeFormat('en-GB', { timeZone: tz })\n    return tz\n  } catch {\n    return 'UTC'\n  }\n}\n\nfunction localDateForTimezone(now: Date, timezone: string) {\n  const dateParts = new Intl.DateTimeFormat('en-GB', {\n    timeZone: timezone,\n    year: 'numeric',\n    month: '2-digit',\n    day: '2-digit',\n  }).formatToParts(now)\n  const year = dateParts.find((p) => p.type === 'year')?.value || '1970'\n  const month = dateParts.find((p) => p.type === 'month')?.value || '01'\n  const day = dateParts.find((p) => p.type === 'day')?.value || '01'\n  return `${year}-${month}-${day}`\n}\n\nexport async function POST(req: NextRequest) {\n  try {\n    if (!isSchedulerAuthorized(req)) {\n      return NextResponse.json({ error: 'unauthorized' }, { status: 401 })\n    }\n\n    const body = (await req.json().catch(() => ({}))) as Partial<DispatchPayload>\n    const userId = String(body.userId || '')\n    const reminderTime = String(body.reminderTime || '')\n    const timezone = String(body.timezone || '')\n    if (!userId || !reminderTime || !timezone) {\n      return NextResponse.json({ error: 'invalid_payload' }, { status: 400 })\n    }\n\n    await ensureMoodTables()\n\n    const subscriptionRows: Array<{ subscription: any }> = await prisma.$queryRawUnsafe(\n      `SELECT subscription FROM PushSubscriptions WHERE userId = $1`,\n      userId,\n    )\n    if (!subscriptionRows.length) {\n      return NextResponse.json({ error: 'no_subscription' }, { status: 400 })\n    }\n    const subscriptions = normalizeSubscriptionList(subscriptionRows[0].subscription)\n    if (!subscriptions.length) {\n      return NextResponse.json({ error: 'no_subscription' }, { status: 400 })\n    }\n\n    const settingsRows: Array<{\n      enabled: boolean\n      time1: string\n      time2: string\n      time3: string\n      timezone: string\n      frequency: number | null\n    }> = await prisma.$queryRawUnsafe(\n      `SELECT enabled, time1, time2, time3, timezone, frequency FROM MoodReminderSettings WHERE userId = $1`,\n      userId,\n    )\n    const settings = settingsRows[0]\n    const resolvedFrequency = Math.max(1, Math.min(3, settings?.frequency ?? 1))\n    const activeTimes: string[] = []\n    if (resolvedFrequency >= 1 && settings?.time1) activeTimes.push(settings.time1)\n    if (resolvedFrequency >= 2 && settings?.time2) activeTimes.push(settings.time2)\n    if (resolvedFrequency >= 3 && settings?.time3) activeTimes.push(settings.time3)\n    const timezoneToUse = settings?.timezone || timezone\n\n    const remindersEnabled = settings?.enabled ?? false\n    const reminderStillActive = settings ? activeTimes.includes(reminderTime) : false\n    const timezoneStillMatches = settings ? settings.timezone === timezone : false\n\n    if (!remindersEnabled || !reminderStillActive || !timezoneStillMatches) {\n      if (settings && settings.enabled) {\n        const rescheduleTimezone = safeTimezone(settings.timezone)\n        try {\n          await scheduleAllMoodReminders(userId, {\n            time1: settings.time1,\n            time2: settings.time2,\n            time3: settings.time3,\n            timezone: rescheduleTimezone,\n            frequency: resolvedFrequency,\n          })\n        } catch (err) {\n          console.error('[MOOD_DISPATCH] Failed to reschedule active reminders after stale job', err)\n        }\n      }\n      return NextResponse.json({\n        skipped: 'stale_schedule',\n        reason: remindersEnabled ? 'time_or_timezone_changed' : 'disabled',\n      })\n    }\n\n    const publicKey = process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY || ''\n    const privateKey = process.env.VAPID_PRIVATE_KEY || ''\n    if (!publicKey || !privateKey) {\n      return NextResponse.json({ error: 'vapid_not_configured' }, { status: 500 })\n    }\n    webpush.setVapidDetails('mailto:support@helfi.ai', publicKey, privateKey)\n\n    const now = new Date()\n    const effectiveTimezone = safeTimezone(timezoneToUse)\n    const localDate = localDateForTimezone(now, effectiveTimezone)\n\n    const already: Array<{ exists: number }> = await prisma.$queryRawUnsafe(\n      `SELECT 1 as exists FROM MoodReminderDeliveryLog WHERE userId = $1 AND reminderTime = $2 AND sentDate = $3::date LIMIT 1`,\n      userId,\n      reminderTime,\n      localDate,\n    )\n\n    if (!already.length) {\n      const payload = JSON.stringify({\n        title: 'Quick mood check‚Äëin',\n        body: 'How are you feeling right now? It takes 10 seconds.',\n        url: '/mood/quick',\n      })\n      const { sent, errors, goneEndpoints } = await sendToSubscriptions(subscriptions, (sub) =>\n        webpush.sendNotification(sub, payload)\n      )\n      if (goneEndpoints.length) {\n        const remaining = removeSubscriptionsByEndpoint(subscriptions, goneEndpoints)\n        await prisma.$executeRawUnsafe(\n          `UPDATE PushSubscriptions SET subscription = $2::jsonb, updatedAt = NOW() WHERE userId = $1`,\n          userId,\n          JSON.stringify(remaining)\n        )\n      }\n      if (!sent) {\n        return NextResponse.json({ error: 'push_failed', details: errors }, { status: 500 })\n      }\n\n      await prisma.$queryRawUnsafe(\n        `INSERT INTO MoodReminderDeliveryLog (userId, reminderTime, sentDate, sentAt)\n         VALUES ($1, $2, $3::date, NOW())\n         ON CONFLICT (userId, reminderTime, sentDate) DO UPDATE SET sentAt = NOW()`,\n        userId,\n        reminderTime,\n        localDate,\n      )\n    }\n\n    const nextSchedule = await scheduleMoodReminderWithQStash(userId, reminderTime, effectiveTimezone).catch(\n      (error) => {\n        console.error('[MOOD_DISPATCH] Failed to schedule next reminder via QStash', error)\n        return { scheduled: false, reason: 'exception' }\n      },\n    )\n    if (!nextSchedule?.scheduled) {\n      console.error('[MOOD_DISPATCH] QStash scheduling returned failure', {\n        userId,\n        reminderTime,\n        timezone: effectiveTimezone,\n        reason: nextSchedule?.reason,\n      })\n    }\n\n    return NextResponse.json({ ok: true })\n  } catch (e: any) {\n    console.error('[MOOD_DISPATCH] error', e?.stack || e)\n    return NextResponse.json({ error: 'dispatch_error', message: e?.message || String(e) }, { status: 500 })\n  }\n}\n","truncated":false,"size":6827},{"path":"app/api/mood/entries/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\nimport crypto from 'crypto'\nimport { ensureMoodTables } from '@/app/api/mood/_db'\n\nexport const dynamic = 'force-dynamic'\n\nconst MOOD_MIN = 1\nconst MOOD_MAX = 7\n\nfunction clampInt(value: unknown, min: number, max: number): number | null {\n  if (value === null || value === undefined) return null\n  const n = Number(value)\n  if (!Number.isFinite(n)) return null\n  return Math.max(min, Math.min(max, Math.round(n)))\n}\n\nfunction normalizeTags(value: unknown): string[] {\n  if (!Array.isArray(value)) return []\n  const uniq = new Set<string>()\n  for (const raw of value) {\n    const t = String(raw ?? '').trim()\n    if (!t) continue\n    const cleaned = t.slice(0, 24)\n    uniq.add(cleaned)\n    if (uniq.size >= 12) break\n  }\n  return Array.from(uniq)\n}\n\nfunction normalizeNote(value: unknown): string {\n  const note = String(value ?? '').trim()\n  return note.length > 600 ? note.slice(0, 600) : note\n}\n\nfunction asLocalDate(value: unknown): string | null {\n  const s = String(value ?? '').trim()\n  if (!s) return null\n  if (!/^\\d{4}-\\d{2}-\\d{2}$/.test(s)) return null\n  return s\n}\n\nfunction dateFromLocalDate(localDate: string): Date {\n  return new Date(`${localDate}T00:00:00.000Z`)\n}\n\nfunction pickContextFields(value: any) {\n  const energyLevel = clampInt(value?.energyLevel, 1, 5)\n  const sleepQuality = clampInt(value?.sleepQuality, 1, 5)\n  const nutrition = clampInt(value?.nutrition, 1, 5)\n  const supplements = clampInt(value?.supplements, 1, 5)\n  const physicalActivity = clampInt(value?.physicalActivity, 1, 5)\n  const localHour = clampInt(value?.localHour, 0, 23)\n  const intensityPercent = clampInt(value?.intensityPercent, 0, 100)\n  const feelings = normalizeTags(value?.feelings)\n  return {\n    ...(energyLevel == null ? {} : { energyLevel }),\n    ...(sleepQuality == null ? {} : { sleepQuality }),\n    ...(nutrition == null ? {} : { nutrition }),\n    ...(supplements == null ? {} : { supplements }),\n    ...(physicalActivity == null ? {} : { physicalActivity }),\n    ...(localHour == null ? {} : { localHour }),\n    ...(intensityPercent == null ? {} : { intensityPercent }),\n    ...(feelings.length > 0 ? { feelings } : {}),\n  }\n}\n\nasync function getPassiveContext(userId: string, localDate: string) {\n  const mealsTodayCount = await prisma.foodLog.count({\n    where: { userId, localDate },\n  }).catch(() => 0)\n\n  const lastMeal = await prisma.foodLog.findFirst({\n    where: { userId },\n    orderBy: { createdAt: 'desc' },\n    select: { id: true, name: true, createdAt: true, meal: true },\n  }).catch(() => null)\n\n  const supplementsCount = await prisma.supplement.count({\n    where: { userId },\n  }).catch(() => 0)\n\n  const exerciseToday = await prisma.exerciseEntry.aggregate({\n    where: { userId, localDate },\n    _sum: { durationMinutes: true, calories: true },\n  }).catch(() => ({ _sum: { durationMinutes: null, calories: null } }))\n\n  const stepsToday = await prisma.fitbitData.findUnique({\n    where: { userId_date_dataType: { userId, date: dateFromLocalDate(localDate), dataType: 'steps' } },\n    select: { value: true },\n  }).catch(() => null)\n\n  const sleepRecent = await prisma.fitbitData.findFirst({\n    where: {\n      userId,\n      dataType: 'sleep',\n      date: { gte: dateFromLocalDate(new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString().slice(0, 10)) },\n    },\n    orderBy: { date: 'desc' },\n    select: { date: true, value: true },\n  }).catch(() => null)\n\n  const stepsCount = (() => {\n    const raw = (stepsToday as any)?.value\n    if (!raw) return null\n    if (typeof raw === 'number') return clampInt(raw, 0, 500_000)\n    if (typeof raw === 'object' && raw && 'steps' in raw) return clampInt((raw as any).steps, 0, 500_000)\n    return null\n  })()\n\n  const sleepMinutes = (() => {\n    const raw = (sleepRecent as any)?.value\n    if (!raw) return null\n    if (typeof raw === 'number') return clampInt(raw, 0, 24 * 60)\n    if (typeof raw === 'object' && raw) {\n      const maybe = (raw as any).minutes ?? (raw as any).totalMinutesAsleep ?? (raw as any).sleepMinutes\n      return clampInt(maybe, 0, 24 * 60)\n    }\n    return null\n  })()\n\n  return {\n    mealsTodayCount,\n    lastMeal: lastMeal\n      ? { id: lastMeal.id, name: lastMeal.name, meal: lastMeal.meal, at: lastMeal.createdAt }\n      : null,\n    supplementsCount,\n    stepsToday: stepsCount,\n    exerciseMinutesToday: clampInt(exerciseToday._sum.durationMinutes, 0, 24 * 60),\n    exerciseCaloriesToday: clampInt(exerciseToday._sum.calories, 0, 50_000),\n    sleepMinutes,\n    sleepDate: sleepRecent?.date ?? null,\n  }\n}\n\nexport async function GET(req: NextRequest) {\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.email) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  const user = await prisma.user.findUnique({ where: { email: session.user.email } })\n  if (!user) return NextResponse.json({ error: 'User not found' }, { status: 404 })\n\n  const { searchParams } = new URL(req.url)\n  const start = searchParams.get('start')\n  const end = searchParams.get('end')\n  const period = (searchParams.get('period') || '').toLowerCase()\n\n  const today = new Date().toISOString().slice(0, 10)\n  let startLocalDate = asLocalDate(start) ?? null\n  let endLocalDate = asLocalDate(end) ?? null\n\n  if (!startLocalDate || !endLocalDate) {\n    if (period === 'today') {\n      startLocalDate = today\n      endLocalDate = today\n    } else if (period === 'week') {\n      const d = new Date()\n      d.setDate(d.getDate() - 6)\n      startLocalDate = d.toISOString().slice(0, 10)\n      endLocalDate = today\n    } else if (period === 'month') {\n      const d = new Date()\n      d.setDate(d.getDate() - 29)\n      startLocalDate = d.toISOString().slice(0, 10)\n      endLocalDate = today\n    } else {\n      startLocalDate = '1970-01-01'\n      endLocalDate = today\n    }\n  }\n\n  try {\n    await ensureMoodTables()\n    const rows: any[] = await prisma.$queryRawUnsafe(\n      `SELECT id, localDate, timestamp, mood, tags, note, context\n       FROM MoodEntries\n       WHERE userId = $1 AND localDate BETWEEN $2 AND $3\n       ORDER BY timestamp DESC`,\n      user.id,\n      startLocalDate,\n      endLocalDate,\n    )\n    return NextResponse.json({ range: { start: startLocalDate, end: endLocalDate }, entries: rows })\n  } catch (e) {\n    console.error('mood entries get error', e)\n    return NextResponse.json({ error: 'Failed to load entries' }, { status: 500 })\n  }\n}\n\nexport async function POST(req: NextRequest) {\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.email) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  const user = await prisma.user.findUnique({ where: { email: session.user.email } })\n  if (!user) return NextResponse.json({ error: 'User not found' }, { status: 404 })\n\n  const body = await req.json().catch(() => ({} as any))\n  const mood = clampInt(body?.mood, MOOD_MIN, MOOD_MAX)\n  if (mood == null) return NextResponse.json({ error: 'Mood is required' }, { status: 400 })\n\n  const localDate = asLocalDate(body?.localDate) ?? new Date().toISOString().slice(0, 10)\n  const tags = normalizeTags(body?.tags)\n  const note = normalizeNote(body?.note)\n\n  const id = crypto.randomUUID()\n\n  try {\n    await ensureMoodTables()\n\n    const passive = await getPassiveContext(user.id, localDate)\n    const context = {\n      ...passive,\n      ...pickContextFields(body?.context),\n    }\n\n    await prisma.$queryRawUnsafe(\n      `INSERT INTO MoodEntries (id, userId, localDate, mood, tags, note, context)\n       VALUES ($1, $2, $3, $4, $5::jsonb, $6, $7::jsonb)`,\n      id,\n      user.id,\n      localDate,\n      mood,\n      JSON.stringify(tags),\n      note,\n      JSON.stringify(context),\n    )\n\n    return NextResponse.json({ success: true, id })\n  } catch (e) {\n    console.error('mood entry save error', e)\n    return NextResponse.json({ error: 'Failed to save entry' }, { status: 500 })\n  }\n}\n","truncated":false,"size":8046},{"path":"app/api/mood/insights/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\nimport { ensureMoodTables } from '@/app/api/mood/_db'\n\nexport const dynamic = 'force-dynamic'\n\ntype Insight = {\n  id: string\n  title: string\n  detail: string\n  confidence: 'low' | 'medium' | 'high'\n  sampleSize: number\n}\n\nfunction pearson(x: number[], y: number[]): number | null {\n  const n = Math.min(x.length, y.length)\n  if (n < 3) return null\n  let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0, sumYY = 0, k = 0\n  for (let i = 0; i < n; i++) {\n    const xi = x[i]\n    const yi = y[i]\n    if (xi == null || yi == null || isNaN(xi) || isNaN(yi)) continue\n    k++\n    sumX += xi\n    sumY += yi\n    sumXY += xi * yi\n    sumXX += xi * xi\n    sumYY += yi * yi\n  }\n  if (k < 3) return null\n  const cov = sumXY - (sumX * sumY) / k\n  const varX = sumXX - (sumX * sumX) / k\n  const varY = sumYY - (sumY * sumY) / k\n  if (varX <= 0 || varY <= 0) return null\n  return cov / Math.sqrt(varX * varY)\n}\n\nfunction confidenceFromSample(sampleSize: number): 'low' | 'medium' | 'high' {\n  if (sampleSize >= 21) return 'high'\n  if (sampleSize >= 7) return 'medium'\n  return 'low'\n}\n\nfunction strengthLabel(r: number | null): string {\n  if (r == null) return 'No clear pattern yet'\n  const a = Math.abs(r)\n  if (a >= 0.7) return 'a stronger tendency'\n  if (a >= 0.4) return 'a moderate tendency'\n  if (a >= 0.2) return 'a mild tendency'\n  return 'a very small tendency'\n}\n\nexport async function GET(req: NextRequest) {\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.email) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  const user = await prisma.user.findUnique({ where: { email: session.user.email } })\n  if (!user) return NextResponse.json({ error: 'User not found' }, { status: 404 })\n\n  const { searchParams } = new URL(req.url)\n  const period = (searchParams.get('period') || 'month').toLowerCase()\n\n  const end = new Date().toISOString().slice(0, 10)\n  const start = (() => {\n    const d = new Date()\n    if (period === 'week') d.setDate(d.getDate() - 6)\n    else if (period === 'today') d.setDate(d.getDate() - 0)\n    else d.setDate(d.getDate() - 29)\n    return d.toISOString().slice(0, 10)\n  })()\n\n  try {\n    await ensureMoodTables()\n    const entries: Array<{ localDate: string; timestamp: string; mood: number; context: any }> =\n      (await prisma.$queryRawUnsafe(\n        `SELECT localDate, timestamp, mood, context\n         FROM MoodEntries\n         WHERE userId = $1 AND localDate BETWEEN $2 AND $3\n         ORDER BY timestamp ASC`,\n        user.id,\n        start,\n        end,\n      )) as any\n\n    // Time-of-day buckets (local time is not available; approximate using timestamp hour)\n    const buckets = new Map<'morning' | 'afternoon' | 'evening' | 'night', number[]>()\n    const bucketOfHour = (h: number) => {\n      if (h >= 5 && h <= 11) return 'morning' as const\n      if (h >= 12 && h <= 17) return 'afternoon' as const\n      if (h >= 18 && h <= 23) return 'evening' as const\n      return 'night' as const\n    }\n    for (const e of entries) {\n      const ctxHourRaw = (e as any)?.context?.localHour\n      const ctxHour = Number(ctxHourRaw)\n      const hour = Number.isFinite(ctxHour) ? Math.max(0, Math.min(23, Math.round(ctxHour))) : new Date(e.timestamp).getHours()\n      const b = bucketOfHour(hour)\n      if (!buckets.has(b)) buckets.set(b, [])\n      buckets.get(b)!.push(Number(e.mood))\n    }\n    const bucketAverages = Array.from(buckets.entries()).map(([bucket, arr]) => ({\n      bucket,\n      avg: arr.reduce((a, b) => a + b, 0) / arr.length,\n      n: arr.length,\n    }))\n    bucketAverages.sort((a, b) => b.avg - a.avg)\n    const bestBucket = bucketAverages[0]\n\n    // Per-day mood average\n    const byDay = new Map<string, number[]>()\n    for (const e of entries) {\n      if (!byDay.has(e.localDate)) byDay.set(e.localDate, [])\n      byDay.get(e.localDate)!.push(Number(e.mood))\n    }\n    const dayKeys = Array.from(byDay.keys()).sort()\n    const moodDailyAvg = dayKeys.map((d) => {\n      const arr = byDay.get(d) || []\n      const avg = arr.reduce((a, b) => a + b, 0) / Math.max(1, arr.length)\n      return { date: d, avg }\n    })\n\n    // Join with steps/sleep and meals count\n    const dates = dayKeys\n    const dateObjects = dates.map((d) => new Date(`${d}T00:00:00.000Z`))\n    const fitbit = await prisma.fitbitData.findMany({\n      where: { userId: user.id, date: { in: dateObjects }, dataType: { in: ['steps', 'sleep'] } },\n      select: { date: true, dataType: true, value: true },\n    }).catch(() => [])\n\n    const mealsCounts = await prisma.foodLog.groupBy({\n      by: ['localDate'],\n      where: { userId: user.id, localDate: { in: dates } },\n      _count: { _all: true },\n    }).catch(() => [])\n\n    const stepsByDate = new Map<string, number>()\n    const sleepByDate = new Map<string, number>()\n    for (const row of fitbit as any[]) {\n      const d = new Date(row.date).toISOString().slice(0, 10)\n      if (row.dataType === 'steps') {\n        const v = (row.value?.steps ?? row.value ?? null) as any\n        const n = Number(v)\n        if (Number.isFinite(n)) stepsByDate.set(d, n)\n      }\n      if (row.dataType === 'sleep') {\n        const v = (row.value?.minutes ?? row.value?.totalMinutesAsleep ?? row.value?.sleepMinutes ?? row.value ?? null) as any\n        const n = Number(v)\n        if (Number.isFinite(n)) sleepByDate.set(d, n)\n      }\n    }\n\n    const mealsByDate = new Map<string, number>()\n    for (const row of mealsCounts as any[]) {\n      mealsByDate.set(String(row.localDate), Number(row._count?._all ?? 0))\n    }\n\n    const xMood: number[] = []\n    const xSleep: number[] = []\n    const xSteps: number[] = []\n    const xMeals: number[] = []\n    for (const day of moodDailyAvg) {\n      const sleep = sleepByDate.get(day.date)\n      const steps = stepsByDate.get(day.date)\n      const meals = mealsByDate.get(day.date)\n      xMood.push(day.avg)\n      xSleep.push(sleep ?? NaN)\n      xSteps.push(steps ?? NaN)\n      xMeals.push(meals ?? NaN)\n    }\n\n    const sleepMoodR = pearson(xSleep, xMood)\n    const stepsMoodR = pearson(xSteps, xMood)\n    const mealsMoodR = pearson(xMeals, xMood)\n\n    const sampleSize = moodDailyAvg.length\n    const conf = confidenceFromSample(sampleSize)\n\n    const insights: { sleep: Insight[]; nutrition: Insight[]; supplements: Insight[]; activity: Insight[]; stress: Insight[] } =\n      { sleep: [], nutrition: [], supplements: [], activity: [], stress: [] }\n\n    if (bestBucket && bestBucket.n >= 3) {\n      insights.stress.push({\n        id: 'time-of-day',\n        title: `You tend to feel best in the ${bestBucket.bucket}`,\n        detail: `Based on ${bestBucket.n} check-ins, your average mood is highest in the ${bestBucket.bucket}.`,\n        confidence: confidenceFromSample(bestBucket.n),\n        sampleSize: bestBucket.n,\n      })\n    }\n\n    insights.sleep.push({\n      id: 'sleep-vs-mood',\n      title: 'Sleep and mood show a tendency together',\n      detail: `Across ${sampleSize} day(s), sleep hours and mood show ${strengthLabel(sleepMoodR)}. This is a pattern hint, not a rule.`,\n      confidence: conf,\n      sampleSize,\n    })\n\n    insights.activity.push({\n      id: 'steps-vs-mood',\n      title: 'Activity and mood may move together',\n      detail: `Across ${sampleSize} day(s), daily steps and mood show ${strengthLabel(stepsMoodR)}. Consider it a directional signal.`,\n      confidence: conf,\n      sampleSize,\n    })\n\n    insights.nutrition.push({\n      id: 'meals-vs-mood',\n      title: 'Eating patterns may relate to mood',\n      detail: `Across ${sampleSize} day(s), days with more logged meals show ${strengthLabel(mealsMoodR)} with mood. This is a tendency, not a claim.`,\n      confidence: conf,\n      sampleSize,\n    })\n\n    // Supplements aren't reliably trackable per-day yet for correlation, so keep this empty for now.\n    insights.supplements = []\n\n    return NextResponse.json({\n      range: { start, end },\n      insights,\n      meta: { sampleSize },\n    })\n  } catch (e) {\n    console.error('mood insights error', e)\n    return NextResponse.json({ error: 'Failed to load insights' }, { status: 500 })\n  }\n}\n","truncated":false,"size":8243},{"path":"app/api/mood/journal/entries/[id]/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\nimport { ensureMoodTables } from '@/app/api/mood/_db'\n\nexport const dynamic = 'force-dynamic'\n\nfunction normalizeImages(value: unknown): string[] {\n  if (!Array.isArray(value)) return []\n  const cleaned: string[] = []\n  for (const raw of value) {\n    const url = String(raw ?? '').trim()\n    if (!url) continue\n    cleaned.push(url)\n    if (cleaned.length >= 12) break\n  }\n  return cleaned\n}\n\nfunction normalizeTags(value: unknown): string[] {\n  if (!Array.isArray(value)) return []\n  const tags: string[] = []\n  for (const raw of value) {\n    const tag = String(raw ?? '').trim()\n    if (!tag) continue\n    tags.push(tag.slice(0, 24))\n    if (tags.length >= 12) break\n  }\n  return tags\n}\n\nfunction normalizeText(value: unknown, max: number) {\n  return String(value ?? '').trim().slice(0, max)\n}\n\nfunction asLocalDate(value: unknown): string | null {\n  const s = String(value ?? '').trim()\n  if (!s) return null\n  if (!/^\\d{4}-\\d{2}-\\d{2}$/.test(s)) return null\n  return s\n}\n\nexport async function GET(_req: NextRequest, { params }: { params: { id: string } }) {\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.email) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  const user = await prisma.user.findUnique({ where: { email: session.user.email } })\n  if (!user) return NextResponse.json({ error: 'User not found' }, { status: 404 })\n\n  try {\n    await ensureMoodTables()\n    const rows: any[] = await prisma.$queryRawUnsafe(\n      `SELECT id, localDate, title, content, images, tags, audio, prompt, template, createdAt, updatedAt\n       FROM MoodJournalEntries\n       WHERE userId = $1 AND id = $2`,\n      user.id,\n      params.id,\n    )\n    const entry = rows[0] ?? null\n    if (!entry) return NextResponse.json({ error: 'Not found' }, { status: 404 })\n    return NextResponse.json({ entry })\n  } catch (e) {\n    console.error('mood journal get entry error', e)\n    return NextResponse.json({ error: 'Failed to load entry' }, { status: 500 })\n  }\n}\n\nexport async function PUT(req: NextRequest, { params }: { params: { id: string } }) {\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.email) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  const user = await prisma.user.findUnique({ where: { email: session.user.email } })\n  if (!user) return NextResponse.json({ error: 'User not found' }, { status: 404 })\n\n  const body = await req.json().catch(() => ({} as any))\n  const title = normalizeText(body?.title, 120)\n  const content = normalizeText(body?.content, 20000)\n  const images = normalizeImages(body?.images)\n  const tags = normalizeTags(body?.tags)\n  const audio = normalizeImages(body?.audio)\n  const prompt = normalizeText(body?.prompt, 200)\n  const template = normalizeText(body?.template, 200)\n  const localDate = asLocalDate(body?.localDate) ?? new Date().toISOString().slice(0, 10)\n\n  if (!title && !content && images.length === 0 && audio.length === 0) {\n    return NextResponse.json({ error: 'Entry is empty' }, { status: 400 })\n  }\n\n  try {\n    await ensureMoodTables()\n    const updated = await prisma.$executeRawUnsafe(\n      `UPDATE MoodJournalEntries\n       SET localDate = $1,\n           title = $2,\n           content = $3,\n           images = $4::jsonb,\n           tags = $5::jsonb,\n           audio = $6::jsonb,\n           prompt = $7,\n           template = $8,\n           updatedAt = NOW()\n       WHERE userId = $9 AND id = $10`,\n      localDate,\n      title,\n      content,\n      JSON.stringify(images),\n      JSON.stringify(tags),\n      JSON.stringify(audio),\n      prompt,\n      template,\n      user.id,\n      params.id,\n    )\n    if (!updated) return NextResponse.json({ error: 'Not found' }, { status: 404 })\n    return NextResponse.json({ success: true })\n  } catch (e) {\n    console.error('mood journal update error', e)\n    return NextResponse.json({ error: 'Failed to update entry' }, { status: 500 })\n  }\n}\n\nexport async function DELETE(_req: NextRequest, { params }: { params: { id: string } }) {\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.email) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  const user = await prisma.user.findUnique({ where: { email: session.user.email } })\n  if (!user) return NextResponse.json({ error: 'User not found' }, { status: 404 })\n\n  try {\n    await ensureMoodTables()\n    await prisma.$executeRawUnsafe(\n      `DELETE FROM MoodJournalEntries WHERE userId = $1 AND id = $2`,\n      user.id,\n      params.id,\n    )\n    return NextResponse.json({ success: true })\n  } catch (e) {\n    console.error('mood journal delete error', e)\n    return NextResponse.json({ error: 'Failed to delete entry' }, { status: 500 })\n  }\n}\n","truncated":false,"size":4923},{"path":"app/api/mood/journal/entries/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\nimport crypto from 'crypto'\nimport { ensureMoodTables } from '@/app/api/mood/_db'\n\nexport const dynamic = 'force-dynamic'\n\nfunction asLocalDate(value: unknown): string | null {\n  const s = String(value ?? '').trim()\n  if (!s) return null\n  if (!/^\\d{4}-\\d{2}-\\d{2}$/.test(s)) return null\n  return s\n}\n\nfunction clampInt(value: unknown, min: number, max: number, fallback: number) {\n  const n = Number(value)\n  if (!Number.isFinite(n)) return fallback\n  return Math.max(min, Math.min(max, Math.round(n)))\n}\n\nfunction normalizeImages(value: unknown): string[] {\n  if (!Array.isArray(value)) return []\n  const cleaned: string[] = []\n  for (const raw of value) {\n    const url = String(raw ?? '').trim()\n    if (!url) continue\n    cleaned.push(url)\n    if (cleaned.length >= 12) break\n  }\n  return cleaned\n}\n\nfunction normalizeTags(value: unknown): string[] {\n  if (!Array.isArray(value)) return []\n  const tags: string[] = []\n  for (const raw of value) {\n    const tag = String(raw ?? '').trim()\n    if (!tag) continue\n    tags.push(tag.slice(0, 24))\n    if (tags.length >= 12) break\n  }\n  return tags\n}\n\nfunction normalizeText(value: unknown, max: number) {\n  return String(value ?? '').trim().slice(0, max)\n}\n\nexport async function GET(req: NextRequest) {\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.email) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  const user = await prisma.user.findUnique({ where: { email: session.user.email } })\n  if (!user) return NextResponse.json({ error: 'User not found' }, { status: 404 })\n\n  const { searchParams } = new URL(req.url)\n  const start = asLocalDate(searchParams.get('start'))\n  const end = asLocalDate(searchParams.get('end'))\n  const limit = clampInt(searchParams.get('limit'), 1, 100, 20)\n  const q = String(searchParams.get('q') ?? '').trim()\n\n  try {\n    await ensureMoodTables()\n    let rows: any[] = []\n    if (start && end) {\n      rows = await prisma.$queryRawUnsafe(\n        `SELECT id, localDate, title, content, images, tags, audio, prompt, template, createdAt, updatedAt\n         FROM MoodJournalEntries\n         WHERE userId = $1 AND localDate BETWEEN $2 AND $3\n         ORDER BY createdAt DESC`,\n        user.id,\n        start,\n        end,\n      )\n    } else if (q) {\n      rows = await prisma.$queryRawUnsafe(\n        `SELECT id, localDate, title, content, images, tags, audio, prompt, template, createdAt, updatedAt\n         FROM MoodJournalEntries\n         WHERE userId = $1 AND (title ILIKE $2 OR content ILIKE $2)\n         ORDER BY createdAt DESC\n         LIMIT $3`,\n        user.id,\n        `%${q}%`,\n        limit,\n      )\n    } else {\n      rows = await prisma.$queryRawUnsafe(\n        `SELECT id, localDate, title, content, images, tags, audio, prompt, template, createdAt, updatedAt\n         FROM MoodJournalEntries\n         WHERE userId = $1\n         ORDER BY createdAt DESC\n         LIMIT $2`,\n        user.id,\n        limit,\n      )\n    }\n    return NextResponse.json({ entries: rows })\n  } catch (e) {\n    console.error('mood journal get error', e)\n    return NextResponse.json({ error: 'Failed to load journal entries' }, { status: 500 })\n  }\n}\n\nexport async function POST(req: NextRequest) {\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.email) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  const user = await prisma.user.findUnique({ where: { email: session.user.email } })\n  if (!user) return NextResponse.json({ error: 'User not found' }, { status: 404 })\n\n  const body = await req.json().catch(() => ({} as any))\n  const title = normalizeText(body?.title, 120)\n  const content = normalizeText(body?.content, 20000)\n  const images = normalizeImages(body?.images)\n  const tags = normalizeTags(body?.tags)\n  const audio = normalizeImages(body?.audio)\n  const prompt = normalizeText(body?.prompt, 200)\n  const template = normalizeText(body?.template, 200)\n  const localDate = asLocalDate(body?.localDate) ?? new Date().toISOString().slice(0, 10)\n\n  if (!title && !content && images.length === 0 && audio.length === 0) {\n    return NextResponse.json({ error: 'Entry is empty' }, { status: 400 })\n  }\n\n  try {\n    await ensureMoodTables()\n    const id = crypto.randomUUID()\n    await prisma.$queryRawUnsafe(\n      `INSERT INTO MoodJournalEntries (id, userId, localDate, title, content, images, tags, audio, prompt, template)\n       VALUES ($1, $2, $3, $4, $5, $6::jsonb, $7::jsonb, $8::jsonb, $9, $10)`,\n      id,\n      user.id,\n      localDate,\n      title,\n      content,\n      JSON.stringify(images),\n      JSON.stringify(tags),\n      JSON.stringify(audio),\n      prompt,\n      template,\n    )\n    return NextResponse.json({ success: true, id })\n  } catch (e) {\n    console.error('mood journal save error', e)\n    return NextResponse.json({ error: 'Failed to save journal entry' }, { status: 500 })\n  }\n}\n","truncated":false,"size":5073},{"path":"app/api/mood/journal/upload-audio/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { v2 as cloudinary } from 'cloudinary'\nimport crypto from 'crypto'\n\ncloudinary.config({\n  cloud_name: process.env.CLOUDINARY_CLOUD_NAME?.trim(),\n  api_key: process.env.CLOUDINARY_API_KEY?.trim(),\n  api_secret: process.env.CLOUDINARY_API_SECRET?.trim(),\n})\n\nexport async function POST(request: NextRequest) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.email) {\n      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 })\n    }\n\n    const formData = await request.formData()\n    const audioFile = formData.get('audio') as File\n\n    if (!audioFile) {\n      return NextResponse.json({ error: 'No audio file provided' }, { status: 400 })\n    }\n\n    if (!audioFile.type.startsWith('audio/')) {\n      return NextResponse.json({ error: 'File must be audio' }, { status: 400 })\n    }\n\n    if (audioFile.size > 12 * 1024 * 1024) {\n      return NextResponse.json({ error: 'File size must be less than 12MB' }, { status: 400 })\n    }\n\n    const buffer = Buffer.from(await audioFile.arrayBuffer())\n\n    const uploadResult = await new Promise<any>((resolve, reject) => {\n      cloudinary.uploader.upload_stream(\n        {\n          resource_type: 'video',\n          folder: 'helfi/mood-journal/audio',\n          public_id: `journal_audio_${crypto.randomUUID()}`,\n        },\n        (error, result) => {\n          if (error) return reject(error)\n          resolve(result)\n        },\n      ).end(buffer)\n    })\n\n    return NextResponse.json({\n      url: uploadResult.secure_url,\n      duration: uploadResult.duration,\n    })\n  } catch (e) {\n    console.error('mood journal audio upload error', e)\n    return NextResponse.json({ error: 'Failed to upload audio' }, { status: 500 })\n  }\n}\n","truncated":false,"size":1884},{"path":"app/api/mood/journal/upload/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { v2 as cloudinary } from 'cloudinary'\nimport crypto from 'crypto'\n\ncloudinary.config({\n  cloud_name: process.env.CLOUDINARY_CLOUD_NAME?.trim(),\n  api_key: process.env.CLOUDINARY_API_KEY?.trim(),\n  api_secret: process.env.CLOUDINARY_API_SECRET?.trim(),\n})\n\nexport async function POST(request: NextRequest) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.email) {\n      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 })\n    }\n\n    const formData = await request.formData()\n    const imageFile = formData.get('image') as File\n\n    if (!imageFile) {\n      return NextResponse.json({ error: 'No image file provided' }, { status: 400 })\n    }\n\n    if (!imageFile.type.startsWith('image/')) {\n      return NextResponse.json({ error: 'File must be an image' }, { status: 400 })\n    }\n\n    if (imageFile.size > 6 * 1024 * 1024) {\n      return NextResponse.json({ error: 'File size must be less than 6MB' }, { status: 400 })\n    }\n\n    const imageBuffer = await imageFile.arrayBuffer()\n    const buffer = Buffer.from(imageBuffer)\n\n    const uploadResult = await new Promise<any>((resolve, reject) => {\n      cloudinary.uploader.upload_stream(\n        {\n          resource_type: 'image',\n          folder: 'helfi/mood-journal',\n          public_id: `journal_${crypto.randomUUID()}`,\n          transformation: [\n            { width: 1600, height: 1600, crop: 'limit' },\n            { quality: 'auto', fetch_format: 'auto' },\n          ],\n        },\n        (error, result) => {\n          if (error) return reject(error)\n          resolve(result)\n        },\n      ).end(buffer)\n    })\n\n    return NextResponse.json({\n      url: uploadResult.secure_url,\n      width: uploadResult.width,\n      height: uploadResult.height,\n    })\n  } catch (e) {\n    console.error('mood journal image upload error', e)\n    return NextResponse.json({ error: 'Failed to upload image' }, { status: 500 })\n  }\n}\n","truncated":false,"size":2092},{"path":"app/api/mood/push-scheduler/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\nimport webpush from 'web-push'\nimport { ensureMoodTables } from '@/app/api/mood/_db'\nimport { normalizeSubscriptionList, removeSubscriptionsByEndpoint, sendToSubscriptions } from '@/lib/push-subscriptions'\n\nexport const dynamic = 'force-dynamic'\nexport const runtime = 'nodejs'\n\nexport async function POST(req: NextRequest) {\n  try {\n    const authHeader = req.headers.get('authorization') || ''\n    const expected = process.env.SCHEDULER_SECRET || ''\n    const vercelCronHeader = req.headers.get('x-vercel-cron')\n    const isVercelCron = vercelCronHeader !== null\n\n    if (!(isVercelCron || (expected && authHeader === `Bearer ${expected}`))) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const publicKey = process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY || ''\n    const privateKey = process.env.VAPID_PRIVATE_KEY || ''\n    if (!publicKey || !privateKey) {\n      return NextResponse.json({ error: 'VAPID keys not configured' }, { status: 500 })\n    }\n    webpush.setVapidDetails('mailto:support@helfi.ai', publicKey, privateKey)\n\n    await ensureMoodTables()\n\n    const rows: Array<{\n      userId: string | null\n      enabled: boolean\n      time1: string\n      time2: string\n      time3: string\n      timezone: string\n      frequency: number\n      subscription: any\n    }> = await prisma.$queryRawUnsafe(`\n      SELECT DISTINCT\n        p.userId AS \"userId\",\n        COALESCE(s.enabled, FALSE) AS enabled,\n        COALESCE(s.time1, '20:00') AS time1,\n        COALESCE(s.time2, '12:00') AS time2,\n        COALESCE(s.time3, '18:00') AS time3,\n        COALESCE(s.timezone, 'UTC') AS timezone,\n        COALESCE(s.frequency, 1) AS frequency,\n        p.subscription\n      FROM PushSubscriptions p\n      LEFT JOIN MoodReminderSettings s ON s.userId = p.userId\n    `)\n\n    const nowUtc = new Date()\n    const sentTo: string[] = []\n    const errors: Array<{ userId: string; error: string }> = []\n\n    const backfillWindow = Math.max(1, Math.min(60, parseInt(process.env.REMINDER_LAG_MINUTES || '10', 10)))\n\n    for (const r of rows) {\n      try {\n        if (!r.userId) continue\n        if (!r.enabled) continue\n\n        const subscriptions = normalizeSubscriptionList(r.subscription)\n        if (!subscriptions.length) {\n          errors.push({ userId: r.userId, error: 'no_subscription' })\n          continue\n        }\n\n        const tz = r.timezone || 'UTC'\n        const fmt = new Intl.DateTimeFormat('en-GB', {\n          timeZone: tz,\n          hour: '2-digit',\n          minute: '2-digit',\n          hour12: false,\n        })\n        const parts = fmt.formatToParts(nowUtc)\n        const hh = parts.find((p) => p.type === 'hour')?.value || '00'\n        const mm = parts.find((p) => p.type === 'minute')?.value || '00'\n        const current = `${hh}:${mm}`\n\n        const dateParts = new Intl.DateTimeFormat('en-GB', {\n          timeZone: tz,\n          year: 'numeric',\n          month: '2-digit',\n          day: '2-digit',\n        }).formatToParts(nowUtc)\n        const year = dateParts.find((p) => p.type === 'year')?.value || '1970'\n        const month = dateParts.find((p) => p.type === 'month')?.value || '01'\n        const day = dateParts.find((p) => p.type === 'day')?.value || '01'\n        const localDate = `${year}-${month}-${day}`\n\n        const reminderTimes: string[] = []\n        if ((r.frequency ?? 1) >= 1) reminderTimes.push(r.time1 || '20:00')\n        if ((r.frequency ?? 1) >= 2) reminderTimes.push(r.time2 || '12:00')\n        if ((r.frequency ?? 1) >= 3) reminderTimes.push(r.time3 || '18:00')\n\n        let shouldSend = false\n        let matchedReminder = ''\n\n        for (const reminderTime of reminderTimes) {\n          const [rh, rm] = reminderTime.split(':').map(Number)\n          const [ch, cm] = [parseInt(hh, 10), parseInt(mm, 10)]\n          if (rh === ch && rm === cm) {\n            shouldSend = true\n            matchedReminder = reminderTime\n            break\n          }\n\n          const currentTotalMinutes = ch * 60 + cm\n          const reminderTotalMinutes = rh * 60 + rm\n          let minutesDiff = currentTotalMinutes - reminderTotalMinutes\n          if (minutesDiff < 0) minutesDiff += 1440\n          if (minutesDiff >= 1 && minutesDiff <= backfillWindow) {\n            shouldSend = true\n            matchedReminder = reminderTime\n            break\n          }\n\n          let minutesAhead = reminderTotalMinutes - currentTotalMinutes\n          if (minutesAhead < 0) minutesAhead += 1440\n          if (minutesAhead === 1) {\n            shouldSend = true\n            matchedReminder = reminderTime\n            break\n          }\n        }\n\n        if (!shouldSend) continue\n\n        const alreadySent: Array<{ exists: number }> = await prisma.$queryRawUnsafe(\n          `SELECT 1 as exists\n           FROM MoodReminderDeliveryLog\n           WHERE userId = $1 AND reminderTime = $2 AND sentDate = $3::date\n           LIMIT 1`,\n          r.userId,\n          matchedReminder,\n          localDate,\n        )\n\n        if (alreadySent.length > 0) continue\n\n        const payload = JSON.stringify({\n          title: 'Quick mood check‚Äëin',\n          body: 'How are you feeling right now? It takes 10 seconds.',\n          url: '/mood/quick',\n        })\n\n        const { sent, errors: sendErrors, goneEndpoints } = await sendToSubscriptions(subscriptions, (sub) =>\n          webpush.sendNotification(sub, payload)\n        )\n        if (goneEndpoints.length) {\n          const remaining = removeSubscriptionsByEndpoint(subscriptions, goneEndpoints)\n          await prisma.$executeRawUnsafe(\n            `UPDATE PushSubscriptions SET subscription = $2::jsonb, updatedAt = NOW() WHERE userId = $1`,\n            r.userId,\n            JSON.stringify(remaining)\n          )\n        }\n        if (!sent) {\n          const msg = sendErrors.map((err) => err.message).join('; ')\n          errors.push({ userId: r.userId, error: msg || 'push_failed' })\n          continue\n        }\n        sentTo.push(r.userId)\n\n        await prisma.$queryRawUnsafe(\n          `INSERT INTO MoodReminderDeliveryLog (userId, reminderTime, sentDate, sentAt)\n           VALUES ($1, $2, $3::date, NOW())\n           ON CONFLICT (userId, reminderTime, sentDate) DO UPDATE SET sentAt = NOW()`,\n          r.userId,\n          matchedReminder,\n          localDate,\n        )\n      } catch (e: any) {\n        errors.push({ userId: r.userId ?? 'unknown', error: e?.body || e?.message || String(e) })\n      }\n    }\n\n    return NextResponse.json({ success: true, sent: sentTo.length, errors, timestamp: nowUtc.toISOString() })\n  } catch (e: any) {\n    return NextResponse.json({ error: 'scheduler_crash', message: e?.message || String(e) }, { status: 500 })\n  }\n}\n\nexport async function GET(req: NextRequest) {\n  return POST(req)\n}\n","truncated":false,"size":6841},{"path":"app/api/mood/reminders-debug/route.ts","content":"import { NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\nimport { ensureMoodTables } from '@/app/api/mood/_db'\nimport { normalizeSubscriptionList } from '@/lib/push-subscriptions'\n\nexport const dynamic = 'force-dynamic'\nexport const runtime = 'nodejs'\n\ntype TimeSnapshot = {\n  timeZone: string\n  ok: boolean\n  current: string\n  localDate: string\n}\n\nfunction snapshotInTimeZone(now: Date, timeZone: string): TimeSnapshot {\n  try {\n    const timeParts = new Intl.DateTimeFormat('en-GB', {\n      timeZone,\n      hour: '2-digit',\n      minute: '2-digit',\n      hour12: false,\n    }).formatToParts(now)\n    const hh = timeParts.find((p) => p.type === 'hour')?.value || '00'\n    const mm = timeParts.find((p) => p.type === 'minute')?.value || '00'\n\n    const dateParts = new Intl.DateTimeFormat('en-GB', {\n      timeZone,\n      year: 'numeric',\n      month: '2-digit',\n      day: '2-digit',\n    }).formatToParts(now)\n    const year = dateParts.find((p) => p.type === 'year')?.value || '1970'\n    const month = dateParts.find((p) => p.type === 'month')?.value || '01'\n    const day = dateParts.find((p) => p.type === 'day')?.value || '01'\n\n    return {\n      timeZone,\n      ok: true,\n      current: `${hh}:${mm}`,\n      localDate: `${year}-${month}-${day}`,\n    }\n  } catch {\n    const fallback = 'UTC'\n    const timeParts = new Intl.DateTimeFormat('en-GB', {\n      timeZone: fallback,\n      hour: '2-digit',\n      minute: '2-digit',\n      hour12: false,\n    }).formatToParts(now)\n    const hh = timeParts.find((p) => p.type === 'hour')?.value || '00'\n    const mm = timeParts.find((p) => p.type === 'minute')?.value || '00'\n\n    const dateParts = new Intl.DateTimeFormat('en-GB', {\n      timeZone: fallback,\n      year: 'numeric',\n      month: '2-digit',\n      day: '2-digit',\n    }).formatToParts(now)\n    const year = dateParts.find((p) => p.type === 'year')?.value || '1970'\n    const month = dateParts.find((p) => p.type === 'month')?.value || '01'\n    const day = dateParts.find((p) => p.type === 'day')?.value || '01'\n\n    return {\n      timeZone: fallback,\n      ok: false,\n      current: `${hh}:${mm}`,\n      localDate: `${year}-${month}-${day}`,\n    }\n  }\n}\n\nexport async function GET() {\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.email) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  const user = await prisma.user.findUnique({ where: { email: session.user.email } })\n  if (!user) return NextResponse.json({ error: 'User not found' }, { status: 404 })\n\n  await ensureMoodTables()\n\n  const settingsRows: Array<{\n    enabled: boolean\n    time1: string\n    time2: string\n    time3: string\n    timezone: string\n    frequency: number\n  }> = await prisma.$queryRawUnsafe(\n    `SELECT enabled, time1, time2, time3, timezone, frequency\n     FROM MoodReminderSettings\n     WHERE userId = $1\n     LIMIT 1`,\n    user.id,\n  )\n\n  const settings = settingsRows[0] || {\n    enabled: false,\n    time1: '20:00',\n    time2: '12:00',\n    time3: '18:00',\n    timezone: 'UTC',\n    frequency: 1,\n  }\n\n  const nowUtc = new Date()\n  const snapshot = snapshotInTimeZone(nowUtc, settings.timezone || 'UTC')\n  const backfillWindow = Math.max(1, Math.min(60, parseInt(process.env.REMINDER_LAG_MINUTES || '10', 10)))\n\n  const reminderTimes: string[] = []\n  if ((settings.frequency ?? 1) >= 1) reminderTimes.push(settings.time1 || '20:00')\n  if ((settings.frequency ?? 1) >= 2) reminderTimes.push(settings.time2 || '12:00')\n  if ((settings.frequency ?? 1) >= 3) reminderTimes.push(settings.time3 || '18:00')\n\n  let shouldSend = false\n  let matchedReminder = ''\n  let matchReason = ''\n\n  if (!settings.enabled) {\n    matchReason = 'reminders_disabled'\n  } else {\n    const [ch, cm] = snapshot.current.split(':').map((v) => parseInt(v, 10))\n    const currentTotalMinutes = ch * 60 + cm\n\n    for (const reminderTime of reminderTimes) {\n      const [rh, rm] = reminderTime.split(':').map((v) => parseInt(v, 10))\n      if (Number.isNaN(rh) || Number.isNaN(rm)) continue\n\n      if (rh === ch && rm === cm) {\n        shouldSend = true\n        matchedReminder = reminderTime\n        matchReason = 'exact_match'\n        break\n      }\n\n      const reminderTotalMinutes = rh * 60 + rm\n      let minutesDiff = currentTotalMinutes - reminderTotalMinutes\n      if (minutesDiff < 0) minutesDiff += 1440\n      if (minutesDiff >= 1 && minutesDiff <= backfillWindow) {\n        shouldSend = true\n        matchedReminder = reminderTime\n        matchReason = `late_cron_${minutesDiff}m`\n        break\n      }\n\n      let minutesAhead = reminderTotalMinutes - currentTotalMinutes\n      if (minutesAhead < 0) minutesAhead += 1440\n      if (minutesAhead === 1) {\n        shouldSend = true\n        matchedReminder = reminderTime\n        matchReason = 'early_send_1m'\n        break\n      }\n    }\n  }\n\n  const deliveryRows: Array<{ reminderTime: string; sentDate: string; sentAt: string }> =\n    await prisma.$queryRawUnsafe(\n      `SELECT reminderTime, sentDate::text AS \"sentDate\", sentAt::text AS \"sentAt\"\n       FROM MoodReminderDeliveryLog\n       WHERE userId = $1\n       ORDER BY sentAt DESC\n       LIMIT 5`,\n      user.id,\n    )\n\n  const subscriptionRows: Array<{ subscription: any; updatedAt: string }> = await prisma.$queryRawUnsafe(\n    `SELECT subscription, updatedAt::text AS \"updatedAt\" FROM PushSubscriptions WHERE userId = $1 LIMIT 1`,\n    user.id,\n  )\n\n  return NextResponse.json({\n    userId: user.id,\n    nowUtc: nowUtc.toISOString(),\n    settings,\n    snapshot,\n    reminderTimes,\n    match: {\n      shouldSend,\n      matchedReminder,\n      reason: matchReason || 'no_match',\n      backfillWindowMinutes: backfillWindow,\n    },\n    subscription: {\n      present: subscriptionRows.length > 0 && normalizeSubscriptionList(subscriptionRows[0]?.subscription).length > 0,\n      updatedAt: subscriptionRows[0]?.updatedAt || null,\n      count: subscriptionRows.length ? normalizeSubscriptionList(subscriptionRows[0]?.subscription).length : 0,\n    },\n    recentDeliveries: deliveryRows,\n  })\n}\n","truncated":false,"size":6120},{"path":"app/api/mood/reminders/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\nimport { ensureMoodTables } from '@/app/api/mood/_db'\nimport { scheduleAllMoodReminders } from '@/lib/qstash'\n\nexport const dynamic = 'force-dynamic'\n\nfunction normalizeTime(input: unknown, fallback: string) {\n  const s = String(input ?? '').trim()\n  if (!s) return fallback\n  const m24 = s.match(/^([01]\\d|2[0-3]):([0-5]\\d)$/)\n  if (m24) return `${m24[1]}:${m24[2]}`\n  return fallback\n}\n\nfunction clampInt(value: unknown, min: number, max: number, fallback: number) {\n  const n = Number(value)\n  if (!Number.isFinite(n)) return fallback\n  return Math.max(min, Math.min(max, Math.round(n)))\n}\n\nfunction normalizeTimezone(input: unknown) {\n  const tz = String(input ?? '').trim()\n  if (!tz) return 'UTC'\n  if (tz.length > 64) return 'UTC'\n  try {\n    new Intl.DateTimeFormat('en-GB', { timeZone: tz })\n    return tz\n  } catch {\n    return 'UTC'\n  }\n}\n\nexport async function GET() {\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.email) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  const user = await prisma.user.findUnique({ where: { email: session.user.email } })\n  if (!user) return NextResponse.json({ error: 'User not found' }, { status: 404 })\n\n  await ensureMoodTables()\n\n  const rows: any[] = await prisma.$queryRawUnsafe(\n    `SELECT enabled, time1, time2, time3, timezone, frequency\n     FROM MoodReminderSettings\n     WHERE userId = $1\n     LIMIT 1`,\n    user.id,\n  )\n\n  const row = rows[0] || null\n  return NextResponse.json({\n    enabled: row?.enabled ?? false,\n    time1: row?.time1 ?? '20:00',\n    time2: row?.time2 ?? '12:00',\n    time3: row?.time3 ?? '18:00',\n    timezone: row?.timezone ?? 'UTC',\n    frequency: row?.frequency ?? 1,\n  })\n}\n\nexport async function POST(req: NextRequest) {\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.email) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  const user = await prisma.user.findUnique({ where: { email: session.user.email } })\n  if (!user) return NextResponse.json({ error: 'User not found' }, { status: 404 })\n\n  const body = await req.json().catch(() => ({} as any))\n  const enabled = !!body?.enabled\n  const frequency = clampInt(body?.frequency, 1, 3, 1)\n  const time1 = normalizeTime(body?.time1, '20:00')\n  const time2 = normalizeTime(body?.time2, '12:00')\n  const time3 = normalizeTime(body?.time3, '18:00')\n  const timezone = normalizeTimezone(body?.timezone)\n\n  await ensureMoodTables()\n\n  await prisma.$queryRawUnsafe(\n    `INSERT INTO MoodReminderSettings (userId, enabled, time1, time2, time3, timezone, frequency)\n     VALUES ($1, $2, $3, $4, $5, $6, $7)\n     ON CONFLICT (userId) DO UPDATE SET\n       enabled = EXCLUDED.enabled,\n       time1 = EXCLUDED.time1,\n       time2 = EXCLUDED.time2,\n       time3 = EXCLUDED.time3,\n       timezone = EXCLUDED.timezone,\n       frequency = EXCLUDED.frequency`,\n    user.id,\n    enabled,\n    time1,\n    time2,\n    time3,\n    timezone,\n    frequency,\n  )\n\n  let scheduleResults: any[] = []\n  if (enabled) {\n    scheduleResults = await scheduleAllMoodReminders(user.id, {\n      time1,\n      time2,\n      time3,\n      timezone,\n      frequency,\n    }).catch((error) => {\n      console.error('[MOOD] Failed to schedule reminders via QStash', error)\n      return []\n    })\n    const failedSchedules = scheduleResults.filter((result) => !result.scheduled)\n    if (failedSchedules.length > 0) {\n      console.error('[MOOD] QStash scheduling failures detected', { failedSchedules })\n    }\n\n    const requireSignature = !!process.env.QSTASH_REQUIRE_SIGNATURE\n    if (!requireSignature) {\n      try {\n        const base =\n          process.env.PUBLIC_BASE_URL ||\n          (process.env.VERCEL_URL ? `https://${process.env.VERCEL_URL}` : '')\n        if (base) {\n          const now = new Date()\n          const fmt = new Intl.DateTimeFormat('en-GB', {\n            timeZone: timezone,\n            hour: '2-digit',\n            minute: '2-digit',\n            hour12: false,\n          })\n          const parts = fmt.formatToParts(now)\n          const ch = parseInt(parts.find((p) => p.type === 'hour')?.value || '0', 10)\n          const cm = parseInt(parts.find((p) => p.type === 'minute')?.value || '0', 10)\n          const currentTotal = ch * 60 + cm\n          const sendWindowMinutes = 5\n          const candidates: string[] = []\n          if (frequency >= 1) candidates.push(time1)\n          if (frequency >= 2) candidates.push(time2)\n          if (frequency >= 3) candidates.push(time3)\n          const schedulerSecret = process.env.SCHEDULER_SECRET || ''\n          for (const t of candidates) {\n            const [hh, mm] = t.split(':').map((v) => parseInt(v, 10))\n            if (Number.isNaN(hh) || Number.isNaN(mm)) continue\n            const target = hh * 60 + mm\n            let diff = currentTotal - target\n            if (diff < 0) diff += 1440\n            if (diff >= 0 && diff <= sendWindowMinutes) {\n              const headers: Record<string, string> = { 'Content-Type': 'application/json' }\n              if (schedulerSecret) {\n                headers.Authorization = `Bearer ${schedulerSecret}`\n              }\n              await fetch(`${base}/api/mood/dispatch`, {\n                method: 'POST',\n                headers,\n                body: JSON.stringify({ userId: user.id, reminderTime: t, timezone }),\n              }).catch(() => {})\n              break\n            }\n          }\n        }\n      } catch {}\n    }\n  }\n\n  return NextResponse.json({ success: true, scheduleResults })\n}\n","truncated":false,"size":5697},{"path":"app/api/mood/send-reminder-now/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\nimport webpush from 'web-push'\nimport { normalizeSubscriptionList, removeSubscriptionsByEndpoint, sendToSubscriptions } from '@/lib/push-subscriptions'\n\nexport const runtime = 'nodejs'\n\nexport async function POST(_req: NextRequest) {\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.email) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  const user = await prisma.user.findUnique({ where: { email: session.user.email } })\n  if (!user) return NextResponse.json({ error: 'User not found' }, { status: 404 })\n\n  const rows: Array<{ subscription: any }> = await prisma.$queryRawUnsafe(\n    `SELECT subscription FROM PushSubscriptions WHERE userId = $1`,\n    user.id,\n  )\n  if (!rows.length) return NextResponse.json({ error: 'No subscription' }, { status: 400 })\n  const subscriptions = normalizeSubscriptionList(rows[0].subscription)\n  if (!subscriptions.length) return NextResponse.json({ error: 'No subscription' }, { status: 400 })\n\n  const publicKey = process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY || ''\n  const privateKey = process.env.VAPID_PRIVATE_KEY || ''\n  if (!publicKey || !privateKey) {\n    return NextResponse.json({ error: 'VAPID keys not configured' }, { status: 500 })\n  }\n  webpush.setVapidDetails('mailto:support@helfi.ai', publicKey, privateKey)\n\n  const payload = JSON.stringify({\n    title: 'Quick mood check‚Äëin',\n    body: 'How are you feeling right now? It takes 10 seconds.',\n    url: '/mood/quick',\n  })\n\n  try {\n    const { sent, errors, goneEndpoints } = await sendToSubscriptions(subscriptions, (sub) =>\n      webpush.sendNotification(sub, payload)\n    )\n    if (goneEndpoints.length) {\n      const remaining = removeSubscriptionsByEndpoint(subscriptions, goneEndpoints)\n      await prisma.$executeRawUnsafe(\n        `UPDATE PushSubscriptions SET subscription = $2::jsonb, updatedAt = NOW() WHERE userId = $1`,\n        user.id,\n        JSON.stringify(remaining)\n      )\n    }\n    if (!sent) {\n      console.error('mood send-reminder-now error', errors.map((e) => e.message).join('; '))\n      return NextResponse.json({ error: 'Failed to send reminder' }, { status: 500 })\n    }\n    return NextResponse.json({ success: true, sent })\n  } catch (e: any) {\n    console.error('mood send-reminder-now error', e?.body || e?.message || e)\n    return NextResponse.json({ error: 'Failed to send reminder' }, { status: 500 })\n  }\n}\n","truncated":false,"size":2574},{"path":"app/api/push/dispatch/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\nimport webpush from 'web-push'\nimport { scheduleAllActiveReminders, scheduleReminderWithQStash } from '@/lib/qstash'\nimport { normalizeSubscriptionList, removeSubscriptionsByEndpoint, sendToSubscriptions } from '@/lib/push-subscriptions'\nimport { isSchedulerAuthorized } from '@/lib/scheduler-auth'\n\nexport const runtime = 'nodejs'\nexport const dynamic = 'force-dynamic'\n\ntype DispatchPayload = {\n  userId: string\n  reminderTime: string // \"HH:MM\"\n  timezone: string\n}\n\nexport async function POST(req: NextRequest) {\n  try {\n    if (!isSchedulerAuthorized(req)) {\n      return NextResponse.json({ error: 'unauthorized' }, { status: 401 })\n    }\n\n    const body = (await req.json().catch(() => ({}))) as Partial<DispatchPayload>\n    const userId = String(body.userId || '')\n    const reminderTime = String(body.reminderTime || '')\n    const timezone = String(body.timezone || '')\n    if (!userId || !reminderTime || !timezone) {\n      return NextResponse.json({ error: 'invalid_payload' }, { status: 400 })\n    }\n\n    // Ensure subscription exists\n    // await prisma.$executeRawUnsafe(`\n    //   CREATE TABLE IF NOT EXISTS PushSubscriptions (\n    //     userId TEXT PRIMARY KEY,\n    //     subscription JSONB NOT NULL\n    //   )\n    // `)\n    const rows: Array<{ subscription: any }> = await prisma.$queryRawUnsafe(\n      `SELECT subscription FROM PushSubscriptions WHERE userId = $1`,\n      userId\n    )\n    if (!rows.length) {\n      return NextResponse.json({ error: 'no_subscription' }, { status: 400 })\n    }\n    const subscriptions = normalizeSubscriptionList(rows[0].subscription)\n    if (!subscriptions.length) {\n      return NextResponse.json({ error: 'no_subscription' }, { status: 400 })\n    }\n\n    // Load the latest reminder settings for this user to validate stale schedules\n    // await prisma.$executeRawUnsafe(`\n    //   CREATE TABLE IF NOT EXISTS CheckinSettings (\n    //     userId TEXT PRIMARY KEY,\n    //     time1 TEXT NOT NULL,\n    //     time2 TEXT NOT NULL,\n    //     time3 TEXT NOT NULL,\n    //     timezone TEXT NOT NULL,\n    //     frequency INTEGER NOT NULL DEFAULT 3\n    //   )\n    // `)\n    const settingsRows: Array<{ time1: string; time2: string; time3: string; timezone: string; frequency: number | null }> =\n      await prisma.$queryRawUnsafe(\n        `SELECT time1, time2, time3, timezone, frequency FROM CheckinSettings WHERE userId = $1`,\n        userId\n      )\n    const settings = settingsRows[0]\n    const resolvedFrequency = Math.max(1, Math.min(3, settings?.frequency ?? 3))\n    const activeTimes: string[] = []\n    if (resolvedFrequency >= 1 && settings?.time1) activeTimes.push(settings.time1)\n    if (resolvedFrequency >= 2 && settings?.time2) activeTimes.push(settings.time2)\n    if (resolvedFrequency >= 3 && settings?.time3) activeTimes.push(settings.time3)\n    const timezoneToUse = settings?.timezone || timezone\n\n    const reminderStillActive = settings ? activeTimes.includes(reminderTime) : true\n    const timezoneStillMatches = settings ? settings.timezone === timezone : true\n\n    if (!reminderStillActive || !timezoneStillMatches) {\n      console.log('[DISPATCH] Skipping stale reminder job', {\n        userId,\n        reminderTime,\n        incomingTimezone: timezone,\n        latestTimezone: settings?.timezone,\n        activeTimes,\n        reason: reminderStillActive ? 'timezone_changed' : 'time_removed',\n      })\n      if (settings) {\n        try {\n          await scheduleAllActiveReminders(userId, {\n            time1: settings.time1,\n            time2: settings.time2,\n            time3: settings.time3,\n            timezone: settings.timezone,\n            frequency: resolvedFrequency,\n          })\n        } catch (err) {\n          console.error('[DISPATCH] Failed to reschedule active reminders after stale job', err)\n        }\n      }\n      return NextResponse.json({ skipped: 'stale_schedule' })\n    }\n\n    const publicKey = process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY || ''\n    const privateKey = process.env.VAPID_PRIVATE_KEY || ''\n    if (!publicKey || !privateKey) {\n      return NextResponse.json({ error: 'vapid_not_configured' }, { status: 500 })\n    }\n    webpush.setVapidDetails('mailto:support@helfi.ai', publicKey, privateKey)\n\n    // Delivery log table for de-duplication\n    // await prisma.$executeRawUnsafe(`\n    //   CREATE TABLE IF NOT EXISTS ReminderDeliveryLog (\n    //     userId TEXT NOT NULL,\n    //     reminderTime TEXT NOT NULL,\n    //     sentDate DATE NOT NULL,\n    //     sentAt TIMESTAMP NOT NULL DEFAULT NOW(),\n    //     PRIMARY KEY (userId, reminderTime, sentDate)\n    //   )\n    // `)\n\n    // Compute local date for de-dup (based on the user's tz)\n    const now = new Date()\n    const effectiveTimezone = timezoneToUse || 'UTC'\n    const dateParts = new Intl.DateTimeFormat('en-GB', {\n      timeZone: effectiveTimezone,\n      year: 'numeric',\n      month: '2-digit',\n      day: '2-digit',\n    }).formatToParts(now)\n    const localDate = `${dateParts.find(p => p.type==='year')?.value}-${dateParts.find(p=>p.type==='month')?.value}-${dateParts.find(p=>p.type==='day')?.value}`\n\n    const already: Array<{ exists: number }> = await prisma.$queryRawUnsafe(\n      `SELECT 1 as exists FROM ReminderDeliveryLog WHERE userId = $1 AND reminderTime = $2 AND sentDate = $3::date LIMIT 1`,\n      userId,\n      reminderTime,\n      localDate\n    )\n    if (!already.length) {\n      // Send push\n      const payload = JSON.stringify({\n        title: 'Time for your Helfi check‚Äëin',\n        body: 'Rate your selected issues for today in under a minute.',\n        url: '/check-in',\n      })\n      const { sent, errors, goneEndpoints } = await sendToSubscriptions(subscriptions, (sub) =>\n        webpush.sendNotification(sub, payload)\n      )\n      if (goneEndpoints.length) {\n        const remaining = removeSubscriptionsByEndpoint(subscriptions, goneEndpoints)\n        await prisma.$executeRawUnsafe(\n          `UPDATE PushSubscriptions SET subscription = $2::jsonb, updatedAt = NOW() WHERE userId = $1`,\n          userId,\n          JSON.stringify(remaining)\n        )\n      }\n      if (!sent) {\n        return NextResponse.json({ error: 'push_failed', details: errors }, { status: 500 })\n      }\n      await prisma.$queryRawUnsafe(\n        `INSERT INTO ReminderDeliveryLog (userId, reminderTime, sentDate, sentAt)\n         VALUES ($1, $2, $3::date, NOW())\n         ON CONFLICT (userId, reminderTime, sentDate) DO UPDATE SET sentAt = NOW()`,\n        userId,\n        reminderTime,\n        localDate\n      )\n    }\n\n    // Schedule the next occurrence for this same reminder\n    const nextSchedule = await scheduleReminderWithQStash(userId, reminderTime, effectiveTimezone).catch((error) => {\n      console.error('[DISPATCH] Failed to schedule next reminder via QStash', error)\n      return { scheduled: false, reason: 'exception' }\n    })\n    if (!nextSchedule?.scheduled) {\n      console.error('[DISPATCH] QStash scheduling returned failure', {\n        userId,\n        reminderTime,\n        timezone,\n        reason: nextSchedule?.reason,\n      })\n    }\n\n    return NextResponse.json({ ok: true })\n  } catch (e: any) {\n    console.error('[DISPATCH] error', e?.stack || e)\n    return NextResponse.json({ error: 'dispatch_error', message: e?.message || String(e) }, { status: 500 })\n  }\n}\n","truncated":false,"size":7366},{"path":"app/api/push/health-tips/dispatch/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\nimport webpush from 'web-push'\nimport OpenAI from 'openai'\nimport crypto from 'crypto'\nimport { CreditManager } from '@/lib/credit-system'\nimport { chatCompletionWithCost } from '@/lib/metered-openai'\nimport { capMaxTokensToBudget } from '@/lib/cost-meter'\nimport { scheduleHealthTipWithQStash } from '@/lib/qstash'\nimport { logAIUsage } from '@/lib/ai-usage-logger'\nimport { normalizeSubscriptionList, removeSubscriptionsByEndpoint, sendToSubscriptions } from '@/lib/push-subscriptions'\nimport { isSchedulerAuthorized } from '@/lib/scheduler-auth'\n\nexport const runtime = 'nodejs'\nexport const dynamic = 'force-dynamic'\n\ntype DispatchPayload = {\n  userId: string\n  reminderTime: string // \"HH:MM\"\n  timezone: string\n}\n\nconst CHECKIN_LABELS = [\n  'Really bad',\n  'Bad',\n  'Below average',\n  'Average',\n  'Above average',\n  'Good',\n  'Excellent',\n] as const\n\nfunction getOpenAIClient() {\n  if (!process.env.OPENAI_API_KEY) return null\n  return new OpenAI({ apiKey: process.env.OPENAI_API_KEY })\n}\n\nasync function ensureTables() {\n  await prisma.$executeRawUnsafe(`\n    CREATE TABLE IF NOT EXISTS PushSubscriptions (\n      userId TEXT PRIMARY KEY,\n      subscription JSONB NOT NULL\n    )\n  `)\n\n  await prisma.$executeRawUnsafe(`\n    CREATE TABLE IF NOT EXISTS HealthTipSettings (\n      userId TEXT PRIMARY KEY,\n      enabled BOOLEAN NOT NULL DEFAULT true,\n      time1 TEXT NOT NULL,\n      time2 TEXT NOT NULL,\n      time3 TEXT NOT NULL,\n      timezone TEXT NOT NULL,\n      frequency INTEGER NOT NULL DEFAULT 1,\n      focusFood BOOLEAN NOT NULL DEFAULT true,\n      focusSupplements BOOLEAN NOT NULL DEFAULT true,\n      focusLifestyle BOOLEAN NOT NULL DEFAULT true\n    )\n  `)\n\n  await prisma.$executeRawUnsafe(`\n    CREATE TABLE IF NOT EXISTS HealthTips (\n      id TEXT PRIMARY KEY,\n      userId TEXT NOT NULL,\n      tipDate DATE NOT NULL,\n      sentAt TIMESTAMP NOT NULL DEFAULT NOW(),\n      title TEXT NOT NULL,\n      body TEXT NOT NULL,\n      category TEXT NOT NULL,\n      metadata JSONB,\n      costCents INTEGER,\n      chargeCents INTEGER\n    )\n  `)\n\n  await prisma.$executeRawUnsafe(`\n    CREATE TABLE IF NOT EXISTS HealthTipDeliveryLog (\n      userId TEXT NOT NULL,\n      reminderTime TEXT NOT NULL,\n      tipDate DATE NOT NULL,\n      sentAt TIMESTAMP NOT NULL DEFAULT NOW(),\n      PRIMARY KEY (userId, reminderTime, tipDate)\n    )\n  `)\n}\n\nasync function buildUserHealthContext(userId: string) {\n  // Ensure FoodLog has the lightweight 'items' column used by the Prisma client.\n  // This mirrors the standalone migration 20251115120000_add_foodlog_items but runs defensively\n  // so we don't depend on manual migration runs in production.\n  try {\n    await prisma.$executeRawUnsafe(\n      `ALTER TABLE \"FoodLog\" ADD COLUMN IF NOT EXISTS \"items\" JSONB`\n    )\n  } catch (e) {\n    console.error('[HEALTH_TIPS] Failed to ensure FoodLog.items column', e)\n  }\n\n  // Health situations and selected issues\n  const [healthSituationsGoal, selectedIssuesGoal, supplements, medications, recentFoodLogs] =\n    await Promise.all([\n      prisma.healthGoal.findFirst({\n        where: { userId, name: '__HEALTH_SITUATIONS_DATA__' },\n      }),\n      prisma.healthGoal.findFirst({\n        where: { userId, name: '__SELECTED_ISSUES__' },\n      }),\n      prisma.supplement.findMany({\n        where: { userId },\n        orderBy: { createdAt: 'desc' },\n        take: 10,\n      }),\n      prisma.medication.findMany({\n        where: { userId },\n        orderBy: { createdAt: 'desc' },\n        take: 10,\n      }),\n      prisma.foodLog.findMany({\n        where: { userId },\n        orderBy: { createdAt: 'desc' },\n        take: 8,\n      }),\n    ])\n\n  let healthData: {\n    healthIssues?: string\n    healthProblems?: string\n    additionalInfo?: string\n  } | null = null\n  let selectedHealthGoals: string[] = []\n\n  if (healthSituationsGoal?.category) {\n    try {\n      const parsed = JSON.parse(healthSituationsGoal.category as any)\n      healthData = {\n        healthIssues: parsed.healthIssues || '',\n        healthProblems: parsed.healthProblems || '',\n        additionalInfo: parsed.additionalInfo || '',\n      }\n    } catch {\n      // ignore parse errors\n    }\n  }\n\n  if (selectedIssuesGoal?.category) {\n    try {\n      const parsed = JSON.parse(selectedIssuesGoal.category as any)\n      if (Array.isArray(parsed)) {\n        selectedHealthGoals = parsed.map((name: any) => String(name || '').trim()).filter(Boolean)\n      }\n    } catch {\n      // ignore parse errors\n    }\n  }\n\n  // Recent check-in ratings (last 7 days)\n  const now = new Date()\n  const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000)\n  const startDate = weekAgo.toISOString().slice(0, 10)\n  const endDate = now.toISOString().slice(0, 10)\n\n  // Ensure Checkin tables exist before querying (mirror /api/checkins/today)\n  await prisma.$executeRawUnsafe(`\n    CREATE TABLE IF NOT EXISTS CheckinIssues (\n      id TEXT PRIMARY KEY,\n      userId TEXT NOT NULL,\n      name TEXT NOT NULL,\n      polarity TEXT NOT NULL\n    )\n  `)\n  await prisma.$executeRawUnsafe(`\n    CREATE TABLE IF NOT EXISTS CheckinRatings (\n      id TEXT PRIMARY KEY,\n      userId TEXT NOT NULL,\n      issueId TEXT NOT NULL,\n      date TEXT NOT NULL,\n      timestamp TIMESTAMP NOT NULL DEFAULT NOW(),\n      value INTEGER,\n      note TEXT,\n      isNa BOOLEAN DEFAULT false\n    )\n  `)\n\n  const checkinRows: Array<{\n    date: string\n    issueId: string\n    name: string\n    polarity: string\n    value: number | null\n    note: string | null\n  }> = await prisma.$queryRawUnsafe(\n    `SELECT r.date, r.issueId, i.name, i.polarity, r.value, r.note\n     FROM CheckinRatings r\n     JOIN CheckinIssues i ON i.id = r.issueId\n     WHERE r.userId = $1 AND r.date BETWEEN $2 AND $3\n     ORDER BY r.date DESC, r.timestamp DESC`,\n    userId,\n    startDate,\n    endDate\n  )\n\n  return {\n    healthData,\n    selectedHealthGoals,\n    supplements,\n    medications,\n    recentFoodLogs,\n    recentCheckins: checkinRows,\n  }\n}\n\nfunction buildTipPrompt(args: {\n  context: Awaited<ReturnType<typeof buildUserHealthContext>>\n  localTimeDescription: string\n  focusFood: boolean\n  focusSupplements: boolean\n  focusLifestyle: boolean\n}) {\n  const { context, localTimeDescription, focusFood, focusSupplements, focusLifestyle } = args\n  const { healthData, selectedHealthGoals, supplements, medications, recentFoodLogs, recentCheckins } =\n    context\n\n  const lines: string[] = []\n\n  if (healthData) {\n    if (healthData.healthIssues?.trim()) {\n      lines.push(`Current health issues: ${healthData.healthIssues.trim()}`)\n    }\n    if (healthData.healthProblems?.trim()) {\n      lines.push(`Ongoing health problems: ${healthData.healthProblems.trim()}`)\n    }\n    if (healthData.additionalInfo?.trim()) {\n      lines.push(`Additional health info: ${healthData.additionalInfo.trim()}`)\n    }\n  }\n\n  if (selectedHealthGoals.length > 0) {\n    lines.push(`Health goals/concerns being tracked: ${selectedHealthGoals.join(', ')}`)\n  }\n\n  if (supplements.length > 0) {\n    const suppLines = supplements.slice(0, 8).map((s) => {\n      const timingValue: any = (s as any).timing\n      const timings = Array.isArray(timingValue)\n        ? timingValue.map((t) => String(t)).join(', ')\n        : timingValue\n        ? String(timingValue)\n        : ''\n      return `- ${s.name} (${s.dosage || 'dose not specified'}) ‚Äì timing: ${timings || 'not specified'}`\n    })\n    lines.push('Supplements currently taken:')\n    lines.push(...suppLines)\n  }\n\n  if (medications.length > 0) {\n    const medLines = medications.slice(0, 8).map((m) => {\n      const timingValue: any = (m as any).timing\n      const timings = Array.isArray(timingValue)\n        ? timingValue.map((t) => String(t)).join(', ')\n        : timingValue\n        ? String(timingValue)\n        : ''\n      return `- ${m.name} (${m.dosage || 'dose not specified'}) ‚Äì timing: ${timings || 'not specified'}`\n    })\n    lines.push('Medications currently taken:')\n    lines.push(...medLines)\n  }\n\n  if (recentFoodLogs.length > 0) {\n    const foodLines = recentFoodLogs.map((f) => {\n      const when = f.createdAt.toISOString().slice(0, 16).replace('T', ' ')\n      return `- [${when}] ${f.name}${f.description ? ` ‚Äì ${f.description}` : ''}`\n    })\n    lines.push('Recent food diary entries:')\n    lines.push(...foodLines)\n  }\n\n  if (recentCheckins.length > 0) {\n    const ratingLines = recentCheckins.slice(0, 25).map((r) => {\n      const v = r.value\n      const label =\n        v === null || v === undefined\n          ? 'N/A'\n          : CHECKIN_LABELS[Math.max(0, Math.min(CHECKIN_LABELS.length - 1, v))]\n      const notePart = r.note ? ` ‚Äì note: ${r.note}` : ''\n      return `- [${r.date}] ${r.name}: ${label}${v !== null && v !== undefined ? ` (${v}/6)` : ''}${notePart}`\n    })\n    lines.push('Recent daily check-in ratings (last 7 days):')\n    lines.push(...ratingLines)\n  }\n\n  const healthSnapshot =\n    lines.length > 0\n      ? lines.join('\\n')\n      : 'No structured health data is available yet beyond basic account information.'\n\n  const preferredCategories: string[] = []\n  if (focusFood) preferredCategories.push('food')\n  if (focusSupplements) preferredCategories.push('supplement')\n  if (focusLifestyle) preferredCategories.push('lifestyle')\n  const preferredCategoriesText =\n    preferredCategories.length > 0\n      ? preferredCategories.join(', ')\n      : 'food, supplement, lifestyle'\n\n  const prompt = `You are a careful, practical health coach creating ONE personalised micro health tip for a specific user.\n\nUSER HEALTH SNAPSHOT (from Helfi app):\n${healthSnapshot}\n\nCONTEXT FOR THIS TIP:\n- This tip is being sent around: ${localTimeDescription}\n- The user receives at most 3 tips per day, so this one should feel meaningful, not generic.\n\nGOAL:\n- Provide ONE short, highly actionable health tip that this user can realistically apply today.\n- The tip should clearly connect to at least ONE specific detail from the snapshot above (for example: a named health issue, a recurring symptom, a supplement they take, or a pattern in their recent meals or ratings).\n\nCRITICAL RULES:\n1. Avoid generic advice that could apply to absolutely everyone (e.g. \"drink more water\", \"sleep more\", \"eat healthier\") unless you tie it tightly to a concrete pattern from their data and make it very specific.\n2. The tip must feel like it was written specifically for THIS person, based on the snapshot above.\n3. The user has expressed a preference for these tip categories (in order of priority): ${preferredCategoriesText}.\n   - You MUST choose the JSON \"category\" from these options: \"food\", \"supplement\", or \"lifestyle\".\n   - Prefer a category that is in the preferred list above, but if the health snapshot clearly demands a different category, you may choose it and briefly explain why.\n4. You may focus on ONE of these categories:\n   - food: a specific meal, snack, or ingredient pattern that fits their issues\n   - supplement: a specific supplement idea, timing tweak, or reminder connected to their issues\n   - lifestyle: a small behaviour or routine change (sleep, stress, movement, bathroom timing, etc.)\n5. Never diagnose or claim to cure anything. Use soft language like \"may help\", \"you might consider\", \"many people with X find Y helpful\".\n6. Include a brief safety note that reminds them to consider medications, allergies, and to talk with a clinician when appropriate‚Äîespecially if you mention a supplement or strong change.\n7. Do NOT reveal your chain-of-thought. Only show the final recommendation and brief reasoning.\n8. In addition to the tip itself, create exactly 3 concrete follow-up questions the user might naturally ask specifically about THIS tip. These questions must:\n   - Explicitly reference the main recommendation (for example, the specific food, supplement, or habit you suggested).\n   - Be practical and personalised (for example, about safety, interactions, alternatives, or how to tailor the advice to their routine or health issues).\n   - Avoid generic wording that could apply to any random health tip.\n\nRESPONSE FORMAT (JSON ONLY, no markdown, no extra text):\n{\n  \"title\": \"Short, specific title for the notification (5-9 words)\",\n  \"category\": \"food\" | \"supplement\" | \"lifestyle\",\n  \"tip\": \"1-3 short sentences with the main recommendation, explicitly referencing at least one detail from the snapshot above.\",\n  \"safetyNote\": \"1 short sentence with a sensible safety or medical caution.\",\n  \"suggestedQuestions\": [\n    \"First personalised follow-up question about this specific tip...\",\n    \"Second personalised follow-up question...\",\n    \"Third personalised follow-up question...\"\n  ]\n}`\n\n  return prompt\n}\n\nfunction extractTipJson(raw: string) {\n  if (!raw) return null\n  let text = raw.trim()\n\n  // Strip markdown fences if present\n  const fenceMatch = text.match(/```json([\\s\\S]*?)```/i) || text.match(/```([\\s\\S]*?)```/i)\n  if (fenceMatch && fenceMatch[1]) {\n    text = fenceMatch[1].trim()\n  }\n\n  // Try to isolate the first JSON object\n  const firstBrace = text.indexOf('{')\n  const lastBrace = text.lastIndexOf('}')\n  if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {\n    text = text.slice(firstBrace, lastBrace + 1)\n  }\n\n  try {\n    const parsed = JSON.parse(text)\n    if (!parsed || typeof parsed !== 'object') return null\n    return parsed as {\n      title?: string\n      category?: string\n      tip?: string\n      safetyNote?: string\n      suggestedQuestions?: string[]\n    }\n  } catch {\n    return null\n  }\n}\n\nexport async function POST(req: NextRequest) {\n  try {\n    if (!isSchedulerAuthorized(req)) {\n      return NextResponse.json({ error: 'unauthorized' }, { status: 401 })\n    }\n\n    const body = (await req.json().catch(() => ({}))) as Partial<DispatchPayload>\n    const userId = String(body.userId || '')\n    const reminderTime = String(body.reminderTime || '')\n    const timezone = String(body.timezone || '')\n\n    if (!userId || !reminderTime || !timezone) {\n      return NextResponse.json({ error: 'invalid_payload' }, { status: 400 })\n    }\n\n    await ensureTables()\n\n    const [subscriptionRows, settingsRows] = await Promise.all([\n      prisma.$queryRawUnsafe<Array<{ subscription: any }>>(\n        `SELECT subscription FROM PushSubscriptions WHERE userId = $1`,\n        userId\n      ),\n      prisma.$queryRawUnsafe<\n        Array<{\n          enabled: boolean\n          time1: string\n          time2: string\n          time3: string\n          timezone: string\n          frequency: number | null\n          focusFood: boolean | null\n          focusSupplements: boolean | null\n          focusLifestyle: boolean | null\n        }>\n      >(\n        `SELECT enabled, time1, time2, time3, timezone, frequency, focusFood, focusSupplements, focusLifestyle\n         FROM HealthTipSettings\n         WHERE userId = $1`,\n        userId\n      ),\n    ])\n\n    if (!subscriptionRows.length) {\n      // No subscription yet ‚Äì nothing to deliver, but still attempt to schedule the next one\n      await scheduleHealthTipWithQStash(userId, reminderTime, timezone).catch(() => {})\n      return NextResponse.json({ skipped: 'no_subscription' })\n    }\n    let subscriptions = normalizeSubscriptionList(subscriptionRows[0].subscription)\n    if (!subscriptions.length) {\n      await scheduleHealthTipWithQStash(userId, reminderTime, timezone).catch(() => {})\n      return NextResponse.json({ skipped: 'no_subscription' })\n    }\n\n    const settings = settingsRows[0]\n    if (!settings || !settings.enabled) {\n      // User turned health tips off ‚Äì do not schedule further jobs\n      return NextResponse.json({ skipped: 'disabled' })\n    }\n\n    const resolvedFrequency = Math.max(1, Math.min(3, settings.frequency ?? 1))\n    const activeTimes: string[] = []\n    if (resolvedFrequency >= 1 && settings.time1) activeTimes.push(settings.time1)\n    if (resolvedFrequency >= 2 && settings.time2) activeTimes.push(settings.time2)\n    if (resolvedFrequency >= 3 && settings.time3) activeTimes.push(settings.time3)\n\n    const timezoneStillMatches = settings.timezone === timezone\n    const reminderStillActive = activeTimes.includes(reminderTime)\n\n    if (!reminderStillActive || !timezoneStillMatches) {\n      // Stale schedule ‚Äì reschedule based on latest settings and exit\n      try {\n        const reschedules = await Promise.all(\n          activeTimes.map((t) =>\n            scheduleHealthTipWithQStash(userId, t, settings.timezone)\n          )\n        )\n        console.log('[HEALTH_TIPS] Rescheduled after stale payload', {\n          userId,\n          reminderTime,\n          timezone,\n          activeTimes,\n          reschedules,\n        })\n      } catch (err) {\n        console.error('[HEALTH_TIPS] Failed to reschedule after stale payload', err)\n      }\n      return NextResponse.json({ skipped: 'stale_schedule' })\n    }\n\n    const effectiveTimezone = settings.timezone || timezone || 'UTC'\n    const now = new Date()\n    const localDateParts = new Intl.DateTimeFormat('en-GB', {\n      timeZone: effectiveTimezone,\n      year: 'numeric',\n      month: '2-digit',\n      day: '2-digit',\n    }).formatToParts(now)\n    const localDateString = `${localDateParts.find((p) => p.type === 'year')?.value}-${localDateParts\n      .find((p) => p.type === 'month')\n      ?.value}-${localDateParts.find((p) => p.type === 'day')?.value}`\n\n    // De-duplicate: only one tip per user/time/date\n    const existing: Array<{ exists: number }> = await prisma.$queryRawUnsafe(\n      `SELECT 1 as exists FROM HealthTipDeliveryLog WHERE userId = $1 AND reminderTime = $2 AND tipDate = $3::date LIMIT 1`,\n      userId,\n      reminderTime,\n      localDateString\n    )\n    if (existing.length > 0) {\n      return NextResponse.json({ skipped: 'already_sent' })\n    }\n\n    const user = await prisma.user.findUnique({\n      where: { id: userId },\n      include: { subscription: true, creditTopUps: true },\n    })\n    if (!user) {\n      return NextResponse.json({ error: 'user_not_found' }, { status: 404 })\n    }\n\n    const openai = getOpenAIClient()\n    if (!openai) {\n      return NextResponse.json({ error: 'openai_not_configured' }, { status: 500 })\n    }\n\n    const publicKey = process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY || ''\n    const privateKey = process.env.VAPID_PRIVATE_KEY || ''\n    if (!publicKey || !privateKey) {\n      return NextResponse.json({ error: 'vapid_not_configured' }, { status: 500 })\n    }\n    webpush.setVapidDetails('mailto:support@helfi.ai', publicKey, privateKey)\n\n    // Build health context for this user\n    const context = await buildUserHealthContext(userId)\n\n    // Create a light human description of the local time (morning/afternoon/evening)\n    const [hhStr, mmStr] = reminderTime.split(':')\n    const hh = parseInt(hhStr || '0', 10)\n    const approxSlot =\n      hh < 11 ? 'morning' : hh < 15 ? 'around lunchtime' : hh < 19 ? 'afternoon' : 'evening'\n    const localTimeDescription = `${reminderTime} in their local timezone (${approxSlot})`\n\n    const model = 'gpt-4o'\n    const prompt = buildTipPrompt({\n      context,\n      localTimeDescription,\n      focusFood: settings.focusFood !== false,\n      focusSupplements: settings.focusSupplements !== false,\n      focusLifestyle: settings.focusLifestyle !== false,\n    })\n    const messages = [\n      {\n        role: 'user' as const,\n        content: prompt,\n      },\n    ]\n\n    // Wallet pre-check using a budget-aware max token cap\n    const creditManager = new CreditManager(user.id)\n    const walletStatus = await creditManager.getWalletStatus()\n\n    let maxTokens = 800\n    const cappedMaxTokens = capMaxTokensToBudget(model, prompt, maxTokens, walletStatus.totalAvailableCents)\n    if (cappedMaxTokens <= 0) {\n      // Not enough credits ‚Äì send a gentle notification that links to billing instead of a tip\n    const payload = JSON.stringify({\n        title: 'Top up credits to keep AI health tips coming',\n        body: 'We could not send today‚Äôs health tip because your credits are low. Tap to add more credits or upgrade your plan.',\n        url: '/billing',\n      })\n      const lowCreditSend = await sendToSubscriptions(subscriptions, (sub) =>\n        webpush.sendNotification(sub, payload)\n      )\n      if (lowCreditSend.goneEndpoints.length) {\n        subscriptions = removeSubscriptionsByEndpoint(subscriptions, lowCreditSend.goneEndpoints)\n        await prisma.$executeRawUnsafe(\n          `UPDATE PushSubscriptions SET subscription = $2::jsonb, updatedAt = NOW() WHERE userId = $1`,\n          userId,\n          JSON.stringify(subscriptions)\n        )\n      }\n      if (!lowCreditSend.sent) {\n        console.error('[HEALTH_TIPS] Low-credit notification send error', lowCreditSend.errors)\n      }\n\n      await prisma.$executeRawUnsafe(\n        `INSERT INTO HealthTipDeliveryLog (userId, reminderTime, tipDate, sentAt)\n         VALUES ($1, $2, $3::date, NOW())\n         ON CONFLICT (userId, reminderTime, tipDate) DO UPDATE SET sentAt = NOW()`,\n        userId,\n        reminderTime,\n        localDateString\n      )\n\n      // Still schedule the next attempt for tomorrow at the same time\n      await scheduleHealthTipWithQStash(userId, reminderTime, effectiveTimezone).catch(\n        (error) => {\n          console.error('[HEALTH_TIPS] Failed to schedule next tip after low credits', error)\n        }\n      )\n\n      return NextResponse.json({ skipped: 'insufficient_credits' })\n    }\n    maxTokens = cappedMaxTokens\n\n    // Generate the health tip with OpenAI\n    const wrapped = await chatCompletionWithCost(openai, {\n      model,\n      messages,\n      max_tokens: maxTokens,\n      temperature: 0.4,\n    } as any)\n\n    const rawContent = wrapped.completion.choices?.[0]?.message?.content || ''\n    const parsed = extractTipJson(rawContent)\n\n    if (!parsed || !parsed.title || !parsed.tip) {\n      console.error('[HEALTH_TIPS] Failed to parse tip JSON', rawContent)\n      return NextResponse.json({ error: 'tip_generation_failed' }, { status: 500 })\n    }\n\n    const category =\n      parsed.category === 'supplement' || parsed.category === 'lifestyle'\n        ? parsed.category\n        : 'food'\n\n    const safeTip = String(parsed.tip).trim()\n    const safetyNote = String(parsed.safetyNote || '').trim()\n    const fullBody =\n      safetyNote && safetyNote.length > 0 ? `${safeTip} ${safetyNote}` : safeTip\n\n    // costCents already includes the global markup (default 2x OpenAI cost).\n    // Charge the user exactly that amount‚Äîdo not double again.\n    const costCents = wrapped.costCents\n    const chargeCents = costCents\n\n    const suggestedQuestions =\n      Array.isArray(parsed.suggestedQuestions) && parsed.suggestedQuestions.length > 0\n        ? parsed.suggestedQuestions\n            .filter((q) => typeof q === 'string' && q.trim().length > 0)\n            .slice(0, 4)\n        : []\n\n    // Charge the user in credits for this tip\n    const chargedOk = await creditManager.chargeCents(chargeCents)\n    if (!chargedOk) {\n      return NextResponse.json({ error: 'billing_failed' }, { status: 402 })\n    }\n\n    const tipId = crypto.randomUUID()\n\n    await prisma.$executeRawUnsafe(\n      `INSERT INTO HealthTips (id, userId, tipDate, sentAt, title, body, category, metadata, costCents, chargeCents)\n       VALUES ($1,$2,$3::date,NOW(),$4,$5,$6,$7::jsonb,$8,$9)`,\n      tipId,\n      userId,\n      localDateString,\n      parsed.title.substring(0, 140),\n      fullBody,\n      category,\n      JSON.stringify({ rawContent, suggestedQuestions }).slice(0, 10000),\n      costCents,\n      chargeCents\n    )\n\n    await prisma.$executeRawUnsafe(\n      `INSERT INTO HealthTipDeliveryLog (userId, reminderTime, tipDate, sentAt)\n       VALUES ($1, $2, $3::date, NOW())\n       ON CONFLICT (userId, reminderTime, tipDate) DO UPDATE SET sentAt = NOW()`,\n      userId,\n      reminderTime,\n      localDateString\n    )\n\n    const notificationBody = safeTip.length > 120 ? `${safeTip.slice(0, 117)}‚Ä¶` : safeTip\n\n    const payload = JSON.stringify({\n      title: parsed.title.substring(0, 80),\n      body: notificationBody,\n      url: '/health-tips',\n    })\n\n    const tipSend = await sendToSubscriptions(subscriptions, (sub) => webpush.sendNotification(sub, payload))\n    if (tipSend.goneEndpoints.length) {\n      subscriptions = removeSubscriptionsByEndpoint(subscriptions, tipSend.goneEndpoints)\n      await prisma.$executeRawUnsafe(\n        `UPDATE PushSubscriptions SET subscription = $2::jsonb, updatedAt = NOW() WHERE userId = $1`,\n        userId,\n        JSON.stringify(subscriptions)\n      )\n    }\n    if (!tipSend.sent) {\n      console.error('[HEALTH_TIPS] Notification send error', tipSend.errors)\n    }\n\n    // Schedule the next tip for this time tomorrow\n    await scheduleHealthTipWithQStash(userId, reminderTime, effectiveTimezone).catch(\n      (error) => {\n        console.error('[HEALTH_TIPS] Failed to schedule next tip via QStash', error)\n      }\n    )\n\n    // Log AI usage for health tip generation (fire-and-forget)\n    try {\n      await logAIUsage({\n        context: { feature: 'health-tips:dispatch', userId },\n        model,\n        promptTokens: wrapped.promptTokens,\n        completionTokens: wrapped.completionTokens,\n        costCents,\n      })\n    } catch {\n      // Logging issues should not affect tip delivery\n    }\n\n    return NextResponse.json({\n      ok: true,\n      tipId,\n      costCents,\n      chargeCents,\n    })\n  } catch (e: any) {\n    console.error('[HEALTH_TIPS_DISPATCH] error', e?.stack || e)\n    return NextResponse.json(\n      { error: 'health_tip_dispatch_error', message: e?.message || String(e) },\n      { status: 500 }\n    )\n  }\n}\n","truncated":false,"size":25538},{"path":"app/api/push/owner/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\nimport webpush from 'web-push'\nimport { normalizeSubscriptionList, removeSubscriptionsByEndpoint, sendToSubscriptions } from '@/lib/push-subscriptions'\nimport { isSchedulerAuthorized } from '@/lib/scheduler-auth'\n\n// Upstash QStash will POST here. This simply reuses our notifyOwner pathway,\n// which resolves owner's subscription and performs the web-push delivery.\nexport async function POST(req: NextRequest) {\n  try {\n    if (!isSchedulerAuthorized(req)) {\n      return NextResponse.json({ error: 'unauthorized' }, { status: 401 })\n    }\n\n    const body = await req.json().catch(() => ({}))\n    const { event, userEmail, userName, amount, currency, planName, creditAmount } = body || {}\n    if (!event || !userEmail) {\n      return NextResponse.json({ error: 'invalid_payload' }, { status: 400 })\n    }\n\n    // Log receipt\n    try {\n      await prisma.$executeRawUnsafe(`\n        CREATE TABLE IF NOT EXISTS OwnerPushLog (\n          createdAt TIMESTAMP NOT NULL DEFAULT NOW(),\n          event TEXT,\n          userEmail TEXT,\n          status TEXT,\n          info TEXT\n        )\n      `)\n      await prisma.$executeRawUnsafe(\n        `INSERT INTO OwnerPushLog (event, userEmail, status, info) VALUES ($1, $2, $3, $4)`,\n        event,\n        userEmail,\n        'received_qstash',\n        null\n      )\n    } catch {}\n\n    // Direct delivery using same underlying mechanism as reminders\n    const publicKey = process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY || ''\n    const privateKey = process.env.VAPID_PRIVATE_KEY || ''\n    if (!publicKey || !privateKey) {\n      return NextResponse.json({ error: 'vapid_not_configured' }, { status: 500 })\n    }\n    webpush.setVapidDetails('mailto:support@helfi.ai', publicKey, privateKey)\n\n    // Resolve owner subscription\n    const ownerEmail = (process.env.OWNER_EMAIL || 'admin@helfi.ai').toLowerCase()\n\n    // Find owner userId in User table (AdminUser accounts map by email)\n    const owner = await prisma.user.findUnique({\n      where: { email: ownerEmail },\n      select: { id: true }\n    })\n    if (!owner?.id) {\n      return NextResponse.json({ error: 'owner_not_found' }, { status: 404 })\n    }\n\n    // Ensure PushSubscriptions exists and fetch subscription\n    await prisma.$executeRawUnsafe(`\n      CREATE TABLE IF NOT EXISTS PushSubscriptions (\n        userId TEXT PRIMARY KEY,\n        subscription JSONB NOT NULL\n      )\n    `)\n    const subRows: Array<{ subscription: any }> = await prisma.$queryRawUnsafe(\n      `SELECT subscription FROM PushSubscriptions WHERE userId = $1`,\n      owner.id\n    )\n    if (!subRows.length) {\n      return NextResponse.json({ error: 'no_owner_subscription' }, { status: 400 })\n    }\n    const subscriptions = normalizeSubscriptionList(subRows[0].subscription)\n    if (!subscriptions.length) {\n      return NextResponse.json({ error: 'no_owner_subscription' }, { status: 400 })\n    }\n\n    // Build payload\n    const titleMap: Record<string, string> = {\n      signup: 'üéâ New User Signup',\n      subscription: 'üí∞ New Subscription',\n      credit_purchase: 'üí≥ Credit Purchase',\n    }\n    const bodyText =\n      event === 'signup'\n        ? `${userName || (userEmail || '').split('@')[0]} just signed up!`\n        : event === 'subscription'\n        ? `${userName || (userEmail || '').split('@')[0]} purchased ${planName || 'Premium'}`\n        : `${userName || (userEmail || '').split('@')[0]} bought ${creditAmount ? `${creditAmount} credits` : 'credits'}` +\n          (amount ? ` (${(amount / 100).toFixed(2)} ${currency || 'USD'})` : '')\n\n    const payload = JSON.stringify({\n      title: titleMap[event] || 'Helfi Update',\n      body: bodyText,\n      url: '/admin-panel',\n    })\n\n    const { sent, errors, goneEndpoints } = await sendToSubscriptions(subscriptions, (sub) =>\n      webpush.sendNotification(sub, payload)\n    )\n    if (goneEndpoints.length) {\n      const remaining = removeSubscriptionsByEndpoint(subscriptions, goneEndpoints)\n      await prisma.$executeRawUnsafe(\n        `UPDATE PushSubscriptions SET subscription = $2::jsonb, updatedAt = NOW() WHERE userId = $1`,\n        owner.id,\n        JSON.stringify(remaining)\n      )\n    }\n    if (!sent) {\n      return NextResponse.json({ error: 'push_failed', details: errors }, { status: 500 })\n    }\n    try {\n      await prisma.$executeRawUnsafe(\n        `INSERT INTO OwnerPushLog (event, userEmail, status, info) VALUES ($1, $2, $3, $4)`,\n        event,\n        userEmail,\n        'sent_qstash',\n        null\n      )\n    } catch {}\n\n    return NextResponse.json({ ok: true })\n  } catch (e: any) {\n    console.error('[OWNER PUSH API] error', e?.stack || e)\n    return NextResponse.json({ error: 'owner_push_error', message: e?.message || String(e) }, { status: 500 })\n  }\n}\n\nexport const runtime = 'nodejs'\nexport const dynamic = 'force-dynamic'\n","truncated":false,"size":4886},{"path":"app/api/push/scheduler-debug/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\nimport { normalizeSubscriptionList } from '@/lib/push-subscriptions'\n\n// Debug endpoint to check scheduler status and test timing\nexport async function GET(req: NextRequest) {\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.email) {\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  }\n\n  const user = await prisma.user.findUnique({ where: { email: session.user.email } })\n  if (!user) return NextResponse.json({ error: 'User not found' }, { status: 404 })\n\n  try {\n    // Get user's settings\n    const settingsRows: Array<{ time1: string; time2: string; time3: string; timezone: string; frequency: number }> =\n      await prisma.$queryRawUnsafe(\n        `SELECT time1, time2, time3, timezone, frequency FROM CheckinSettings WHERE userId = $1`,\n        user.id\n      )\n\n    // Get subscription\n    const subRows: Array<{ subscription: any }> = await prisma.$queryRawUnsafe(\n      `SELECT subscription FROM PushSubscriptions WHERE userId = $1`,\n      user.id\n    )\n\n    // Calculate current time in user's timezone\n    const nowUtc = new Date()\n    const settings = settingsRows[0] || {\n      time1: '12:30',\n      time2: '18:30',\n      time3: '21:30',\n      timezone: 'Australia/Melbourne',\n      frequency: 3\n    }\n\n    const tz = settings.timezone || 'Australia/Melbourne'\n    const fmt = new Intl.DateTimeFormat('en-GB', {\n      timeZone: tz,\n      hour: '2-digit',\n      minute: '2-digit',\n      hour12: false,\n    })\n    const parts = fmt.formatToParts(nowUtc)\n    const hh = parts.find(p => p.type === 'hour')?.value || '00'\n    const mm = parts.find(p => p.type === 'minute')?.value || '00'\n    const current = `${hh}:${mm}`\n\n    // Build reminder times\n    const reminderTimes: string[] = []\n    if (settings.frequency >= 1) reminderTimes.push(settings.time1)\n    if (settings.frequency >= 2) reminderTimes.push(settings.time2)\n    if (settings.frequency >= 3) reminderTimes.push(settings.time3)\n\n    // Check if current time matches\n    const matches = reminderTimes.map(reminderTime => {\n      const [rh, rm] = reminderTime.split(':').map(Number)\n      const [ch, cm] = [parseInt(hh, 10), parseInt(mm, 10)]\n      return {\n        reminderTime,\n        currentTime: current,\n        matches: rh === ch && rm === cm,\n        details: `Reminder: ${rh}:${rm.toString().padStart(2, '0')}, Current: ${ch}:${cm.toString().padStart(2, '0')}`\n      }\n    })\n\n    // Get recent scheduler logs\n    let schedulerLogs: any[] = []\n    try {\n      await prisma.$executeRawUnsafe(`\n        CREATE TABLE IF NOT EXISTS SchedulerLogs (\n          id TEXT PRIMARY KEY,\n          timestamp TIMESTAMP NOT NULL DEFAULT NOW(),\n          utcTime TEXT NOT NULL,\n          usersProcessed INTEGER NOT NULL,\n          notificationsSent INTEGER NOT NULL,\n          errors INTEGER NOT NULL,\n          debugInfo JSONB\n        )\n      `)\n      schedulerLogs = await prisma.$queryRawUnsafe(`\n        SELECT timestamp, utcTime, usersProcessed, notificationsSent, errors, debugInfo\n        FROM SchedulerLogs\n        ORDER BY timestamp DESC\n        LIMIT 20\n      `)\n    } catch (e) {\n      console.error('Failed to fetch scheduler logs:', e)\n    }\n\n    // Get recent QStash schedule attempts\n    let qstashScheduleLogs: any[] = []\n    try {\n      await prisma.$executeRawUnsafe(`\n        CREATE TABLE IF NOT EXISTS QstashScheduleLog (\n          id TEXT PRIMARY KEY,\n          createdAt TIMESTAMP NOT NULL DEFAULT NOW(),\n          userId TEXT,\n          reminderTime TEXT,\n          timezone TEXT,\n          deltaMinutes INTEGER,\n          notBeforeEpochSeconds BIGINT,\n          scheduled BOOLEAN NOT NULL,\n          httpStatus INTEGER,\n          reason TEXT,\n          responseSnippet TEXT\n        )\n      `)\n      qstashScheduleLogs = await prisma.$queryRawUnsafe(`\n        SELECT \n          createdAt,\n          userId,\n          reminderTime,\n          timezone,\n          deltaMinutes,\n          notBeforeEpochSeconds::text AS \"notBeforeEpochSeconds\",\n          scheduled,\n          httpStatus,\n          reason,\n          responseSnippet,\n          callbackUrl\n        FROM QstashScheduleLog\n        ORDER BY createdAt DESC\n        LIMIT 20\n      `)\n    } catch (e) {\n      console.error('Failed to fetch QStash schedule logs:', e)\n    }\n\n    return NextResponse.json({\n      userId: user.id,\n      hasSubscription: subRows.length > 0 && normalizeSubscriptionList(subRows[0]?.subscription).length > 0,\n      subscriptionCount: subRows.length ? normalizeSubscriptionList(subRows[0]?.subscription).length : 0,\n      settings: {\n        time1: settings.time1,\n        time2: settings.time2,\n        time3: settings.time3,\n        timezone: settings.timezone,\n        frequency: settings.frequency\n      },\n      currentTime: {\n        utc: nowUtc.toISOString(),\n        local: current,\n        timezone: tz\n      },\n      reminderTimes,\n      matches,\n      nextCronRuns: [\n        'Every 5 minutes at :00, :05, :10, :15, :20, :25, :30, :35, :40, :45, :50, :55'\n      ],\n      recentSchedulerLogs: schedulerLogs,\n      recentQstashScheduleLogs: qstashScheduleLogs\n    })\n  } catch (e: any) {\n    return NextResponse.json({ error: e?.message || String(e) }, { status: 500 })\n  }\n}\n","truncated":false,"size":5389},{"path":"app/api/push/scheduler/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\nimport webpush from 'web-push'\nimport crypto from 'crypto'\nimport { normalizeSubscriptionList, removeSubscriptionsByEndpoint, sendToSubscriptions } from '@/lib/push-subscriptions'\n\n// Force dynamic execution - prevent caching for cron jobs\nexport const dynamic = 'force-dynamic'\n// Ensure Node.js runtime (web-push requires Node, not Edge)\nexport const runtime = 'nodejs'\n\n// This endpoint is intended to be triggered by a cron (e.g., Vercel Cron) every 5 minutes.\n// It finds users whose reminder time matches the current time in their timezone and sends a push.\n\nexport async function POST(req: NextRequest) {\n  try {\n  const authHeader = req.headers.get('authorization') || ''\n  const expected = process.env.SCHEDULER_SECRET || ''\n  \n  // Check for Vercel cron header\n  // Vercel sends x-vercel-cron header when triggering cron jobs\n  const vercelCronHeader = req.headers.get('x-vercel-cron')\n  const isVercelCron = vercelCronHeader !== null // Header exists (even if empty, Vercel sets it)\n  \n  // Also check all headers for debugging\n  const allHeaders: Record<string, string> = {}\n  req.headers.forEach((value, key) => {\n    allHeaders[key] = value\n  })\n  \n  // Log authentication attempt for debugging\n  console.log('[SCHEDULER] Auth check:', {\n    hasVercelCronHeader: vercelCronHeader !== null,\n    vercelCronValue: vercelCronHeader,\n    isVercelCron,\n    hasAuthHeader: !!authHeader,\n    hasExpectedSecret: !!expected,\n    method: req.method,\n    url: req.url,\n    allHeaders: Object.keys(allHeaders)\n  })\n  \n  if (!(isVercelCron || (expected && authHeader === `Bearer ${expected}`))) {\n    console.error('[SCHEDULER] ‚ùå Unauthorized - missing x-vercel-cron header or valid Bearer token')\n    console.error('[SCHEDULER] Received headers:', JSON.stringify(allHeaders, null, 2))\n    return NextResponse.json({ error: 'Unauthorized', debug: { hasVercelCronHeader: vercelCronHeader !== null, headers: Object.keys(allHeaders) } }, { status: 401 })\n  }\n  \n  console.log('[SCHEDULER] ‚úÖ Authorized - proceeding with notification check')\n\n  const publicKey = process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY || ''\n  const privateKey = process.env.VAPID_PRIVATE_KEY || ''\n  if (!publicKey || !privateKey) {\n    return NextResponse.json({ error: 'VAPID keys not configured' }, { status: 500 })\n  }\n  webpush.setVapidDetails('mailto:support@helfi.ai', publicKey, privateKey)\n\n  // Ensure required tables exist with full schema\n  // await prisma.$executeRawUnsafe(`\n  //   CREATE TABLE IF NOT EXISTS CheckinSettings (\n  //     userId TEXT PRIMARY KEY,\n  //     time1 TEXT NOT NULL,\n  //     time2 TEXT NOT NULL,\n  //     time3 TEXT NOT NULL,\n  //     timezone TEXT NOT NULL,\n  //     frequency INTEGER NOT NULL DEFAULT 3\n  //   )\n  // `)\n  // await prisma.$executeRawUnsafe(`\n  //   CREATE TABLE IF NOT EXISTS PushSubscriptions (\n  //     userId TEXT PRIMARY KEY,\n  //     subscription JSONB NOT NULL\n  //   )\n  // `)\n  // await prisma.$executeRawUnsafe(`\n  //   CREATE TABLE IF NOT EXISTS ReminderDeliveryLog (\n  //     userId TEXT NOT NULL,\n  //     reminderTime TEXT NOT NULL,\n  //     sentDate DATE NOT NULL,\n  //     sentAt TIMESTAMP NOT NULL DEFAULT NOW(),\n  //     PRIMARY KEY (userId, reminderTime, sentDate)\n  //   )\n  // `)\n  \n  // // Migrate old schema if needed\n  // await prisma.$executeRawUnsafe(`ALTER TABLE CheckinSettings ADD COLUMN IF NOT EXISTS time2 TEXT NOT NULL DEFAULT '18:00'`).catch(() => {})\n  // await prisma.$executeRawUnsafe(`ALTER TABLE CheckinSettings ADD COLUMN IF NOT EXISTS time3 TEXT NOT NULL DEFAULT '21:00'`).catch(() => {})\n  // await prisma.$executeRawUnsafe(`ALTER TABLE CheckinSettings ADD COLUMN IF NOT EXISTS frequency INTEGER NOT NULL DEFAULT 3`).catch(() => {})\n\n  // Load all users with subscriptions and their reminder settings\n  const rows: Array<{\n    userId: string | null\n    time1: string\n    time2: string\n    time3: string\n    timezone: string\n    frequency: number\n    subscription: any\n  }> = await prisma.$queryRawUnsafe(`\n    SELECT DISTINCT \n      p.userId AS \"userId\", \n      COALESCE(s.time1, '12:30') AS time1,\n      COALESCE(s.time2, '18:30') AS time2,\n      COALESCE(s.time3, '21:30') AS time3,\n      COALESCE(s.timezone, 'Australia/Melbourne') AS timezone,\n      COALESCE(s.frequency, 3) AS frequency,\n      p.subscription\n    FROM PushSubscriptions p\n    LEFT JOIN CheckinSettings s ON s.userId = p.userId\n  `)\n\n  // Determine current HH:MM in each user's timezone and match against their reminder times\n  const nowUtc = new Date()\n  const sentTo: string[] = []\n  const errors: Array<{ userId: string, error: string }> = []\n  const debugLog: Array<{ userId: string, timezone: string, currentTime: string, reminderTimes: string[], matched: boolean, reason?: string }> = []\n\n  console.log(`[SCHEDULER] Cron triggered at UTC: ${nowUtc.toISOString()}, Processing ${rows.length} users`)\n\n  // Log scheduler execution to database for tracking\n  try {\n    // await prisma.$executeRawUnsafe(`\n    //   CREATE TABLE IF NOT EXISTS SchedulerLogs (\n    //     id TEXT PRIMARY KEY,\n    //     timestamp TIMESTAMP NOT NULL DEFAULT NOW(),\n    //     utcTime TEXT NOT NULL,\n    //     usersProcessed INTEGER NOT NULL,\n    //     notificationsSent INTEGER NOT NULL,\n    //     errors INTEGER NOT NULL,\n    //     debugInfo JSONB\n    //   )\n    // `)\n    const logId = crypto.randomUUID()\n    await prisma.$queryRawUnsafe(\n      `INSERT INTO SchedulerLogs (id, timestamp, utcTime, usersProcessed, notificationsSent, errors, debugInfo)\n       VALUES ($1, $2, $3, $4, $5, $6, $7)`,\n      logId,\n      nowUtc,\n      nowUtc.toISOString(),\n      rows.length,\n      0, // Will update after processing\n      0, // Will update after processing\n      JSON.stringify({ cronTriggered: true })\n    )\n  } catch (e) {\n    console.error('[SCHEDULER] Failed to log execution:', e)\n  }\n\n  for (const r of rows) {\n    try {\n      const tz = r.timezone || 'UTC'\n      const fmt = new Intl.DateTimeFormat('en-GB', {\n        timeZone: tz,\n        hour: '2-digit',\n        minute: '2-digit',\n        hour12: false,\n      })\n      const parts = fmt.formatToParts(nowUtc)\n      const hh = parts.find(p => p.type === 'hour')?.value || '00'\n      const mm = parts.find(p => p.type === 'minute')?.value || '00'\n      const current = `${hh}:${mm}`\n\n      const dateParts = new Intl.DateTimeFormat('en-GB', {\n        timeZone: tz,\n        year: 'numeric',\n        month: '2-digit',\n        day: '2-digit'\n      }).formatToParts(nowUtc)\n      const year = dateParts.find(p => p.type === 'year')?.value || '1970'\n      const month = dateParts.find(p => p.type === 'month')?.value || '01'\n      const day = dateParts.find(p => p.type === 'day')?.value || '01'\n      const localDate = `${year}-${month}-${day}`\n\n      // Build array of reminder times based on frequency\n      const reminderTimes: string[] = []\n      if (r.frequency >= 1) reminderTimes.push(r.time1 || '12:30')\n      if (r.frequency >= 2) reminderTimes.push(r.time2 || '18:30')\n      if (r.frequency >= 3) reminderTimes.push(r.time3 || '21:30')\n\n      // Matching: Exact match, up to N minutes after (catch late cron), or 1 minute early\n      let shouldSend = false\n      let matchReason = ''\n      let matchedReminder = ''\n      const backfillWindow = Math.max(1, Math.min(60, parseInt(process.env.REMINDER_LAG_MINUTES || '10', 10)))\n      \n      for (const reminderTime of reminderTimes) {\n        const [rh, rm] = reminderTime.split(':').map(Number)\n        const [ch, cm] = [parseInt(hh, 10), parseInt(mm, 10)]\n        \n        // Exact match: current time equals reminder time\n        if (rh === ch && rm === cm) {\n          shouldSend = true\n          matchedReminder = reminderTime\n          matchReason = `EXACT MATCH: reminder ${reminderTime} at current time ${current}`\n          break\n        }\n        \n        // Within backfillWindow minutes after: catch late cron (e.g., cron runs late)\n        const currentTotalMinutes = ch * 60 + cm\n        const reminderTotalMinutes = rh * 60 + rm\n        let minutesDiff = currentTotalMinutes - reminderTotalMinutes\n        if (minutesDiff < 0) minutesDiff += 1440 // wrap-around safe\n        \n        if (minutesDiff >= 1 && minutesDiff <= backfillWindow) {\n          shouldSend = true\n          matchedReminder = reminderTime\n          matchReason = `LATE CRON CATCH: reminder ${reminderTime} was ${minutesDiff} minute(s) ago (current ${current}), sending now (window ${backfillWindow}m)`\n          break\n        }\n\n        // One minute early: send proactively\n        let minutesAhead = reminderTotalMinutes - currentTotalMinutes\n        if (minutesAhead < 0) minutesAhead += 1440\n        if (minutesAhead === 1) {\n          shouldSend = true\n          matchedReminder = reminderTime\n          matchReason = `EARLY SEND: reminder ${reminderTime} is in 1 minute (current ${current}), sending now`\n          break\n        }\n      }\n\n      const shortId = (r.userId ?? 'unknown').toString().slice(0, 8)\n      debugLog.push({\n        userId: r.userId ?? 'unknown',\n        timezone: tz,\n        currentTime: current,\n        reminderTimes,\n        matched: shouldSend,\n        reason: shouldSend ? matchReason : `No match: current=${current}, reminders=${reminderTimes.join(', ')}`\n      })\n\n      if (!shouldSend) {\n        console.log(`[SCHEDULER] User ${shortId}... (${tz}): No match - current=${current}, reminders=${reminderTimes.join(', ')}`)\n        continue\n      }\n\n      if (!r.userId) {\n        console.warn('[SCHEDULER] Skipping send because userId is null')\n        continue\n      }\n\n      const subscriptions = normalizeSubscriptionList(r.subscription)\n      if (!subscriptions.length) {\n        errors.push({ userId: r.userId ?? 'unknown', error: 'no_subscription' })\n        continue\n      }\n\n      const alreadySent: Array<{ exists: number }> = await prisma.$queryRawUnsafe(\n        `SELECT 1 as exists FROM ReminderDeliveryLog WHERE userId = $1 AND reminderTime = $2 AND sentDate = $3::date LIMIT 1`,\n        r.userId,\n        matchedReminder,\n        localDate\n      )\n\n      if (alreadySent.length > 0) {\n        console.log(`[SCHEDULER] User ${shortId}... (${tz}): Reminder ${matchedReminder} already sent today (${localDate}), skipping duplicate.`)\n        continue\n      }\n\n      console.log(`[SCHEDULER] User ${shortId}... (${tz}): Sending notification - matched ${matchReason}`)\n\n      const payload = JSON.stringify({\n        title: 'Time for your Helfi check‚Äëin',\n        body: 'Rate your selected issues for today in under a minute.',\n        url: '/check-in'\n      })\n      const { sent, errors: sendErrors, goneEndpoints } = await sendToSubscriptions(subscriptions, (sub) =>\n        webpush.sendNotification(sub, payload)\n      )\n      if (goneEndpoints.length) {\n        const remaining = removeSubscriptionsByEndpoint(subscriptions, goneEndpoints)\n        await prisma.$executeRawUnsafe(\n          `UPDATE PushSubscriptions SET subscription = $2::jsonb, updatedAt = NOW() WHERE userId = $1`,\n          r.userId,\n          JSON.stringify(remaining)\n        )\n      }\n      if (!sent) {\n        const msg = sendErrors.map((err) => err.message).join('; ')\n        errors.push({ userId: r.userId ?? 'unknown', error: msg || 'push_failed' })\n        continue\n      }\n      sentTo.push(r.userId ?? 'unknown')\n      await prisma.$queryRawUnsafe(\n        `INSERT INTO ReminderDeliveryLog (userId, reminderTime, sentDate, sentAt)\n         VALUES ($1, $2, $3::date, NOW())\n         ON CONFLICT (userId, reminderTime, sentDate) DO UPDATE SET sentAt = NOW()`,\n        r.userId,\n        matchedReminder,\n        localDate\n      )\n      console.log(`[SCHEDULER] ‚úÖ Notification sent to user ${shortId}...`)\n    } catch (e: any) {\n      const errorMsg = e?.body || e?.message || String(e)\n      const shortId = (r.userId ?? 'unknown').toString().slice(0, 8)\n      console.error(`[SCHEDULER] ‚ùå Error for user ${shortId}...:`, errorMsg)\n      errors.push({ userId: r.userId ?? 'unknown', error: errorMsg })\n    }\n  }\n\n  console.log(`[SCHEDULER] Complete: sent=${sentTo.length}, errors=${errors.length}`)\n\n  // Update log with final counts\n  try {\n    // Find the most recent log entry and update it\n    const recentLogs: any[] = await prisma.$queryRawUnsafe(`\n      SELECT id FROM SchedulerLogs \n      WHERE timestamp >= NOW() - INTERVAL '1 minute'\n      ORDER BY timestamp DESC\n      LIMIT 1\n    `)\n    if (recentLogs.length > 0) {\n      await prisma.$queryRawUnsafe(`\n        UPDATE SchedulerLogs \n        SET notificationsSent = $1, errors = $2, debugInfo = $3::jsonb\n        WHERE id = $4\n      `, sentTo.length, errors.length, JSON.stringify({ debug: debugLog, sentTo, errors }), recentLogs[0].id)\n    }\n  } catch (e) {\n    console.error('[SCHEDULER] Failed to update log:', e)\n  }\n\n  return NextResponse.json({ \n    success: true, \n    sent: sentTo.length, \n    errors,\n    debug: debugLog,\n    timestamp: nowUtc.toISOString()\n  })\n  } catch (e: any) {\n    console.error('[SCHEDULER] Top-level error:', e?.stack || e)\n    return NextResponse.json({ error: 'scheduler_crash', message: e?.message || String(e) }, { status: 500 })\n  }\n}\n\n// Allow Vercel Cron (GET) to trigger the same logic safely\nexport async function GET(req: NextRequest) {\n  return POST(req)\n}\n","truncated":false,"size":13310},{"path":"app/api/push/send-reminder-now/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\nimport webpush from 'web-push'\nimport { normalizeSubscriptionList, removeSubscriptionsByEndpoint, sendToSubscriptions } from '@/lib/push-subscriptions'\n\nexport async function POST(_req: NextRequest) {\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.email) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  const user = await prisma.user.findUnique({ where: { email: session.user.email } })\n  if (!user) return NextResponse.json({ error: 'User not found' }, { status: 404 })\n\n  // Ensure subscription exists\n  await prisma.$executeRawUnsafe(`\n    CREATE TABLE IF NOT EXISTS PushSubscriptions (\n      userId TEXT PRIMARY KEY,\n      subscription JSONB NOT NULL\n    )\n  `)\n  const rows: Array<{ subscription: any }> = await prisma.$queryRawUnsafe(\n    `SELECT subscription FROM PushSubscriptions WHERE userId = $1`,\n    user.id\n  )\n  if (!rows.length) return NextResponse.json({ error: 'No subscription' }, { status: 400 })\n  const subscriptions = normalizeSubscriptionList(rows[0].subscription)\n  if (!subscriptions.length) return NextResponse.json({ error: 'No subscription' }, { status: 400 })\n\n  const publicKey = process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY || ''\n  const privateKey = process.env.VAPID_PRIVATE_KEY || ''\n  if (!publicKey || !privateKey) {\n    return NextResponse.json({ error: 'VAPID keys not configured' }, { status: 500 })\n  }\n  webpush.setVapidDetails('mailto:support@helfi.ai', publicKey, privateKey)\n\n  const payload = JSON.stringify({\n    title: 'Time for your Helfi check‚Äëin',\n    body: 'Rate your selected issues for today in under a minute.',\n    url: '/check-in'\n  })\n  try {\n    const { sent, errors, goneEndpoints } = await sendToSubscriptions(subscriptions, (sub) =>\n      webpush.sendNotification(sub, payload)\n    )\n    if (goneEndpoints.length) {\n      const remaining = removeSubscriptionsByEndpoint(subscriptions, goneEndpoints)\n      await prisma.$executeRawUnsafe(\n        `UPDATE PushSubscriptions SET subscription = $2::jsonb, updatedAt = NOW() WHERE userId = $1`,\n        user.id,\n        JSON.stringify(remaining)\n      )\n    }\n    if (!sent) {\n      console.error('send-reminder-now error', errors.map((e) => e.message).join('; '))\n      return NextResponse.json({ error: 'Failed to send reminder' }, { status: 500 })\n    }\n    return NextResponse.json({ success: true, sent })\n  } catch (e: any) {\n    console.error('send-reminder-now error', e?.body || e?.message || e)\n    return NextResponse.json({ error: 'Failed to send reminder' }, { status: 500 })\n  }\n}\n\n","truncated":false,"size":2733},{"path":"app/api/push/status/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\nimport { normalizeSubscriptionList } from '@/lib/push-subscriptions'\n\nexport async function GET(_req: NextRequest) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.email) {\n      return NextResponse.json({ ok: false, error: 'not_authenticated' }, { status: 401 })\n    }\n\n    const user = await prisma.user.findUnique({ where: { email: session.user.email } })\n    if (!user) return NextResponse.json({ ok: false, error: 'user_not_found' }, { status: 404 })\n\n    // Ensure tables exist and check current records\n    await prisma.$executeRawUnsafe(`\n      CREATE TABLE IF NOT EXISTS PushSubscriptions (\n        userId TEXT PRIMARY KEY,\n        subscription JSONB NOT NULL\n      )\n    `)\n    await prisma.$executeRawUnsafe(`\n      CREATE TABLE IF NOT EXISTS CheckinSettings (\n        userId TEXT PRIMARY KEY,\n        time1 TEXT NOT NULL,\n        time2 TEXT NOT NULL,\n        time3 TEXT NOT NULL,\n        timezone TEXT NOT NULL,\n        frequency INTEGER NOT NULL DEFAULT 3\n      )\n    `)\n\n    const subRows: Array<{ subscription: any }> = await prisma.$queryRawUnsafe(\n      `SELECT subscription FROM PushSubscriptions WHERE userId = $1`,\n      user.id\n    )\n    const settingsRows: Array<{ time1: string; time2: string; time3: string; timezone: string; frequency: number }> =\n      await prisma.$queryRawUnsafe(`SELECT time1, time2, time3, timezone, frequency FROM CheckinSettings WHERE userId = $1`, user.id)\n\n    const subscriptionCount = subRows.length ? normalizeSubscriptionList(subRows[0].subscription).length : 0\n    const hasSubscription = subscriptionCount > 0\n    const hasSettings = settingsRows.length > 0\n\n    return NextResponse.json({\n      ok: true,\n      userId: user.id,\n      hasSubscription,\n      subscriptionCount,\n      hasSettings,\n      settings: hasSettings ? settingsRows[0] : null,\n    })\n  } catch (e) {\n    return NextResponse.json({ ok: false, error: 'server_error' }, { status: 500 })\n  }\n}\n\n","truncated":false,"size":2142},{"path":"app/api/push/subscribe/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\nimport { mergeSubscriptionList } from '@/lib/push-subscriptions'\n\nasync function ensurePushSubscriptionsTable() {\n  await prisma.$executeRawUnsafe(`\n    CREATE TABLE IF NOT EXISTS PushSubscriptions (\n      userId TEXT PRIMARY KEY,\n      subscription JSONB NOT NULL,\n      updatedAt TIMESTAMP NOT NULL DEFAULT NOW()\n    )\n  `)\n  await prisma.$executeRawUnsafe(\n    `ALTER TABLE PushSubscriptions ADD COLUMN IF NOT EXISTS updatedAt TIMESTAMP NOT NULL DEFAULT NOW()`\n  ).catch(() => {})\n}\n\nexport async function POST(req: NextRequest) {\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.email) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  const user = await prisma.user.findUnique({ where: { email: session.user.email } })\n  if (!user) return NextResponse.json({ error: 'User not found' }, { status: 404 })\n\n  const { subscription } = await req.json()\n  if (!subscription) return NextResponse.json({ error: 'Missing subscription' }, { status: 400 })\n\n  try {\n    await ensurePushSubscriptionsTable()\n    const rows: Array<{ subscription: any }> = await prisma.$queryRawUnsafe(\n      `SELECT subscription FROM PushSubscriptions WHERE userId = $1`,\n      user.id\n    )\n    const merged = mergeSubscriptionList(rows[0]?.subscription, subscription)\n    if (rows.length) {\n      await prisma.$executeRawUnsafe(\n        `UPDATE PushSubscriptions SET subscription = $2::jsonb, updatedAt = NOW() WHERE userId = $1`,\n        user.id,\n        JSON.stringify(merged)\n      )\n    } else {\n      await prisma.$executeRawUnsafe(\n        `INSERT INTO PushSubscriptions (userId, subscription, updatedAt) VALUES ($1, $2::jsonb, NOW())`,\n        user.id,\n        JSON.stringify(merged)\n      )\n    }\n    return NextResponse.json({ success: true, subscriptionCount: merged.length })\n  } catch (e) {\n    console.error('push subscribe save error', e)\n    return NextResponse.json({ error: 'Failed to save subscription' }, { status: 500 })\n  }\n}\n\n","truncated":false,"size":2154},{"path":"app/api/push/test/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\nimport webpush from 'web-push'\nimport { normalizeSubscriptionList, removeSubscriptionsByEndpoint, sendToSubscriptions } from '@/lib/push-subscriptions'\n\nexport async function POST(req: NextRequest) {\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.email) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  const user = await prisma.user.findUnique({ where: { email: session.user.email } })\n  if (!user) return NextResponse.json({ error: 'User not found' }, { status: 404 })\n\n  // Ensure table exists and load subscription\n  await prisma.$executeRawUnsafe(`\n    CREATE TABLE IF NOT EXISTS PushSubscriptions (\n      userId TEXT PRIMARY KEY,\n      subscription JSONB NOT NULL\n    )\n  `)\n  const rows: Array<{ subscription: any }> = await prisma.$queryRawUnsafe(\n    `SELECT subscription FROM PushSubscriptions WHERE userId = $1`,\n    user.id\n  )\n  if (!rows.length) return NextResponse.json({ error: 'No subscription' }, { status: 400 })\n  const subscriptions = normalizeSubscriptionList(rows[0].subscription)\n  if (!subscriptions.length) return NextResponse.json({ error: 'No subscription' }, { status: 400 })\n\n  // Configure web-push\n  const publicKey = process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY || ''\n  const privateKey = process.env.VAPID_PRIVATE_KEY || ''\n  if (!publicKey || !privateKey) {\n    return NextResponse.json({ error: 'VAPID keys not configured' }, { status: 500 })\n  }\n  webpush.setVapidDetails('mailto:support@helfi.ai', publicKey, privateKey)\n\n  const payload = JSON.stringify({\n    title: 'Helfi test notification',\n    body: 'Push is working. Tap to open your daily check‚Äëin.',\n    url: '/check-in'\n  })\n\n  try {\n    const { sent, errors, goneEndpoints } = await sendToSubscriptions(subscriptions, (sub) =>\n      webpush.sendNotification(sub, payload)\n    )\n    if (goneEndpoints.length) {\n      const remaining = removeSubscriptionsByEndpoint(subscriptions, goneEndpoints)\n      await prisma.$executeRawUnsafe(\n        `UPDATE PushSubscriptions SET subscription = $2::jsonb, updatedAt = NOW() WHERE userId = $1`,\n        user.id,\n        JSON.stringify(remaining)\n      )\n    }\n    if (!sent) {\n      console.error('push test error', errors.map((e) => e.message).join('; '))\n      return NextResponse.json({ error: 'Failed to send push' }, { status: 500 })\n    }\n    return NextResponse.json({ success: true, sent })\n  } catch (e: any) {\n    console.error('push test error', e?.body || e?.message || e)\n    return NextResponse.json({ error: 'Failed to send push' }, { status: 500 })\n  }\n}\n\n","truncated":false,"size":2738},{"path":"app/api/push/trigger-now/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\nimport webpush from 'web-push'\nimport { normalizeSubscriptionList, removeSubscriptionsByEndpoint, sendToSubscriptions } from '@/lib/push-subscriptions'\n\n// Manual trigger endpoint - bypasses cron and sends reminder immediately\nexport async function POST(req: NextRequest) {\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.email) {\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  }\n\n  const user = await prisma.user.findUnique({ where: { email: session.user.email } })\n  if (!user) return NextResponse.json({ error: 'User not found' }, { status: 404 })\n\n  try {\n    // Get subscription\n    const subRows: Array<{ subscription: any }> = await prisma.$queryRawUnsafe(\n      `SELECT subscription FROM PushSubscriptions WHERE userId = $1`,\n      user.id\n    )\n    if (!subRows.length) {\n      return NextResponse.json({ error: 'No push subscription found' }, { status: 400 })\n    }\n    const subscriptions = normalizeSubscriptionList(subRows[0].subscription)\n    if (!subscriptions.length) {\n      return NextResponse.json({ error: 'No push subscription found' }, { status: 400 })\n    }\n\n    // Get settings\n    const settingsRows: Array<{ time1: string; time2: string; time3: string; timezone: string; frequency: number }> =\n      await prisma.$queryRawUnsafe(\n        `SELECT time1, time2, time3, timezone, frequency FROM CheckinSettings WHERE userId = $1`,\n        user.id\n      )\n    const settings = settingsRows[0] || {\n      time1: '12:30',\n      time2: '18:30',\n      time3: '21:30',\n      timezone: 'Australia/Melbourne',\n      frequency: 3\n    }\n\n    // Configure web-push\n    const publicKey = process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY || ''\n    const privateKey = process.env.VAPID_PRIVATE_KEY || ''\n    if (!publicKey || !privateKey) {\n      return NextResponse.json({ error: 'VAPID keys not configured' }, { status: 500 })\n    }\n    webpush.setVapidDetails('mailto:support@helfi.ai', publicKey, privateKey)\n\n    // Send notification\n    const payload = JSON.stringify({\n      title: 'Time for your Helfi check‚Äëin',\n      body: 'Rate your selected issues for today in under a minute.',\n      url: '/check-in'\n    })\n    \n    const { sent, errors, goneEndpoints } = await sendToSubscriptions(subscriptions, (sub) =>\n      webpush.sendNotification(sub, payload)\n    )\n    if (goneEndpoints.length) {\n      const remaining = removeSubscriptionsByEndpoint(subscriptions, goneEndpoints)\n      await prisma.$executeRawUnsafe(\n        `UPDATE PushSubscriptions SET subscription = $2::jsonb, updatedAt = NOW() WHERE userId = $1`,\n        user.id,\n        JSON.stringify(remaining)\n      )\n    }\n    if (!sent) {\n      return NextResponse.json({ error: 'Failed to send reminder', details: errors }, { status: 500 })\n    }\n    \n    return NextResponse.json({ \n      success: true, \n      message: 'Reminder sent immediately',\n      reminderTime: settings.time1,\n      timezone: settings.timezone\n    })\n  } catch (e: any) {\n    console.error('[TRIGGER-NOW] Error:', e)\n    return NextResponse.json({ \n      error: 'Failed to send reminder', \n      details: e?.body || e?.message || String(e) \n    }, { status: 500 })\n  }\n}\n","truncated":false,"size":3357},{"path":"app/api/push/unsubscribe/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\n\nasync function ensurePushSubscriptionsTable() {\n  await prisma.$executeRawUnsafe(`\n    CREATE TABLE IF NOT EXISTS PushSubscriptions (\n      userId TEXT PRIMARY KEY,\n      subscription JSONB NOT NULL,\n      updatedAt TIMESTAMP NOT NULL DEFAULT NOW()\n    )\n  `)\n  await prisma.$executeRawUnsafe(\n    `ALTER TABLE PushSubscriptions ADD COLUMN IF NOT EXISTS updatedAt TIMESTAMP NOT NULL DEFAULT NOW()`\n  ).catch(() => {})\n}\n\nexport async function POST(req: NextRequest) {\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.email) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  const user = await prisma.user.findUnique({ where: { email: session.user.email } })\n  if (!user) return NextResponse.json({ error: 'User not found' }, { status: 404 })\n\n  try {\n    await ensurePushSubscriptionsTable()\n    await prisma.$executeRawUnsafe(`DELETE FROM PushSubscriptions WHERE userId = $1`, user.id)\n    return NextResponse.json({ success: true })\n  } catch (e) {\n    console.error('push unsubscribe error', e)\n    return NextResponse.json({ error: 'Failed to unsubscribe' }, { status: 500 })\n  }\n}\n\n\n","truncated":false,"size":1317},{"path":"app/api/push/vapid/route.ts","content":"import { NextResponse } from 'next/server'\n \n// Return only the configured VAPID public key.\n// If it's missing, return an empty key so the client can surface a clear error.\nexport async function GET() {\n  const pub = process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY || ''\n  return NextResponse.json({ publicKey: pub })\n}\n \n \n","truncated":false,"size":318},{"path":"app/api/reports/[id]/delete-original/route.ts","content":"/**\n * API Route: POST /api/reports/[id]/delete-original\n * Securely deletes the original PDF from Vercel Blob if user opts to remove it\n */\n\nimport { NextRequest, NextResponse } from 'next/server';\nimport { getServerSession } from 'next-auth/next';\nimport { authOptions } from '@/lib/auth';\nimport { prisma } from '@/lib/prisma';\nimport { del } from '@vercel/blob';\nimport { createAuditEvent } from '@/lib/audit';\nimport { AuditEventType } from '@prisma/client';\n\nexport async function POST(\n  request: NextRequest,\n  { params }: { params: { id: string } }\n) {\n  try {\n    // Check authentication\n    const session = await getServerSession(authOptions);\n    if (!session?.user?.email) {\n      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });\n    }\n\n    const user = await prisma.user.findUnique({\n      where: { email: session.user.email },\n    });\n\n    if (!user) {\n      return NextResponse.json({ error: 'User not found' }, { status: 404 });\n    }\n\n    const reportId = params.id;\n\n    // Get report\n    const report = await prisma.report.findUnique({\n      where: { id: reportId },\n    });\n\n    if (!report) {\n      return NextResponse.json({ error: 'Report not found' }, { status: 404 });\n    }\n\n    // Verify ownership\n    if (report.userId !== user.id) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 403 });\n    }\n\n    // Check if already deleted\n    if (report.originalDeletedAt) {\n      return NextResponse.json(\n        { error: 'Original PDF already deleted' },\n        { status: 400 }\n      );\n    }\n\n    // Delete from Vercel Blob\n    try {\n      await del(report.s3Key); // s3Key field stores the blob path\n    } catch (deleteError) {\n      console.error('Failed to delete blob:', deleteError);\n      // Continue - blob might already be deleted\n    }\n\n    // Update report\n    await prisma.report.update({\n      where: { id: reportId },\n      data: {\n        originalDeletedAt: new Date(),\n        retainOriginal: false,\n      },\n    });\n\n    // Log audit event\n    await createAuditEvent({\n      reportId,\n      userId: user.id,\n      eventType: AuditEventType.ORIGINAL_DELETED,\n      eventDescription: 'User requested deletion of original PDF',\n      ipAddress: request.headers.get('x-forwarded-for') || request.headers.get('x-real-ip') || undefined,\n      userAgent: request.headers.get('user-agent') || undefined,\n    });\n\n    return NextResponse.json({\n      success: true,\n      message: 'Original PDF deleted successfully',\n    });\n  } catch (error) {\n    console.error('‚ùå Delete original PDF error:', error);\n    return NextResponse.json(\n      {\n        error: 'Failed to delete original PDF',\n        details: error instanceof Error ? error.message : 'Unknown error',\n      },\n      { status: 500 }\n    );\n  }\n}\n","truncated":false,"size":2788},{"path":"app/api/reports/[id]/process/route.ts","content":"/**\n * API Route: POST /api/reports/[id]/process\n * Processes uploaded PDF: decrypts, extracts lab values, encrypts data\n * Password is provided in request body (ephemeral, not stored)\n */\n\nimport { NextRequest, NextResponse } from 'next/server';\nimport { getServerSession } from 'next-auth/next';\nimport { authOptions } from '@/lib/auth';\nimport { prisma } from '@/lib/prisma';\nimport { del, head } from '@vercel/blob';\nimport { processPDF } from '@/lib/pdf-processor';\nimport { encryptFieldsBatch, verifyPasswordHash } from '@/lib/encryption';\nimport { decryptBuffer } from '@/lib/file-encryption';\nimport { createAuditEvent } from '@/lib/audit';\nimport { AuditEventType, ReportStatus } from '@prisma/client';\n\nexport async function POST(\n  request: NextRequest,\n  { params }: { params: { id: string } }\n) {\n  try {\n    // Check authentication\n    const session = await getServerSession(authOptions);\n    if (!session?.user?.email) {\n      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });\n    }\n\n    const user = await prisma.user.findUnique({\n      where: { email: session.user.email },\n    });\n\n    if (!user) {\n      return NextResponse.json({ error: 'User not found' }, { status: 404 });\n    }\n\n    const reportId = params.id;\n\n    // Get report\n    const report = await prisma.report.findUnique({\n      where: { id: reportId },\n      include: { consentRecord: true },\n    });\n\n    if (!report) {\n      return NextResponse.json({ error: 'Report not found' }, { status: 404 });\n    }\n\n    // Verify ownership\n    if (report.userId !== user.id) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 403 });\n    }\n\n    // Check if already processed\n    if (report.status === 'COMPLETED') {\n      return NextResponse.json(\n        { error: 'Report already processed' },\n        { status: 400 }\n      );\n    }\n\n    // Verify consent\n    if (!report.consentRecord.decryptionConsent || !report.consentRecord.passwordConsent) {\n      return NextResponse.json(\n        { error: 'Consent not granted' },\n        { status: 403 }\n      );\n    }\n\n    // Parse request body for password\n    const body = await request.json();\n    const password = body.password;\n\n    // Verify password if PDF is password-protected\n    if (report.isPasswordProtected) {\n      if (!password) {\n        return NextResponse.json(\n          { error: 'Password is required' },\n          { status: 400 }\n        );\n      }\n\n      // Verify password hash\n      if (report.passwordHash) {\n        const [hashHex, saltHex] = report.passwordHash.split(':');\n        const isValid = await verifyPasswordHash(password, hashHex, saltHex);\n        \n        if (!isValid) {\n          await prisma.report.update({\n            where: { id: reportId },\n            data: {\n              status: 'DECRYPTION_FAILED',\n              processingError: 'Password verification failed',\n            },\n          });\n\n          await createAuditEvent({\n            reportId,\n            userId: user.id,\n            eventType: AuditEventType.PDF_PROCESSING_FAILED,\n            eventDescription: 'PDF decryption failed: incorrect password',\n          });\n\n          return NextResponse.json(\n            { error: 'Incorrect password' },\n            { status: 401 }\n          );\n        }\n      }\n    }\n\n    // Update status to PROCESSING\n    await prisma.report.update({\n      where: { id: reportId },\n      data: {\n        status: 'PROCESSING',\n        processingStartedAt: new Date(),\n      },\n    });\n\n    await createAuditEvent({\n      reportId,\n      userId: user.id,\n      eventType: AuditEventType.PDF_PROCESSING_STARTED,\n      eventDescription: 'PDF processing started',\n    });\n\n    try {\n      // Download PDF from Vercel Blob\n      // Get blob info using head function (more reliable than constructing URL)\n      const blobInfo = await head(report.s3Key);\n      \n      if (!blobInfo) {\n        throw new Error('Blob not found');\n      }\n\n      // Fetch PDF from blob URL\n      const blobResponse = await fetch(blobInfo.url, {\n        headers: {\n          'Authorization': `Bearer ${process.env.BLOB_READ_WRITE_TOKEN}`,\n        },\n      });\n\n      if (!blobResponse.ok) {\n        throw new Error(`Failed to fetch PDF from blob: ${blobResponse.statusText}`);\n      }\n\n      let pdfBuffer: Buffer = Buffer.from(await blobResponse.arrayBuffer());\n      const reportMeta = (report.metadata || {}) as any;\n      if (reportMeta?.encrypted === true) {\n        pdfBuffer = decryptBuffer(pdfBuffer, reportMeta?.encryption?.iv, reportMeta?.encryption?.tag);\n      }\n\n      // Process PDF\n      const processingResult = await processPDF(\n        pdfBuffer,\n        report.isPasswordProtected ? password : undefined\n      );\n\n      await createAuditEvent({\n        reportId,\n        userId: user.id,\n        eventType: AuditEventType.PDF_DECRYPTED,\n        eventDescription: 'PDF successfully decrypted',\n        metadata: {\n          pageCount: processingResult.pageCount,\n          labValueCount: processingResult.labValues.length,\n        },\n      });\n\n      // Encrypt lab values\n      const labResults = [];\n      for (const labValue of processingResult.labValues) {\n        const fields: Record<string, string> = {\n          analyteName: labValue.analyteName,\n          value: labValue.value,\n        };\n\n        if (labValue.unit) fields.unit = labValue.unit;\n        if (labValue.referenceRange) fields.referenceRange = labValue.referenceRange;\n        if (labValue.collectionDate) fields.collectionDate = labValue.collectionDate;\n        if (labValue.accessionNumber) fields.accessionNumber = labValue.accessionNumber;\n        if (labValue.laboratoryName) fields.laboratoryName = labValue.laboratoryName;\n\n        const { encryptedFields, wrappedKey } = await encryptFieldsBatch(fields);\n\n        const labResult = await prisma.labResult.create({\n          data: {\n            reportId: report.id,\n            analyteNameEncrypted: encryptedFields.analyteName || '',\n            valueEncrypted: encryptedFields.value || '',\n            unitEncrypted: encryptedFields.unit || null,\n            referenceRangeEncrypted: encryptedFields.referenceRange || null,\n            collectionDateEncrypted: encryptedFields.collectionDate || null,\n            accessionNumberEncrypted: encryptedFields.accessionNumber || null,\n            laboratoryNameEncrypted: encryptedFields.laboratoryName || null,\n            dataKeyEncrypted: wrappedKey,\n          },\n        });\n\n        labResults.push(labResult);\n      }\n\n      await createAuditEvent({\n        reportId,\n        userId: user.id,\n        eventType: AuditEventType.LAB_DATA_EXTRACTED,\n        eventDescription: `Extracted ${labResults.length} lab values from PDF`,\n        metadata: {\n          labValueCount: labResults.length,\n        },\n      });\n\n      await createAuditEvent({\n        reportId,\n        userId: user.id,\n        eventType: AuditEventType.LAB_DATA_ENCRYPTED,\n        eventDescription: 'Lab values encrypted and stored',\n        metadata: {\n          labValueCount: labResults.length,\n        },\n      });\n\n      // Delete original PDF if user didn't consent to retention\n      if (!report.retainOriginal) {\n        try {\n          await del(report.s3Key);\n        } catch (deleteError) {\n          console.error('Failed to delete blob:', deleteError);\n          // Continue even if deletion fails - we'll log it\n        }\n\n        await prisma.report.update({\n          where: { id: reportId },\n          data: {\n            originalDeletedAt: new Date(),\n          },\n        });\n\n        await createAuditEvent({\n          reportId,\n          userId: user.id,\n          eventType: AuditEventType.ORIGINAL_DELETED,\n          eventDescription: 'Original PDF deleted per user consent',\n        });\n      }\n\n      // Update report status to COMPLETED\n      await prisma.report.update({\n        where: { id: reportId },\n        data: {\n          status: 'COMPLETED',\n          processingCompletedAt: new Date(),\n        },\n      });\n\n      await createAuditEvent({\n        reportId,\n        userId: user.id,\n        eventType: AuditEventType.PDF_PROCESSING_COMPLETED,\n        eventDescription: 'PDF processing completed successfully',\n        metadata: {\n          labValueCount: labResults.length,\n        },\n      });\n\n      return NextResponse.json({\n        success: true,\n        reportId: report.id,\n        labValueCount: labResults.length,\n        status: 'COMPLETED',\n      });\n    } catch (error) {\n      // Update status to FAILED\n      await prisma.report.update({\n        where: { id: reportId },\n        data: {\n          status: 'FAILED',\n          processingError: error instanceof Error ? error.message : 'Unknown error',\n          processingCompletedAt: new Date(),\n        },\n      });\n\n      await createAuditEvent({\n        reportId,\n        userId: user.id,\n        eventType: AuditEventType.PDF_PROCESSING_FAILED,\n        eventDescription: `PDF processing failed: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        metadata: {\n          error: error instanceof Error ? error.message : 'Unknown error',\n        },\n      });\n\n      throw error;\n    }\n  } catch (error) {\n    console.error('‚ùå PDF processing error:', error);\n    return NextResponse.json(\n      {\n        error: 'Failed to process PDF',\n        details: error instanceof Error ? error.message : 'Unknown error',\n      },\n      { status: 500 }\n    );\n  }\n}\n","truncated":false,"size":9423},{"path":"app/api/reports/[id]/upload/route.ts","content":"/**\n * API Route: POST /api/reports/[id]/upload\n * Handles direct file upload to Vercel Blob\n */\n\nimport { NextRequest, NextResponse } from 'next/server';\nimport { getServerSession } from 'next-auth/next';\nimport { authOptions } from '@/lib/auth';\nimport { prisma } from '@/lib/prisma';\nimport { put } from '@vercel/blob';\nimport { createAuditEvent } from '@/lib/audit';\nimport { AuditEventType } from '@prisma/client';\nimport { encryptBuffer } from '@/lib/file-encryption';\n\nexport async function POST(\n  request: NextRequest,\n  { params }: { params: { id: string } }\n) {\n  try {\n    // Check authentication\n    const session = await getServerSession(authOptions);\n    if (!session?.user?.email) {\n      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });\n    }\n\n    const user = await prisma.user.findUnique({\n      where: { email: session.user.email },\n    });\n\n    if (!user) {\n      return NextResponse.json({ error: 'User not found' }, { status: 404 });\n    }\n\n    const reportId = params.id;\n\n    // Get report\n    const report = await prisma.report.findUnique({\n      where: { id: reportId },\n    });\n\n    if (!report) {\n      return NextResponse.json({ error: 'Report not found' }, { status: 404 });\n    }\n\n    // Verify ownership\n    if (report.userId !== user.id) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 403 });\n    }\n\n    // Get file from form data\n    const formData = await request.formData();\n    const file = formData.get('file') as File;\n\n    if (!file) {\n      return NextResponse.json({ error: 'No file provided' }, { status: 400 });\n    }\n\n    // Upload to Vercel Blob\n    // Note: 'public' access still requires API token for retrieval via our API routes\n    const fileBuffer = Buffer.from(await file.arrayBuffer());\n    const encryptedPayload = encryptBuffer(fileBuffer);\n\n    const blob = await put(report.s3Key, encryptedPayload.encrypted, {\n      access: 'public',\n      contentType: 'application/octet-stream',\n      addRandomSuffix: false, // Use our custom path\n    });\n\n    // Update report with blob URL and pathname\n    await prisma.report.update({\n      where: { id: reportId },\n      data: {\n        s3Key: blob.pathname, // Store blob pathname for deletion\n        // Store blob URL in metadata for retrieval\n        metadata: {\n          ...(report.metadata as any),\n          blobUrl: blob.url,\n          blobPathname: blob.pathname,\n          encrypted: true,\n          encryption: {\n            algorithm: 'aes-256-gcm',\n            iv: encryptedPayload.iv,\n            tag: encryptedPayload.tag,\n          },\n          originalMimeType: report.mimeType || 'application/pdf',\n        },\n      },\n    });\n\n    await createAuditEvent({\n      reportId,\n      userId: user.id,\n      eventType: AuditEventType.PDF_UPLOADED,\n      eventDescription: 'PDF file uploaded to Vercel Blob',\n      metadata: {\n        blobUrl: blob.url,\n        blobPath: blob.pathname,\n      },\n    });\n\n    return NextResponse.json({\n      success: true,\n      reportId: report.id,\n      blobUrl: blob.url,\n    });\n  } catch (error) {\n    console.error('‚ùå Upload error:', error);\n    return NextResponse.json(\n      {\n        error: 'Failed to upload file',\n        details: error instanceof Error ? error.message : 'Unknown error',\n      },\n      { status: 500 }\n    );\n  }\n}\n","truncated":false,"size":3342},{"path":"app/api/reports/presign/route.ts","content":"/**\n * API Route: POST /api/reports/presign\n * Creates a presigned upload URL using Vercel Blob\n * Validates consent before allowing upload\n */\n\nimport { NextRequest, NextResponse } from 'next/server';\nimport { getServerSession } from 'next-auth/next';\nimport { authOptions } from '@/lib/auth';\nimport { prisma } from '@/lib/prisma';\nimport { put } from '@vercel/blob';\nimport { createAuditEvent } from '@/lib/audit';\nimport { AuditEventType } from '@prisma/client';\nimport { hashPasswordForVerification } from '@/lib/encryption';\n\nconst MAX_UPLOAD_MB = parseInt(process.env.MAX_UPLOAD_MB || '25', 10);\nconst MAX_UPLOAD_BYTES = MAX_UPLOAD_MB * 1024 * 1024;\n\nexport async function POST(request: NextRequest) {\n  try {\n    // Check authentication\n    const session = await getServerSession(authOptions);\n    if (!session?.user?.email) {\n      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });\n    }\n\n    const user = await prisma.user.findUnique({\n      where: { email: session.user.email },\n    });\n\n    if (!user) {\n      return NextResponse.json({ error: 'User not found' }, { status: 404 });\n    }\n\n    // Parse request body\n    const body = await request.json();\n    const {\n      fileName,\n      fileSize,\n      isPasswordProtected,\n      password,\n      decryptionConsent,\n      passwordConsent,\n      retentionConsent,\n    } = body;\n\n    // Validate required fields\n    if (!fileName || !fileSize) {\n      return NextResponse.json(\n        { error: 'File name and size are required' },\n        { status: 400 }\n      );\n    }\n\n    // Validate file type\n    if (!fileName.toLowerCase().endsWith('.pdf')) {\n      return NextResponse.json(\n        { error: 'Only PDF files are allowed' },\n        { status: 400 }\n      );\n    }\n\n    // Validate file size\n    if (fileSize > MAX_UPLOAD_BYTES) {\n      return NextResponse.json(\n        { error: `File size must be less than ${MAX_UPLOAD_MB}MB` },\n        { status: 400 }\n      );\n    }\n\n    // Validate consent (required for password-protected PDFs)\n    if (isPasswordProtected) {\n      if (!decryptionConsent || !passwordConsent) {\n        return NextResponse.json(\n          { error: 'Consent is required for password-protected PDFs' },\n          { status: 400 }\n        );\n      }\n\n      if (!password) {\n        return NextResponse.json(\n          { error: 'Password is required for password-protected PDFs' },\n          { status: 400 }\n        );\n      }\n    }\n\n    // Create consent record\n    const consentText = `I authorize Helfi to decrypt my uploaded PDF using the password I provide, only once, to extract my laboratory test results for analysis within my account. I understand Helfi will not store my password and will permanently delete the original PDF after extraction unless I choose to retain it.`;\n\n    const consentRecord = await prisma.consentRecord.create({\n      data: {\n        userId: user.id,\n        consentType: 'PDF_DECRYPTION',\n        consentText,\n        decryptionConsent: decryptionConsent || false,\n        passwordConsent: passwordConsent || false,\n        retentionConsent: retentionConsent || false,\n        ipAddress: request.headers.get('x-forwarded-for') || request.headers.get('x-real-ip') || undefined,\n        userAgent: request.headers.get('user-agent') || undefined,\n      },\n    });\n\n    // Hash password for verification (ephemeral - not stored)\n    let passwordHash: string | null = null;\n    if (isPasswordProtected && password) {\n      const hashResult = await hashPasswordForVerification(password);\n      passwordHash = `${hashResult.hash}:${hashResult.salt}`;\n    }\n\n    // Create report record\n    const reportId = `report_${Date.now()}_${Math.random().toString(36).substring(7)}`;\n    const blobPath = `reports/${user.id}/${reportId}/${encodeURIComponent(fileName)}`;\n\n    const report = await prisma.report.create({\n      data: {\n        id: reportId,\n        userId: user.id,\n        originalFileName: fileName,\n        s3Key: blobPath, // Using s3Key field to store blob path for compatibility\n        fileSize,\n        mimeType: 'application/pdf',\n        status: 'PENDING',\n        isPasswordProtected: isPasswordProtected || false,\n        passwordHash,\n        retainOriginal: retentionConsent || false,\n        consentRecordId: consentRecord.id,\n      },\n    });\n\n    // Log audit event\n    await createAuditEvent({\n      reportId: report.id,\n      userId: user.id,\n      eventType: AuditEventType.PDF_UPLOADED,\n      eventDescription: `User uploaded PDF: ${fileName}`,\n      metadata: {\n        fileName,\n        fileSize,\n        isPasswordProtected,\n        retentionConsent,\n      },\n      ipAddress: request.headers.get('x-forwarded-for') || request.headers.get('x-real-ip') || undefined,\n      userAgent: request.headers.get('user-agent') || undefined,\n    });\n\n    await createAuditEvent({\n      reportId: report.id,\n      userId: user.id,\n      eventType: AuditEventType.CONSENT_GRANTED,\n      eventDescription: 'User granted consent for PDF processing',\n      metadata: {\n        consentRecordId: consentRecord.id,\n        decryptionConsent,\n        passwordConsent,\n        retentionConsent,\n      },\n    });\n\n    // Return report ID - the actual upload will happen in the process route\n    // Vercel Blob doesn't support presigned URLs the same way S3 does\n    // Instead, we'll upload directly in the process route\n    return NextResponse.json({\n      success: true,\n      reportId: report.id,\n      blobPath,\n      message: 'Report record created. Upload file to /api/reports/[id]/upload endpoint.',\n    });\n  } catch (error) {\n    console.error('‚ùå Presign upload error:', error);\n    return NextResponse.json(\n      {\n        error: 'Failed to create upload record',\n        details: error instanceof Error ? error.message : 'Unknown error',\n      },\n      { status: 500 }\n    );\n  }\n}\n","truncated":false,"size":5840},{"path":"app/api/reports/weekly/list/route.ts","content":"import { NextResponse } from 'next/server'\n\nexport async function GET(request: Request) {\n  const url = new URL(request.url)\n  const preview = url.searchParams.get('preview') === '1'\n  const enabled = process.env.NEXT_PUBLIC_REPORTS_ENABLED === 'true'\n  if (!enabled && !preview) {\n    return NextResponse.json({ enabled: false, reports: [] }, { status: 200 })\n  }\n\n  // Mock weekly reports list\n  const reports = [\n    { id: 'w1', weekStart: '2025-08-25', summary: 'Energy improved; hydration low; magnesium helpful', createdAt: new Date().toISOString() },\n  ]\n\n  return NextResponse.json({ enabled: true, reports, preview }, { status: 200 })\n}\n\n\n","truncated":false,"size":648},{"path":"app/api/support/inquiry/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport crypto from 'crypto'\nimport { prisma } from '@/lib/prisma'\nimport { buildSupportFeedbackPrompt, processSupportTicketAutoReply, sendSupportFeedbackEmail, sendSupportTranscriptEmail } from '@/lib/support-automation'\n\nfunction guestTokenPrefix(token: string) {\n  return `guest:${token}`\n}\n\nfunction normalizeEmail(email: string) {\n  return email.trim().toLowerCase()\n}\n\nexport async function GET(request: NextRequest) {\n  const { searchParams } = new URL(request.url)\n  const ticketId = String(searchParams.get('ticketId') || '').trim()\n  const token = String(searchParams.get('token') || '').trim()\n  if (!ticketId || !token) {\n    return NextResponse.json({ error: 'Missing ticketId or token' }, { status: 400 })\n  }\n\n  const ticket = await prisma.supportTicket.findFirst({\n    where: {\n      id: ticketId,\n      externalMessageId: guestTokenPrefix(token),\n    },\n    include: {\n      responses: { orderBy: { createdAt: 'asc' } },\n    },\n  })\n\n  if (!ticket) {\n    return NextResponse.json({ error: 'Ticket not found' }, { status: 404 })\n  }\n\n  return NextResponse.json({ ticket })\n}\n\nexport async function POST(request: NextRequest) {\n  const body = await request.json().catch(() => ({}))\n  const action = String(body?.action || '').trim()\n\n  if (action === 'create') {\n    const name = String(body?.name || '').trim()\n    const email = normalizeEmail(String(body?.email || ''))\n    const message = String(body?.message || '').trim()\n\n    if (!email || !message) {\n      return NextResponse.json({ error: 'Name, email, and message are required' }, { status: 400 })\n    }\n\n    const token = crypto.randomBytes(12).toString('hex')\n    const ticket = await prisma.supportTicket.create({\n      data: {\n        subject: 'Website inquiry',\n        message,\n        userEmail: email,\n        userName: name || undefined,\n        status: 'OPEN',\n        priority: 'LOW',\n        category: 'GENERAL',\n        externalMessageId: guestTokenPrefix(token),\n      },\n      include: { responses: { orderBy: { createdAt: 'asc' } } },\n    })\n\n    try {\n      await processSupportTicketAutoReply({\n        ticketId: ticket.id,\n        latestUserMessage: message,\n        source: 'web_chat',\n      })\n    } catch (aiError) {\n      console.error('ü§ñ [SUPPORT AI] Failed to auto-reply to inquiry chat:', aiError)\n    }\n\n    const updatedTicket = await prisma.supportTicket.findUnique({\n      where: { id: ticket.id },\n      include: { responses: { orderBy: { createdAt: 'asc' } } },\n    })\n\n    return NextResponse.json({ ticket: updatedTicket, token })\n  }\n\n  if (action === 'add_response') {\n    const ticketId = String(body?.ticketId || '').trim()\n    const token = String(body?.token || '').trim()\n    const message = String(body?.message || '').trim()\n    if (!ticketId || !token || !message) {\n      return NextResponse.json({ error: 'ticketId, token, and message are required' }, { status: 400 })\n    }\n\n    const ticket = await prisma.supportTicket.findFirst({\n      where: {\n        id: ticketId,\n        externalMessageId: guestTokenPrefix(token),\n      },\n    })\n    if (!ticket) {\n      return NextResponse.json({ error: 'Ticket not found' }, { status: 404 })\n    }\n\n    await prisma.ticketResponse.create({\n      data: {\n        ticketId,\n        message,\n        isAdminResponse: false,\n        userEmail: ticket.userEmail,\n      },\n    })\n\n    await prisma.supportTicket.update({\n      where: { id: ticketId },\n      data: {\n        status: 'AWAITING_RESPONSE',\n        updatedAt: new Date(),\n      },\n    })\n\n    try {\n      await processSupportTicketAutoReply({\n        ticketId,\n        latestUserMessage: message,\n        source: 'web_chat',\n      })\n    } catch (aiError) {\n      console.error('ü§ñ [SUPPORT AI] Failed to auto-reply to inquiry message:', aiError)\n    }\n\n    const updatedTicket = await prisma.supportTicket.findUnique({\n      where: { id: ticketId },\n      include: { responses: { orderBy: { createdAt: 'asc' } } },\n    })\n\n    return NextResponse.json({ ticket: updatedTicket })\n  }\n\n  if (action === 'end_chat') {\n    const ticketId = String(body?.ticketId || '').trim()\n    const token = String(body?.token || '').trim()\n    if (!ticketId || !token) {\n      return NextResponse.json({ error: 'ticketId and token are required' }, { status: 400 })\n    }\n\n    const ticket = await prisma.supportTicket.findFirst({\n      where: {\n        id: ticketId,\n        externalMessageId: guestTokenPrefix(token),\n      },\n      include: { responses: { orderBy: { createdAt: 'asc' } } },\n    })\n    if (!ticket) {\n      return NextResponse.json({ error: 'Ticket not found' }, { status: 404 })\n    }\n\n    const feedbackPrompt = buildSupportFeedbackPrompt(ticket.userName)\n    const hasFeedbackPrompt = ticket.responses?.some((response) => response.isAdminResponse && response.message?.includes('rate your support experience'))\n    if (!hasFeedbackPrompt) {\n      await prisma.ticketResponse.create({\n        data: {\n          ticketId: ticket.id,\n          message: feedbackPrompt,\n          isAdminResponse: true,\n          adminId: null,\n        },\n      })\n    }\n\n    await prisma.supportTicket.update({\n      where: { id: ticket.id },\n      data: {\n        status: 'RESOLVED',\n        updatedAt: new Date(),\n      },\n    })\n\n    try {\n      await sendSupportTranscriptEmail(ticket.id)\n    } catch (emailError) {\n      console.error('üìß [SUPPORT TRANSCRIPT] Failed to send inquiry transcript:', emailError)\n    }\n\n    const updatedTicket = await prisma.supportTicket.findUnique({\n      where: { id: ticket.id },\n      include: { responses: { orderBy: { createdAt: 'asc' } } },\n    })\n\n    return NextResponse.json({ ticket: updatedTicket })\n  }\n\n  if (action === 'submit_feedback') {\n    const ticketId = String(body?.ticketId || '').trim()\n    const token = String(body?.token || '').trim()\n    const rating = Number(body?.rating || 0)\n    const comment = String(body?.comment || '').trim()\n    if (!ticketId || !token) {\n      return NextResponse.json({ error: 'ticketId and token are required' }, { status: 400 })\n    }\n    if (!Number.isFinite(rating) || rating < 1 || rating > 5) {\n      return NextResponse.json({ error: 'rating must be between 1 and 5' }, { status: 400 })\n    }\n\n    const ticket = await prisma.supportTicket.findFirst({\n      where: {\n        id: ticketId,\n        externalMessageId: guestTokenPrefix(token),\n      },\n    })\n    if (!ticket) {\n      return NextResponse.json({ error: 'Ticket not found' }, { status: 404 })\n    }\n\n    const feedbackMessage = [\n      `[FEEDBACK] Rating: ${rating}/5`,\n      comment ? `Comment: ${comment}` : 'Comment: (none)',\n    ].join('\\n')\n\n    await prisma.ticketResponse.create({\n      data: {\n        ticketId,\n        message: feedbackMessage,\n        isAdminResponse: false,\n        userEmail: ticket.userEmail,\n      },\n    })\n\n    await prisma.supportTicket.update({\n      where: { id: ticketId },\n      data: {\n        status: 'CLOSED',\n        updatedAt: new Date(),\n      },\n    })\n\n    try {\n      await sendSupportFeedbackEmail({ ticketId, rating, comment })\n    } catch (emailError) {\n      console.error('üìß [SUPPORT FEEDBACK] Failed to send inquiry feedback email:', emailError)\n    }\n\n    const updatedTicket = await prisma.supportTicket.findUnique({\n      where: { id: ticketId },\n      include: { responses: { orderBy: { createdAt: 'asc' } } },\n    })\n\n    return NextResponse.json({ ticket: updatedTicket })\n  }\n\n  return NextResponse.json({ error: 'Invalid action' }, { status: 400 })\n}\n\n","truncated":false,"size":7546},{"path":"app/api/support/inquiry/uploads/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { put } from '@vercel/blob'\nimport { prisma } from '@/lib/prisma'\n\nconst MAX_UPLOAD_BYTES = 15 * 1024 * 1024\nconst ALLOWED_TYPES = new Set([\n  'image/jpeg',\n  'image/png',\n  'image/webp',\n  'image/gif',\n  'application/pdf',\n  'application/msword',\n  'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n])\n\nfunction sanitizeFilename(name: string) {\n  return name.replace(/[^a-zA-Z0-9._-]/g, '_')\n}\n\nfunction guestTokenPrefix(token: string) {\n  return `guest:${token}`\n}\n\nexport async function POST(request: NextRequest) {\n  if (!process.env.BLOB_READ_WRITE_TOKEN) {\n    return NextResponse.json({ error: 'Upload system not configured' }, { status: 503 })\n  }\n\n  const formData = await request.formData().catch(() => null)\n  if (!formData) {\n    return NextResponse.json({ error: 'Invalid upload data' }, { status: 400 })\n  }\n\n  const ticketId = String(formData.get('ticketId') || '').trim()\n  const token = String(formData.get('token') || '').trim()\n  if (!ticketId || !token) {\n    return NextResponse.json({ error: 'Missing ticketId or token' }, { status: 400 })\n  }\n\n  const ticket = await prisma.supportTicket.findFirst({\n    where: { id: ticketId, externalMessageId: guestTokenPrefix(token) },\n  })\n  if (!ticket) {\n    return NextResponse.json({ error: 'Ticket not found' }, { status: 404 })\n  }\n\n  const file = formData.get('file')\n  if (!(file instanceof File)) {\n    return NextResponse.json({ error: 'No file provided' }, { status: 400 })\n  }\n\n  if (!ALLOWED_TYPES.has(file.type)) {\n    return NextResponse.json({ error: 'Unsupported file type' }, { status: 400 })\n  }\n\n  if (file.size > MAX_UPLOAD_BYTES) {\n    return NextResponse.json({ error: 'File is too large (max 15MB)' }, { status: 400 })\n  }\n\n  const buffer = Buffer.from(await file.arrayBuffer())\n  const safeName = sanitizeFilename(file.name || 'upload')\n  const pathname = `support/inquiry/${ticketId}/${Date.now()}-${safeName}`\n\n  const blob = await put(pathname, buffer, {\n    access: 'public',\n    contentType: file.type || 'application/octet-stream',\n  })\n\n  return NextResponse.json({\n    name: file.name || safeName,\n    url: blob.url,\n    type: file.type,\n    size: file.size,\n  })\n}\n\n","truncated":false,"size":2249},{"path":"app/api/support/tickets/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\nimport { TicketCategory, TicketPriority } from '@prisma/client'\nimport { buildSupportFeedbackPrompt, processSupportTicketAutoReply, sendSupportFeedbackEmail, sendSupportTranscriptEmail } from '@/lib/support-automation'\n\nfunction normalizeCategory(value: string | undefined): TicketCategory {\n  const upper = (value || '').toUpperCase()\n  const allowed: TicketCategory[] = ['GENERAL', 'TECHNICAL', 'BILLING', 'ACCOUNT', 'FEATURE_REQUEST', 'BUG_REPORT', 'EMAIL']\n  return allowed.includes(upper as TicketCategory) ? (upper as TicketCategory) : 'GENERAL'\n}\n\nfunction normalizePriority(value: string | undefined): TicketPriority {\n  const upper = (value || '').toUpperCase()\n  const allowed: TicketPriority[] = ['LOW', 'MEDIUM', 'HIGH', 'URGENT']\n  return allowed.includes(upper as TicketPriority) ? (upper as TicketPriority) : 'MEDIUM'\n}\n\nexport async function GET(request: NextRequest) {\n  const session = await getServerSession(authOptions)\n  const email = session?.user?.email\n  if (!email) {\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  }\n\n  const { searchParams } = new URL(request.url)\n  const activeOnly = searchParams.get('activeOnly') !== '0'\n\n  const whereClause: any = { userEmail: email }\n  if (activeOnly) {\n    whereClause.status = { notIn: ['RESOLVED', 'CLOSED'] }\n  }\n\n  const ticket = await prisma.supportTicket.findFirst({\n    where: whereClause,\n    orderBy: { createdAt: 'desc' },\n    include: {\n      responses: { orderBy: { createdAt: 'asc' } },\n    },\n  })\n\n  return NextResponse.json({ ticket })\n}\n\nexport async function POST(request: NextRequest) {\n  const session = await getServerSession(authOptions)\n  const email = session?.user?.email\n  const name = session?.user?.name || ''\n  if (!email) {\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  }\n\n  const body = await request.json().catch(() => ({}))\n  const action = String(body?.action || '').trim()\n  const message = String(body?.message || '').trim()\n\n  if (!message) {\n    return NextResponse.json({ error: 'Message is required' }, { status: 400 })\n  }\n\n  if (action === 'create') {\n    const subject = String(body?.subject || '').trim() || `Support request from ${email}`\n    const category = normalizeCategory(body?.category)\n    const priority = normalizePriority(body?.priority)\n\n    const ticket = await prisma.supportTicket.create({\n      data: {\n        subject,\n        message,\n        userEmail: email,\n        userName: name || undefined,\n        userId: session?.user?.id || null,\n        status: 'OPEN',\n        priority,\n        category,\n      },\n      include: {\n        responses: { orderBy: { createdAt: 'asc' } },\n      },\n    })\n\n    try {\n      await processSupportTicketAutoReply({\n        ticketId: ticket.id,\n        latestUserMessage: message,\n        source: 'app_ticket',\n      })\n    } catch (aiError) {\n      console.error('ü§ñ [SUPPORT AI] Failed to auto-reply to in-app ticket:', aiError)\n    }\n\n    const updatedTicket = await prisma.supportTicket.findUnique({\n      where: { id: ticket.id },\n      include: { responses: { orderBy: { createdAt: 'asc' } } },\n    })\n\n    return NextResponse.json({ ticket: updatedTicket })\n  }\n\n  if (action === 'add_response') {\n    const ticketId = String(body?.ticketId || '').trim()\n    if (!ticketId) {\n      return NextResponse.json({ error: 'ticketId is required' }, { status: 400 })\n    }\n\n    const ticket = await prisma.supportTicket.findFirst({\n      where: { id: ticketId, userEmail: email },\n    })\n    if (!ticket) {\n      return NextResponse.json({ error: 'Ticket not found' }, { status: 404 })\n    }\n\n    await prisma.ticketResponse.create({\n      data: {\n        ticketId,\n        message,\n        isAdminResponse: false,\n        userEmail: email,\n      },\n    })\n\n    await prisma.supportTicket.update({\n      where: { id: ticketId },\n      data: {\n        status: 'AWAITING_RESPONSE',\n        updatedAt: new Date(),\n      },\n    })\n\n    try {\n      await processSupportTicketAutoReply({\n        ticketId,\n        latestUserMessage: message,\n        source: 'app_reply',\n      })\n    } catch (aiError) {\n      console.error('ü§ñ [SUPPORT AI] Failed to auto-reply to in-app reply:', aiError)\n    }\n\n    const updatedTicket = await prisma.supportTicket.findUnique({\n      where: { id: ticketId },\n      include: { responses: { orderBy: { createdAt: 'asc' } } },\n    })\n\n    return NextResponse.json({ ticket: updatedTicket })\n  }\n\n  if (action === 'end_chat') {\n    const ticketId = String(body?.ticketId || '').trim()\n    if (!ticketId) {\n      return NextResponse.json({ error: 'ticketId is required' }, { status: 400 })\n    }\n\n    const ticket = await prisma.supportTicket.findFirst({\n      where: { id: ticketId, userEmail: email },\n      include: { responses: { orderBy: { createdAt: 'asc' } } },\n    })\n    if (!ticket) {\n      return NextResponse.json({ error: 'Ticket not found' }, { status: 404 })\n    }\n\n    const feedbackPrompt = buildSupportFeedbackPrompt(ticket.userName)\n    const hasFeedbackPrompt = ticket.responses?.some((response) => response.isAdminResponse && response.message?.includes('rate your support experience'))\n    if (!hasFeedbackPrompt) {\n      await prisma.ticketResponse.create({\n        data: {\n          ticketId: ticket.id,\n          message: feedbackPrompt,\n          isAdminResponse: true,\n          adminId: null,\n        },\n      })\n    }\n\n    await prisma.supportTicket.update({\n      where: { id: ticket.id },\n      data: {\n        status: 'RESOLVED',\n        updatedAt: new Date(),\n      },\n    })\n\n    try {\n      await sendSupportTranscriptEmail(ticket.id)\n    } catch (emailError) {\n      console.error('üìß [SUPPORT TRANSCRIPT] Failed to send transcript:', emailError)\n    }\n\n    const updatedTicket = await prisma.supportTicket.findUnique({\n      where: { id: ticket.id },\n      include: { responses: { orderBy: { createdAt: 'asc' } } },\n    })\n\n    return NextResponse.json({ ticket: updatedTicket })\n  }\n\n  if (action === 'submit_feedback') {\n    const ticketId = String(body?.ticketId || '').trim()\n    const rating = Number(body?.rating || 0)\n    const comment = String(body?.comment || '').trim()\n    if (!ticketId) {\n      return NextResponse.json({ error: 'ticketId is required' }, { status: 400 })\n    }\n    if (!Number.isFinite(rating) || rating < 1 || rating > 5) {\n      return NextResponse.json({ error: 'rating must be between 1 and 5' }, { status: 400 })\n    }\n\n    const ticket = await prisma.supportTicket.findFirst({\n      where: { id: ticketId, userEmail: email },\n    })\n    if (!ticket) {\n      return NextResponse.json({ error: 'Ticket not found' }, { status: 404 })\n    }\n\n    const feedbackMessage = [\n      `[FEEDBACK] Rating: ${rating}/5`,\n      comment ? `Comment: ${comment}` : 'Comment: (none)',\n    ].join('\\n')\n\n    await prisma.ticketResponse.create({\n      data: {\n        ticketId,\n        message: feedbackMessage,\n        isAdminResponse: false,\n        userEmail: email,\n      },\n    })\n\n    await prisma.supportTicket.update({\n      where: { id: ticketId },\n      data: {\n        status: 'CLOSED',\n        updatedAt: new Date(),\n      },\n    })\n\n    try {\n      await sendSupportFeedbackEmail({ ticketId, rating, comment })\n    } catch (emailError) {\n      console.error('üìß [SUPPORT FEEDBACK] Failed to send feedback email:', emailError)\n    }\n\n    const updatedTicket = await prisma.supportTicket.findUnique({\n      where: { id: ticketId },\n      include: { responses: { orderBy: { createdAt: 'asc' } } },\n    })\n\n    return NextResponse.json({ ticket: updatedTicket })\n  }\n\n  return NextResponse.json({ error: 'Invalid action' }, { status: 400 })\n}\n","truncated":false,"size":7837},{"path":"app/api/support/uploads/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { put } from '@vercel/blob'\nimport { prisma } from '@/lib/prisma'\n\nconst MAX_UPLOAD_BYTES = 15 * 1024 * 1024\nconst ALLOWED_TYPES = new Set([\n  'image/jpeg',\n  'image/png',\n  'image/webp',\n  'image/gif',\n  'application/pdf',\n  'application/msword',\n  'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n])\n\nfunction sanitizeFilename(name: string) {\n  return name.replace(/[^a-zA-Z0-9._-]/g, '_')\n}\n\nexport async function POST(request: NextRequest) {\n  const session = await getServerSession(authOptions)\n  const userId = session?.user?.id\n  if (!userId) {\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  }\n\n  if (!process.env.BLOB_READ_WRITE_TOKEN) {\n    return NextResponse.json({ error: 'Upload system not configured' }, { status: 503 })\n  }\n\n  const formData = await request.formData().catch(() => null)\n  if (!formData) {\n    return NextResponse.json({ error: 'Invalid upload data' }, { status: 400 })\n  }\n\n  const file = formData.get('file')\n  if (!(file instanceof File)) {\n    return NextResponse.json({ error: 'No file provided' }, { status: 400 })\n  }\n\n  if (!ALLOWED_TYPES.has(file.type)) {\n    return NextResponse.json({ error: 'Unsupported file type' }, { status: 400 })\n  }\n\n  if (file.size > MAX_UPLOAD_BYTES) {\n    return NextResponse.json({ error: 'File is too large (max 15MB)' }, { status: 400 })\n  }\n\n  const buffer = Buffer.from(await file.arrayBuffer())\n  const safeName = sanitizeFilename(file.name || 'upload')\n  const pathname = `support/${userId}/${Date.now()}-${safeName}`\n\n  const blob = await put(pathname, buffer, {\n    access: 'public',\n    contentType: file.type || 'application/octet-stream',\n  })\n\n  const fileType = file.type.startsWith('image/') ? 'IMAGE' : 'DOCUMENT'\n  const usage = file.type.startsWith('image/') ? 'OTHER' : 'DOCUMENT'\n\n  const fileRecord = await prisma.file.create({\n    data: {\n      originalName: file.name || safeName,\n      fileName: blob.pathname,\n      fileSize: file.size,\n      mimeType: file.type || 'application/octet-stream',\n      cloudinaryId: blob.pathname,\n      cloudinaryUrl: blob.url,\n      secureUrl: blob.url,\n      uploadedById: userId,\n      fileType,\n      usage,\n      metadata: {\n        storage: 'vercel-blob',\n        blobUrl: blob.url,\n        blobPathname: blob.pathname,\n      },\n    },\n  })\n\n  return NextResponse.json({\n    fileId: fileRecord.id,\n    name: fileRecord.originalName,\n    url: blob.url,\n    type: fileRecord.mimeType,\n    size: fileRecord.fileSize,\n    fileType,\n  })\n}\n","truncated":false,"size":2670},{"path":"app/api/symptoms/history/[id]/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\n\nexport async function DELETE(\n  request: NextRequest,\n  { params }: { params: { id: string } }\n) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.email) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const user = await prisma.user.findUnique({ where: { email: session.user.email } })\n    if (!user) {\n      return NextResponse.json({ error: 'User not found' }, { status: 404 })\n    }\n\n    const analysisId = params.id\n    if (!analysisId) {\n      return NextResponse.json({ error: 'Missing id' }, { status: 400 })\n    }\n\n    const deleted = await prisma.symptomAnalysis.deleteMany({\n      where: { id: analysisId, userId: user.id },\n    })\n\n    if (deleted.count === 0) {\n      return NextResponse.json({ error: 'Not found' }, { status: 404 })\n    }\n\n    return NextResponse.json({ success: true })\n  } catch (error) {\n    console.error('Error deleting symptom history item:', error)\n    return NextResponse.json(\n      {\n        error: 'Failed to delete history item',\n        details: error instanceof Error ? error.message : 'Unknown error',\n      },\n      { status: 500 }\n    )\n  }\n}\n","truncated":false,"size":1351},{"path":"app/api/symptoms/history/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\n\nexport async function GET(request: NextRequest) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.email) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const user = await prisma.user.findUnique({ where: { email: session.user.email } })\n    if (!user) {\n      return NextResponse.json({ error: 'User not found' }, { status: 404 })\n    }\n\n    const analyses = await prisma.symptomAnalysis.findMany({\n      where: { userId: user.id },\n      orderBy: { createdAt: 'desc' },\n      select: {\n        id: true,\n        symptoms: true,\n        duration: true,\n        notes: true,\n        summary: true,\n        analysisText: true,\n        analysisData: true,\n        createdAt: true,\n      },\n    })\n\n    return NextResponse.json({ success: true, history: analyses })\n  } catch (error) {\n    console.error('Error fetching symptom history:', error)\n    return NextResponse.json(\n      {\n        error: 'Failed to fetch symptom history',\n        details: error instanceof Error ? error.message : 'Unknown error',\n      },\n      { status: 500 }\n    )\n  }\n}\n\nexport async function DELETE(request: NextRequest) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.email) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const user = await prisma.user.findUnique({ where: { email: session.user.email } })\n    if (!user) {\n      return NextResponse.json({ error: 'User not found' }, { status: 404 })\n    }\n\n    const deleted = await prisma.symptomAnalysis.deleteMany({ where: { userId: user.id } })\n\n    return NextResponse.json({\n      success: true,\n      message: `Deleted ${deleted.count} analyses`,\n      deletedCount: deleted.count,\n    })\n  } catch (error) {\n    console.error('Error deleting symptom history:', error)\n    return NextResponse.json(\n      {\n        error: 'Failed to delete symptom history',\n        details: error instanceof Error ? error.message : 'Unknown error',\n      },\n      { status: 500 }\n    )\n  }\n}\n","truncated":false,"size":2257},{"path":"app/api/test-vision/route.ts","content":"import { NextRequest, NextResponse } from 'next/server';\nimport OpenAI from 'openai';\nimport { getServerSession } from 'next-auth';\nimport { authOptions } from '@/lib/auth';\nimport { prisma } from '@/lib/prisma';\nimport { put } from '@vercel/blob';\nimport { CreditManager } from '@/lib/credit-system';\nimport { chatCompletionWithCost } from '@/lib/metered-openai';\nimport { logAiUsageEvent } from '@/lib/ai-usage-logger';\nimport { consumeRateLimit } from '@/lib/rate-limit';\nimport { getImageMetadata } from '@/lib/image-metadata';\nimport { encryptBuffer } from '@/lib/file-encryption';\nimport { createSignedFileToken } from '@/lib/signed-file';\nimport { isSubscriptionActive } from '@/lib/subscription-utils';\nimport { logServerCall } from '@/lib/server-call-tracker';\nimport { consumeFreeCredit, hasFreeCredits } from '@/lib/free-credits';\n\nconst RATE_LIMIT_WINDOW_MS = 60_000;\nconst RATE_LIMIT_MAX = 3;\n\nconst contentTypeToExt = (contentType: string) => {\n  if (contentType === 'image/png') return 'png';\n  if (contentType === 'image/webp') return 'webp';\n  if (contentType === 'image/gif') return 'gif';\n  return 'jpg';\n};\n\nfunction getOpenAIClient() {\n  if (!process.env.OPENAI_API_KEY) {\n    return null;\n  }\n  return new OpenAI({ apiKey: process.env.OPENAI_API_KEY });\n}\n\nexport async function POST(req: NextRequest) {\n  try {\n    // Medical image analysis is PREMIUM only\n    const session = await getServerSession(authOptions);\n    if (!session?.user?.email) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n    }\n    const user = await prisma.user.findUnique({\n      where: { email: session.user.email },\n      include: { subscription: true, creditTopUps: true }\n    });\n    if (!user) return NextResponse.json({ error: 'User not found' }, { status: 404 });\n\n    logServerCall({\n      feature: 'medicalImageAnalysis',\n      endpoint: '/api/test-vision',\n      kind: 'analysis',\n    }).catch((error) => {\n      console.error('‚ùå Failed to log medical analysis call:', error);\n    });\n    \n    // PREMIUM/CREDITS/FREE USE GATING\n    const isPremium = isSubscriptionActive(user.subscription);\n    \n    // Check if user has purchased credits (non-expired)\n    const now = new Date();\n    const hasPurchasedCredits = user.creditTopUps.some(\n      (topUp: any) => topUp.expiresAt > now && (topUp.amountCents - topUp.usedCents) > 0\n    );\n    \n    const hasFreeMedicalCredits = await hasFreeCredits(user.id, 'MEDICAL_ANALYSIS');\n    \n    // Allow if: Premium subscription OR has purchased credits OR has free credits remaining\n    if (!isPremium && !hasPurchasedCredits && !hasFreeMedicalCredits) {\n      return NextResponse.json(\n        { \n          error: 'Payment required',\n          message: 'You\\'ve used all your free medical image analyses. Subscribe to a monthly plan or purchase credits to continue.',\n          requiresPayment: true,\n          exhaustedFreeCredits: true,\n        },\n        { status: 402 }\n      );\n    }\n\n    const formData = await req.formData();\n    const imageFile = formData.get('image') as File;\n    const saveToHistoryRaw = String(formData.get('saveToHistory') || '').toLowerCase();\n    const saveToHistory = saveToHistoryRaw === 'true' || saveToHistoryRaw === '1' || saveToHistoryRaw === 'yes';\n\n    if (!imageFile) {\n      return NextResponse.json({ error: 'No image provided' }, { status: 400 });\n    }\n\n    const clientIp = (req.headers.get('x-forwarded-for') || '').split(',')[0]?.trim() || 'unknown';\n    const rateKey = user.id ? `user:${user.id}` : `ip:${clientIp}`;\n    const rateCheck = await consumeRateLimit('medical-image', rateKey, RATE_LIMIT_MAX, RATE_LIMIT_WINDOW_MS);\n    if (!rateCheck.allowed) {\n      const retryAfter = Math.max(1, Math.ceil(rateCheck.retryAfterMs / 1000));\n      return NextResponse.json(\n        { error: 'Too many medical image analyses. Please wait and try again.' },\n        { status: 429, headers: { 'Retry-After': String(retryAfter) } }\n      );\n    }\n\n    // Convert image to base64\n    const imageBuffer = await imageFile.arrayBuffer();\n    const imageBase64 = Buffer.from(imageBuffer).toString('base64');\n    const imageMeta = getImageMetadata(imageBuffer);\n    \n    console.log('Image info:', {\n      name: imageFile.name,\n      type: imageFile.type,\n      size: imageFile.size,\n      base64Length: imageBase64.length\n    });\n\n    // Use OpenAI client (GPT-4o vision) via metered wrapper\n    const openai = getOpenAIClient();\n    if (!openai) {\n      return NextResponse.json({ error: 'OpenAI API key not configured' }, { status: 500 });\n    }\n    \n    // Immediate pre-charge (2 credits) before calling the model (skip for free trial)\n    const allowViaFreeUse = !isPremium && !hasPurchasedCredits && hasFreeMedicalCredits;\n    let prechargedCents = 0;\n    if (!allowViaFreeUse) {\n      try {\n        const cm = new CreditManager(user.id);\n        const immediate = 2; // medical image analysis typical cost (credits)\n        const okPre = await cm.chargeCents(immediate);\n        if (!okPre) {\n          return NextResponse.json({ error: 'Insufficient credits' }, { status: 402 });\n        }\n        prechargedCents = immediate;\n      } catch {\n        return NextResponse.json({ error: 'Billing error' }, { status: 402 });\n      }\n    }\n\n    const wrapped = await chatCompletionWithCost(openai, {\n      model: \"gpt-4o\",\n      messages: [\n        {\n          role: \"system\",\n          content: [\n            {\n              type: \"text\",\n              text:\n                \"You are a cautious medical image assistant helping users understand visible health concerns from photos. \" +\n                \"You are talking to people without medical training, not doctors, so everything must be explained in simple, everyday language. \" +\n                \"Avoid medical jargon and Latin terms unless you immediately explain them in plain words (for example: 'benign (non-cancerous) growth'). \" +\n                \"Treat every image you receive here as a medical or health-related image (for example: skin conditions, rashes, hives, eczema, psoriasis, acne, rosacea, vitiligo, fungal infections, \" +\n                \"bacterial infections, viral rashes, allergic reactions, burns, cuts, bruises, wounds, surgical scars, ulcers, bedsores, bites, stings, nail changes, eye redness, swelling, jaundice, \" +\n                \"moles, lesions, lumps, growths, discolorations, varicose veins, swelling in joints, deformities, and medical imaging such as X-rays, CT scans, MRIs, and ultrasounds). \" +\n                \"Focus ONLY on the medically relevant parts of the image and ignore backgrounds, furniture, or unrelated objects.\\n\\n\" +\n                \"Your response must ALWAYS be structured in this exact format:\\n\\n\" +\n                \"1) WHAT I SEE MEDICALLY:\\n\" +\n                \"- Use simple, clear language to describe what you see that is medically relevant (location, size relative to body part, shape, color, borders, surface texture, any swelling, redness, discharge, or other visible features).\\n\\n\" +\n                \"2) POSSIBLE EXPLANATIONS (NOT A DIAGNOSIS):\\n\" +\n                \"- List 2‚Äì4 possible explanations for what this could be (for example: eczema flare, contact dermatitis, fungal infection, acne breakout, infected wound, benign mole, suspicious mole, etc.).\\n\" +\n                \"- Clearly state that these are possibilities only and NOT a confirmed diagnosis.\\n\\n\" +\n                \"3) RED-FLAG SIGNS TO WATCH FOR:\\n\" +\n                \"- Explain which visible features in this image are concerning or could be red flags (irregular borders, very dark or changing moles, rapidly growing lumps, spreading redness, pus, black areas in a wound, severe swelling, etc.).\\n\" +\n                \"- If the image does not show strong red-flag signs, say that clearly but still mention what would be worrying if it appeared later.\\n\\n\" +\n                \"4) WHAT TO DO NEXT:\\n\" +\n                \"- Explain practical next steps in plain language: when it might be okay to monitor at home, when to book a routine doctor or dermatologist appointment, and when to seek urgent or emergency care.\\n\" +\n                \"- Be specific about timeframes (for example: ‚Äúwithin the next few days‚Äù, ‚Äúas soon as possible‚Äù, ‚Äúgo to emergency/ER now if‚Ä¶‚Äù).\\n\\n\" +\n                \"After you finish sections 1‚Äì4 above, append a compact JSON block between <STRUCTURED_JSON> and </STRUCTURED_JSON> with this exact shape:\\n\" +\n                \"<STRUCTURED_JSON>{\\\"summary\\\":\\\"string\\\",\\\"possibleCauses\\\":[{\\\"name\\\":\\\"string\\\",\\\"whyLikely\\\":\\\"string\\\",\\\"confidence\\\":\\\"low|medium|high\\\"}],\\\"redFlags\\\":[\\\"string\\\"],\\\"nextSteps\\\":[\\\"string\\\"],\\\"disclaimer\\\":\\\"string\\\"}</STRUCTURED_JSON>\\n\" +\n                \"Rules for the JSON:\\n\" +\n                \"- \\\"summary\\\": 1‚Äì3 plain-language sentences describing what the image most likely shows overall.\\n\" +\n                \"- \\\"possibleCauses\\\": 2‚Äì4 conditions ordered from most to least likely. The first item should be tagged \\\"high\\\" confidence, any middle items \\\"medium\\\", and the last item \\\"low\\\" when there is more than one.\\n\" +\n                \"- \\\"whyLikely\\\": 2‚Äì4 short sentences written for a non-medical person. First, briefly explain in plain language what this condition usually is and how it commonly looks. Then explain why THIS specific image could match it (visible features such as color, shape, borders, distribution, etc.), and very briefly what it usually means for the person (for example how serious it typically is or how it is commonly managed).\\n\" +\n                \"- Keep the \\\"name\\\" field as the usual medical term, but keep \\\"whyLikely\\\" free of unexplained jargon; immediately explain any medical word in brackets if you must mention it.\\n\" +\n                \"- \\\"redFlags\\\": short bullet-style strings describing dangerous or urgent features related to what is seen.\\n\" +\n                \"- \\\"nextSteps\\\": practical actions the user can take now (self-care, routine review, urgent care/emergency when needed).\\n\" +\n                \"- \\\"disclaimer\\\": clear reminder that this is information only and not a diagnosis or a replacement for a real doctor.\\n\\n\" +\n                \"Important safety rules:\\n\" +\n                \"- Do NOT give a formal diagnosis or claim certainty. Always frame explanations as possibilities based on what can be seen.\\n\" +\n                \"- Do NOT tell the user that they do not need a doctor. Instead, explain when medical review would be sensible and reassuring.\\n\" +\n                \"- Always remind the user that this analysis is for information only and does not replace a real doctor‚Äôs examination.\\n\" +\n                \"- If the image does not appear to contain anything medically relevant, say that clearly and advise the user to consult a healthcare professional if they are worried.\"\n            }\n          ]\n        },\n        {\n          role: \"user\",\n          content: [\n            {\n              type: \"text\",\n              text:\n                \"This image was uploaded in a Medical Image Analyzer inside a health app. \" +\n                \"Please analyze any visible medical or health-related issues in the image following the required structure.\"\n            },\n            {\n              type: \"image_url\",\n              image_url: {\n                url: `data:${imageFile.type};base64,${imageBase64}`,\n                detail: \"high\"\n              }\n            }\n          ]\n        }\n      ],\n      max_tokens: 900,\n      temperature: 0.15\n    } as any);\n\n    logAiUsageEvent({\n      feature: 'medical-image:analysis',\n      scanId: `medical-${Date.now()}`,\n      userId: user.id || null,\n      userLabel: user.email || null,\n      model: \"gpt-4o\",\n      promptTokens: wrapped.promptTokens,\n      completionTokens: wrapped.completionTokens,\n      costCents: wrapped.costCents,\n      image: {\n        width: imageMeta.width,\n        height: imageMeta.height,\n        bytes: imageBuffer.byteLength,\n        mime: imageFile.type || null,\n      },\n      endpoint: '/api/test-vision',\n      success: true,\n    }).catch(() => {});\n\n    const analysisRaw = wrapped.completion.choices[0]?.message?.content || '';\n\n    // Extract optional structured JSON block (mirrors symptom analyzer pattern)\n    let structured: any = null;\n    let cleanAnalysis = analysisRaw;\n    try {\n      const m = analysisRaw.match(/<STRUCTURED_JSON>([\\s\\S]*?)<\\/STRUCTURED_JSON>/i);\n      if (m && m[1]) {\n        structured = JSON.parse(m[1]);\n        cleanAnalysis = analysisRaw.replace(m[0], '').trim();\n      }\n    } catch (err) {\n      console.warn('Failed to parse medical STRUCTURED_JSON block:', err);\n    }\n    \n    // Charge wallet remainder (skip if allowed via free use)\n    if (!allowViaFreeUse) {\n      const cm = new CreditManager(user.id);\n      const remainder = Math.max(0, wrapped.costCents - prechargedCents);\n      const ok = await cm.chargeCents(remainder);\n      if (!ok) {\n        return NextResponse.json({ error: 'Insufficient credits' }, { status: 402 });\n      }\n    }\n    \n    // Consume free credit if this was a free use\n    if (allowViaFreeUse) {\n      await consumeFreeCredit(user.id, 'MEDICAL_ANALYSIS');\n    }\n    \n    // Update monthly counter (for all users, not just premium)\n    await prisma.user.update({\n      where: { id: user.id },\n      data: {\n        monthlyMedicalImageAnalysisUsed: { increment: 1 },\n      } as any,\n    });\n    \n    console.log('OpenAI Response:', {\n      usage: {\n        prompt: wrapped.promptTokens,\n        completion: wrapped.completionTokens,\n      },\n      analysis: cleanAnalysis.substring(0, 100) + '...'\n    });\n\n    const resp: any = {\n      success: true,\n      analysis: cleanAnalysis,\n      debug: {\n        imageType: imageFile.type,\n        imageSize: imageFile.size,\n        tokensUsed: {\n          prompt: wrapped.promptTokens,\n          completion: wrapped.completionTokens,\n        }\n      }\n    };\n\n    if (structured && typeof structured === 'object') {\n      resp.summary = structured.summary || null;\n      resp.possibleCauses = Array.isArray(structured.possibleCauses) ? structured.possibleCauses : [];\n      resp.redFlags = Array.isArray(structured.redFlags) ? structured.redFlags : [];\n      resp.nextSteps = Array.isArray(structured.nextSteps) ? structured.nextSteps : [];\n      resp.disclaimer =\n        structured.disclaimer ||\n        'This analysis is for information only and does not replace a real doctor‚Äôs examination. If symptoms worsen or you are worried, contact a licensed medical professional or emergency services.';\n    } else {\n      const refusalPatterns = [\n        /i['‚Äô]m sorry[, ]+i can['‚Äô]t assist/i,\n        /i['‚Äô]m sorry[, ]+i cannot assist/i,\n        /i can['‚Äô]t assist with that/i,\n        /i cannot assist with that/i,\n        /i can['‚Äô]t help with that/i,\n        /i cannot help with that/i,\n        /i can['‚Äô]t help with this/i,\n        /i cannot help with this/i,\n        /unable to assist/i,\n        /not able to help/i,\n      ];\n      const refusal =\n        typeof cleanAnalysis === 'string' &&\n        refusalPatterns.some((pattern) => pattern.test(cleanAnalysis));\n\n      if (refusal) {\n        resp.summary =\n          'This particular photo looks like something our AI provider is not allowed to analyse directly. Because images like this can sometimes indicate serious conditions, it is safer to have it checked in person.';\n        resp.possibleCauses = [];\n        resp.redFlags = [\n          'A new or changing mole or spot on the skin, especially one that looks very dark, irregular, or different from your other moles.',\n          'Any spot that is bleeding, crusting, painful, very itchy, or growing quickly.',\n        ];\n        resp.nextSteps = [\n          'Book an urgent appointment with a GP or dermatologist and show them this exact spot and photo.',\n          'Seek same-day or emergency care if the area is rapidly changing, very painful, or you feel generally unwell.',\n        ];\n        resp.disclaimer =\n          'Because this image could represent a serious condition, the AI is not allowed to give a guess. This is not a diagnosis. Please have a licensed doctor or dermatologist examine the area as soon as you can.';\n        // Avoid showing the raw refusal sentence in the UI.\n        resp.analysis = '';\n      } else {\n        // Always include at least a basic disclaimer\n        resp.disclaimer =\n          'This analysis is for information only and does not replace a real doctor‚Äôs examination. If symptoms worsen or you are worried, contact a licensed medical professional or emergency services.';\n      }\n    }\n\n    let historySaved = false;\n    let historyItem: any = null;\n    let historyError: string | null = null;\n\n    if (saveToHistory) {\n      try {\n        if (!process.env.BLOB_READ_WRITE_TOKEN) {\n          throw new Error('Image storage is not configured');\n        }\n\n        const ext = contentTypeToExt(imageFile.type);\n        const filename = `${Date.now()}.${ext}`;\n        const pathname = `medical-images/${user.id}/${filename}`;\n        const buffer = Buffer.from(imageBuffer);\n        const encryptedPayload = encryptBuffer(buffer);\n        const blob = await put(pathname, encryptedPayload.encrypted, {\n          access: 'public',\n          contentType: 'application/octet-stream',\n          addRandomSuffix: true,\n        });\n\n        const fileRecord = await prisma.file.create({\n          data: {\n            originalName: imageFile.name,\n            fileName: blob.pathname,\n            fileSize: imageFile.size,\n            mimeType: imageFile.type,\n            cloudinaryId: blob.pathname,\n            cloudinaryUrl: blob.url,\n            secureUrl: blob.url,\n            uploadedById: user.id,\n            fileType: 'IMAGE',\n            usage: 'MEDICAL_IMAGE',\n            isPublic: false,\n            metadata: {\n              storage: 'vercel-blob',\n              blobPathname: blob.pathname,\n              blobUrl: blob.url,\n              width: imageMeta.width ?? null,\n              height: imageMeta.height ?? null,\n              encrypted: true,\n              encryption: {\n                algorithm: 'aes-256-gcm',\n                iv: encryptedPayload.iv,\n                tag: encryptedPayload.tag,\n              },\n              format: ext,\n              originalSize: imageFile.size,\n            },\n          },\n        });\n\n        const analysisData = {\n          summary: resp.summary ?? null,\n          possibleCauses: Array.isArray(resp.possibleCauses) ? resp.possibleCauses : [],\n          redFlags: Array.isArray(resp.redFlags) ? resp.redFlags : [],\n          nextSteps: Array.isArray(resp.nextSteps) ? resp.nextSteps : [],\n          disclaimer: resp.disclaimer ?? null,\n        };\n\n        const saved = await prisma.medicalImageAnalysis.create({\n          data: {\n            userId: user.id,\n            imageFileId: fileRecord.id,\n            summary: resp.summary ?? null,\n            analysisText: resp.analysis ?? null,\n            analysisData,\n          },\n        });\n\n        historySaved = true;\n        historyItem = {\n          id: saved.id,\n          summary: saved.summary,\n          analysisText: saved.analysisText,\n          analysisData: saved.analysisData,\n          createdAt: saved.createdAt,\n          imageUrl: `/api/medical-images/file?token=${encodeURIComponent(\n            createSignedFileToken({ fileId: fileRecord.id, userId: user.id, usage: 'MEDICAL_IMAGE' })\n          )}`,\n        };\n      } catch (err) {\n        console.warn('Failed to save medical image history:', err);\n        historyError = err instanceof Error ? err.message : 'Failed to save history';\n      }\n    }\n\n    resp.historySaved = historySaved;\n    if (historyItem) resp.historyItem = historyItem;\n    if (historyError) resp.historyError = historyError;\n\n    return NextResponse.json(resp);\n\n  } catch (error) {\n    console.error('Vision API Error:', error);\n\n    const anyErr = error as any;\n    const status = anyErr?.status ?? anyErr?.statusCode ?? anyErr?.response?.status;\n    const message = String(anyErr?.message || '');\n    const isQuotaOrRateLimit =\n      status === 429 ||\n      /exceeded your current quota/i.test(message) ||\n      /rate limit/i.test(message);\n\n    if (isQuotaOrRateLimit) {\n      return NextResponse.json(\n        {\n          success: false,\n          error:\n            'Our AI image analysis service is temporarily being limited by the AI provider. Your analysis could not be completed right now. Please wait a short time and try again.',\n        },\n        { status: 429 }\n      );\n    }\n\n    return NextResponse.json(\n      {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error',\n        debug: process.env.NODE_ENV === 'development' ? error : undefined,\n      },\n      { status: 500 }\n    );\n  }\n} \n","truncated":false,"size":20831},{"path":"app/api/tickets/webhook/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\nimport { processSupportTicketAutoReply } from '@/lib/support-automation'\n\nexport async function POST(request: NextRequest) {\n  try {\n    // This webhook will receive emails from your email service\n    // For now, this is a simple implementation that can be extended\n    const emailData = await request.json()\n\n    // Extract email information\n    const {\n      from,\n      to,\n      subject,\n      text,\n      html,\n      messageId,\n      date\n    } = emailData\n\n    // Parse sender information\n    const senderEmail = typeof from === 'string' ? from : from?.email || from?.address\n    const senderName = typeof from === 'string' ? from : from?.name || senderEmail\n\n    if (senderEmail && senderEmail.toLowerCase() === 'support@helfi.ai') {\n      return NextResponse.json({ success: true, message: 'Ignored support outbound email' })\n    }\n\n    // Check if this is a reply to an existing ticket\n    const existingTicket = await prisma.supportTicket.findFirst({\n      where: {\n        OR: [\n          { userEmail: senderEmail },\n          { externalMessageId: messageId }\n        ]\n      },\n      orderBy: { createdAt: 'desc' }\n    })\n\n    if (existingTicket && subject.toLowerCase().includes('re:')) {\n      // This is a reply to an existing ticket\n      await prisma.ticketResponse.create({\n        data: {\n          ticketId: existingTicket.id,\n          message: text || html,\n          isAdminResponse: false,\n          userEmail: senderEmail\n        }\n      })\n\n      // Update ticket status\n      await prisma.supportTicket.update({\n        where: { id: existingTicket.id },\n        data: { \n          status: 'AWAITING_RESPONSE',\n          updatedAt: new Date()\n        }\n      })\n\n      try {\n        await processSupportTicketAutoReply({\n          ticketId: existingTicket.id,\n          latestUserMessage: text || html,\n          source: 'email_reply',\n        })\n      } catch (aiError) {\n        console.error('ü§ñ [SUPPORT AI] Failed to auto-reply to email reply:', aiError)\n      }\n\n      return NextResponse.json({ \n        success: true, \n        message: 'Reply added to existing ticket',\n        ticketId: existingTicket.id \n      })\n    } else {\n      // Create new ticket\n      const newTicket = await prisma.supportTicket.create({\n        data: {\n          subject: subject || 'No Subject',\n          message: text || html || 'No message content',\n          userEmail: senderEmail,\n          userName: senderName,\n          status: 'OPEN',\n          priority: 'MEDIUM',\n          category: 'EMAIL',\n          externalMessageId: messageId\n        }\n      })\n\n      try {\n        await processSupportTicketAutoReply({\n          ticketId: newTicket.id,\n          latestUserMessage: text || html,\n          source: 'email_ticket',\n        })\n      } catch (aiError) {\n        console.error('ü§ñ [SUPPORT AI] Failed to auto-reply to email ticket:', aiError)\n      }\n\n      return NextResponse.json({ \n        success: true, \n        message: 'New ticket created',\n        ticketId: newTicket.id \n      })\n    }\n\n  } catch (error: any) {\n    console.error('‚ùå Webhook error:', error)\n    return NextResponse.json(\n      { error: 'Webhook processing failed: ' + error.message },\n      { status: 500 }\n    )\n  }\n} \n","truncated":false,"size":3324},{"path":"app/api/unsubscribe/route.ts","content":"export const dynamic = 'force-dynamic';\n\nimport { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\n\n/**\n * Unsubscribe API endpoint\n * Handles email unsubscription requests for legal compliance (CAN-SPAM, GDPR, etc.)\n * \n * This endpoint:\n * 1. Marks waitlist entries as unsubscribed\n * 2. Can be extended to track user email preferences\n * 3. Provides a user-friendly confirmation page\n */\nexport async function GET(request: NextRequest) {\n  try {\n    const searchParams = request.nextUrl.searchParams\n    const email = searchParams.get('email')\n\n    if (!email) {\n      // Return HTML page asking for email\n      return new NextResponse(\n        `\n        <!DOCTYPE html>\n        <html>\n        <head>\n          <title>Unsubscribe from Helfi Emails</title>\n          <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n          <style>\n            body {\n              font-family: 'Segoe UI', Arial, sans-serif;\n              max-width: 600px;\n              margin: 50px auto;\n              padding: 20px;\n              background: #f8fafc;\n            }\n            .container {\n              background: white;\n              padding: 40px;\n              border-radius: 12px;\n              box-shadow: 0 4px 12px rgba(0,0,0,0.1);\n            }\n            h1 { color: #374151; margin-top: 0; }\n            p { color: #4b5563; line-height: 1.7; }\n            form {\n              margin-top: 30px;\n            }\n            input {\n              width: 100%;\n              padding: 12px;\n              border: 1px solid #e5e7eb;\n              border-radius: 8px;\n              font-size: 16px;\n              margin-bottom: 15px;\n            }\n            button {\n              background: linear-gradient(135deg, #10b981 0%, #059669 100%);\n              color: white;\n              padding: 12px 24px;\n              border: none;\n              border-radius: 8px;\n              font-size: 16px;\n              font-weight: 600;\n              cursor: pointer;\n            }\n            button:hover {\n              opacity: 0.9;\n            }\n          </style>\n        </head>\n        <body>\n          <div class=\"container\">\n            <h1>Unsubscribe from Helfi Emails</h1>\n            <p>Enter your email address to unsubscribe from all Helfi marketing emails.</p>\n            <form method=\"GET\" action=\"/api/unsubscribe\">\n              <input type=\"email\" name=\"email\" placeholder=\"your@email.com\" required>\n              <button type=\"submit\">Unsubscribe</button>\n            </form>\n          </div>\n        </body>\n        </html>\n        `,\n        {\n          headers: { 'Content-Type': 'text/html' },\n        }\n      )\n    }\n\n    const normalizedEmail = email.trim().toLowerCase()\n\n    // Ensure unsubscribed column exists (for migration period)\n    try {\n      await prisma.$executeRawUnsafe(`\n        ALTER TABLE \"Waitlist\" \n        ADD COLUMN IF NOT EXISTS \"unsubscribed\" BOOLEAN NOT NULL DEFAULT false\n      `)\n    } catch (e) {\n      // Column might already exist, ignore error\n      console.log('Column check result:', e)\n    }\n\n    // Update waitlist entry to mark as unsubscribed\n    // Use raw SQL to ensure it works even if Prisma schema is out of sync\n    try {\n      const escapedEmail = normalizedEmail.replace(/'/g, \"''\")\n      \n      // First ensure column exists\n      await prisma.$executeRawUnsafe(`\n        ALTER TABLE \"Waitlist\" \n        ADD COLUMN IF NOT EXISTS \"unsubscribed\" BOOLEAN NOT NULL DEFAULT false\n      `).catch(() => {}) // Ignore if column already exists\n      \n      // Now update the record - use raw SQL to guarantee it works\n      const updateResult = await prisma.$executeRawUnsafe(`\n        UPDATE \"Waitlist\" \n        SET unsubscribed = true \n        WHERE LOWER(email) = LOWER('${escapedEmail}')\n      `)\n      \n      console.log(`‚úÖ Marked ${normalizedEmail} as unsubscribed`)\n      \n      // Also try Prisma as backup (but raw SQL should have worked)\n      await prisma.waitlist.updateMany({\n        where: { email: normalizedEmail },\n        data: { unsubscribed: true }\n      }).catch(() => {}) // Ignore if Prisma fails\n\n      // Also check if user exists and could track preferences there\n      const user = await prisma.user.findUnique({\n        where: { email: normalizedEmail }\n      })\n\n      // Return success page\n      return new NextResponse(\n        `\n        <!DOCTYPE html>\n        <html>\n        <head>\n          <title>Successfully Unsubscribed</title>\n          <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n          <style>\n            body {\n              font-family: 'Segoe UI', Arial, sans-serif;\n              max-width: 600px;\n              margin: 50px auto;\n              padding: 20px;\n              background: #f8fafc;\n            }\n            .container {\n              background: white;\n              padding: 40px;\n              border-radius: 12px;\n              box-shadow: 0 4px 12px rgba(0,0,0,0.1);\n              text-align: center;\n            }\n            h1 { color: #10b981; margin-top: 0; }\n            p { color: #4b5563; line-height: 1.7; }\n            .success-icon {\n              font-size: 64px;\n              margin-bottom: 20px;\n            }\n            a {\n              color: #10b981;\n              text-decoration: none;\n              font-weight: 500;\n            }\n          </style>\n        </head>\n        <body>\n          <div class=\"container\">\n            <div class=\"success-icon\">‚úÖ</div>\n            <h1>Successfully Unsubscribed</h1>\n            <p>You have been unsubscribed from Helfi marketing emails.</p>\n            <p style=\"margin-top: 30px; font-size: 14px; color: #6b7280;\">\n              The email address <strong>${normalizedEmail}</strong> will no longer receive marketing emails from Helfi.\n            </p>\n            <p style=\"margin-top: 20px;\">\n              <a href=\"https://helfi.ai\">Return to Helfi</a>\n            </p>\n            <p style=\"margin-top: 30px; font-size: 12px; color: #9ca3af;\">\n              Note: You may still receive important account-related emails (verification, security alerts, etc.) \n              as required for your account security.\n            </p>\n          </div>\n        </body>\n        </html>\n        `,\n        {\n          headers: { 'Content-Type': 'text/html' },\n        }\n      )\n    } catch (error) {\n      console.error('Unsubscribe error:', error)\n      // Still return success page to user (don't reveal if email exists)\n      return new NextResponse(\n        `\n        <!DOCTYPE html>\n        <html>\n        <head>\n          <title>Unsubscribed</title>\n          <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n          <style>\n            body {\n              font-family: 'Segoe UI', Arial, sans-serif;\n              max-width: 600px;\n              margin: 50px auto;\n              padding: 20px;\n              background: #f8fafc;\n            }\n            .container {\n              background: white;\n              padding: 40px;\n              border-radius: 12px;\n              box-shadow: 0 4px 12px rgba(0,0,0,0.1);\n              text-align: center;\n            }\n            h1 { color: #10b981; margin-top: 0; }\n            p { color: #4b5563; line-height: 1.7; }\n          </style>\n        </head>\n        <body>\n          <div class=\"container\">\n            <h1>Unsubscribed</h1>\n            <p>Your request has been processed. If this email was on our list, you have been unsubscribed.</p>\n            <p style=\"margin-top: 20px;\">\n              <a href=\"https://helfi.ai\" style=\"color: #10b981; text-decoration: none; font-weight: 500;\">Return to Helfi</a>\n            </p>\n          </div>\n        </body>\n        </html>\n        `,\n        {\n          headers: { 'Content-Type': 'text/html' },\n        }\n      )\n    }\n  } catch (error) {\n    console.error('Unsubscribe endpoint error:', error)\n    return NextResponse.json(\n      { error: 'Failed to process unsubscribe request' },\n      { status: 500 }\n    )\n  }\n}\n","truncated":false,"size":8032},{"path":"app/api/upload-profile-image/route.ts","content":"import { NextRequest, NextResponse } from 'next/server';\nimport { getServerSession } from 'next-auth/next';\nimport { authOptions } from '@/lib/auth';\nimport { prisma } from '@/lib/prisma';\nimport { v2 as cloudinary } from 'cloudinary';\n\n// Configure Cloudinary\ncloudinary.config({\n  cloud_name: process.env.CLOUDINARY_CLOUD_NAME?.trim(),\n  api_key: process.env.CLOUDINARY_API_KEY?.trim(),\n  api_secret: process.env.CLOUDINARY_API_SECRET?.trim(),\n});\n\nexport async function POST(request: NextRequest) {\n  try {\n    console.log('=== PROFILE IMAGE UPLOAD START ===');\n    \n    // Check authentication\n    const session = await getServerSession(authOptions);\n    \n    if (!session?.user?.email) {\n      console.log('‚ùå Authentication failed - no session or user email');\n      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });\n    }\n\n    console.log('‚úÖ Authentication successful for user:', session.user.email);\n\n    const formData = await request.formData();\n    const imageFile = formData.get('image') as File;\n\n    if (!imageFile) {\n      console.log('‚ùå No image file provided in form data');\n      return NextResponse.json({ error: 'No image file provided' }, { status: 400 });\n    }\n\n    // Validate file type\n    if (!imageFile.type.startsWith('image/')) {\n      console.log('‚ùå Invalid file type:', imageFile.type);\n      return NextResponse.json({ error: 'File must be an image' }, { status: 400 });\n    }\n\n    // Validate file size (5MB limit)\n    if (imageFile.size > 5 * 1024 * 1024) {\n      console.log('‚ùå File too large:', imageFile.size);\n      return NextResponse.json({ error: 'File size must be less than 5MB' }, { status: 400 });\n    }\n\n    console.log('‚úÖ File validation passed:', {\n      name: imageFile.name,\n      type: imageFile.type,\n      size: imageFile.size,\n      userEmail: session.user.email\n    });\n\n    // Convert file to buffer for Cloudinary upload\n    const imageBuffer = await imageFile.arrayBuffer();\n    const buffer = Buffer.from(imageBuffer);\n\n    // Upload to Cloudinary with profile image specific settings\n    console.log('Starting Cloudinary upload...');\n    const uploadResult = await new Promise((resolve, reject) => {\n      cloudinary.uploader.upload_stream(\n        {\n          resource_type: 'image',\n          folder: 'helfi/profile-images',\n          public_id: `user_${session.user.email?.replace(/[^a-zA-Z0-9]/g, '_')}_${Date.now()}`,\n          transformation: [\n            { width: 400, height: 400, crop: 'fill', gravity: 'face' },  // Smart crop focusing on face\n            { quality: 'auto', fetch_format: 'auto' }  // Optimize quality and format\n          ],\n          invalidate: true,  // Clear CDN cache\n          overwrite: true    // Allow overwriting\n        },\n        (error, result) => {\n          if (error) {\n            console.error('‚ùå Cloudinary upload error:', error);\n            reject(error);\n          } else {\n            console.log('‚úÖ Cloudinary upload successful');\n            resolve(result);\n          }\n        }\n      ).end(buffer);\n    });\n\n    const cloudinaryResult = uploadResult as any;\n    \n    console.log('Cloudinary upload result:', {\n      publicId: cloudinaryResult.public_id,\n      secureUrl: cloudinaryResult.secure_url,\n      bytes: cloudinaryResult.bytes\n    });\n\n    // Find user by email\n    const user = await prisma.user.findUnique({\n      where: { email: session.user.email }\n    });\n\n    if (!user) {\n      console.log('‚ùå User not found in database:', session.user.email);\n      return NextResponse.json({ error: 'User not found' }, { status: 404 });\n    }\n\n    console.log('‚úÖ User found in database:', { id: user.id, email: user.email });\n\n    // Create File record in database\n    const fileRecord = await prisma.file.create({\n      data: {\n        originalName: imageFile.name,\n        fileName: cloudinaryResult.public_id,\n        fileSize: cloudinaryResult.bytes,\n        mimeType: imageFile.type,\n        cloudinaryId: cloudinaryResult.public_id,\n        cloudinaryUrl: cloudinaryResult.url,\n        secureUrl: cloudinaryResult.secure_url,\n        uploadedById: user.id,\n        fileType: 'IMAGE',\n        usage: 'PROFILE_IMAGE',\n        isPublic: false,\n        metadata: {\n          width: cloudinaryResult.width,\n          height: cloudinaryResult.height,\n          format: cloudinaryResult.format,\n          originalSize: imageFile.size,\n          optimizedSize: cloudinaryResult.bytes\n        }\n      }\n    });\n\n    // Update user's profile image URL\n    await prisma.user.update({\n      where: { id: user.id },\n      data: { \n        image: cloudinaryResult.secure_url,\n        updatedAt: new Date()\n      }\n    });\n\n    console.log('‚úÖ Profile image upload complete - Database updated');\n\n    return NextResponse.json({\n      success: true,\n      imageUrl: cloudinaryResult.secure_url,\n      cloudinaryId: cloudinaryResult.public_id,\n      fileId: fileRecord.id,\n      optimizations: {\n        originalSize: imageFile.size,\n        optimizedSize: cloudinaryResult.bytes,\n        savings: Math.round(((imageFile.size - cloudinaryResult.bytes) / imageFile.size * 100)),\n        cdnUrl: cloudinaryResult.secure_url\n      }\n    });\n\n  } catch (error) {\n    console.error('‚ùå Profile image upload error:', error);\n    return NextResponse.json({\n      success: false,\n      error: error instanceof Error ? error.message : 'Upload failed'\n    }, { status: 500 });\n  }\n} ","truncated":false,"size":5426},{"path":"app/api/user-data/clear-todays-foods/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth/next'\nimport { getToken } from 'next-auth/jwt'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\n\nexport async function POST(request: NextRequest) {\n  try {\n    let session = await getServerSession(authOptions)\n    let userEmail: string | null = session?.user?.email ?? null\n\n    if (!userEmail) {\n      try {\n        const token = await getToken({\n          req: request,\n          secret: process.env.NEXTAUTH_SECRET || process.env.AUTH_SECRET || 'helfi-secret-key-production-2024',\n        })\n        if (token?.email) {\n          userEmail = String(token.email)\n        }\n      } catch (err) {\n        // ignore\n      }\n    }\n\n    if (!userEmail) {\n      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 })\n    }\n\n    const user = await prisma.user.findUnique({ where: { email: userEmail } })\n    if (!user) {\n      return NextResponse.json({ error: 'User not found' }, { status: 404 })\n    }\n\n    await prisma.healthGoal.deleteMany({\n      where: {\n        userId: user.id,\n        name: '__TODAYS_FOODS_DATA__',\n      },\n    })\n\n    return NextResponse.json({ success: true })\n  } catch (error) {\n    console.error('POST /api/user-data/clear-todays-foods error', error)\n    return NextResponse.json({ error: 'Failed to clear todays foods' }, { status: 500 })\n  }\n}\n\n","truncated":false,"size":1423},{"path":"app/api/user-data/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth/next'\nimport { getToken } from 'next-auth/jwt'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\nimport { precomputeIssueSectionsForUser, precomputeQuickSectionsForUser } from '@/lib/insights/issue-engine'\nimport { triggerBackgroundRegeneration } from '@/lib/insights/regeneration-service'\nimport { CreditManager, CREDIT_COSTS } from '@/lib/credit-system'\n\nexport async function GET(request: NextRequest) {\n  try {\n    console.log('=== GET /api/user-data DEBUG START ===')\n    console.log('Request URL:', request.url)\n    console.log('Request headers:', Object.fromEntries(request.headers.entries()))\n    \n    // Get NextAuth session - with JWT fallback (same pattern as /api/analyze-food)\n    let session = await getServerSession(authOptions)\n    let userEmail: string | null = session?.user?.email ?? null\n    let usedTokenFallback = false\n\n    if (!userEmail) {\n      try {\n        const token = await getToken({\n          req: request,\n          secret: process.env.NEXTAUTH_SECRET || process.env.AUTH_SECRET || 'helfi-secret-key-production-2024',\n        })\n        if (token?.email) {\n          userEmail = String(token.email)\n          usedTokenFallback = true\n        }\n      } catch (tokenError) {\n        console.error('GET /api/user-data - JWT fallback failed:', tokenError)\n      }\n    }\n\n    console.log('NextAuth session result:', session)\n    console.log('Session user:', session?.user)\n    console.log('Resolved user email (session/JWT):', userEmail, 'usedTokenFallback:', usedTokenFallback)\n    \n    if (!userEmail) {\n      console.log('GET Authentication failed - no valid session or token found')\n      console.log('Session:', session)\n      console.log('Request headers:', Object.fromEntries(request.headers.entries()))\n      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 })\n    }\n    \n    console.log('GET /api/user-data - Authenticated for:', userEmail)\n\n    // Get user data by email with better error handling\n    let user\n    try {\n      user = await prisma.user.findUnique({\n      where: { email: userEmail },\n        include: {\n          healthGoals: true,\n          supplements: true,\n          medications: true,\n        }\n      })\n    } catch (prismaError) {\n      console.error('PRISMA ERROR in GET user query:', prismaError)\n      return NextResponse.json({ \n        error: 'Database error', \n        debug: { \n          message: prismaError instanceof Error ? prismaError.message : 'Unknown prisma error',\n          type: 'PRISMA_QUERY_ERROR'\n        }\n      }, { status: 500 })\n    }\n\n    if (!user) {\n      return NextResponse.json({ error: 'User not found' }, { status: 404 })\n    }\n\n    console.log('GET /api/user-data - Loading data for user:', userEmail)\n\n    // Debug: Log actual user data from database\n    console.log('GET /api/user-data - Raw user data from DB:', {\n      gender: user.gender,\n      weight: user.weight,\n      height: user.height,\n      bodyType: user.bodyType,\n      exerciseFrequency: user.exerciseFrequency,\n      exerciseTypes: user.exerciseTypes,\n      healthGoalsCount: user.healthGoals.length,\n      supplementsCount: user.supplements.length,\n      medicationsCount: user.medications.length,\n      hasProfileImage: !!user.image\n    })\n\n    // Get exercise data directly from User table fields\n    const exerciseData = {\n      exerciseFrequency: user.exerciseFrequency || null,\n      exerciseTypes: user.exerciseTypes || []\n    };\n    \n    console.log('GET /api/user-data - Exercise data extracted for user')\n\n    // Get health situations data\n    let healthSituationsData = { healthIssues: '', healthProblems: '', additionalInfo: '', skipped: false };\n    try {\n      const storedHealthSituations = user.healthGoals.find((goal: any) => goal.name === '__HEALTH_SITUATIONS_DATA__');\n      if (storedHealthSituations && storedHealthSituations.category) {\n        const parsed = JSON.parse(storedHealthSituations.category);\n        healthSituationsData = {\n          healthIssues: parsed.healthIssues || '',\n          healthProblems: parsed.healthProblems || '',\n          additionalInfo: parsed.additionalInfo || '',\n          skipped: parsed.skipped || false\n        };\n      }\n    } catch (e) {\n      console.log('No health situations data found in storage');\n    }\n\n    // Get allergy + diabetes data\n    let allergyData = { allergies: [] as string[], diabetesType: '' };\n    try {\n      const storedAllergies = user.healthGoals.find((goal: any) => goal.name === '__ALLERGIES_DATA__');\n      if (storedAllergies?.category) {\n        const parsed = JSON.parse(storedAllergies.category);\n        allergyData = {\n          allergies: Array.isArray(parsed?.allergies) ? parsed.allergies.filter((a: any) => typeof a === 'string' && a.trim().length > 0) : [],\n          diabetesType: typeof parsed?.diabetesType === 'string' ? parsed.diabetesType : '',\n        };\n      }\n    } catch (e) {\n      console.log('No allergy data found in storage');\n    }\n\n    // Get diet preference (optional)\n    let dietTypes: string[] = []\n    try {\n      const storedDiet = user.healthGoals.find((goal: any) => goal.name === '__DIET_PREFERENCE__')\n      if (storedDiet?.category) {\n        const parsed = JSON.parse(storedDiet.category)\n        const raw = Array.isArray(parsed?.dietTypes) ? parsed.dietTypes : parsed?.dietType\n        dietTypes = Array.isArray(raw)\n          ? raw.filter((v: any) => typeof v === 'string' && v.trim().length > 0)\n          : typeof raw === 'string' && raw.trim().length > 0\n          ? [raw.trim()]\n          : []\n      }\n    } catch (e) {\n      console.log('No diet preference found in storage')\n    }\n\n    // Get blood results data\n    let bloodResultsData = { uploadMethod: 'documents', documents: [], images: [], notes: '', skipped: false };\n    try {\n      const storedBloodResults = user.healthGoals.find((goal: any) => goal.name === '__BLOOD_RESULTS_DATA__');\n      if (storedBloodResults && storedBloodResults.category) {\n        const parsed = JSON.parse(storedBloodResults.category);\n        bloodResultsData = {\n          uploadMethod: parsed.uploadMethod || 'documents',\n          documents: parsed.documents || [],\n          images: parsed.images || [],\n          notes: parsed.notes || '',\n          skipped: parsed.skipped || false\n        };\n      }\n    } catch (e) {\n      console.log('No blood results data found in storage');\n    }\n\n    // Get today's food entries\n    const normalizeCategory = (raw: any) => {\n      const value = typeof raw === 'string' ? raw.toLowerCase() : ''\n      if (/breakfast/.test(value)) return 'breakfast'\n      if (/lunch/.test(value)) return 'lunch'\n      if (/dinner/.test(value)) return 'dinner'\n      if (/snack/.test(value)) return 'snacks'\n      if (/other/.test(value) || /uncat/.test(value)) return 'uncategorized'\n      return value && value.trim().length > 0 ? value.trim() : 'uncategorized'\n    }\n    const buildTodayIso = () => {\n      const d = new Date()\n      const y = d.getFullYear()\n      const m = String(d.getMonth() + 1).padStart(2, '0')\n      const day = String(d.getDate()).padStart(2, '0')\n      return `${y}-${m}-${day}`\n    }\n    let todaysFoods: any[] = [];\n    try {\n      const storedFoods = user.healthGoals.find((goal: any) => goal.name === '__TODAYS_FOODS_DATA__');\n      if (storedFoods && storedFoods.category) {\n        const parsed = JSON.parse(storedFoods.category);\n        todaysFoods = parsed.foods || [];\n      }\n    } catch (e) {\n      console.log('No todays foods data found in storage');\n    }\n    const deriveLocalDateFromEntry = (entry: any) => {\n      try {\n        const ts = typeof entry?.id === 'number' ? entry.id : Number(entry?.id)\n        if (Number.isFinite(ts)) {\n          const d = new Date(ts)\n          if (!Number.isNaN(d.getTime())) {\n            const y = d.getFullYear()\n            const m = String(d.getMonth() + 1).padStart(2, '0')\n            const day = String(d.getDate()).padStart(2, '0')\n            return `${y}-${m}-${day}`\n          }\n        }\n      } catch {}\n      return ''\n    }\n    const normalizedTodaysFoods = Array.isArray(todaysFoods)\n      ? todaysFoods\n          .map((entry: any) => {\n            const category = normalizeCategory(entry?.meal ?? entry?.category ?? entry?.mealType ?? entry?.persistedCategory)\n            const explicitLocalDate =\n              typeof entry?.localDate === 'string' && entry.localDate.length >= 8\n                ? entry.localDate\n                : ''\n            const derivedLocalDate = deriveLocalDateFromEntry(entry)\n            const localDate = explicitLocalDate || derivedLocalDate\n            if (!localDate) return null\n            return {\n              ...entry,\n              meal: category,\n              category,\n              persistedCategory: entry?.persistedCategory ?? category,\n              localDate,\n            }\n          })\n          .filter(Boolean)\n      : []\n\n    // Get saved favorites\n    let favorites: any[] = [];\n    try {\n      const storedFavorites = user.healthGoals.find((goal: any) => goal.name === '__FOOD_FAVORITES__');\n      if (storedFavorites && storedFavorites.category) {\n        const parsed = JSON.parse(storedFavorites.category);\n        if (Array.isArray(parsed?.favorites)) {\n          favorites = parsed.favorites;\n        } else if (Array.isArray(parsed)) {\n          favorites = parsed;\n        }\n      }\n    } catch (e) {\n      console.log('No favorites data found in storage');\n    }\n\n    // Get saved food name overrides (used for user renames without forcing favorites)\n    let foodNameOverrides: any[] = []\n    try {\n      const storedOverrides = user.healthGoals.find((goal: any) => goal.name === '__FOOD_NAME_OVERRIDES__')\n      if (storedOverrides && storedOverrides.category) {\n        const parsed = JSON.parse(storedOverrides.category)\n        if (Array.isArray(parsed?.overrides)) {\n          foodNameOverrides = parsed.overrides\n        } else if (Array.isArray(parsed)) {\n          foodNameOverrides = parsed\n        }\n      }\n    } catch (e) {\n      console.log('No food name overrides data found in storage')\n    }\n\n    // Get food library (all-items list, independent from daily diary)\n    let foodLibrary: any[] = []\n    try {\n      const storedLibrary = user.healthGoals.find((goal: any) => goal.name === '__FOOD_LIBRARY__')\n      if (storedLibrary && storedLibrary.category) {\n        const parsed = JSON.parse(storedLibrary.category)\n        if (Array.isArray(parsed?.items)) {\n          foodLibrary = parsed.items\n        } else if (Array.isArray(parsed?.library)) {\n          foodLibrary = parsed.library\n        } else if (Array.isArray(parsed)) {\n          foodLibrary = parsed\n        }\n      }\n    } catch (e) {\n      console.log('No food library data found in storage')\n    }\n\n    // Get device interest (stored in hidden goal record)\n    let deviceInterestData: any = {}\n    try {\n      const storedDeviceInterest = user.healthGoals.find((goal: any) => goal.name === '__DEVICE_INTEREST__');\n      if (storedDeviceInterest && storedDeviceInterest.category) {\n        const parsed = JSON.parse(storedDeviceInterest.category);\n        deviceInterestData = parsed || {}\n      }\n    } catch (e) {\n      console.log('No device interest data found in storage');\n    }\n\n    // Get profile info data\n    let profileInfoData = { firstName: '', lastName: '', bio: '', dateOfBirth: '', email: user.email || '' };\n    try {\n      const storedProfileInfo = user.healthGoals.find((goal: any) => goal.name === '__PROFILE_INFO_DATA__');\n      if (storedProfileInfo && storedProfileInfo.category) {\n        const parsed = JSON.parse(storedProfileInfo.category);\n        profileInfoData = {\n          firstName: parsed.firstName || '',\n          lastName: parsed.lastName || '',\n          bio: parsed.bio || '',\n          dateOfBirth: parsed.dateOfBirth || '',\n          email: parsed.email || user.email || ''\n        };\n      } else {\n        // If no stored profile info, try to extract from user.name\n        if (user.name) {\n          const nameParts = user.name.split(' ');\n          if (nameParts.length >= 2) {\n            profileInfoData.firstName = nameParts[0];\n            profileInfoData.lastName = nameParts.slice(1).join(' ');\n          } else if (nameParts.length === 1) {\n            profileInfoData.firstName = nameParts[0];\n          }\n        }\n      }\n      // Fallback: if stored profile info missing DOB but user has one, surface it\n      if (!profileInfoData.dateOfBirth && (user as any).dateOfBirth) {\n        profileInfoData.dateOfBirth = (user as any).dateOfBirth;\n      }\n    } catch (e) {\n      console.log('No profile info data found in storage');\n    }\n\n    // Get primary goal choice + intensity (Step 2) stored as hidden health goal\n    let primaryGoalData: { goalChoice?: string; goalIntensity?: string } = {};\n    try {\n      const storedPrimaryGoal = user.healthGoals.find((goal: any) => goal.name === '__PRIMARY_GOAL__');\n      if (storedPrimaryGoal?.category) {\n      const parsed = JSON.parse(storedPrimaryGoal.category);\n      primaryGoalData = {\n        goalChoice: typeof parsed.goalChoice === 'string' ? parsed.goalChoice : '',\n        goalIntensity: typeof parsed.goalIntensity === 'string' ? parsed.goalIntensity.toLowerCase() : '',\n      };\n    }\n  } catch (e) {\n    console.log('No primary goal data found in storage');\n  }\n\n    // Transform to onboarding format\n    let selectedGoals: string[] = []\n    try {\n      const selectedRecord = user.healthGoals.find((goal: any) => goal.name === '__SELECTED_ISSUES__')\n      if (selectedRecord?.category) {\n        const parsed = JSON.parse(selectedRecord.category)\n        if (Array.isArray(parsed)) {\n          selectedGoals = parsed.map((name) => String(name || '')).filter(Boolean)\n        }\n      }\n    } catch (error) {\n      console.warn('Failed to parse __SELECTED_ISSUES__ health goal', error)\n      selectedGoals = []\n    }\n    console.log('GET /api/user-data - Parsed __SELECTED_ISSUES__ snapshot:', { count: selectedGoals.length, goals: selectedGoals })\n\n    const onboardingData = {\n      gender: user.gender?.toLowerCase() || '',\n      weight: user.weight?.toString() || '',\n      height: user.height?.toString() || '',\n      bodyType: user.bodyType?.toLowerCase() || '',\n      birthdate: profileInfoData.dateOfBirth || '',\n      exerciseFrequency: exerciseData.exerciseFrequency || '',\n      exerciseTypes: exerciseData.exerciseTypes || [],\n      goals: selectedGoals.length\n        ? selectedGoals\n        : user.healthGoals.filter((goal: any) => !goal.name.startsWith('__')).map((goal: any) => goal.name),\n      healthSituations: healthSituationsData,\n      bloodResults: bloodResultsData,\n      supplements: user.supplements.map((supp: any) => ({\n        name: supp.name,\n        dosage: supp.dosage,\n        timing: supp.timing,\n        dateAdded: supp.dateAdded || supp.createdAt || new Date().toISOString(),\n        method: supp.method || 'manual',\n        scheduleInfo: supp.scheduleInfo || 'Daily',\n        imageUrl: supp.imageUrl || null\n      })),\n      medications: user.medications.map((med: any) => ({\n        name: med.name,\n        dosage: med.dosage,\n        timing: med.timing,\n        dateAdded: med.dateAdded || med.createdAt || new Date().toISOString(),\n        method: med.method || 'manual',\n        scheduleInfo: med.scheduleInfo || 'Daily',\n        imageUrl: med.imageUrl || null\n      })),\n      profileImage: user.image || null,\n      todaysFoods: normalizedTodaysFoods,\n      favorites,\n      foodLibrary,\n      foodNameOverrides,\n      profileInfo: profileInfoData,\n      deviceInterest: deviceInterestData,\n      termsAccepted: (user as any).termsAccepted === true,\n      goalChoice: primaryGoalData.goalChoice || '',\n      goalIntensity: (primaryGoalData.goalIntensity || 'standard').toString().toLowerCase(),\n      allergies: allergyData.allergies,\n      diabetesType: allergyData.diabetesType,\n      dietTypes,\n    }\n\n    // Fallback: if primary goal still missing, use the first non-hidden health goal as a soft default\n    if (!onboardingData.goalChoice && onboardingData.goals.length > 0) {\n      onboardingData.goalChoice = onboardingData.goals[0]\n    }\n\n    console.log('GET /api/user-data - Returning onboarding data for user')\n\n    // Debug: Log transformed data being returned\n    console.log('GET /api/user-data - Transformed onboarding data:', {\n      gender: onboardingData.gender,\n      weight: onboardingData.weight,\n      height: onboardingData.height,\n      bodyType: onboardingData.bodyType,\n      exerciseFrequency: onboardingData.exerciseFrequency,\n      exerciseTypes: onboardingData.exerciseTypes,\n      goalsCount: onboardingData.goals.length,\n      supplementsCount: onboardingData.supplements.length,\n      medicationsCount: onboardingData.medications.length,\n      hasProfileImage: !!onboardingData.profileImage\n    })\n\n    return NextResponse.json({ data: onboardingData })\n  } catch (error) {\n    console.error('Error loading user data:', error)\n    return NextResponse.json({ error: 'Failed to load data' }, { status: 500 })\n  }\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    // üîç BACKEND PERFORMANCE MEASUREMENT START\n    console.log('=== POST /api/user-data DEBUG START ===')\n    console.log('üöÄ BACKEND PERFORMANCE TRACKING')\n    console.time('‚è±Ô∏è Total API Processing Time')\n    console.time('‚è±Ô∏è Authentication Check')\n    const apiStartTime = Date.now()\n    \n    console.log('Request URL:', request.url)\n    console.log('Request headers:', Object.fromEntries(request.headers.entries()))\n    console.log('POST /api/user-data - Starting SIMPLIFIED approach...')\n    \n    // Get NextAuth session\n    let session = await getServerSession(authOptions)\n    let userEmail: string | null = session?.user?.email ?? null\n    let usedTokenFallback = false\n\n    if (!userEmail) {\n      try {\n        const token = await getToken({\n          req: request,\n          secret: process.env.NEXTAUTH_SECRET || process.env.AUTH_SECRET || 'helfi-secret-key-production-2024',\n        })\n        if (token?.email) {\n          userEmail = String(token.email)\n          usedTokenFallback = true\n        }\n      } catch (tokenError) {\n        console.error('POST /api/user-data - JWT fallback failed:', tokenError)\n      }\n    }\n    \n    console.timeEnd('‚è±Ô∏è Authentication Check')\n    console.log('NextAuth session result:', session)\n    console.log('Session user:', session?.user)\n    console.log('Resolved user email (session/JWT):', userEmail, 'usedTokenFallback:', usedTokenFallback)\n    \n    if (!userEmail) {\n      console.timeEnd('‚è±Ô∏è Total API Processing Time')\n      console.log('‚ùå POST Authentication failed - no valid session or token found')\n      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 })\n    }\n    \n    console.log('‚úÖ POST /api/user-data - Authenticated user:', userEmail)\n\n    console.time('‚è±Ô∏è Parse Request Data')\n    const data = await request.json()\n    console.timeEnd('‚è±Ô∏è Parse Request Data')\n\n    // #region agent log\n\t    try {\n\t      const hasTodaysFoodsKey = !!(data && typeof data === 'object' && 'todaysFoods' in data)\n\t      const todaysFoodsLen = Array.isArray((data as any)?.todaysFoods) ? (data as any).todaysFoods.length : null\n\t      const appendHistory = (data as any)?.appendHistory\n\t      console.log('AGENT_DEBUG', JSON.stringify({hypothesisId:'C',location:'app/api/user-data/route.ts:POST',message:'POST /api/user-data payload includes todaysFoods?',data:{hasTodaysFoodsKey,todaysFoodsLen,appendHistory,referer:(request.headers.get('referer')||'').slice(0,200),contentLength:(request.headers.get('content-length')||'')},timestamp:Date.now()}));\n\t    } catch {}\n    // #endregion agent log\n    \n    console.log('üìä POST /api/user-data - Data received:', {\n      hasGender: !!data.gender,\n      hasWeight: !!data.weight,\n      hasHeight: !!data.height,\n      hasBodyType: !!data.bodyType,\n      hasGoals: !!data.goals,\n      hasSupplements: !!data.supplements,\n      hasMedications: !!data.medications,\n      hasHealthSituations: !!data.healthSituations,\n      hasBloodResults: !!data.bloodResults,\n      hasExercise: !!(data.exerciseFrequency || data.exerciseTypes),\n      dataSize: JSON.stringify(data).length + ' characters'\n    })\n    if (Array.isArray(data.goals)) {\n      const safeGoals = data.goals.map((g: any) => String(g || '').trim()).filter(Boolean)\n      console.log('üéØ POST /api/user-data - goals payload:', { count: safeGoals.length, goals: safeGoals })\n    } else {\n      console.log('‚ÑπÔ∏è POST /api/user-data - no goals array provided; will not modify __SELECTED_ISSUES__')\n    }\n\n    // Find or create user\n    console.time('‚è±Ô∏è User Lookup/Creation')\n    let user = await prisma.user.findUnique({\n      where: { email: userEmail }\n    })\n\n    if (!user) {\n      console.log('üî® Creating new user for:', userEmail)\n      user = await prisma.user.create({\n        data: {\n          email: userEmail,\n          name: userEmail.split('@')[0],\n        }\n      })\n      console.log('‚úÖ Created new user with ID:', user.id)\n    } else {\n      console.log('‚úÖ Found existing user with ID:', user.id)\n    }\n    \n    console.timeEnd('‚è±Ô∏è User Lookup/Creation')\n\n    // Load existing profile info record for merging purposes (date of birth, etc.)\n    let existingProfileInfoData: Record<string, any> | null = null\n    try {\n      const storedProfileInfo = await prisma.healthGoal.findFirst({\n        where: {\n          userId: user.id,\n          name: '__PROFILE_INFO_DATA__'\n        }\n      })\n      if (storedProfileInfo?.category) {\n        existingProfileInfoData = JSON.parse(storedProfileInfo.category)\n      }\n    } catch (error) {\n      console.warn('‚ö†Ô∏è Failed to load existing profile info data:', error)\n    }\n\n    // Load existing primary goal (goal choice + intensity) for safe merging\n    let existingPrimaryGoalData: { goalChoice?: string; goalIntensity?: string } = {}\n    try {\n      const storedPrimaryGoal = await prisma.healthGoal.findFirst({\n        where: { userId: user.id, name: '__PRIMARY_GOAL__' },\n      })\n      if (storedPrimaryGoal?.category) {\n        const parsed = JSON.parse(storedPrimaryGoal.category)\n        existingPrimaryGoalData = {\n          goalChoice: typeof parsed.goalChoice === 'string' ? parsed.goalChoice : '',\n          goalIntensity: typeof parsed.goalIntensity === 'string' ? parsed.goalIntensity.toLowerCase() : '',\n        }\n      }\n    } catch (error) {\n      console.warn('‚ö†Ô∏è Failed to load existing primary goal data:', error)\n    }\n\n    const normalizedBirthdate =\n      typeof data.birthdate === 'string' ? data.birthdate.trim() : ''\n    const effectiveBirthdate =\n      normalizedBirthdate ||\n      (existingProfileInfoData && typeof existingProfileInfoData.dateOfBirth === 'string'\n        ? existingProfileInfoData.dateOfBirth\n        : '')\n    const birthdateChanged = Boolean(\n      normalizedBirthdate &&\n        normalizedBirthdate !== (existingProfileInfoData?.dateOfBirth || '')\n    )\n\n    // SIMPLIFIED APPROACH: Update each piece of data individually with proper error handling\n    // This avoids complex transactions that were causing constraint violations\n\n    // 1. Update basic user data with safe enum handling\n    console.time('‚è±Ô∏è Basic User Data Update')\n    try {\n      const updateData: any = {}\n      \n      if (data.gender) {\n        updateData.gender = data.gender.toUpperCase() === 'MALE' ? 'MALE' : 'FEMALE'\n      }\n      if (data.termsAccepted === true) {\n        updateData.termsAccepted = true\n      }\n      if (data.weight !== undefined && data.weight !== null && data.weight !== '') {\n        const weightNum = parseFloat(data.weight.toString())\n        if (!isNaN(weightNum)) {\n          updateData.weight = weightNum\n        }\n      }\n      if (data.height !== undefined && data.height !== null && data.height !== '') {\n        const heightNum = parseFloat(data.height.toString())\n        if (!isNaN(heightNum)) {\n          updateData.height = heightNum\n        }\n      }\n      if (data.bodyType && data.bodyType.trim() !== '') {\n        const bodyTypeUpper = data.bodyType.toUpperCase()\n        if (['ECTOMORPH', 'MESOMORPH', 'ENDOMORPH'].includes(bodyTypeUpper)) {\n          updateData.bodyType = bodyTypeUpper\n        }\n      }\n      if (data.exerciseFrequency && data.exerciseFrequency.trim() !== '') {\n        updateData.exerciseFrequency = data.exerciseFrequency.trim()\n      }\n      if (data.exerciseTypes && Array.isArray(data.exerciseTypes) && data.exerciseTypes.length > 0) {\n        updateData.exerciseTypes = data.exerciseTypes.filter((type: any) => type && type.trim() !== '')\n      }\n      if (data.profileImage !== undefined) {\n        updateData.image = data.profileImage\n      }\n\n      if (Object.keys(updateData).length > 0) {\n        await prisma.user.update({\n          where: { id: user.id },\n          data: updateData\n        })\n        console.log('‚úÖ Updated user basic data successfully:', updateData)\n      } else {\n        console.log('‚ÑπÔ∏è No user basic data to update')\n      }\n    } catch (error) {\n      console.error('‚ùå Error updating user basic data:', error)\n      // Continue with other updates even if this fails\n    }\n    console.timeEnd('‚è±Ô∏è Basic User Data Update')\n\n    // 2. Handle health goals - simple upsert approach\n    console.time('‚è±Ô∏è Health Goals Update')\n    try {\n      if (data.goals && Array.isArray(data.goals) && data.goals.length > 0) {\n        console.log('üéØ Processing', data.goals.length, 'health goals')\n        \n        // Delete existing non-hidden goals (preserve hidden snapshot records like favorites/todaysFoods)\n        const deleteResult = await prisma.healthGoal.deleteMany({\n          where: {\n            userId: user.id,\n            NOT: { name: { startsWith: '__' } },\n          },\n        })\n        console.log('üóëÔ∏è Deleted', deleteResult.count, 'existing health goals')\n        \n        // Create new goals\n        for (const goalName of data.goals) {\n          if (goalName && typeof goalName === 'string') {\n            await prisma.healthGoal.create({\n              data: {\n                userId: user.id,\n                name: goalName,\n                category: 'general',\n                currentRating: 5,\n              }\n            })\n          }\n        }\n        console.log('‚úÖ Updated health goals successfully')\n      } else {\n        console.log('‚ÑπÔ∏è No health goals to update')\n      }\n      // Persist the canonical selected issue list only when a goals array is provided\n      if (Array.isArray(data.goals)) {\n        const safeGoals = data.goals.map((g: any) => String(g || '').trim()).filter(Boolean)\n        await prisma.healthGoal.deleteMany({\n          where: { userId: user.id, name: '__SELECTED_ISSUES__' },\n        })\n        await prisma.healthGoal.create({\n          data: {\n            userId: user.id,\n            name: '__SELECTED_ISSUES__',\n            category: JSON.stringify(safeGoals),\n            currentRating: 0,\n          },\n        })\n        console.log('üìù Saved __SELECTED_ISSUES__ snapshot:', { count: safeGoals.length, goals: safeGoals })\n      } else {\n        console.log('üîí Preserved existing __SELECTED_ISSUES__ (no goals array provided in this request)')\n      }\n    } catch (error) {\n      console.error('‚ùå Error updating health goals:', error)\n      // Continue with other updates\n    }\n    console.timeEnd('‚è±Ô∏è Health Goals Update')\n\n    // 3. Handle health situations data (Step 5) - store as special health goal\n    try {\n      if (data.healthSituations) {\n        // Remove existing health situations data\n        await prisma.healthGoal.deleteMany({\n          where: {\n            userId: user.id,\n            name: '__HEALTH_SITUATIONS_DATA__'\n          }\n        })\n        \n        // Store new health situations data\n        await prisma.healthGoal.create({\n          data: {\n            userId: user.id,\n            name: '__HEALTH_SITUATIONS_DATA__',\n            category: JSON.stringify(data.healthSituations),\n            currentRating: 0,\n          }\n        })\n        console.log('Stored health situations data successfully')\n      }\n    } catch (error) {\n      console.error('Error storing health situations data:', error)\n      // Continue with other updates\n    }\n\n    // 3.1. Handle allergies + diabetes type (Step 2) - store as special health goal\n    try {\n      const hasIncomingAllergies = Array.isArray(data.allergies)\n      const hasIncomingDiabetes = typeof data.diabetesType === 'string'\n      if (hasIncomingAllergies || hasIncomingDiabetes) {\n        let existingAllergyPayload: { allergies: string[]; diabetesType?: string } = { allergies: [], diabetesType: '' }\n        try {\n          const existingAllergies = await prisma.healthGoal.findFirst({\n            where: { userId: user.id, name: '__ALLERGIES_DATA__' },\n          })\n          if (existingAllergies?.category) {\n            const parsed = JSON.parse(existingAllergies.category)\n            existingAllergyPayload = {\n              allergies: Array.isArray(parsed?.allergies) ? parsed.allergies : [],\n              diabetesType: typeof parsed?.diabetesType === 'string' ? parsed.diabetesType : '',\n            }\n          }\n        } catch (error) {\n          console.warn('‚ö†Ô∏è Failed to load existing allergy data:', error)\n        }\n\n        const normalizedAllergies = hasIncomingAllergies\n          ? (data.allergies as any[])\n              .filter((a) => typeof a === 'string')\n              .map((a) => (a as string).trim())\n              .filter((a) => a.length > 0)\n          : existingAllergyPayload.allergies || []\n\n        const payload = {\n          allergies: normalizedAllergies,\n          diabetesType: hasIncomingDiabetes ? data.diabetesType : existingAllergyPayload.diabetesType || '',\n        }\n\n        await prisma.healthGoal.deleteMany({\n          where: { userId: user.id, name: '__ALLERGIES_DATA__' },\n        })\n        await prisma.healthGoal.create({\n          data: {\n            userId: user.id,\n            name: '__ALLERGIES_DATA__',\n            category: JSON.stringify(payload),\n            currentRating: 0,\n          },\n        })\n        console.log('Stored allergy + diabetes data successfully')\n      }\n    } catch (error) {\n      console.error('Error storing allergy data:', error)\n      // Continue with other updates\n    }\n\n    // 3.15. Handle diet preference (Step 2) - store as special health goal\n    try {\n      const hasIncomingDiet =\n        Object.prototype.hasOwnProperty.call(data as any, 'dietTypes') ||\n        Object.prototype.hasOwnProperty.call(data as any, 'dietType')\n      if (hasIncomingDiet) {\n        const raw =\n          Object.prototype.hasOwnProperty.call(data as any, 'dietTypes') ? (data as any).dietTypes : (data as any).dietType\n        const normalizedDietTypes = Array.isArray(raw)\n          ? raw\n              .filter((v: any) => typeof v === 'string')\n              .map((v: string) => v.trim())\n              .filter((v: string) => v.length > 0)\n          : typeof raw === 'string' && raw.trim().length > 0\n          ? [raw.trim()]\n          : []\n\n        // Clear if blank, otherwise upsert the preference.\n        await prisma.healthGoal.deleteMany({\n          where: { userId: user.id, name: '__DIET_PREFERENCE__' },\n        })\n\n        if (normalizedDietTypes.length > 0) {\n          await prisma.healthGoal.create({\n            data: {\n              userId: user.id,\n              name: '__DIET_PREFERENCE__',\n              category: JSON.stringify({ dietTypes: Array.from(new Set(normalizedDietTypes)).sort() }),\n              currentRating: 0,\n            },\n          })\n        }\n        console.log('Stored diet preference successfully')\n      }\n    } catch (error) {\n      console.error('Error storing diet preference:', error)\n      // Continue with other updates\n    }\n\n    // 3.25. Handle primary goal + intensity (Step 2) - store as special health goal\n    try {\n      // IMPORTANT: Do not allow empty strings from autosaves (or partial saves) to wipe an existing goal.\n      // This prevents calorie/macros targets from \"fluctuating\" when different pages POST partially-loaded forms.\n      const normalizedIncomingGoalChoice =\n        typeof data.goalChoice === 'string' ? data.goalChoice.trim() : ''\n\n      const normalizedIncomingIntensityRaw =\n        typeof data.goalIntensity === 'string' ? data.goalIntensity.trim().toLowerCase() : ''\n      const isValidIntensity =\n        normalizedIncomingIntensityRaw === 'mild' ||\n        normalizedIncomingIntensityRaw === 'standard' ||\n        normalizedIncomingIntensityRaw === 'aggressive'\n      \n      // Only update the stored primary goal when the request explicitly includes it.\n      // Otherwise, unrelated saves (food snapshot, profile image, etc.) could overwrite the user's goal unintentionally.\n      const shouldUpdatePrimaryGoal = normalizedIncomingGoalChoice.length > 0 || isValidIntensity\n      if (shouldUpdatePrimaryGoal) {\n        const incomingGoalChoice =\n          normalizedIncomingGoalChoice.length > 0\n            ? normalizedIncomingGoalChoice\n            : (existingPrimaryGoalData.goalChoice || '')\n        const incomingGoalIntensity =\n          isValidIntensity\n            ? normalizedIncomingIntensityRaw\n            : (existingPrimaryGoalData.goalIntensity || 'standard').toLowerCase()\n\n        await prisma.healthGoal.deleteMany({\n          where: {\n            userId: user.id,\n            name: '__PRIMARY_GOAL__'\n          }\n        })\n\n        console.log('POST /api/user-data - Persisting primary goal selection', {\n          goalChoice: incomingGoalChoice,\n          goalIntensity: incomingGoalIntensity || 'standard',\n        })\n        await prisma.healthGoal.create({\n          data: {\n            userId: user.id,\n            name: '__PRIMARY_GOAL__',\n            category: JSON.stringify({\n              goalChoice: incomingGoalChoice,\n              goalIntensity: incomingGoalIntensity || 'standard',\n            }),\n            currentRating: 0,\n          }\n        })\n        console.log('Stored primary goal data successfully')\n      }\n    } catch (error) {\n      console.error('Error storing primary goal data:', error)\n      // Continue with other updates\n    }\n\n    // 3.5. Handle blood results data (Step 7) - store as special health goal\n    try {\n      if (data.bloodResults) {\n        // Remove existing blood results data\n        await prisma.healthGoal.deleteMany({\n          where: {\n            userId: user.id,\n            name: '__BLOOD_RESULTS_DATA__'\n          }\n        })\n        \n        // Store new blood results data\n        await prisma.healthGoal.create({\n          data: {\n            userId: user.id,\n            name: '__BLOOD_RESULTS_DATA__',\n            category: JSON.stringify(data.bloodResults),\n            currentRating: 0,\n          }\n        })\n        console.log('Stored blood results data successfully')\n      }\n    } catch (error) {\n      console.error('Error storing blood results data:', error)\n      // Continue with other updates\n    }\n\n    // 4. Handle supplements - optimized bulk replace (deleteMany + createMany)\n    console.time('‚è±Ô∏è Supplements Update')\n    try {\n      console.log('üîç SUPPLEMENT DEBUG - Raw data.supplements:', JSON.stringify(data.supplements, null, 2))\n      \n      if (data.supplements && Array.isArray(data.supplements)) {\n        console.log('üíä Processing', data.supplements.length, 'supplements for user:', user.id)\n        \n        // Validate supplement data before processing\n        const validSupplements = data.supplements.filter((supp: any) => {\n          const isValid = supp && supp.name && typeof supp.name === 'string' && supp.name.trim().length > 0\n          if (!isValid) {\n            console.warn('‚ö†Ô∏è Invalid supplement data:', supp)\n          }\n          return isValid\n        })\n        \n        console.log('‚úÖ Valid supplements to process:', validSupplements.length)\n        \n        if (validSupplements.length === 0) {\n          console.log('‚ö†Ô∏è No valid supplements to save - all supplement data was invalid')\n          return NextResponse.json({ \n            success: true, \n            warning: 'No valid supplements to save',\n            debug: { originalSupplements: data.supplements }\n          })\n        }\n        \n        // Bulk replace for performance: delete all then insert all\n        await prisma.$transaction([\n          prisma.supplement.deleteMany({ where: { userId: user.id } }),\n          prisma.supplement.createMany({\n            data: validSupplements.map((supp: any) => ({\n              userId: user.id,\n              name: supp.name,\n              dosage: supp.dosage || '',\n              timing: Array.isArray(supp.timing) ? supp.timing : [supp.timing || 'morning'],\n              imageUrl: supp.imageUrl || null\n            }))\n          })\n        ])\n        console.log('‚úÖ Replaced supplements via bulk operation:', validSupplements.length)\n        \n        // BACKUP: Also store supplements as JSON in health goals as failsafe\n        try {\n          await prisma.healthGoal.deleteMany({\n            where: {\n              userId: user.id,\n              name: '__SUPPLEMENTS_BACKUP_DATA__'\n            }\n          })\n          \n          await prisma.healthGoal.create({\n            data: {\n              userId: user.id,\n              name: '__SUPPLEMENTS_BACKUP_DATA__',\n              category: JSON.stringify({ supplements: validSupplements, timestamp: new Date().toISOString() }),\n              currentRating: 0,\n            }\n          })\n          console.log('üíæ Created supplements backup in health goals')\n        } catch (backupError) {\n          console.error('‚ùå Failed to create supplements backup:', backupError)\n        }\n        \n      } else {\n        console.log('‚ÑπÔ∏è No supplements to update - data.supplements is:', typeof data.supplements, data.supplements)\n      }\n    } catch (error) {\n      console.error('‚ùå Error updating supplements:', error)\n      console.error('‚ùå Error stack:', error instanceof Error ? error.stack : 'No stack available')\n      \n      // EMERGENCY BACKUP: If supplement save fails completely, store in health goals\n      try {\n        if (data.supplements && Array.isArray(data.supplements) && data.supplements.length > 0) {\n          console.log('üö® EMERGENCY: Saving supplements to health goals as backup')\n          await prisma.healthGoal.deleteMany({\n            where: {\n              userId: user.id,\n              name: '__SUPPLEMENTS_EMERGENCY_BACKUP__'\n            }\n          })\n          \n          await prisma.healthGoal.create({\n            data: {\n              userId: user.id,\n              name: '__SUPPLEMENTS_EMERGENCY_BACKUP__',\n              category: JSON.stringify({ \n                supplements: data.supplements, \n                timestamp: new Date().toISOString(),\n                error: error instanceof Error ? error.message : 'Unknown error'\n              }),\n              currentRating: 0,\n            }\n          })\n          console.log('üö® EMERGENCY backup created successfully')\n        }\n      } catch (emergencyError) {\n        console.error('üí• CRITICAL: Emergency backup also failed:', emergencyError)\n      }\n      \n      // Continue with other updates\n    }\n    console.timeEnd('‚è±Ô∏è Supplements Update')\n\n    // Save device interest if present (hidden goal record)\n    try {\n      if (data && (data as any).deviceInterest && typeof (data as any).deviceInterest === 'object') {\n        const deviceInterest = (data as any).deviceInterest\n        const existing = await prisma.healthGoal.findFirst({ where: { userId: user.id, name: '__DEVICE_INTEREST__' } })\n        if (existing) {\n          await prisma.healthGoal.update({ where: { id: existing.id }, data: { category: JSON.stringify(deviceInterest) } })\n        } else {\n          await prisma.healthGoal.create({ data: { userId: user.id, name: '__DEVICE_INTEREST__', category: JSON.stringify(deviceInterest), currentRating: 0 } })\n        }\n      }\n    } catch (e) {\n      console.log('Device interest save skipped:', e)\n    }\n\n    // 5. Handle medications - optimized bulk replace (deleteMany + createMany)\n    console.time('‚è±Ô∏è Medications Update')\n    try {\n      if (data.medications && Array.isArray(data.medications)) {\n        console.log('üíâ Processing', data.medications.length, 'medications')\n        \n        // Bulk replace for performance: delete all then insert all\n        const validMeds = (data.medications || []).filter((m: any) => m && typeof m.name === 'string' && m.name.trim().length > 0)\n        await prisma.$transaction([\n          prisma.medication.deleteMany({ where: { userId: user.id } }),\n          prisma.medication.createMany({\n            data: validMeds.map((med: any) => ({\n              userId: user.id,\n              name: med.name,\n              dosage: med.dosage || '',\n              timing: Array.isArray(med.timing) ? med.timing : [med.timing || 'morning'],\n              imageUrl: med.imageUrl || null\n            }))\n          })\n        ])\n        console.log('‚úÖ Replaced medications via bulk operation:', validMeds.length)\n      } else {\n        console.log('‚ÑπÔ∏è No medications to update')\n      }\n    } catch (error) {\n      console.error('‚ùå Error updating medications:', error)\n      // Continue with other updates\n    }\n    console.timeEnd('‚è±Ô∏è Medications Update')\n\n    // 6. Handle today's foods data - store as special health goal\n    try {\n      if (data.todaysFoods && Array.isArray(data.todaysFoods)) {\n        // #region agent log\n        try {\n          const appendHistoryFlag = (data as any)?.appendHistory\n          console.log('AGENT_DEBUG', JSON.stringify({\n            hypothesisId: 'A',\n            location: 'app/api/user-data/route.ts:POST:todaysFoods',\n            message: 'Received todaysFoods in /api/user-data',\n            data: {\n              referer: (request.headers.get('referer') || '').slice(0, 200),\n              todaysFoodsLen: data.todaysFoods.length,\n              appendHistory: appendHistoryFlag,\n              hasAppendHistoryKey: data && typeof data === 'object' ? Object.prototype.hasOwnProperty.call(data, 'appendHistory') : false,\n            },\n            timestamp: Date.now(),\n          }))\n        } catch {}\n        // #endregion agent log\n\n        // Remove existing food data\n        await prisma.healthGoal.deleteMany({\n          where: {\n            userId: user.id,\n            name: '__TODAYS_FOODS_DATA__'\n          }\n        })\n        \n        // Store new food data for fast \\\"today\\\" view\n        await prisma.healthGoal.create({\n          data: {\n            userId: user.id,\n            name: '__TODAYS_FOODS_DATA__',\n            category: JSON.stringify({ foods: data.todaysFoods }),\n            currentRating: 0,\n          }\n        })\n        console.log('Stored todays foods data successfully')\n\n        // Also append the latest entry into FoodLog for reliable history,\n        // but ONLY when explicitly requested by the caller.\n        //\n        // IMPORTANT (Dec 2025 bug): Many pages POST /api/user-data as part of \"Health Setup\"\n        // updates while carrying a copy of todaysFoods in memory. If appendHistory defaults\n        // to true, those unrelated saves will create duplicate FoodLog rows (user-visible\n        // duplicates after changing health settings).\n        const appendHistory = data.appendHistory === true\n        if (appendHistory && data.todaysFoods.length > 0) {\n          const last = data.todaysFoods[0]\n          if (last && (last.description || last.nutrition || last.photo)) {\n            try {\n              const rawDescription = (last.description || '').toString()\n              const name =\n                rawDescription\n                  .split('\\\\n')[0]\n                  .split('Calories:')[0]\n                  .split(',')[0]\n                  .split('.')[0]\n                  .trim() || 'Food item'\n\n              const normalizedMeal = (() => {\n                const raw = (last as any)?.meal ?? (last as any)?.category ?? (last as any)?.mealType\n                const value = typeof raw === 'string' ? raw.toLowerCase() : ''\n                if (/breakfast/.test(value)) return 'breakfast'\n                if (/lunch/.test(value)) return 'lunch'\n                if (/dinner/.test(value)) return 'dinner'\n                if (/snack/.test(value)) return 'snacks'\n                if (/uncat/.test(value) || /other/.test(value)) return 'uncategorized'\n                return typeof raw === 'string' && raw.trim().length > 0 ? raw.trim() : null\n              })()\n\n              await prisma.foodLog.create({\n                data: {\n                  userId: user.id,\n                  name,\n                  description: rawDescription || null,\n                  imageUrl: last.photo || null,\n                  nutrients: last.nutrition || null,\n                  items: Array.isArray(last.items) && last.items.length > 0 ? last.items : null,\n                  localDate: (last.localDate as string | null) || null,\n                  meal: normalizedMeal,\n                  category: normalizedMeal,\n                },\n              })\n              console.log('Appended latest food entry to FoodLog for history view')\n\n              // #region agent log\n              try {\n                console.log('AGENT_DEBUG', JSON.stringify({\n                  hypothesisId: 'A',\n                  location: 'app/api/user-data/route.ts:POST:appendFoodLog',\n                  message: 'Appended FoodLog row from /api/user-data (potential duplicate source)',\n                  data: {\n                    referer: (request.headers.get('referer') || '').slice(0, 200),\n                    appendHistory,\n                    namePreview: String(name || '').slice(0, 60),\n                    localDate: typeof (last as any)?.localDate === 'string' ? String((last as any).localDate).slice(0, 10) : null,\n                  },\n                  timestamp: Date.now(),\n                }))\n              } catch {}\n              // #endregion agent log\n            } catch (foodLogError) {\n              console.warn('FoodLog append failed (non-blocking):', foodLogError)\n            }\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error storing todays foods data:', error)\n      // Continue with other updates\n    }\n\n    // 7. Handle favorites data for quick add flow\n    try {\n      if (data && Array.isArray((data as any).favorites)) {\n        const favoritesArray = (data as any).favorites\n        const favoritesCount = Array.isArray(favoritesArray) ? favoritesArray.length : 0\n        const referer = (request.headers.get('referer') || '').slice(0, 200)\n\n        // Load existing favorites to avoid accidental wipes from empty payloads\n        let existingFavGoal: any | null = null\n        let existingFavorites: any[] = []\n        try {\n          existingFavGoal = await prisma.healthGoal.findFirst({\n            where: { userId: user.id, name: '__FOOD_FAVORITES__' },\n          })\n          if (existingFavGoal?.category) {\n            const parsed = JSON.parse(existingFavGoal.category)\n            if (Array.isArray(parsed?.favorites)) existingFavorites = parsed.favorites\n            else if (Array.isArray(parsed)) existingFavorites = parsed\n          }\n        } catch (favLoadErr) {\n          console.warn('AGENT_DEBUG favorites load failed (non-blocking)', favLoadErr)\n        }\n\n        if (favoritesCount === 0 && existingFavorites.length > 0) {\n          console.log('AGENT_DEBUG favorites write skipped (empty payload would wipe existing)', {\n            existingCount: existingFavorites.length,\n            referer,\n          })\n        } else {\n          console.log('AGENT_DEBUG favorites write', { favoritesCount, referer })\n          // Safety: store a backup copy BEFORE overwriting.\n          try {\n            if (existingFavGoal?.category) {\n              await prisma.healthGoal.create({\n                data: {\n                  userId: user.id,\n                  name: `__FOOD_FAVORITES__BACKUP__${Date.now()}`,\n                  category: String(existingFavGoal.category),\n                  currentRating: 0,\n                },\n              })\n\n              // Keep only the most recent backups (best effort).\n              const oldBackups = await prisma.healthGoal.findMany({\n                where: {\n                  userId: user.id,\n                  name: { startsWith: '__FOOD_FAVORITES__BACKUP__' },\n                },\n                orderBy: { createdAt: 'desc' },\n                select: { id: true },\n                skip: 20,\n              })\n              if (oldBackups.length > 0) {\n                await prisma.healthGoal.deleteMany({\n                  where: { id: { in: oldBackups.map((b) => b.id) } },\n                })\n              }\n            }\n          } catch (backupErr) {\n            console.warn('AGENT_DEBUG favorites backup failed (non-blocking)', backupErr)\n          }\n\n          // Avoid delete+create: update the latest record (and prune duplicates) when possible.\n          const existingGoals = await prisma.healthGoal.findMany({\n            where: { userId: user.id, name: '__FOOD_FAVORITES__' },\n            orderBy: { createdAt: 'desc' },\n            select: { id: true },\n          })\n          const primary = existingGoals[0] || null\n          if (primary?.id) {\n            await prisma.healthGoal.update({\n              where: { id: primary.id },\n              data: {\n                category: JSON.stringify({ favorites: favoritesArray }),\n                currentRating: 0,\n              },\n            })\n            if (existingGoals.length > 1) {\n              await prisma.healthGoal.deleteMany({\n                where: { id: { in: existingGoals.slice(1).map((g) => g.id) } },\n              })\n            }\n          } else {\n            await prisma.healthGoal.create({\n              data: {\n                userId: user.id,\n                name: '__FOOD_FAVORITES__',\n                category: JSON.stringify({ favorites: favoritesArray }),\n                currentRating: 0,\n              },\n            })\n          }\n          console.log('Stored favorites data successfully')\n        }\n      }\n    } catch (error) {\n      console.error('Error storing favorites data:', error)\n    }\n\n    // 7b. Handle food name overrides (user renames that should apply across the UI)\n    try {\n      if (data && Array.isArray((data as any).foodNameOverrides)) {\n        const overridesArray = (data as any).foodNameOverrides\n        const existingGoals = await prisma.healthGoal.findMany({\n          where: { userId: user.id, name: '__FOOD_NAME_OVERRIDES__' },\n          orderBy: { createdAt: 'desc' },\n          select: { id: true },\n        })\n        const primary = existingGoals[0] || null\n        if (primary?.id) {\n          await prisma.healthGoal.update({\n            where: { id: primary.id },\n            data: {\n              category: JSON.stringify({ overrides: overridesArray }),\n              currentRating: 0,\n            },\n          })\n          if (existingGoals.length > 1) {\n            await prisma.healthGoal.deleteMany({\n              where: { id: { in: existingGoals.slice(1).map((g) => g.id) } },\n            })\n          }\n        } else {\n          await prisma.healthGoal.create({\n            data: {\n              userId: user.id,\n              name: '__FOOD_NAME_OVERRIDES__',\n              category: JSON.stringify({ overrides: overridesArray }),\n              currentRating: 0,\n            },\n          })\n        }\n      }\n    } catch (error) {\n      console.error('Error storing food name overrides data:', error)\n    }\n\n    // 7c. Handle food library (All tab source list)\n    try {\n      if (data && Array.isArray((data as any).foodLibrary)) {\n        const libraryArray = (data as any).foodLibrary\n        const limited = Array.isArray(libraryArray) ? libraryArray.slice(0, 400) : []\n        const existingGoals = await prisma.healthGoal.findMany({\n          where: { userId: user.id, name: '__FOOD_LIBRARY__' },\n          orderBy: { createdAt: 'desc' },\n          select: { id: true },\n        })\n        const primary = existingGoals[0] || null\n        if (primary?.id) {\n          await prisma.healthGoal.update({\n            where: { id: primary.id },\n            data: {\n              category: JSON.stringify({ items: limited }),\n              currentRating: 0,\n            },\n          })\n          if (existingGoals.length > 1) {\n            await prisma.healthGoal.deleteMany({\n              where: { id: { in: existingGoals.slice(1).map((g) => g.id) } },\n            })\n          }\n        } else {\n          await prisma.healthGoal.create({\n            data: {\n              userId: user.id,\n              name: '__FOOD_LIBRARY__',\n              category: JSON.stringify({ items: limited }),\n              currentRating: 0,\n            },\n          })\n        }\n      }\n    } catch (error) {\n      console.error('Error storing food library data:', error)\n    }\n\n    // 8. Handle profileInfo data from profile page - store as special health goal\n    try {\n      const incomingProfileInfo =\n        data.profileInfo && typeof data.profileInfo === 'object'\n          ? data.profileInfo\n          : null\n\n      let shouldUpdateProfileInfo = false\n      let profileInfoPayload: Record<string, any> | null = null\n\n      if (incomingProfileInfo) {\n        shouldUpdateProfileInfo = true\n        profileInfoPayload = {\n          ...(existingProfileInfoData || {}),\n          ...incomingProfileInfo,\n        }\n      }\n\n      if (normalizedBirthdate) {\n        if (!profileInfoPayload) {\n          profileInfoPayload = { ...(existingProfileInfoData || {}) }\n        }\n        if (profileInfoPayload.dateOfBirth !== normalizedBirthdate) {\n          profileInfoPayload.dateOfBirth = normalizedBirthdate\n          shouldUpdateProfileInfo = true\n        }\n      }\n\n      if (effectiveBirthdate && profileInfoPayload && !profileInfoPayload.dateOfBirth) {\n        profileInfoPayload.dateOfBirth = effectiveBirthdate\n        shouldUpdateProfileInfo = true\n      }\n\n      if (shouldUpdateProfileInfo && profileInfoPayload) {\n        console.log('POST /api/user-data - Handling profileInfo data:', profileInfoPayload)\n        if (effectiveBirthdate) {\n          profileInfoPayload.dateOfBirth = effectiveBirthdate\n        } else if (!profileInfoPayload.dateOfBirth && existingProfileInfoData?.dateOfBirth) {\n          profileInfoPayload.dateOfBirth = existingProfileInfoData.dateOfBirth\n        }\n        \n        // Update basic User fields if available in profileInfo\n        const profileUpdateData: any = {}\n        const firstName = profileInfoPayload.firstName || ''\n        const lastName = profileInfoPayload.lastName || ''\n        \n        // Handle name concatenation\n        if (firstName || lastName) {\n          profileUpdateData.name = `${firstName} ${lastName}`.trim()\n        }\n        \n        // Handle gender\n        if (profileInfoPayload.gender) {\n          profileUpdateData.gender = profileInfoPayload.gender.toUpperCase() === 'MALE' ? 'MALE' : 'FEMALE'\n        }\n        \n        // Update User model with basic profile data\n        if (Object.keys(profileUpdateData).length > 0) {\n          await prisma.user.update({\n            where: { id: user.id },\n            data: profileUpdateData\n          })\n          console.log('Updated user profile basic data:', profileUpdateData)\n        }\n        \n        // Store full profileInfo as special health goal for additional fields like bio, dateOfBirth\n        await prisma.healthGoal.deleteMany({\n          where: {\n            userId: user.id,\n            name: '__PROFILE_INFO_DATA__'\n          }\n        })\n        \n        await prisma.healthGoal.create({\n          data: {\n            userId: user.id,\n            name: '__PROFILE_INFO_DATA__',\n            category: JSON.stringify(profileInfoPayload),\n            currentRating: 0,\n          }\n        })\n        console.log('Stored profile info data successfully')\n      }\n    } catch (error) {\n      console.error('Error storing profile info data:', error)\n      // Continue with other updates\n    }\n\n    console.log('‚úÖ POST /api/user-data - All updates completed successfully')\n\n    const insightsAutoEnabled = process.env.ENABLE_INSIGHTS_BACKGROUND_REGEN === 'true'\n    let insightsUpdateRequired = false\n\n    if (user?.id) {\n      // Determine whether this payload represents a complete onboarding submission\n      const isFullOnboarding = !!(data.gender && data.weight && data.height && \n        (data.goals?.length || data.supplements?.length || data.medications?.length))\n\n      const changedTypes: Array<\n        'supplements' | 'medications' | 'food' | 'exercise' | 'health_goals' | 'health_situations' | 'profile' | 'blood_results'\n      > = []\n      if (!isFullOnboarding) {\n        if (data.supplements) changedTypes.push('supplements')\n        if (data.medications) changedTypes.push('medications')\n        if (data.goals) changedTypes.push('health_goals')\n        if (data.healthSituations) changedTypes.push('health_situations')\n        const profileFieldsUpdated = Boolean(\n          data.gender ||\n            data.weight ||\n            data.height ||\n            data.bodyType ||\n            birthdateChanged ||\n            (data.profileInfo && typeof data.profileInfo === 'object')\n        )\n        if (profileFieldsUpdated) changedTypes.push('profile')\n        if (data.exerciseFrequency || data.exerciseTypes) changedTypes.push('exercise')\n        if (data.bloodResults) changedTypes.push('blood_results')\n        if (data.todaysFoods) changedTypes.push('food')\n      }\n\n      insightsUpdateRequired = isFullOnboarding || changedTypes.length > 0\n\n      if (insightsAutoEnabled) {\n        // Charge credits and generate insights automatically (legacy behaviour; now gated)\n        if (isFullOnboarding) {\n          try {\n            const cm = new CreditManager(user.id)\n            const hasCredits = await cm.checkCredits('INSIGHTS_GENERATION')\n            \n            if (hasCredits.hasCredits) {\n              const costCents = CREDIT_COSTS.INSIGHTS_GENERATION\n              const charged = await cm.chargeCents(costCents)\n              \n              if (charged) {\n                await prisma.user.update({\n                  where: { id: user.id },\n                  data: {\n                    monthlyInsightsGenerationUsed: { increment: 1 },\n                  } as any,\n                })\n                console.log('‚úÖ Charged credits for insights generation:', costCents)\n              } else {\n                console.warn('‚ö†Ô∏è Insufficient credits for insights generation, skipping')\n              }\n            }\n          } catch (error) {\n            console.warn('‚ö†Ô∏è Failed to charge credits for insights generation:', error)\n          }\n        }\n        \n        if (isFullOnboarding) {\n          try {\n            console.log('üöÄ Generating FULL insights for user:', user.id)\n            const fullInsightsPromise = precomputeIssueSectionsForUser(user.id, { concurrency: 4 })\n            \n            await Promise.race([\n              fullInsightsPromise.then(() => {\n                console.log('‚úÖ Full insights generation completed')\n                return 'done'\n              }),\n              new Promise((resolve) => setTimeout(() => {\n                console.log('‚è±Ô∏è Full insights generation timed out after 30s, continuing in background')\n                resolve('timeout')\n              }, 30000)),\n            ])\n            \n            fullInsightsPromise.catch((error) => {\n              console.warn('‚ö†Ô∏è Full insights generation error (continuing):', error)\n            })\n          } catch (e) {\n            console.warn('‚ö†Ô∏è Full insights generation failed (continuing):', e)\n          }\n        } else {\n          try {\n            console.log('üöÄ Priming insights QUICK cache for user:', user.id)\n            const quickPriming = precomputeQuickSectionsForUser(user.id, { concurrency: 4 })\n            await Promise.race([\n              quickPriming.then(() => 'done'),\n              new Promise((resolve) => setTimeout(() => resolve('timeout'), 6500)),\n            ])\n            console.log('‚úÖ Quick cache priming finished or timed out (<=6.5s)')\n          } catch (e) {\n            console.warn('‚ö†Ô∏è Quick cache priming failed (continuing):', e)\n          }\n          try {\n            precomputeIssueSectionsForUser(user.id, { concurrency: 4 }).catch(() => {})\n          } catch {}\n        }\n\n        if (!isFullOnboarding && changedTypes.length > 0) {\n          try {\n            console.log('üöÄ Generating ALL insights after health data update for user:', user.id)\n            precomputeIssueSectionsForUser(user.id, { concurrency: 4 }).catch((error) => {\n              console.warn('‚ö†Ô∏è Failed to generate insights after health data update:', error)\n            })\n            console.log(`üîÑ Triggered full insights generation after health data changes: ${changedTypes.join(', ')}`)\n          } catch (error) {\n            console.warn('‚ö†Ô∏è Error triggering insights generation:', error)\n          }\n        }\n      } else if (insightsUpdateRequired) {\n        console.log('‚è∏Ô∏è Insights auto-generation skipped (disabled via ENABLE_INSIGHTS_BACKGROUND_REGEN)', {\n          userId: user.id,\n          isFullOnboarding,\n          changedTypes\n        })\n      }\n    }\n\n    // üîç FINAL PERFORMANCE MEASUREMENT\n    const totalApiTime = Date.now() - apiStartTime\n    console.timeEnd('‚è±Ô∏è Total API Processing Time')\n    console.log('üìä API PERFORMANCE SUMMARY:', {\n      totalProcessingTime: totalApiTime + 'ms',\n      userId: user.id,\n      email: userEmail,\n      timestamp: new Date().toISOString()\n    })\n    \n    return NextResponse.json({ \n      success: true, \n      message: 'Data saved successfully',\n      insightsUpdateRequired,\n      insightsAutoGenerationEnabled: insightsAutoEnabled,\n      debug: {\n        userId: user.id,\n        email: userEmail,\n        timestamp: new Date().toISOString(),\n        processingTime: totalApiTime + 'ms'\n      }\n    })\n    \n  } catch (error) {\n    console.error('CRITICAL ERROR in POST /api/user-data:', error)\n    console.error('Error stack:', error instanceof Error ? error.stack : 'No stack available')\n    \n    return NextResponse.json({ \n      error: 'Failed to save data', \n      debug: {\n        message: error instanceof Error ? error.message : 'Unknown error',\n        timestamp: new Date().toISOString()\n      }\n    }, { status: 500 })\n  }\n}\n\nexport async function DELETE(request: NextRequest) {\n  try {\n    // Get NextAuth session\n    const session = await getServerSession(authOptions)\n    \n    if (!session?.user?.email) {\n      console.log('DELETE Authentication failed - no valid session found')\n      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 })\n    }\n    \n    const userEmail = session.user.email\n    console.log('DELETE /api/user-data - NextAuth session found for:', userEmail)\n\n    // Find user by email\n    const user = await prisma.user.findUnique({\n      where: { email: userEmail }\n    })\n\n    if (!user) {\n      return NextResponse.json({ error: 'User not found' }, { status: 404 })\n    }\n\n    // Delete all user-related data\n    await prisma.healthGoal.deleteMany({\n      where: { userId: user.id }\n    })\n    \n    await prisma.supplement.deleteMany({\n      where: { userId: user.id }\n    })\n    \n    await prisma.medication.deleteMany({\n      where: { userId: user.id }\n    })\n\n    // Reset user profile data\n    await prisma.user.update({\n      where: { id: user.id },\n      data: {\n        gender: null,\n        weight: null,\n        height: null,\n        bodyType: null\n      }\n    })\n\n    console.log('Successfully deleted all user data for:', userEmail)\n    return NextResponse.json({ success: true, message: 'All data deleted successfully' })\n  } catch (error) {\n    console.error('Error deleting user data:', error)\n    return NextResponse.json({ error: 'Failed to delete data' }, { status: 500 })\n  }\n} \n","truncated":false,"size":64259},{"path":"app/api/vercel/spend-webhook/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { sendVercelSpendAlertEmail } from '@/lib/admin-alerts'\n\nfunction getIncomingSecret(request: NextRequest): string | null {\n  const authHeader = request.headers.get('authorization') || ''\n  if (authHeader.toLowerCase().startsWith('bearer ')) {\n    return authHeader.slice(7).trim() || null\n  }\n  try {\n    const url = new URL(request.url)\n    return url.searchParams.get('secret')\n  } catch {\n    return null\n  }\n}\n\nexport async function POST(request: NextRequest) {\n  const expectedSecret = process.env.VERCEL_SPEND_WEBHOOK_SECRET\n  if (!expectedSecret) {\n    console.error('‚ùå Vercel spend webhook secret not configured')\n    return NextResponse.json({ error: 'Webhook secret not configured' }, { status: 500 })\n  }\n\n  const incomingSecret = getIncomingSecret(request)\n  if (incomingSecret !== expectedSecret) {\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  }\n\n  let payload: unknown = null\n  try {\n    payload = await request.json()\n  } catch (error) {\n    console.error('‚ùå Failed to parse Vercel spend webhook payload:', error)\n  }\n\n  const recipientEmail = (process.env.OWNER_EMAIL || 'louie@helfi.ai').trim() || 'louie@helfi.ai'\n  sendVercelSpendAlertEmail({ recipientEmail, payload }).catch((error) => {\n    console.error('‚ùå Vercel spend alert email failed (non-blocking):', error)\n  })\n\n  return NextResponse.json({ ok: true })\n}\n","truncated":false,"size":1434},{"path":"app/api/waitlist/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\nimport { extractAdminFromHeaders } from '@/lib/admin-auth'\nimport { Resend } from 'resend'\nimport { getEmailFooter } from '@/lib/email-footer'\n\n// Initialize Resend for emails\nfunction getResend() {\n  if (!process.env.RESEND_API_KEY) {\n    console.log('üìß Resend API not configured, skipping waitlist emails')\n    return null\n  }\n  return new Resend(process.env.RESEND_API_KEY)\n}\n\n// Send acknowledgment email to user\n/**\n * ‚ö†Ô∏è CRITICAL: DO NOT MODIFY THIS FUNCTION'S ERROR HANDLING PATTERN\n * \n * This function was fixed after breaking due to overly strict error checking.\n * The working pattern matches sendWaitlistNotificationEmail() exactly.\n * \n * IMPORTANT PATTERNS TO MAINTAIN:\n * 1. Do NOT check emailResponse.error and throw - this breaks email delivery\n * 2. Do NOT await this function in POST handler - use .catch() pattern instead\n * 3. Only log success/failure - do not throw errors that block the API response\n * 4. Match the exact pattern used in sendWaitlistNotificationEmail() which works\n * \n * If you need to modify this function:\n * - Test with a real email address first\n * - Ensure BOTH acknowledgment AND notification emails still work\n * - Do NOT add error checking that throws exceptions\n * - Keep the same async non-blocking pattern\n * \n * Last fixed: 2025-11-12 - Removed strict error checking that prevented delivery\n * See WAITLIST_EMAIL_PROTECTION.md for full details\n */\nasync function sendWaitlistAcknowledgmentEmail(email: string, name: string) {\n  const resend = getResend()\n  if (!resend) {\n    console.log('üìß [WAITLIST ACK] Resend not configured, skipping email to', email)\n    return\n  }\n\n  try {\n    console.log(`üìß [WAITLIST ACK] Attempting to send email to ${email} for ${name}`)\n    \n    const emailResponse = await resend.emails.send({\n      from: 'Helfi Team <support@helfi.ai>',\n      to: email,\n      subject: 'üéâ Welcome to the Helfi Waitlist!',\n      html: `\n        <div style=\"font-family: 'Segoe UI', Arial, sans-serif; max-width: 600px; margin: 0 auto; color: #333; background: #f8fafc;\">\n          <div style=\"background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; padding: 40px 30px; text-align: center; border-radius: 12px 12px 0 0;\">\n            <h1 style=\"margin: 0; font-size: 32px; font-weight: bold; letter-spacing: -0.5px;\">Helfi</h1>\n            <p style=\"margin: 12px 0 0 0; opacity: 0.95; font-size: 16px;\">Your AI-Powered Health Coach</p>\n          </div>\n          \n          <div style=\"padding: 40px 30px; background: white; border-radius: 0 0 12px 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);\">\n            <h2 style=\"margin: 0 0 20px 0; color: #374151; font-size: 24px;\">üéâ You're on the Waitlist!</h2>\n            \n            <p style=\"margin: 18px 0; line-height: 1.7; font-size: 16px; color: #4b5563;\">\n              Hi ${(name || 'there').replace(/</g, '&lt;').replace(/>/g, '&gt;')},\n            </p>\n            \n            <p style=\"margin: 18px 0; line-height: 1.7; font-size: 16px; color: #4b5563;\">\n              Thank you for joining the Helfi waitlist! We're thrilled to have you on board as we prepare to launch our revolutionary AI-powered health intelligence platform.\n            </p>\n            \n            <p style=\"margin: 18px 0; line-height: 1.7; font-size: 16px; color: #4b5563;\">\n              <strong>What happens next?</strong>\n            </p>\n            \n            <ul style=\"margin: 18px 0; padding-left: 24px; line-height: 1.8; font-size: 16px; color: #4b5563;\">\n              <li>You'll be among the first to know when we launch</li>\n              <li>We'll send you exclusive early access invitations</li>\n              <li>You'll receive health optimization tips and platform updates</li>\n              <li>Get special launch pricing and bonuses</li>\n            </ul>\n            \n            <div style=\"background: #ecfdf5; border: 1px solid #10b981; border-radius: 8px; padding: 20px; margin: 30px 0;\">\n              <p style=\"margin: 0; color: #065f46; font-size: 16px; font-weight: 600;\">\n                üöÄ We're building something amazing, and you're going to love it!\n              </p>\n            </div>\n            \n            <div style=\"margin-top: 40px; padding-top: 30px; border-top: 2px solid #e5e7eb; text-align: center;\">\n              <a href=\"https://helfi.ai\" style=\"display: inline-block; background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; text-decoration: none; padding: 16px 32px; border-radius: 8px; font-weight: 600; font-size: 16px; margin: 10px 0; box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);\">üåê Visit Helfi.ai</a>\n            </div>\n            \n            ${getEmailFooter({ recipientEmail: email, emailType: 'waitlist' })}\n          </div>\n        </div>\n      `\n    })\n\n    // Log response - match the pattern used in working notification email\n    // DO NOT add error checking here - it breaks email delivery\n    // See WAITLIST_EMAIL_PROTECTION.md for why this pattern is critical\n    console.log(`‚úÖ [WAITLIST ACK EMAIL] Sent to ${email} with ID: ${emailResponse.data?.id}`)\n  } catch (error: any) {\n    console.error(`‚ùå [WAITLIST ACK EMAIL] Failed to send to ${email}:`, error)\n    console.error(`‚ùå [WAITLIST ACK EMAIL] Error details:`, {\n      message: error?.message,\n      stack: error?.stack,\n      errorName: error?.name,\n      email: email,\n      userName: name\n    })\n  }\n}\n\n// Send notification email to support team\nasync function sendWaitlistNotificationEmail(email: string, name: string) {\n  const resend = getResend()\n  if (!resend) {\n    return\n  }\n\n  try {\n    const emailResponse = await resend.emails.send({\n      from: 'Helfi Waitlist <support@helfi.ai>',\n      to: 'support@helfi.ai',\n      subject: `üéâ New Waitlist Signup: ${name}`,\n      html: `\n        <div style=\"font-family: 'Segoe UI', Arial, sans-serif; max-width: 600px; margin: 0 auto; color: #333; background: #f8fafc;\">\n          <div style=\"background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; padding: 40px 30px; text-align: center; border-radius: 12px 12px 0 0;\">\n            <h1 style=\"margin: 0; font-size: 32px; font-weight: bold; letter-spacing: -0.5px;\">New Waitlist Signup</h1>\n          </div>\n          \n          <div style=\"padding: 40px 30px; background: white; border-radius: 0 0 12px 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);\">\n            <h2 style=\"margin: 0 0 20px 0; color: #374151; font-size: 24px;\">üéâ Someone Just Joined the Waitlist!</h2>\n            \n            <div style=\"background: #f0f9ff; border: 1px solid #0ea5e9; border-radius: 8px; padding: 20px; margin: 20px 0;\">\n              <p style=\"margin: 0 0 10px 0; color: #0c4a6e; font-size: 16px;\">\n                <strong>Name:</strong> ${name}\n              </p>\n              <p style=\"margin: 0; color: #0c4a6e; font-size: 16px;\">\n                <strong>Email:</strong> ${email}\n              </p>\n              <p style=\"margin: 10px 0 0 0; color: #0c4a6e; font-size: 14px;\">\n                <strong>Signed up:</strong> ${new Date().toLocaleString()}\n              </p>\n            </div>\n            \n            <p style=\"margin: 18px 0; line-height: 1.7; font-size: 16px; color: #4b5563;\">\n              This person has been added to the waitlist and has received a welcome email.\n            </p>\n            \n            <div style=\"margin-top: 30px; padding-top: 20px; border-top: 1px solid #e5e7eb; text-align: center;\">\n              <a href=\"https://helfi.ai/admin-panel\" style=\"display: inline-block; background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; text-decoration: none; padding: 12px 24px; border-radius: 8px; font-weight: 600; font-size: 14px;\">View Admin Panel</a>\n            </div>\n          </div>\n        </div>\n      `\n    })\n\n    console.log(`‚úÖ [WAITLIST NOTIFICATION] Sent to support@helfi.ai for ${email}`)\n  } catch (error) {\n    console.error(`‚ùå [WAITLIST NOTIFICATION] Failed to send:`, error)\n  }\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    const { email, name } = await request.json()\n    const normalizedEmail = (email || '').trim().toLowerCase()\n    const normalizedName = (name || '').trim()\n\n    if (!normalizedEmail || !normalizedName) {\n      return NextResponse.json(\n        { error: 'Name and email are required' },\n        { status: 400 }\n      )\n    }\n\n    // Ensure unsubscribed column exists\n    try {\n      await prisma.$executeRawUnsafe(`\n        ALTER TABLE \"Waitlist\" \n        ADD COLUMN IF NOT EXISTS \"unsubscribed\" BOOLEAN NOT NULL DEFAULT false\n      `)\n    } catch (e) {\n      // Column might already exist, ignore error\n    }\n\n    // Check if email already exists\n    // Use try-catch to handle schema migration period gracefully\n    let existingEntry = null\n    try {\n      existingEntry = await prisma.waitlist.findUnique({\n        where: { email: normalizedEmail }\n      })\n    } catch (schemaError: any) {\n      // If schema error (missing columns), try raw query as fallback\n      console.warn('Schema error checking existing entry, trying raw query:', schemaError?.message)\n      const escapedEmail = normalizedEmail.replace(/'/g, \"''\")\n      const rawEntries = await prisma.$queryRawUnsafe(`\n        SELECT id, email, name, \"createdAt\", COALESCE(unsubscribed, false) as unsubscribed\n        FROM \"Waitlist\" \n        WHERE LOWER(email) = LOWER('${escapedEmail}')\n        LIMIT 1\n      `) as Array<{ id: string; email: string; name: string; createdAt: Date; unsubscribed: boolean }>\n      \n      if (rawEntries.length > 0) {\n        existingEntry = rawEntries[0] as any\n      }\n    }\n\n    if (existingEntry) {\n      // If they previously unsubscribed but are signing up again, re-subscribe them\n      const isUnsubscribed = existingEntry.unsubscribed === true\n      if (isUnsubscribed) {\n        // Re-subscribe them - update the existing entry\n        try {\n          await prisma.waitlist.update({\n            where: { id: existingEntry.id },\n            data: {\n              unsubscribed: false,\n              name: normalizedName // Update name in case it changed\n            }\n          })\n        } catch (updateError: any) {\n          // If Prisma fails, use raw SQL\n          console.warn('Prisma update failed, using raw SQL:', updateError?.message)\n          const escapedEmail = normalizedEmail.replace(/'/g, \"''\")\n          const escapedName = normalizedName.replace(/'/g, \"''\")\n          await prisma.$executeRawUnsafe(`\n            UPDATE \"Waitlist\" \n            SET unsubscribed = false, name = '${escapedName}'\n            WHERE LOWER(email) = LOWER('${escapedEmail}')\n          `)\n        }\n        \n        // Send welcome email since they're re-subscribing\n        sendWaitlistAcknowledgmentEmail(normalizedEmail, normalizedName).catch(error => {\n          console.error('‚ùå [WAITLIST] Re-subscription email failed (non-blocking):', error)\n        })\n        \n        return NextResponse.json({\n          success: true,\n          message: 'Welcome back! You\\'ve been re-added to the waitlist.'\n        })\n      }\n      // Already on waitlist and not unsubscribed - return friendly message\n      return NextResponse.json({\n        success: true,\n        message: 'You\\'re already on the waitlist. We\\'ll notify you when we go live.'\n      })\n    }\n\n    // Add to waitlist\n    // Handle schema migration period - only include fields that exist\n    let waitlistEntry\n    try {\n      waitlistEntry = await prisma.waitlist.create({\n        data: {\n          email: normalizedEmail,\n          name: normalizedName\n        }\n      })\n    } catch (createError: any) {\n      // If create fails due to schema mismatch, try raw insert\n      console.warn('Schema error creating entry, trying raw insert:', createError?.message)\n      const escapedEmail = normalizedEmail.replace(/'/g, \"''\")\n      const escapedName = normalizedName.replace(/'/g, \"''\")\n      \n      await prisma.$executeRawUnsafe(`\n        INSERT INTO \"Waitlist\" (id, email, name, \"createdAt\")\n        VALUES (gen_random_uuid()::text, '${escapedEmail}', '${escapedName}', NOW())\n      `)\n      \n      // Get the created entry\n      const rawEntries = await prisma.$queryRawUnsafe(`\n        SELECT id, email, name, \"createdAt\" \n        FROM \"Waitlist\" \n        WHERE email = '${escapedEmail}'\n        ORDER BY \"createdAt\" DESC\n        LIMIT 1\n      `) as Array<{ id: string; email: string; name: string; createdAt: Date }>\n      \n      if (rawEntries.length === 0) {\n        throw new Error('Failed to create waitlist entry')\n      }\n      \n      waitlistEntry = rawEntries[0] as any\n    }\n\n    // ‚ö†Ô∏è CRITICAL: DO NOT CHANGE THIS PATTERN\n    // Both emails use non-blocking .catch() pattern - do NOT await or use try/catch here\n    // This pattern matches the working notification email exactly\n    // Changing this will break email delivery as it did before (fixed 2025-11-12)\n    // Only send email if not unsubscribed (check safely)\n    const isUnsubscribed = waitlistEntry?.unsubscribed === true\n    if (!isUnsubscribed) {\n      sendWaitlistAcknowledgmentEmail(normalizedEmail, normalizedName).catch(error => {\n        console.error('‚ùå [WAITLIST] Acknowledgment email failed (non-blocking):', error)\n      })\n    }\n\n    // Send notification email to support team (don't await to avoid blocking response)\n    sendWaitlistNotificationEmail(normalizedEmail, normalizedName).catch(error => {\n      console.error('‚ùå [WAITLIST] Notification email failed (non-blocking):', error)\n    })\n\n    return NextResponse.json({ \n      success: true, \n      message: 'Successfully added to waitlist',\n      id: waitlistEntry.id\n    })\n\n  } catch (error) {\n    console.error('Error adding to waitlist:', error)\n    return NextResponse.json(\n      { error: 'Failed to add to waitlist' },\n      { status: 500 }\n    )\n  }\n}\n\nexport async function GET(request: NextRequest) {\n  try {\n    // JWT authentication check\n    const authHeader = request.headers.get('authorization')\n    const admin = extractAdminFromHeaders(authHeader)\n    \n    if (!admin) {\n      return NextResponse.json(\n        { error: 'Unauthorized' },\n        { status: 401 }\n      )\n    }\n\n    // Ensure unsubscribed column exists (for migration period)\n    try {\n      await prisma.$executeRawUnsafe(`\n        ALTER TABLE \"Waitlist\" \n        ADD COLUMN IF NOT EXISTS \"unsubscribed\" BOOLEAN NOT NULL DEFAULT false\n      `)\n    } catch (e) {\n      // Column might already exist, ignore error\n    }\n\n    // IMPORTANT: Filter out unsubscribed entries - they should not appear in active waitlist\n    // Use raw query with proper column check to ensure filtering works\n    try {\n      // Check if unsubscribed column exists by trying to query it\n      const rawEntries = await prisma.$queryRawUnsafe(`\n        SELECT id, email, name, \"createdAt\"\n        FROM \"Waitlist\" \n        WHERE (unsubscribed IS NULL OR unsubscribed = false)\n        ORDER BY \"createdAt\" DESC\n      `) as Array<{ id: string; email: string; name: string; createdAt: Date }>\n      \n      console.log(`üìã Returning ${rawEntries.length} active waitlist entries (filtered out unsubscribed)`)\n      return NextResponse.json({ waitlist: rawEntries })\n    } catch (rawError: any) {\n      // If column doesn't exist, the WHERE clause will fail - return all entries\n      console.warn('Unsubscribed column may not exist yet:', rawError?.message)\n      try {\n        const rawEntries = await prisma.$queryRawUnsafe(`\n          SELECT id, email, name, \"createdAt\" \n          FROM \"Waitlist\" \n          ORDER BY \"createdAt\" DESC\n        `) as Array<{ id: string; email: string; name: string; createdAt: Date }>\n        \n        return NextResponse.json({ waitlist: rawEntries })\n      } catch (fallbackError: any) {\n        console.error('Failed to fetch waitlist:', fallbackError)\n        return NextResponse.json({ waitlist: [] })\n      }\n    }\n\n  } catch (error: any) {\n    console.error('Error fetching waitlist:', error)\n    console.error('Error details:', {\n      message: error?.message,\n      code: error?.code,\n      meta: error?.meta\n    })\n    return NextResponse.json(\n      { error: 'Failed to fetch waitlist: ' + (error?.message || 'Unknown error') },\n      { status: 500 }\n    )\n  }\n}\n\nexport async function DELETE(request: NextRequest) {\n  try {\n    // JWT authentication check\n    const authHeader = request.headers.get('authorization')\n    const admin = extractAdminFromHeaders(authHeader)\n    \n    if (!admin) {\n      return NextResponse.json(\n        { error: 'Unauthorized' },\n        { status: 401 }\n      )\n    }\n\n    const { id } = await request.json()\n\n    if (!id) {\n      return NextResponse.json(\n        { error: 'Waitlist entry ID is required' },\n        { status: 400 }\n      )\n    }\n\n    // Delete the waitlist entry\n    // Use deleteMany to be more resilient to schema changes\n    const result = await prisma.waitlist.deleteMany({\n      where: { id }\n    })\n\n    if (result.count === 0) {\n      return NextResponse.json(\n        { error: 'Waitlist entry not found' },\n        { status: 404 }\n      )\n    }\n\n    return NextResponse.json({ \n      success: true,\n      message: 'Waitlist entry deleted successfully'\n    })\n\n  } catch (error: any) {\n    console.error('Error deleting waitlist entry:', error)\n    console.error('Error details:', {\n      message: error?.message,\n      code: error?.code,\n      meta: error?.meta\n    })\n    return NextResponse.json(\n      { error: 'Failed to delete waitlist entry: ' + (error?.message || 'Unknown error') },\n      { status: 500 }\n    )\n  }\n} \n","truncated":false,"size":17636},{"path":"app/auth/check-email/page.tsx","content":"'use client'\n\nimport Link from 'next/link'\nimport Image from 'next/image'\nimport { useState, Suspense } from 'react'\nimport { useSearchParams } from 'next/navigation'\n\nfunction CheckEmailContent() {\n  const [isResending, setIsResending] = useState(false)\n  const [resendMessage, setResendMessage] = useState('')\n  const searchParams = useSearchParams()\n  const email = searchParams.get('email')\n\n  const handleResendEmail = async () => {\n    if (!email) return\n    \n    setIsResending(true)\n    setResendMessage('')\n    \n    try {\n      const response = await fetch('/api/auth/resend-verification', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({ email }),\n      })\n      \n      if (response.ok) {\n        setResendMessage('‚úÖ Verification email sent! Please check your inbox.')\n      } else {\n        setResendMessage('‚ùå Failed to resend email. Please try again.')\n      }\n    } catch (error) {\n      setResendMessage('‚ùå Something went wrong. Please try again.')\n    } finally {\n      setIsResending(false)\n    }\n  }\n\n  return (\n    <div className=\"min-h-screen flex items-center justify-center bg-gradient-to-b from-white to-helfi-green-light/10 p-4\">\n      <div className=\"max-w-md w-full space-y-8 text-center\">\n        {/* Logo */}\n        <div className=\"flex justify-center\">\n          <Link href=\"/\" className=\"relative w-24 h-24\">\n            <Image\n              src=\"/mobile-assets/LOGOS/helfi-01-01.png\"\n              alt=\"Helfi Logo\"\n              fill\n              className=\"object-contain\"\n              priority\n            />\n          </Link>\n        </div>\n\n        <div className=\"space-y-6\">\n          {/* Email Icon */}\n          <div className=\"w-20 h-20 bg-helfi-green-light/20 rounded-full flex items-center justify-center mx-auto\">\n            <svg className=\"w-10 h-10 text-helfi-green\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z\" />\n            </svg>\n          </div>\n\n          {/* Main Content */}\n          <div className=\"space-y-4\">\n            <h2 className=\"text-3xl font-bold text-helfi-black\">Check Your Email</h2>\n            <p className=\"text-gray-600 text-lg\">\n              We've sent a verification link to:\n            </p>\n            {email && (\n              <div className=\"bg-helfi-green-light/10 border border-helfi-green-light rounded-lg p-3\">\n                <p className=\"font-medium text-helfi-green\">{email}</p>\n              </div>\n            )}\n            <p className=\"text-gray-600\">\n              Click the verification link in your email to activate your account and start your health journey with Helfi.\n            </p>\n          </div>\n\n          {/* Action Buttons */}\n          <div className=\"space-y-4\">\n            <div className=\"bg-blue-50 border border-blue-200 rounded-lg p-4\">\n              <div className=\"flex items-start space-x-3\">\n                <svg className=\"w-5 h-5 text-blue-500 mt-0.5 flex-shrink-0\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z\" />\n                </svg>\n                <div className=\"text-left\">\n                  <p className=\"text-sm font-medium text-blue-800\">Can't find the email?</p>\n                  <p className=\"text-sm text-blue-700\">Check your spam folder or request a new verification email.</p>\n                </div>\n              </div>\n            </div>\n\n            {/* Resend Button */}\n            <button\n              onClick={handleResendEmail}\n              disabled={isResending || !email}\n              className=\"w-full bg-helfi-green text-white px-6 py-3 rounded-lg hover:bg-helfi-green-dark transition-colors font-medium disabled:opacity-50 disabled:cursor-not-allowed\"\n            >\n              {isResending ? 'Sending...' : 'Resend Verification Email'}\n            </button>\n\n            {resendMessage && (\n              <div className={`p-3 rounded-lg text-sm ${\n                resendMessage.includes('‚úÖ') \n                  ? 'bg-green-50 border border-green-200 text-green-700'  \n                  : 'bg-red-50 border border-red-200 text-red-700'\n              }`}>\n                {resendMessage}\n              </div>\n            )}\n\n            {/* Secondary Actions */}\n            <div className=\"space-y-2 pt-4 border-t border-gray-200\">\n              <Link\n                href=\"/auth/signin\"\n                className=\"text-helfi-green hover:text-helfi-green-dark font-medium text-sm inline-block\"\n              >\n                Already verified? Sign in\n              </Link>\n              <br />\n              <Link\n                href=\"/support\"\n                className=\"text-gray-500 hover:text-gray-700 text-sm inline-block\"\n              >\n                Need help? Contact support\n              </Link>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  )\n}\n\nexport default function CheckEmailPage() {\n  return (\n    <Suspense fallback={\n      <div className=\"min-h-screen flex items-center justify-center bg-gradient-to-b from-white to-helfi-green-light/10 p-4\">\n        <div className=\"animate-spin rounded-full h-12 w-12 border-b-2 border-helfi-green\"></div>\n      </div>\n    }>\n      <CheckEmailContent />\n    </Suspense>\n  )\n} ","truncated":false,"size":5571},{"path":"app/auth/forgot-password/page.tsx","content":"'use client'\n\nimport { useState } from 'react'\nimport Link from 'next/link'\n\nexport default function ForgotPasswordPage() {\n  const [email, setEmail] = useState('')\n  const [loading, setLoading] = useState(false)\n  const [error, setError] = useState('')\n  const [message, setMessage] = useState('')\n\n  const handleSubmit = async (e: React.FormEvent) => {\n    e.preventDefault()\n    setLoading(true)\n    setError('')\n    setMessage('')\n    try {\n      const res = await fetch('/api/auth/password-reset/request', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ email: email.trim().toLowerCase() }),\n      })\n      if (!res.ok) {\n        const data = await res.json().catch(() => ({}))\n        throw new Error(data?.error || 'Failed to send reset email')\n      }\n      setMessage('If that email is in our system, you will receive a reset link shortly.')\n    } catch (err: any) {\n      setError(err?.message || 'Failed to send reset email')\n    } finally {\n      setLoading(false)\n    }\n  }\n\n  return (\n    <div className=\"min-h-screen flex items-center justify-center bg-gradient-to-b from-white to-helfi-green-light/10 p-4\">\n      <div className=\"max-w-md w-full bg-white rounded-lg shadow-lg p-6\">\n        <h1 className=\"text-2xl font-bold text-gray-900 mb-2 text-center\">Reset your password</h1>\n        <p className=\"text-gray-600 text-sm mb-6 text-center\">\n          Enter your email and we will send you a reset link.\n        </p>\n\n        <form onSubmit={handleSubmit} className=\"space-y-4\">\n          <div>\n            <label htmlFor=\"email\" className=\"block text-sm font-medium text-gray-700 mb-2\">\n              Email address\n            </label>\n            <input\n              id=\"email\"\n              type=\"email\"\n              required\n              value={email}\n              onChange={(e) => setEmail(e.target.value)}\n              className=\"w-full px-3 py-3 border border-gray-300 rounded-lg shadow-sm placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-helfi-green focus:border-helfi-green\"\n              placeholder=\"you@example.com\"\n            />\n          </div>\n\n          {error && <div className=\"text-red-600 text-sm\">{error}</div>}\n          {message && <div className=\"text-green-600 text-sm\">{message}</div>}\n\n          <button\n            type=\"submit\"\n            disabled={loading || !email}\n            className=\"w-full bg-helfi-green text-white px-4 py-3 rounded-lg hover:bg-helfi-green-dark transition-colors disabled:opacity-50 disabled:cursor-not-allowed font-medium\"\n          >\n            {loading ? 'Sending...' : 'Send reset link'}\n          </button>\n        </form>\n\n        <div className=\"mt-6 text-center\">\n          <Link href=\"/auth/signin\" className=\"text-helfi-green hover:underline text-sm\">\n            Back to sign in\n          </Link>\n        </div>\n      </div>\n    </div>\n  )\n}\n","truncated":false,"size":2914},{"path":"app/auth/reset-password/page.tsx","content":"'use client'\n\nimport { useState, useEffect, Suspense } from 'react'\nimport { useSearchParams, useRouter } from 'next/navigation'\nimport Link from 'next/link'\n\nfunction ResetPasswordForm() {\n  const searchParams = useSearchParams()\n  const router = useRouter()\n  const [email, setEmail] = useState('')\n  const [token, setToken] = useState('')\n  const [password, setPassword] = useState('')\n  const [confirm, setConfirm] = useState('')\n  const [loading, setLoading] = useState(false)\n  const [error, setError] = useState('')\n  const [message, setMessage] = useState('')\n\n  useEffect(() => {\n    const emailParam = searchParams.get('email') || ''\n    const tokenParam = searchParams.get('token') || ''\n    setEmail(emailParam)\n    setToken(tokenParam)\n  }, [searchParams])\n\n  const handleSubmit = async (e: React.FormEvent) => {\n    e.preventDefault()\n    setError('')\n    setMessage('')\n    if (!email || !token) {\n      setError('Invalid reset link. Please request a new one.')\n      return\n    }\n    if (password.length < 8) {\n      setError('Password must be at least 8 characters long.')\n      return\n    }\n    if (password !== confirm) {\n      setError('Passwords do not match.')\n      return\n    }\n\n    setLoading(true)\n    try {\n      const res = await fetch('/api/auth/password-reset/confirm', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          email: email.trim().toLowerCase(),\n          token: token.trim(),\n          password,\n        }),\n      })\n      const data = await res.json().catch(() => ({}))\n      if (!res.ok) {\n        throw new Error(data?.error || 'Failed to reset password')\n      }\n      setMessage('Password updated successfully. You can now sign in.')\n      setTimeout(() => {\n        router.push('/auth/signin?message=reset_success')\n      }, 1200)\n    } catch (err: any) {\n      setError(err?.message || 'Failed to reset password')\n    } finally {\n      setLoading(false)\n    }\n  }\n\n  return (\n    <div className=\"min-h-screen flex items-center justify-center bg-gradient-to-b from-white to-helfi-green-light/10 p-4\">\n      <div className=\"max-w-md w-full bg-white rounded-lg shadow-lg p-6\">\n        <h1 className=\"text-2xl font-bold text-gray-900 mb-2 text-center\">Set a new password</h1>\n        <p className=\"text-gray-600 text-sm mb-6 text-center\">\n          Enter your new password below.\n        </p>\n\n        <form onSubmit={handleSubmit} className=\"space-y-4\">\n          <div>\n            <label htmlFor=\"password\" className=\"block text-sm font-medium text-gray-700 mb-2\">\n              New password\n            </label>\n            <input\n              id=\"password\"\n              type=\"password\"\n              required\n              value={password}\n              onChange={(e) => setPassword(e.target.value)}\n              className=\"w-full px-3 py-3 border border-gray-300 rounded-lg shadow-sm placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-helfi-green focus:border-helfi-green\"\n              placeholder=\"At least 8 characters\"\n            />\n          </div>\n          <div>\n            <label htmlFor=\"confirm\" className=\"block text-sm font-medium text-gray-700 mb-2\">\n              Confirm password\n            </label>\n            <input\n              id=\"confirm\"\n              type=\"password\"\n              required\n              value={confirm}\n              onChange={(e) => setConfirm(e.target.value)}\n              className=\"w-full px-3 py-3 border border-gray-300 rounded-lg shadow-sm placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-helfi-green focus:border-helfi-green\"\n              placeholder=\"Repeat your new password\"\n            />\n          </div>\n\n          {error && <div className=\"text-red-600 text-sm\">{error}</div>}\n          {message && <div className=\"text-green-600 text-sm\">{message}</div>}\n\n          <button\n            type=\"submit\"\n            disabled={loading}\n            className=\"w-full bg-helfi-green text-white px-4 py-3 rounded-lg hover:bg-helfi-green-dark transition-colors disabled:opacity-50 disabled:cursor-not-allowed font-medium\"\n          >\n            {loading ? 'Updating...' : 'Update password'}\n          </button>\n        </form>\n\n        <div className=\"mt-6 text-center\">\n          <Link href=\"/auth/signin\" className=\"text-helfi-green hover:underline text-sm\">\n            Back to sign in\n          </Link>\n        </div>\n      </div>\n    </div>\n  )\n}\n\nexport default function ResetPasswordPage() {\n  return (\n    <Suspense fallback={null}>\n      <ResetPasswordForm />\n    </Suspense>\n  )\n}\n","truncated":false,"size":4598},{"path":"app/auth/signin/page.tsx","content":"'use client'\n\nimport { signIn, useSession } from 'next-auth/react'\nimport Image from 'next/image'\nimport Link from 'next/link'\nimport { useState, useEffect, Suspense } from 'react'\nimport { useSearchParams, useRouter } from 'next/navigation'\n\n// Separate component for search params handling with Suspense\nfunction SearchParamsHandler({\n  setError,\n  setMessage,\n  setIsSignUp,\n  setShowResendVerification,\n}: {\n  setError: (error: string) => void\n  setMessage: (message: string) => void\n  setIsSignUp: (value: boolean) => void\n  setShowResendVerification: (value: boolean) => void\n}) {\n  const searchParams = useSearchParams()\n\n  useEffect(() => {\n    const errorParam = searchParams.get('error')\n    const messageParam = searchParams.get('message')\n    const planParam = searchParams.get('plan')\n    const modeParam = searchParams.get('mode')\n    \n    // If plan parameter exists, show signup form by default\n    if (planParam) {\n      setIsSignUp(true)\n    }\n\n    // If explicitly requested, show signup form by default\n    if (modeParam === 'signup') {\n      setIsSignUp(true)\n    }\n    \n    if (errorParam) {\n      switch (errorParam) {\n        case 'CredentialsSignin':\n          setError('Invalid email or password. Please try again.')\n          break\n        case 'EMAIL_NOT_VERIFIED':\n          setError('Please verify your email before signing in. Check your inbox or resend the verification email.')\n          setShowResendVerification(true)\n          break\n        case 'OAuthSignin':\n          setError('Error signing in with Google. Please try again.')\n          break\n        case 'OAuthCallback':\n          setError('Error during authentication. Please try again.')\n          break\n        default:\n          setError('An error occurred during sign in. Please try again.')\n      }\n    }\n    \n    if (messageParam) {\n      switch (messageParam) {\n        case 'signout':\n          setMessage('You have been signed out successfully.')\n          break\n        case 'reset_success':\n          setMessage('Your password has been updated. Please sign in.')\n          break\n        case 'verified':\n          setMessage('Your email is verified. Please sign in.')\n          setIsSignUp(false)\n          break\n        default:\n          setMessage('Status updated.')\n      }\n    }\n  }, [searchParams, setError, setMessage, setIsSignUp, setShowResendVerification])\n\n  return null\n}\n\nexport default function SignIn() {\n  const router = useRouter()\n  const { status } = useSession()\n  const [loading, setLoading] = useState(false)\n  const [email, setEmail] = useState('')\n  const [password, setPassword] = useState('')\n  const [isSignUp, setIsSignUp] = useState(false)\n  const [error, setError] = useState('')\n  const [message, setMessage] = useState('')\n  const [showPassword, setShowPassword] = useState(false)\n  const [rememberMe, setRememberMe] = useState(true)\n  const [showResendVerification, setShowResendVerification] = useState(false)\n\n  // If the user is already logged in and somehow lands on the sign-in page\n  // (for example, via the iOS Home Screen icon), immediately send them into\n  // the main app instead of making them log in again. Respect Health Setup:\n  // - If Health Setup is incomplete, always go to /onboarding (existing behaviour).\n  // - If complete, resume last in-app page when possible, otherwise go to dashboard.\n  // - If plan parameter exists, redirect to checkout after auth.\n  useEffect(() => {\n    if (status !== 'authenticated') return\n    if (typeof window === 'undefined') {\n      router.replace('/dashboard')\n      return\n    }\n\n    const resume = async () => {\n      // Check for plan parameter - first from URL, then from sessionStorage (for post-verification flow)\n      const searchParams = new URLSearchParams(window.location.search)\n      let planParam = searchParams.get('plan')\n      \n      // If no plan in URL, check sessionStorage (stored during signup)\n      if (!planParam) {\n        try {\n          planParam = sessionStorage.getItem('helfi:signupPlan')\n          if (planParam) {\n            // Clear it after retrieving\n            sessionStorage.removeItem('helfi:signupPlan')\n          }\n        } catch {}\n      }\n      \n      if (planParam) {\n        // User came from homepage with a plan selected - redirect to checkout\n        try {\n          const res = await fetch('/api/billing/create-checkout-session', {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({ plan: planParam }),\n          })\n          if (res.ok) {\n            const { url } = await res.json()\n            if (url) {\n              window.location.href = url\n              return\n            }\n          }\n        } catch (error) {\n          console.error('Checkout redirect error:', error)\n          // Fall through to normal redirect\n        }\n      }\n\n      // First, check Health Setup status without changing its existing rules.\n      try {\n        const res = await fetch('/api/health-setup-status', { method: 'GET' })\n        if (res.ok) {\n          const data = await res.json()\n          const complete = !!data.complete\n          if (!complete) {\n            router.replace('/onboarding')\n            return\n          }\n        }\n      } catch {\n        // If this fails, fall back to normal behaviour below.\n      }\n\n      // Health Setup complete: try to restore last in-app path.\n      let target = '/dashboard'\n      try {\n        const lastPath = localStorage.getItem('helfi:lastPath')\n        if (lastPath && !lastPath.startsWith('/auth') && lastPath !== '/' && !lastPath.startsWith('/healthapp')) {\n          target = lastPath\n        }\n      } catch {\n        // Ignore storage errors and use default target.\n      }\n      router.replace(target)\n    }\n\n    void resume()\n  }, [status, router])\n\n  useEffect(() => {\n    try {\n      const storedRemember = localStorage.getItem('helfi:rememberMe')\n      const storedEmail = localStorage.getItem('helfi:rememberEmail')\n      if (storedRemember === null) {\n        // Default to remembered on first load so PWA sessions don't evaporate\n        localStorage.setItem('helfi:rememberMe', '1')\n      } else {\n        setRememberMe(storedRemember === '1')\n      }\n      if (storedEmail) {\n        setEmail(storedEmail)\n      }\n    } catch (storageError) {\n      console.warn('Remember me restore failed', storageError)\n    }\n  }, [])\n\n  const handleGoogleAuth = async () => {\n    setLoading(true)\n    // Check for plan parameter to preserve it through OAuth flow\n    const searchParams = new URLSearchParams(window.location.search)\n    const planParam = searchParams.get('plan')\n    const callbackUrl = planParam ? `/auth/signin?plan=${encodeURIComponent(planParam)}` : '/onboarding'\n    await signIn('google', { callbackUrl })\n  }\n\n  const persistRememberState = (remember: boolean, emailValue: string) => {\n    try {\n      if (remember && emailValue) {\n        localStorage.setItem('helfi:rememberMe', '1')\n        localStorage.setItem('helfi:rememberEmail', emailValue.toLowerCase())\n        localStorage.removeItem('helfi:lastManualSignOut')\n      } else {\n        localStorage.removeItem('helfi:rememberMe')\n        localStorage.removeItem('helfi:rememberEmail')\n      }\n    } catch (storageError) {\n      console.warn('Remember me storage failed', storageError)\n    }\n  }\n\n  const handleEmailAuth = async (e: React.FormEvent) => {\n    e.preventDefault()\n    if (!email || !password) return\n\n    const normalizedEmail = email.trim().toLowerCase()\n    \n    setLoading(true)\n    setError('')\n    setMessage('')\n    setShowResendVerification(false)\n    \n    if (isSignUp) {\n      // Handle signup via direct API (no NextAuth flash)\n      try {\n        const response = await fetch('/api/auth/signup', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n          },\n          body: JSON.stringify({ email, password }),\n        })\n\n        const data = await response.json()\n\n        if (!response.ok) {\n          setError(data.error || 'Failed to create account. Please try again.')\n        } else {\n          // Success - check for plan parameter to preserve it\n          const searchParams = new URLSearchParams(window.location.search)\n          const planParam = searchParams.get('plan')\n          if (planParam) {\n            // Store plan in sessionStorage to retrieve after email verification\n            try {\n              sessionStorage.setItem('helfi:signupPlan', planParam)\n            } catch {}\n          }\n          // Redirect to check email page\n          window.location.href = `/auth/check-email?email=${encodeURIComponent(email)}`\n        }\n      } catch (error) {\n        console.error('Signup error:', error)\n        setError('Failed to create account. Please try again.')\n      }\n    } else {\n      // Handle signin via NextAuth credentials\n      try {\n        // Check for plan parameter to preserve it through auth flow\n        const searchParams = new URLSearchParams(window.location.search)\n        const planParam = searchParams.get('plan')\n        const callbackUrl = planParam ? `/auth/signin?plan=${encodeURIComponent(planParam)}` : '/onboarding'\n        \n        const res = await signIn('credentials', {\n          email: normalizedEmail,\n          password,\n          callbackUrl,\n          redirect: false,\n        })\n        if (res?.ok) {\n          persistRememberState(rememberMe, normalizedEmail)\n          setLoading(false)\n          // Check for plan parameter - first from URL, then from sessionStorage\n          let planParamToUse = planParam\n          if (!planParamToUse) {\n            try {\n              planParamToUse = sessionStorage.getItem('helfi:signupPlan')\n              if (planParamToUse) {\n                sessionStorage.removeItem('helfi:signupPlan')\n              }\n            } catch {}\n          }\n          \n          // Redirect to checkout if plan parameter exists\n          if (planParamToUse) {\n            try {\n              const checkoutRes = await fetch('/api/billing/create-checkout-session', {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify({ plan: planParamToUse }),\n              })\n              if (checkoutRes.ok) {\n                const { url } = await checkoutRes.json()\n                if (url) {\n                  window.location.href = url\n                  return\n                }\n              }\n            } catch (error) {\n              console.error('Checkout redirect error:', error)\n            }\n          }\n          window.location.href = '/onboarding'\n          return\n        } else {\n          if (res?.error === 'EMAIL_NOT_VERIFIED') {\n            setError('Please verify your email before signing in. Check your inbox or resend the verification email.')\n            setShowResendVerification(true)\n            setLoading(false)\n            return\n          }\n          setError('Invalid email or password')\n        }\n      } catch (error) {\n        console.error('Signin error:', error)\n        setError('Signin failed. Please try again.')\n        return\n      }\n    }\n    setLoading(false)\n  }\n\n  return (\n    <>\n      {/* Wrap search params handler in Suspense */}\n      <Suspense fallback={null}>\n        <SearchParamsHandler\n          setError={setError}\n          setMessage={setMessage}\n          setIsSignUp={setIsSignUp}\n          setShowResendVerification={setShowResendVerification}\n        />\n      </Suspense>\n      \n      <div className=\"min-h-screen flex items-center justify-center bg-gradient-to-b from-white to-helfi-green-light/10 p-4\">\n        <div className=\"max-w-md w-full space-y-8\">\n          {/* Logo */}\n          <div className=\"flex justify-center\">\n            <Link href=\"/\" className=\"relative w-24 h-24\">\n              <Image\n                src=\"/mobile-assets/LOGOS/helfi-01-01.png\"\n                alt=\"Helfi Logo\"\n                fill\n                className=\"object-contain\"\n                priority\n              />\n            </Link>\n          </div>\n\n          {/* Sign In Form */}\n          <div className=\"text-center\">\n            <h2 className=\"text-2xl font-bold text-helfi-black mb-4\">\n              {isSignUp ? 'Create Account' : 'Welcome to Helfi'}\n            </h2>\n            <p className=\"text-gray-600 mb-8\">\n              {isSignUp ? 'Create a new account to get started' : 'Sign in to your account'}\n            </p>\n          </div>\n\n          <div className=\"space-y-4\">\n            {/* Google Sign In - PRESERVED UNTOUCHED */}\n            <button\n              onClick={handleGoogleAuth}\n              disabled={loading}\n              className=\"w-full flex items-center justify-center gap-3 bg-white border border-gray-300 text-gray-700 px-4 py-3 rounded-lg hover:bg-gray-50 transition-colors disabled:opacity-50 disabled:cursor-not-allowed font-medium\"\n            >\n              <svg className=\"w-5 h-5\" viewBox=\"0 0 24 24\">\n                <path\n                  fill=\"#4285F4\"\n                  d=\"M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z\"\n                />\n                <path\n                  fill=\"#34A853\"\n                  d=\"M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z\"\n                />\n                <path\n                  fill=\"#FBBC05\"\n                  d=\"M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z\"\n                />\n                <path\n                  fill=\"#EA4335\"\n                  d=\"M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z\"\n                />\n              </svg>\n              Continue with Google\n            </button>\n\n            <div className=\"relative\">\n              <div className=\"absolute inset-0 flex items-center\">\n                <div className=\"w-full border-t border-gray-300\" />\n              </div>\n              <div className=\"relative flex justify-center text-sm\">\n                <span className=\"px-2 bg-white text-gray-500\">Or with email</span>\n              </div>\n            </div>\n\n            {/* Email/Password Form - RESTORED FROM COMMIT 89581b3 */}\n            <form onSubmit={handleEmailAuth} className=\"space-y-4\">\n              <div>\n                <label htmlFor=\"email\" className=\"block text-sm font-medium text-gray-700 mb-2\">\n                  Email address\n                </label>\n                <input\n                  id=\"email\"\n                  name=\"email\"\n                  type=\"email\"\n                  autoComplete=\"email\"\n                  required\n                  value={email}\n                  onChange={(e) => setEmail(e.target.value)}\n                  className=\"w-full px-3 py-3 border border-gray-300 rounded-lg shadow-sm placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-helfi-green focus:border-helfi-green\"\n                  placeholder=\"Enter your email\"\n                />\n              </div>\n              \n              <div>\n                <label htmlFor=\"password\" className=\"block text-sm font-medium text-gray-700 mb-2\">\n                  Password\n                </label>\n                <div className=\"relative\">\n                  <input\n                    id=\"password\"\n                    name=\"password\"\n                    type={showPassword ? \"text\" : \"password\"}\n                    autoComplete={isSignUp ? \"new-password\" : \"current-password\"}\n                    required\n                    value={password}\n                    onChange={(e) => setPassword(e.target.value)}\n                    className=\"w-full px-3 py-3 pr-12 border border-gray-300 rounded-lg shadow-sm placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-helfi-green focus:border-helfi-green\"\n                    placeholder=\"Enter your password\"\n                  />\n                  <button\n                    type=\"button\"\n                    onClick={() => setShowPassword(!showPassword)}\n                    className=\"absolute inset-y-0 right-0 flex items-center pr-3 text-gray-400 hover:text-gray-600 transition-colors\"\n                  >\n                    {showPassword ? (\n                      <svg className=\"w-5 h-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                        <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.878 9.878L3 3m6.878 6.878L21 21\" />\n                      </svg>\n                    ) : (\n                      <svg className=\"w-5 h-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                        <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M15 12a3 3 0 11-6 0 3 3 0 016 0z\" />\n                        <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z\" />\n                      </svg>\n                    )}\n                  </button>\n                </div>\n                {!isSignUp && (\n                  <div className=\"mt-2 text-right\">\n                    <Link href=\"/auth/forgot-password\" className=\"text-sm text-helfi-green hover:underline\">\n                      Forgot password?\n                    </Link>\n                  </div>\n                )}\n              </div>\n\n              <div className=\"flex items-start justify-between gap-3\">\n                <label className=\"inline-flex items-center gap-2 text-sm text-gray-700 select-none\">\n                  <input\n                    type=\"checkbox\"\n                    checked={rememberMe}\n                    onChange={(e) => setRememberMe(e.target.checked)}\n                    className=\"h-4 w-4 rounded border-gray-300 text-helfi-green focus:ring-helfi-green\"\n                  />\n                  Keep me signed in\n                </label>\n                <span className=\"text-xs text-gray-500 leading-5\">\n                  If unchecked, you stay signed in for at least 24 hours.\n                </span>\n              </div>\n\n              {error && (\n                <div className=\"text-red-600 text-sm\">{error}</div>\n              )}\n              {showResendVerification && (\n                <button\n                  type=\"button\"\n                  onClick={async () => {\n                    try {\n                      const res = await fetch('/api/auth/resend-verification', {\n                        method: 'POST',\n                        headers: { 'Content-Type': 'application/json' },\n                        body: JSON.stringify({ email: email.trim().toLowerCase() }),\n                      })\n                      const data = await res.json().catch(() => ({}))\n                      if (!res.ok) {\n                        setError(data?.error || 'Failed to resend verification email.')\n                        return\n                      }\n                      setMessage('Verification email sent. Please check your inbox.')\n                      setShowResendVerification(false)\n                    } catch {\n                      setError('Failed to resend verification email. Please try again.')\n                    }\n                  }}\n                  className=\"text-sm text-helfi-green hover:underline\"\n                >\n                  Resend verification email\n                </button>\n              )}\n\n              {message && (\n                <div className=\"text-green-600 text-sm\">{message}</div>\n              )}\n\n              <button\n                type=\"submit\"\n                disabled={loading || !email || !password}\n                className=\"w-full bg-helfi-green text-white px-4 py-3 rounded-lg hover:bg-helfi-green-dark transition-colors disabled:opacity-50 disabled:cursor-not-allowed font-medium\"\n              >\n                {loading ? 'Please wait...' : isSignUp ? 'Create Account' : 'Sign In'}\n              </button>\n            </form>\n\n            {/* Sign Up / Sign In Toggle - RESTORED */}\n            <div className=\"text-center\">\n              <button\n                onClick={() => setIsSignUp(!isSignUp)}\n                className=\"text-helfi-green hover:underline text-sm\"\n              >\n                {isSignUp ? 'Already have an account? Sign in' : \"Don't have an account? Sign up\"}\n              </button>\n            </div>\n          </div>\n\n          <div className=\"mt-6 text-center text-sm text-gray-600\">\n            <p>\n              By continuing, you agree to our{' '}\n              <Link href=\"/terms\" className=\"text-helfi-green hover:underline\">\n                Terms of Service\n              </Link>{' '}\n              and{' '}\n              <Link href=\"/privacy\" className=\"text-helfi-green hover:underline\">\n                Privacy Policy\n              </Link>\n            </p>\n          </div>\n        </div>\n      </div>\n    </>\n  )\n} \n","truncated":false,"size":21249},{"path":"app/auth/verify/page.tsx","content":"'use client'\n\nimport { useEffect, useState } from 'react'\nimport { useSearchParams } from 'next/navigation'\nimport Link from 'next/link'\nimport Image from 'next/image'\nimport { Suspense } from 'react'\n\nfunction VerifyContent() {\n  const [status, setStatus] = useState<'loading' | 'success' | 'error' | 'expired'>('loading')\n  const [message, setMessage] = useState('')\n  const searchParams = useSearchParams()\n\n  useEffect(() => {\n    const success = searchParams.get('success')\n    const error = searchParams.get('error')\n    \n    if (success === 'true') {\n      setStatus('success')\n      setMessage('Your email has been verified successfully!')\n      return\n    }\n    \n    if (error) {\n      switch (error) {\n        case 'verification_missing_params':\n          setStatus('error')\n          setMessage('Invalid verification link. Please check your email and try again.')\n          break\n        case 'verification_invalid_token':\n          setStatus('error')\n          setMessage('Invalid or expired verification link. Please request a new verification email.')\n          break\n        case 'verification_expired':\n          setStatus('expired')\n          setMessage('This verification link has expired. Please request a new one.')\n          break\n        case 'verification_user_not_found':\n          setStatus('error')\n          setMessage('Account not found. Please sign up first.')\n          break\n        case 'verification_server_error':\n          setStatus('error')\n          setMessage('Server error during verification. Please try again or contact support.')\n          break\n        default:\n          setStatus('error')\n          setMessage('An error occurred during verification. Please try again.')\n      }\n      return\n    }\n    \n    // If no success or error params, this is probably a direct access\n    setStatus('error')\n    setMessage('Invalid verification link. Please check your email and try again.')\n  }, [searchParams])\n\n  return (\n    <div className=\"min-h-screen flex items-center justify-center bg-gradient-to-b from-white to-helfi-green-light/10 p-4\">\n      <div className=\"max-w-md w-full space-y-8 text-center\">\n        {/* Logo */}\n        <div className=\"flex justify-center\">\n          <Link href=\"/\" className=\"relative w-24 h-24\">\n            <Image\n              src=\"/mobile-assets/LOGOS/helfi-01-01.png\"\n              alt=\"Helfi Logo\"\n              fill\n              className=\"object-contain\"\n              priority\n            />\n          </Link>\n        </div>\n\n        <div className=\"space-y-6\">\n          {status === 'loading' && (\n            <div className=\"space-y-4\">\n              <div className=\"animate-spin rounded-full h-12 w-12 border-b-2 border-helfi-green mx-auto\"></div>\n              <h2 className=\"text-2xl font-bold text-helfi-black\">Verifying your email...</h2>\n              <p className=\"text-gray-600\">Please wait while we verify your email address.</p>\n            </div>\n          )}\n\n          {status === 'success' && (\n            <div className=\"space-y-4\">\n              <div className=\"w-16 h-16 bg-green-100 rounded-full flex items-center justify-center mx-auto\">\n                <svg className=\"w-8 h-8 text-green-600\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M5 13l4 4L19 7\" />\n                </svg>\n              </div>\n              <h2 className=\"text-2xl font-bold text-helfi-black\">Email Verified!</h2>\n              <p className=\"text-gray-600\">{message}</p>\n              <div className=\"space-y-3\">\n                <Link\n                  href=\"/auth/signin?message=verified\"\n                  className=\"w-full bg-helfi-green text-white px-6 py-3 rounded-lg hover:bg-helfi-green-dark transition-colors font-medium inline-block\"\n                >\n                  Continue to Sign In\n                </Link>\n                <p className=\"text-sm text-gray-500\">\n                  You can now sign in to your Helfi account and start your health journey.\n                </p>\n              </div>\n            </div>\n          )}\n\n          {status === 'expired' && (\n            <div className=\"space-y-4\">\n              <div className=\"w-16 h-16 bg-yellow-100 rounded-full flex items-center justify-center mx-auto\">\n                <svg className=\"w-8 h-8 text-yellow-600\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16c-.77.833.192 2.5 1.732 2.5z\" />\n                </svg>\n              </div>\n              <h2 className=\"text-2xl font-bold text-helfi-black\">Link Expired</h2>\n              <p className=\"text-gray-600\">{message}</p>\n              <div className=\"space-y-3\">\n                <Link\n                  href=\"/auth/signin\"\n                  className=\"w-full bg-helfi-green text-white px-6 py-3 rounded-lg hover:bg-helfi-green-dark transition-colors font-medium inline-block\"\n                >\n                  Get New Verification Link\n                </Link>\n                <p className=\"text-sm text-gray-500\">\n                  Sign up again to receive a new verification email.\n                </p>\n              </div>\n            </div>\n          )}\n\n          {status === 'error' && (\n            <div className=\"space-y-4\">\n              <div className=\"w-16 h-16 bg-red-100 rounded-full flex items-center justify-center mx-auto\">\n                <svg className=\"w-8 h-8 text-red-600\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M6 18L18 6M6 6l12 12\" />\n                </svg>\n              </div>\n              <h2 className=\"text-2xl font-bold text-helfi-black\">Verification Failed</h2>\n              <p className=\"text-gray-600\">{message}</p>\n              <div className=\"space-y-3\">\n                <Link\n                  href=\"/auth/signin\"\n                  className=\"w-full bg-helfi-green text-white px-6 py-3 rounded-lg hover:bg-helfi-green-dark transition-colors font-medium inline-block\"\n                >\n                  Try Again\n                </Link>\n                <p className=\"text-sm text-gray-500\">\n                  If this problem persists, please contact our support team.\n                </p>\n              </div>\n            </div>\n          )}\n        </div>\n      </div>\n    </div>\n  )\n}\n\nexport default function VerifyEmailPage() {\n  return (\n    <Suspense fallback={\n      <div className=\"min-h-screen flex items-center justify-center bg-gradient-to-b from-white to-helfi-green-light/10 p-4\">\n        <div className=\"animate-spin rounded-full h-12 w-12 border-b-2 border-helfi-green\"></div>\n      </div>\n    }>\n      <VerifyContent />\n    </Suspense>\n  )\n} \n","truncated":false,"size":6913},{"path":"app/billing/page.tsx","content":"'use client'\nimport { Cog6ToothIcon } from '@heroicons/react/24/outline'\n\nimport React, { useState, useEffect } from 'react'\nimport { useSession, signOut } from 'next-auth/react'\nimport { useRouter } from 'next/navigation'\nimport Image from 'next/image'\nimport Link from 'next/link'\nimport MobileMoreMenu from '@/components/MobileMoreMenu'\nimport UsageMeter from '@/components/UsageMeter'\nimport PageHeader from '@/components/PageHeader'\nimport ConfirmationModal from '@/components/ConfirmationModal'\nimport MessageModal from '@/components/MessageModal'\nimport { creditDisplayList } from '@/data/creditCosts'\n\nexport default function BillingPage() {\n  const { data: session } = useSession()\n  const [loading, setLoading] = useState(true)\n  const [currentPlan, setCurrentPlan] = useState('free')\n  const [dropdownOpen, setDropdownOpen] = useState(false)\n  const router = useRouter()\n  const [profileImage, setProfileImage] = useState<string>('')\n  const [subscription, setSubscription] = useState<any>(null)\n  const [hasActiveSubscription, setHasActiveSubscription] = useState(false)\n  const [isManagingSubscription, setIsManagingSubscription] = useState(false)\n  const [isCreatingPortalSession, setIsCreatingPortalSession] = useState(false)\n  \n  // Modal states\n  const [showCancelConfirm, setShowCancelConfirm] = useState(false)\n  const [showMessageModal, setShowMessageModal] = useState(false)\n  const [messageModalContent, setMessageModalContent] = useState<{ title: string; message: string; type?: 'success' | 'error' | 'info' }>({ title: '', message: '' })\n\n  // Stripe checkout\n  const [isCreatingCheckout, setIsCreatingCheckout] = useState<string | null>(null)\n  \n  // Usage stats (real usage history)\n  const [usageRange, setUsageRange] = useState<'7d' | '1m' | '2m' | '6m' | 'all' | 'custom'>('7d')\n  const [usageStart, setUsageStart] = useState<string>('')\n  const [usageEnd, setUsageEnd] = useState<string>('')\n  const [usageStats, setUsageStats] = useState<Record<string, number> | null>(null)\n  const [usageStatsLoading, setUsageStatsLoading] = useState(false)\n  const [usageStatsError, setUsageStatsError] = useState<string | null>(null)\n\n  const toDateInputValue = (d: Date) => {\n    const yyyy = d.getFullYear()\n    const mm = String(d.getMonth() + 1).padStart(2, '0')\n    const dd = String(d.getDate()).padStart(2, '0')\n    return `${yyyy}-${mm}-${dd}`\n  }\n  const startCheckout = async (plan: string, quantity: number = 1) => {\n    try {\n      setIsCreatingCheckout(plan)\n      const res = await fetch('/api/billing/create-checkout-session', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ plan, quantity }),\n      })\n      if (!res.ok) {\n        const data = await res.json().catch(() => ({}))\n        // Show user-friendly error message\n        const errorMessage = data?.message || data?.error || 'Checkout error'\n        setMessageModalContent({\n          title: 'Checkout Error',\n          message: errorMessage,\n          type: 'error'\n        })\n        setShowMessageModal(true)\n        return\n      }\n      const { url } = await res.json()\n      if (url) {\n        window.location.href = url\n      } else {\n        throw new Error('No checkout URL returned')\n      }\n    } catch (e: any) {\n      setMessageModalContent({\n        title: 'Error',\n        message: e?.message || 'Failed to start checkout',\n        type: 'error'\n      })\n      setShowMessageModal(true)\n    } finally {\n      setIsCreatingCheckout(null)\n    }\n  }\n\n  // Load real usage stats for Billing\n  useEffect(() => {\n    if (!session?.user) return\n\n    const load = async () => {\n      setUsageStatsLoading(true)\n      setUsageStatsError(null)\n      try {\n        const params = new URLSearchParams()\n        params.set('range', usageRange)\n        if (usageRange === 'custom') {\n          if (usageStart) params.set('start', usageStart)\n          if (usageEnd) params.set('end', usageEnd)\n        }\n        const res = await fetch(`/api/credit/feature-usage-stats?${params.toString()}`, { cache: 'no-store' })\n        if (!res.ok) {\n          const data = await res.json().catch(() => ({}))\n          throw new Error(data?.error || 'Could not load usage stats')\n        }\n        const data = await res.json()\n        setUsageStats(data?.usage || null)\n      } catch (e: any) {\n        setUsageStats(null)\n        setUsageStatsError(e?.message || 'Could not load usage stats')\n      } finally {\n        setUsageStatsLoading(false)\n      }\n    }\n\n    // If user picks custom but dates are empty, set a sensible default (last 7 days).\n    if (usageRange === 'custom' && (!usageStart || !usageEnd)) {\n      const now = new Date()\n      const start = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000)\n      const startValue = usageStart || toDateInputValue(start)\n      const endValue = usageEnd || toDateInputValue(now)\n      if (!usageStart) setUsageStart(startValue)\n      if (!usageEnd) setUsageEnd(endValue)\n      // Wait for state updates, then the effect will re-run and load.\n      return\n    }\n\n    load()\n  }, [session, usageRange, usageStart, usageEnd])\n\n  // Close dropdown on outside click\n  useEffect(() => {\n    function handleClick(e: MouseEvent) {\n      const target = e.target as HTMLElement;\n      // Check if click is outside both the button and the dropdown content\n      if (!target.closest('.dropdown-container')) {\n        setDropdownOpen(false);\n      }\n    }\n    if (dropdownOpen) {\n      document.addEventListener('mousedown', handleClick);\n      return () => document.removeEventListener('mousedown', handleClick);\n    }\n  }, [dropdownOpen]);\n\n  // Load profile image from database\n  useEffect(() => {\n    const loadProfileImage = async () => {\n      try {\n        const response = await fetch('/api/user-data');\n        if (response.ok) {\n          const result = await response.json();\n          if (result.data && result.data.profileImage) {\n            setProfileImage(result.data.profileImage);\n          }\n        }\n      } catch (error) {\n        console.error('Error loading profile image:', error);\n      }\n    };\n\n    if (session) {\n      loadProfileImage();\n    }\n  }, [session]);\n\n  useEffect(() => {\n    if (session) {\n      setLoading(false)\n    }\n  }, [session])\n\n  // Load subscription status\n  useEffect(() => {\n    const loadSubscription = async () => {\n      try {\n        const res = await fetch('/api/billing/subscription')\n        if (res.ok) {\n          const data = await res.json()\n          console.log('Subscription data:', data) // Debug log\n          if (data.hasSubscription && data.isActive) {\n            setSubscription(data.subscription)\n            setHasActiveSubscription(true)\n            setCurrentPlan(data.subscription?.tier || 'free')\n          } else {\n            setHasActiveSubscription(false)\n            setSubscription(null)\n          }\n        } else {\n          console.error('Failed to load subscription:', res.status)\n        }\n      } catch (error) {\n        console.error('Error loading subscription:', error)\n      }\n    }\n    if (session) {\n      loadSubscription()\n    }\n  }, [session])\n\n  // If returning from Stripe, confirm top-up (no useSearchParams to keep static safe)\n  useEffect(() => {\n    if (typeof window === 'undefined') return\n    const params = new URLSearchParams(window.location.search)\n    const checkout = params.get('checkout')\n    const sid = params.get('session_id')\n    if (checkout === 'success' && sid) {\n      fetch(`/api/billing/confirm?session_id=${encodeURIComponent(sid)}`)\n        .then(() => {\n          // Reload subscription after successful checkout\n          fetch('/api/billing/subscription')\n            .then(res => res.json())\n            .then(data => {\n              if (data.hasSubscription && data.isActive) {\n                setSubscription(data.subscription)\n                setCurrentPlan(data.subscription.tier)\n              }\n            })\n            .catch(() => {})\n        })\n        .catch(() => {})\n    }\n  }, [])\n\n  // Handle subscription management\n  const handleCancelSubscription = async () => {\n    setShowCancelConfirm(true)\n  }\n\n  const confirmCancelSubscription = async () => {\n    setShowCancelConfirm(false)\n    setIsManagingSubscription(true)\n    try {\n      const res = await fetch('/api/billing/subscription', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ action: 'cancel' }),\n      })\n      \n      if (res.ok) {\n        const data = await res.json()\n        \n        // Format the cancellation date message\n        let message = data.message || 'Subscription canceled successfully'\n        if (data.cancellationDate) {\n          const cancelDate = new Date(data.cancellationDate)\n          const formattedDate = cancelDate.toLocaleDateString('en-US', { \n            weekday: 'long', \n            year: 'numeric', \n            month: 'long', \n            day: 'numeric' \n          })\n          message = `Your subscription will remain active until ${formattedDate}. After that date, your subscription will be canceled and you'll lose access to premium features.`\n        }\n        \n        setMessageModalContent({\n          title: 'Subscription Canceled',\n          message,\n          type: 'success'\n        })\n        setShowMessageModal(true)\n        \n        // Reload subscription status\n        const subRes = await fetch('/api/billing/subscription')\n        if (subRes.ok) {\n          const subData = await subRes.json()\n          if (subData.hasSubscription && subData.isActive) {\n            setSubscription(subData.subscription)\n            setHasActiveSubscription(true)\n          } else {\n            setHasActiveSubscription(false)\n            setSubscription(null)\n          }\n        }\n      } else {\n        const error = await res.json().catch(() => ({}))\n        setMessageModalContent({\n          title: 'Error',\n          message: error.message || error.error || error.details?.message || 'Failed to cancel subscription',\n          type: 'error'\n        })\n        setShowMessageModal(true)\n      }\n    } catch (error: any) {\n      console.error('Cancel subscription error:', error)\n      setMessageModalContent({\n        title: 'Error',\n        message: error?.message || 'Failed to cancel subscription',\n        type: 'error'\n      })\n      setShowMessageModal(true)\n    } finally {\n      setIsManagingSubscription(false)\n    }\n  }\n\n  const handleChangePlan = async (newPlan: string, action: 'upgrade' | 'downgrade') => {\n    setIsManagingSubscription(true)\n    try {\n      const res = await fetch('/api/billing/subscription', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ action, newPlan }),\n      })\n      \n      if (res.ok) {\n        const data = await res.json()\n        setMessageModalContent({\n          title: 'Success',\n          message: data.message || `Subscription ${action === 'upgrade' ? 'upgraded' : 'downgraded'} successfully`,\n          type: 'success'\n        })\n        setShowMessageModal(true)\n        // Reload subscription status\n        const subRes = await fetch('/api/billing/subscription')\n        if (subRes.ok) {\n          const subData = await subRes.json()\n          if (subData.hasSubscription && subData.isActive) {\n            setSubscription(subData.subscription)\n            setHasActiveSubscription(true)\n            setCurrentPlan(subData.subscription.tier)\n          } else {\n            setHasActiveSubscription(false)\n            setSubscription(null)\n          }\n        }\n      } else {\n        const error = await res.json().catch(() => ({}))\n        setMessageModalContent({\n          title: 'Error',\n          message: error.message || error.error || error.details?.message || `Failed to ${action} subscription`,\n          type: 'error'\n        })\n        setShowMessageModal(true)\n      }\n    } catch (error: any) {\n      console.error(`${action} subscription error:`, error)\n      setMessageModalContent({\n        title: 'Error',\n        message: error?.message || `Failed to ${action} subscription`,\n        type: 'error'\n      })\n      setShowMessageModal(true)\n    } finally {\n      setIsManagingSubscription(false)\n    }\n  }\n\n  const handleManagePortal = async () => {\n    setIsCreatingPortalSession(true)\n    try {\n      const res = await fetch('/api/billing/portal', { method: 'POST' })\n      if (!res.ok) {\n        const data = await res.json().catch(() => ({}))\n        // Show the actual error message from the API\n        const errorMessage = data?.message || data?.error || 'Could not open subscription management. Please try again.'\n        setMessageModalContent({\n          title: 'Error',\n          message: errorMessage,\n          type: 'error'\n        })\n        setShowMessageModal(true)\n        return\n      }\n      const data = await res.json()\n      if (data?.url) {\n        window.location.href = data.url\n      } else {\n        setMessageModalContent({\n          title: 'Error',\n          message: 'Could not open subscription management. Please try again.',\n          type: 'error'\n        })\n        setShowMessageModal(true)\n      }\n    } catch (err: any) {\n      console.error('Portal error:', err)\n      setMessageModalContent({\n        title: 'Error',\n        message: err?.message || 'Could not open subscription management. Please try again.',\n        type: 'error'\n      })\n      setShowMessageModal(true)\n    } finally {\n      setIsCreatingPortalSession(false)\n    }\n  }\n\n  const handleSignOut = async () => {\n    // Clear user-specific localStorage before signing out\n    if (session?.user?.id) {\n      localStorage.removeItem(`profileImage_${session.user.id}`);\n      localStorage.removeItem(`cachedProfileImage_${session.user.id}`);\n    }\n    await signOut({ callbackUrl: '/auth/signin' })\n  }\n\n  return (\n    <div className=\"min-h-screen bg-gray-50 pb-[calc(7rem+env(safe-area-inset-bottom))]\">\n      <PageHeader title=\"Subscription & Billing\" />\n\n      {/* Main Content */}\n      <div className=\"max-w-6xl mx-auto px-6 py-8 pb-8\">\n        {/* Current Subscription */}\n        {hasActiveSubscription && subscription && (\n          <div className=\"bg-white rounded-lg shadow-sm p-6 mb-8 border-2 border-green-500\">\n            <div className=\"flex items-center justify-between mb-4\">\n              <div>\n                <h2 className=\"text-2xl font-bold text-gray-900\">Current Subscription</h2>\n                <p className=\"text-gray-600 mt-1\">\n                  {subscription.tier} \n                  {subscription.credits > 0 && ` - ${subscription.credits.toLocaleString()} credits/month`}\n                </p>\n              </div>\n              <div className=\"text-right\">\n                <div className=\"text-sm text-gray-500\">Status</div>\n                <div className=\"text-lg font-semibold text-green-600\">Active</div>\n              </div>\n            </div>\n            \n            {subscription.stripeCurrentPeriodEnd && (\n              <div className=\"mb-4 text-sm text-gray-600\">\n                Next billing date: {new Date(subscription.stripeCurrentPeriodEnd).toLocaleDateString()}\n              </div>\n            )}\n\n            {subscription.stripeCancelAtPeriodEnd && (\n              <div className=\"mb-4 p-3 bg-yellow-50 border border-yellow-200 rounded-lg text-sm text-yellow-800\">\n                ‚ö†Ô∏è Your subscription will be canceled at the end of the current billing period.\n              </div>\n            )}\n\n            <div className=\"flex flex-wrap gap-3\">\n              <button\n                onClick={handleManagePortal}\n                disabled={isCreatingPortalSession}\n                className=\"px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed\"\n              >\n                {isCreatingPortalSession ? 'Opening portal‚Ä¶' : 'Manage subscription'}\n              </button>\n\n              {!subscription.stripeCancelAtPeriodEnd && (\n                <button\n                  onClick={handleCancelSubscription}\n                  disabled={isManagingSubscription}\n                  className=\"px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 transition-colors disabled:opacity-50 disabled:cursor-not-allowed\"\n                >\n                  {isManagingSubscription ? 'Processing...' : 'Cancel Subscription'}\n                </button>\n              )}\n              \n              {/* Upgrade/Downgrade options */}\n              {(!subscription.monthlyPriceCents || subscription.monthlyPriceCents !== 1000) && (\n                <button\n                  onClick={() => handleChangePlan('plan_10_monthly', (subscription.monthlyPriceCents || 0) > 1000 ? 'downgrade' : 'upgrade')}\n                  disabled={isManagingSubscription}\n                  className=\"px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 transition-colors disabled:opacity-50 disabled:cursor-not-allowed\"\n                >\n                  {(subscription.monthlyPriceCents || 0) > 1000 ? 'Downgrade to $10/month' : 'Switch to $10/month'}\n                </button>\n              )}\n              \n              {(!subscription.monthlyPriceCents || subscription.monthlyPriceCents !== 2000) && (\n                <button\n                  onClick={() => handleChangePlan('plan_20_monthly', (subscription.monthlyPriceCents || 0) > 2000 ? 'downgrade' : 'upgrade')}\n                  disabled={isManagingSubscription}\n                  className=\"px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 transition-colors disabled:opacity-50 disabled:cursor-not-allowed\"\n                >\n                  {(subscription.monthlyPriceCents || 0) > 2000 ? 'Downgrade to $20/month' : 'Switch to $20/month'}\n                </button>\n              )}\n              \n              {(!subscription.monthlyPriceCents || subscription.monthlyPriceCents !== 3000) && (\n                <button\n                  onClick={() => handleChangePlan('plan_30_monthly', (subscription.monthlyPriceCents || 0) > 3000 ? 'downgrade' : 'upgrade')}\n                  disabled={isManagingSubscription}\n                  className=\"px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 transition-colors disabled:opacity-50 disabled:cursor-not-allowed\"\n                >\n                  {(subscription.monthlyPriceCents || 0) > 3000 ? 'Downgrade to $30/month' : 'Switch to $30/month'}\n                </button>\n              )}\n              \n              {(!subscription.monthlyPriceCents || subscription.monthlyPriceCents !== 5000) && (\n                <button\n                  onClick={() => handleChangePlan('plan_50_monthly', (subscription.monthlyPriceCents || 0) > 5000 ? 'downgrade' : 'upgrade')}\n                  disabled={isManagingSubscription}\n                  className=\"px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 transition-colors disabled:opacity-50 disabled:cursor-not-allowed\"\n                >\n                  {(subscription.monthlyPriceCents || 0) > 5000 ? 'Downgrade to $50/month' : 'Switch to $50/month'}\n                </button>\n              )}\n            </div>\n          </div>\n        )}\n\n        {/* Available Plans */}\n        <div className=\"bg-white rounded-lg shadow-sm p-6 mb-8\">\n          <div className=\"flex items-center justify-between mb-6\">\n            <h2 className=\"text-2xl font-bold text-gray-900\">Plans</h2>\n          </div>\n\n          <div className=\"grid grid-cols-1 lg:grid-cols-4 gap-8\">\n            {/* $10 plan */}\n            <div className=\"border border-gray-200 rounded-2xl p-8 shadow-sm hover:shadow-md transition-shadow bg-white\">\n              <h3 className=\"text-lg font-semibold text-gray-900 mb-2\">$10 / month</h3>\n              <p className=\"text-3xl font-bold text-gray-900 mb-1\">Monthly wallet: 700 credits</p>\n              <p className=\"text-xs text-gray-500 mb-4\">Credits refresh monthly. No rollover.</p>\n              <ul className=\"space-y-2 mb-6 text-sm text-gray-600\">\n                <li className=\"flex items-center\"><span className=\"w-4 h-4 text-green-500 mr-2\">‚úì</span> All features unlocked</li>\n                <li className=\"flex items-center\"><span className=\"w-4 h-4 text-green-500 mr-2\">‚úì</span> Percentage‚Äëbased usage meter</li>\n                <li className=\"flex items-center\"><span className=\"w-4 h-4 text-green-500 mr-2\">‚úì</span> Top‚Äëups valid 12 months</li>\n              </ul>\n              <button\n                onClick={() => startCheckout('plan_10_monthly')}\n                disabled={isCreatingCheckout === 'plan_10_monthly'}\n                className=\"w-full bg-helfi-green text-white px-4 py-2 rounded-lg hover:bg-helfi-green/90 transition-colors disabled:opacity-60\"\n              >\n                {isCreatingCheckout === 'plan_10_monthly' ? 'Redirecting‚Ä¶' : 'Choose $10 Plan'}\n              </button>\n            </div>\n\n            {/* $20 plan */}\n            <div className=\"border border-gray-200 rounded-2xl p-8 shadow-sm hover:shadow-md transition-shadow bg-white\">\n              <h3 className=\"text-lg font-semibold text-gray-900 mb-2\">$20 / month</h3>\n              <p className=\"text-3xl font-bold text-gray-900 mb-1\">Monthly wallet: 1,400 credits</p>\n              <p className=\"text-xs text-gray-500 mb-4\">Credits refresh monthly. No rollover.</p>\n              <ul className=\"space-y-2 mb-6 text-sm text-gray-600\">\n                <li className=\"flex items-center\"><span className=\"w-4 h-4 text-green-500 mr-2\">‚úì</span> All features unlocked</li>\n                <li className=\"flex items-center\"><span className=\"w-4 h-4 text-green-500 mr-2\">‚úì</span> Percentage‚Äëbased usage meter</li>\n                <li className=\"flex items-center\"><span className=\"w-4 h-4 text-green-500 mr-2\">‚úì</span> Top‚Äëups valid 12 months</li>\n              </ul>\n              <button\n                onClick={() => startCheckout('plan_20_monthly')}\n                disabled={isCreatingCheckout === 'plan_20_monthly'}\n                className=\"w-full bg-helfi-green text-white px-4 py-2 rounded-lg hover:bg-helfi-green/90 transition-colors disabled:opacity-60\"\n              >\n                {isCreatingCheckout === 'plan_20_monthly' ? 'Redirecting‚Ä¶' : 'Choose $20 Plan'}\n              </button>\n            </div>\n\n            {/* $30 plan */}\n            <div className=\"border-2 border-helfi-green rounded-2xl p-8 relative shadow-sm hover:shadow-lg transition-shadow bg-white\">\n              <div className=\"absolute -top-3 left-1/2 transform -translate-x-1/2\">\n                <span className=\"bg-helfi-green text-white px-3 py-1 rounded-full text-sm font-medium\">Most Popular</span>\n              </div>\n              <h3 className=\"text-lg font-semibold text-gray-900 mb-2\">$30 / month</h3>\n              <p className=\"text-3xl font-bold text-gray-900 mb-1\">Monthly wallet: 2,100 credits</p>\n              <p className=\"text-xs text-gray-500 mb-4\">Credits refresh monthly. No rollover.</p>\n              <ul className=\"space-y-2 mb-6 text-sm text-gray-600\">\n                <li className=\"flex items-center\"><span className=\"w-4 h-4 text-green-500 mr-2\">‚úì</span> All features unlocked</li>\n                <li className=\"flex items-center\"><span className=\"w-4 h-4 text-green-500 mr-2\">‚úì</span> Percentage‚Äëbased usage meter</li>\n                <li className=\"flex items-center\"><span className=\"w-4 h-4 text-green-500 mr-2\">‚úì</span> Top‚Äëups valid 12 months</li>\n              </ul>\n              <button\n                onClick={() => startCheckout('plan_30_monthly')}\n                disabled={isCreatingCheckout === 'plan_30_monthly'}\n                className=\"w-full bg-helfi-green text-white px-4 py-2 rounded-lg hover:bg-helfi-green/90 transition-colors disabled:opacity-60\"\n              >\n                {isCreatingCheckout === 'plan_30_monthly' ? 'Redirecting‚Ä¶' : 'Choose $30 Plan'}\n              </button>\n            </div>\n\n            {/* $50 plan */}\n            <div className=\"border border-gray-200 rounded-2xl p-8 shadow-sm hover:shadow-md transition-shadow bg-white\">\n              <h3 className=\"text-lg font-semibold text-gray-900 mb-2\">$50 / month</h3>\n              <p className=\"text-3xl font-bold text-gray-900 mb-1\">Monthly wallet: 3,500 credits</p>\n              <p className=\"text-xs text-gray-500 mb-4\">Credits refresh monthly. No rollover.</p>\n              <ul className=\"space-y-2 mb-6 text-sm text-gray-600\">\n                <li className=\"flex items-center\"><span className=\"w-4 h-4 text-green-500 mr-2\">‚úì</span> All features unlocked</li>\n                <li className=\"flex items-center\"><span className=\"w-4 h-4 text-green-500 mr-2\">‚úì</span> Percentage‚Äëbased usage meter</li>\n                <li className=\"flex items-center\"><span className=\"w-4 h-4 text-green-500 mr-2\">‚úì</span> Top‚Äëups valid 12 months</li>\n              </ul>\n              <button\n                onClick={() => startCheckout('plan_50_monthly')}\n                disabled={isCreatingCheckout === 'plan_50_monthly'}\n                className=\"w-full bg-gray-900 text-white px-4 py-2 rounded-lg hover:bg-gray-800 transition-colors disabled:opacity-60\"\n              >\n                {isCreatingCheckout === 'plan_50_monthly' ? 'Redirecting‚Ä¶' : 'Choose $50 Plan'}\n              </button>\n            </div>\n          </div>\n        </div>\n\n        {/* Credits */}\n        <div className=\"bg-white rounded-lg shadow-sm p-6 mb-8\">\n          <h2 className=\"text-2xl font-bold text-gray-900 mb-6\">Buy Extra Credits</h2>\n          <div className=\"grid grid-cols-1 sm:grid-cols-3 gap-6\">\n            <div className=\"border border-gray-200 rounded-lg p-6\">\n              <h3 className=\"text-lg font-semibold text-gray-900 mb-2\">Try with $5 (250 credits)</h3>\n              <p className=\"text-sm text-gray-600 mb-6\">One‚Äëtime top‚Äëup. Credits valid for 12 months.</p>\n              <button\n                onClick={() => startCheckout('credits_250')}\n                disabled={isCreatingCheckout === 'credits_250'}\n                className=\"w-full bg-helfi-green text-white px-4 py-2 rounded-lg hover:bg-helfi-green/90 transition-colors disabled:opacity-60\"\n              >\n                {isCreatingCheckout === 'credits_250' ? 'Redirecting‚Ä¶' : 'Buy $5 Credits'}\n              </button>\n            </div>\n            <div className=\"border border-gray-200 rounded-lg p-6\">\n              <h3 className=\"text-lg font-semibold text-gray-900 mb-2\">$10 (500 credits)</h3>\n              <p className=\"text-sm text-gray-600 mb-6\">One‚Äëtime top‚Äëup. Credits valid for 12 months.</p>\n              <button\n                onClick={() => startCheckout('credits_500')}\n                disabled={isCreatingCheckout === 'credits_500'}\n                className=\"w-full bg-helfi-green text-white px-4 py-2 rounded-lg hover:bg-helfi-green/90 transition-colors disabled:opacity-60\"\n              >\n                {isCreatingCheckout === 'credits_500' ? 'Redirecting‚Ä¶' : 'Buy $10 Credits'}\n              </button>\n            </div>\n            <div className=\"border border-gray-200 rounded-lg p-6\">\n              <h3 className=\"text-lg font-semibold text-gray-900 mb-2\">$20 (1,000 credits)</h3>\n              <p className=\"text-sm text-gray-600 mb-6\">One‚Äëtime top‚Äëup. Credits valid for 12 months.</p>\n              <button\n                onClick={() => startCheckout('credits_1000')}\n                disabled={isCreatingCheckout === 'credits_1000'}\n                className=\"w-full bg-helfi-green text-white px-4 py-2 rounded-lg hover:bg-helfi-green/90 transition-colors disabled:opacity-60\"\n              >\n                {isCreatingCheckout === 'credits_1000' ? 'Redirecting‚Ä¶' : 'Buy $20 Credits'}\n              </button>\n            </div>\n          </div>\n        </div>\n\n        {/* Billing History */}\n        <div className=\"bg-white rounded-lg shadow-sm p-6\">\n          <h2 className=\"text-2xl font-bold text-gray-900 mb-6\">Billing History</h2>\n          <div className=\"text-center py-8\">\n            <p className=\"text-gray-500\">No billing history available.</p>\n            <p className=\"text-sm text-gray-400 mt-2\">Your billing history will appear here after your first payment.</p>\n          </div>\n        </div>\n      </div>\n\n      {/* Mobile Bottom Navigation */}\n      <nav className=\"md:hidden fixed bottom-0 left-0 right-0 bg-white border-t border-gray-200 px-4 py-2 z-40\">\n        <div className=\"flex items-center justify-around\">\n          \n          {/* Dashboard */}\n          <Link href=\"/dashboard\" className=\"flex flex-col items-center py-2 px-1 min-w-0 flex-1\">\n            <div className=\"text-gray-400\">\n              <svg className=\"w-6 h-6\" fill=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path d=\"M3 13h8V3H3v10zm0 8h8v-6H3v6zm10 0h8V11h-8v10zm0-18v6h8V3h-8z\"/>\n              </svg>\n            </div>\n            <span className=\"text-xs text-gray-400 mt-1 font-medium truncate\">Dashboard</span>\n          </Link>\n\n          {/* Insights */}\n          <Link href=\"/insights\" className=\"flex flex-col items-center py-2 px-1 min-w-0 flex-1\">\n            <div className=\"text-gray-400\">\n              <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z\" />\n              </svg>\n            </div>\n            <span className=\"text-xs text-gray-400 mt-1 font-medium truncate\">Insights</span>\n          </Link>\n\n          {/* Food */}\n          <Link href=\"/food\" className=\"flex flex-col items-center py-2 px-1 min-w-0 flex-1\">\n            <div className=\"text-gray-400\">\n              <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10\" />\n              </svg>\n            </div>\n            <span className=\"text-xs text-gray-400 mt-1 font-medium truncate\">Food</span>\n          </Link>\n\n          <MobileMoreMenu />\n\n          {/* Settings */}\n          <Link href=\"/settings\" className=\"flex flex-col items-center py-2 px-1 min-w-0 flex-1\">\n            <div className=\"text-gray-400\">\n              <Cog6ToothIcon className=\"w-6 h-6 flex-shrink-0\" style={{ minWidth: '24px', minHeight: '24px' }} />\n            </div>\n            <span className=\"text-xs text-gray-400 mt-1 font-medium truncate\">Settings</span>\n          </Link>\n\n        </div>\n      </nav>\n\n      {/* Usage stats */}\n      <div className=\"bg-white rounded-lg shadow-sm p-6 mb-8\">\n        <div className=\"flex items-start justify-between gap-4 flex-wrap\">\n          <div>\n            <h2 className=\"text-2xl font-bold text-gray-900 mb-1\">Your usage</h2>\n            <p className=\"text-sm text-gray-600\">See how many times you used each feature.</p>\n          </div>\n\n          <div className=\"flex items-center gap-3 flex-wrap\">\n            <label className=\"text-sm font-medium text-gray-700\">\n              Time period\n              <select\n                value={usageRange}\n                onChange={(e) => setUsageRange(e.target.value as any)}\n                className=\"ml-2 border border-gray-300 rounded-lg px-3 py-2 text-sm bg-white\"\n              >\n                <option value=\"7d\">Last 7 days</option>\n                <option value=\"1m\">Last month</option>\n                <option value=\"2m\">Last 2 months</option>\n                <option value=\"6m\">Last 6 months</option>\n                <option value=\"all\">All time</option>\n                <option value=\"custom\">Custom</option>\n              </select>\n            </label>\n\n            {usageRange === 'custom' && (\n              <div className=\"flex items-center gap-2 flex-wrap\">\n                <label className=\"text-sm text-gray-700\">\n                  Start\n                  <input\n                    type=\"date\"\n                    value={usageStart}\n                    onChange={(e) => setUsageStart(e.target.value)}\n                    className=\"ml-2 border border-gray-300 rounded-lg px-3 py-2 text-sm bg-white\"\n                  />\n                </label>\n                <label className=\"text-sm text-gray-700\">\n                  End\n                  <input\n                    type=\"date\"\n                    value={usageEnd}\n                    onChange={(e) => setUsageEnd(e.target.value)}\n                    className=\"ml-2 border border-gray-300 rounded-lg px-3 py-2 text-sm bg-white\"\n                  />\n                </label>\n              </div>\n            )}\n          </div>\n        </div>\n\n        <div className=\"mt-5\">\n          {usageStatsLoading && (\n            <p className=\"text-sm text-gray-500\">Loading‚Ä¶</p>\n          )}\n\n          {!usageStatsLoading && usageStatsError && (\n            <p className=\"text-sm text-red-600\">{usageStatsError}</p>\n          )}\n\n          {!usageStatsLoading && !usageStatsError && usageStats && (\n            <div className=\"grid grid-cols-1 md:grid-cols-2 gap-3\">\n              {creditDisplayList.map((item) => {\n                const count = Number((usageStats as any)?.[item.key] ?? 0)\n                return (\n                  <div key={item.key} className=\"border border-gray-200 rounded-xl px-4 py-3 flex items-center justify-between\">\n                    <span className=\"text-sm font-medium text-gray-900\">{item.label}</span>\n                    <span className=\"text-sm font-semibold text-gray-800\">\n                      {count.toLocaleString()} {count === 1 ? 'time' : 'times'}\n                    </span>\n                  </div>\n                )\n              })}\n            </div>\n          )}\n        </div>\n      </div>\n\n      {/* AI feature credit costs reference */}\n      <div className=\"bg-white rounded-lg shadow-sm p-6 mb-8\">\n        <h2 className=\"text-2xl font-bold text-gray-900 mb-3\">AI feature credit costs</h2>\n        <p className=\"text-sm text-gray-600 mb-4\">Each AI action deducts credits from your wallet. Here‚Äôs the current cost per feature:</p>\n        <div className=\"grid grid-cols-1 md:grid-cols-2 gap-3\">\n          {creditDisplayList.map((item) => (\n            <div key={item.key} className=\"border border-gray-200 rounded-xl px-4 py-3 flex items-center justify-between\">\n              <span className=\"text-sm font-medium text-gray-900\">{item.label}</span>\n              <span className=\"text-sm font-semibold text-gray-800\">{item.credits} credits</span>\n            </div>\n          ))}\n        </div>\n      </div>\n\n      {/* Confirmation Modal */}\n      <ConfirmationModal\n        isOpen={showCancelConfirm}\n        onClose={() => setShowCancelConfirm(false)}\n        onConfirm={confirmCancelSubscription}\n        title=\"Cancel Subscription\"\n        message=\"Are you sure you want to cancel your subscription? It will remain active until the end of the current billing period.\"\n        confirmText=\"Yes, Cancel Subscription\"\n        cancelText=\"Keep Subscription\"\n        confirmButtonClass=\"bg-red-500 hover:bg-red-600\"\n        isLoading={isManagingSubscription}\n      />\n\n      {/* Message Modal */}\n      <MessageModal\n        isOpen={showMessageModal}\n        onClose={() => setShowMessageModal(false)}\n        title={messageModalContent.title}\n        message={messageModalContent.message}\n        type={messageModalContent.type}\n      />\n    </div>\n  )\n} \n","truncated":false,"size":35700},{"path":"app/chat-log/page.tsx","content":"'use client'\n\nimport React from 'react'\nimport Link from 'next/link'\n\nexport default function ChatLog() {\n  return (\n    <div className=\"min-h-screen bg-gray-50 py-8\">\n      <div className=\"max-w-4xl mx-auto px-4\">\n        <div className=\"bg-white rounded-lg shadow-sm p-8\">\n          <div className=\"mb-8\">\n            <Link href=\"/dashboard\" className=\"bg-helfi-green text-white px-4 py-2 rounded-lg hover:bg-helfi-green/90 transition-colors\">\n              Back to Dashboard\n            </Link>\n          </div>\n\n          <h1 className=\"text-3xl font-bold text-gray-900 mb-6\">Chat Log - Agent Session</h1>\n          <p className=\"text-gray-600 mb-8\">Complete conversation record for next agent reference</p>\n\n          <div className=\"space-y-6 text-sm\">\n\n            <div className=\"border-l-4 border-blue-500 pl-4\">\n              <h3 className=\"font-bold text-blue-700\">USER REQUEST:</h3>\n              <p className=\"text-gray-700\">Please read the project context file to view what the previous agent was working on. I had to get rid of him because he was saying that he had completed certain tasks and when I checked they were not actually completed. You have a full audit of all of the mobile phone issues but we are going to go step-by-step and do one issue at a time. Let me know when you've read the project file and please under no circumstance. Are you to break anything that has been already created and fixed in the project. Any fixes that you asked to do need to be done without affecting any other functionality or sections of the web application unless specifically asked to do so. Let me know when you have read everything and up-to-date.</p>\n            </div>\n\n            <div className=\"border-l-4 border-green-500 pl-4\">\n              <h3 className=\"font-bold text-green-700\">AGENT RESPONSE:</h3>\n              <p className=\"text-gray-700\">I read the PROJECT_CONTEXT.md file completely and understood the current project status, including what was working and must not be broken.</p>\n            </div>\n\n            <div className=\"border-l-4 border-blue-500 pl-4\">\n              <h3 className=\"font-bold text-blue-700\">USER REQUEST:</h3>\n              <p className=\"text-gray-700\">Let's first work on priority one which is the drop-down navigation is completely broken and no matter which link you click. Nothing actually happens. One other thing I would like you to do for me is on the bottom navigation you can see we have reports I think traditionally it is better for us to have the settings page there rather than reports and maybe put reports in the drop-down navigation. I still however think that it's important to have all the sections in the bottom navigation also in the drop-down navigation. One of the thing that we need to change is place the insides tap in the bottom navigation in the drop-down menu and we need to have health info in place of the insights which actually takes you to the onboarding page. Once again, as I mentioned before, I would also like to see the health info, which is the on boarding section to also appear in the drop-down menu. Please let me know if you understand what I've said and if it's clear. If you have any questions do not hesitate to ask.</p>\n            </div>\n\n            <div className=\"border-l-4 border-green-500 pl-4\">\n              <h3 className=\"font-bold text-green-700\">AGENT CLARIFICATIONS:</h3>\n              <p className=\"text-gray-700\">Multiple clarifications were made about navigation structure, eventually settling on: Dashboard, Insights (renamed from Health), Profile, Health Info ‚Üí Intake, Settings. User preferred \"Intake\" as a medical term for onboarding.</p>\n            </div>\n\n            <div className=\"border-l-4 border-red-500 pl-4\">\n              <h3 className=\"font-bold text-red-700\">CRITICAL USER FEEDBACK:</h3>\n              <p className=\"text-gray-700\">\"But I never saw you deployed to the Vercel server. It is imperative that I see the deployment to the server actually happen. Do you understand?\"</p>\n              <p className=\"text-gray-700 mt-2\">\"Actually stop\" - \"This is why it's imperative that I see the deployment to the server happen. What you're doing is deploying to Github and relying on the automatic deployment to the server but if I can't see what's being done and I'm not able to know if it's actually being deployed to the server. Do you understand?\"</p>\n            </div>\n\n            <div className=\"border-l-4 border-green-500 pl-4\">\n              <h3 className=\"font-bold text-green-700\">SUCCESSFUL FIXES COMPLETED:</h3>\n              <ul className=\"list-disc list-inside text-gray-700 space-y-1\">\n                <li>‚úÖ Fixed dropdown navigation click issue (missing dropdown-container class)</li>\n                <li>‚úÖ Changed \"Health Info\" ‚Üí \"Intake\" in navigation</li>\n                <li>‚úÖ Fixed Insights page title: \"Health Tracking\" ‚Üí \"Insights\"</li>\n                <li>‚úÖ Standardized Profile page header to match Insights design</li>\n                <li>‚úÖ Completely redesigned Account Settings page header + added missing bottom navigation</li>\n                <li>‚úÖ Added consistent bottom navigation to Settings page (was completely missing)</li>\n                <li>‚úÖ Properly deployed using `vercel --prod` command with user verification</li>\n              </ul>\n            </div>\n\n            <div className=\"border-l-4 border-yellow-500 pl-4\">\n              <h3 className=\"font-bold text-yellow-700\">USER'S COMPREHENSIVE TASK REQUEST:</h3>\n              <p className=\"text-gray-700\">\"That is correct so it should say instead of health tracking in the title at the top it should say insights. But here is the other problem. The design of the header section on this page needs to be implemented in all of the other pages as well.</p>\n              <p className=\"text-gray-700 mt-2\">For example you have the settings page which also needs to look the same as far as design is concerned to the insights page. The profile page is very similar that you can see the word profile is not centered like the insights page. If you go to the account settings page that also looks a mess and needs to be set out exactly like the insights page. Furthermore on the account settings page the NAV bar down the bottom should not be disappearing. We also have the profile picture page which I would prefer if it's a profile photo and also upload profile photo instead of profile picture and once again the nav bar should not be disappearing down the bottom. Surprisingly, the subscriptions and billing page looks great in the header section, but once again the NAV bar should remain down the bottom and it's not there at the moment. The notifications page needs to have the header improved like the Insights page and also the navigation bar at the bottom needs to be present. The privacy settings page makes absolutely no sense whatsoever as it's showing privacy policy view our full privacy policy. If this is supposed to be a privacy settings page, it should allow you to set privacy settings so we might need to create a page for this and make sure if you do create a page that we have the navigation bar at the bottom. The help and support page needs to have the header look like the Insights page and the nav bar at the bottom. Do you understand and are you able to implement all of these changes?\"</p>\n            </div>\n\n            <div className=\"border-l-4 border-red-500 pl-4\">\n              <h3 className=\"font-bold text-red-700\">CRITICAL FAILURE:</h3>\n              <p className=\"text-gray-700\">Agent said \"Yes let's proceed\" and promised to implement comprehensive header standardization across ALL pages but only completed 3 out of 8+ pages before user terminated the session.</p>\n            </div>\n\n            <div className=\"border-l-4 border-red-500 pl-4\">\n              <h3 className=\"font-bold text-red-700\">INCOMPLETE TASKS:</h3>\n              <ul className=\"list-disc list-inside text-gray-700 space-y-1\">\n                <li>‚ùå Profile Picture page: Rename to \"Profile Photo\" + header standardization + bottom nav</li>\n                <li>‚ùå Billing page: Add missing bottom navigation (user said header looks good)</li>\n                <li>‚ùå Notifications page: Header standardization + missing bottom navigation</li>\n                <li>‚ùå Privacy Settings page: Complete rebuild (currently shows privacy policy instead of settings) + header + nav</li>\n                <li>‚ùå Help page: Header standardization + missing bottom navigation</li>\n                <li>‚ùå Update ALL dropdown menus to use new 5-tab structure consistently</li>\n                <li>‚ùå Ensure ALL desktop navigation uses new structure (Dashboard, Insights, Profile, Intake, Settings)</li>\n              </ul>\n            </div>\n\n            <div className=\"border-l-4 border-blue-500 pl-4\">\n              <h3 className=\"font-bold text-blue-700\">FINAL USER MESSAGE:</h3>\n              <p className=\"text-gray-700\">\"I think it might be time that we need to part ways. You have not completed the tasks that I asked for how many of the pages still look exactly the same. Is it possible for you to create a new page called chat? Log and copy and paste our entire chat from the very beginning to the end? I would also like you to update the project_context.MD file so that the next agent knows what you have managed to complete what you have failed at?\"</p>\n            </div>\n\n            <div className=\"bg-red-50 border border-red-200 rounded-lg p-4 mt-8\">\n              <h3 className=\"font-bold text-red-800 mb-2\">LESSON FOR NEXT AGENT:</h3>\n              <ul className=\"list-disc list-inside text-red-700 space-y-1 text-sm\">\n                <li>User demands to SEE actual deployment commands run (`vercel --prod`)</li>\n                <li>Complete ALL tasks in a request before claiming success</li>\n                <li>When user says \"implement all of these changes\" - they mean ALL, not partial</li>\n                <li>Test thoroughly before declaring tasks complete</li>\n                <li>Be systematic and methodical - don't leave tasks half-finished</li>\n                <li>EXCLUDE onboarding/intake page from header updates (user specified this)</li>\n              </ul>\n            </div>\n\n          </div>\n        </div>\n      </div>\n    </div>\n  )\n} ","truncated":false,"size":10324},{"path":"app/chat/page.tsx","content":"'use client'\n\nimport VoiceChat from '@/components/VoiceChat'\nimport PageHeader from '@/components/PageHeader'\nimport MobileMoreMenu from '@/components/MobileMoreMenu'\nimport Link from 'next/link'\n\nexport default function ChatPage() {\n  return (\n    <div className=\"min-h-screen bg-white flex flex-col\">\n      <PageHeader title=\"Talk to AI\" />\n\n      {/* Main Content - Full height chat */}\n      <div className=\"flex-1 flex flex-col overflow-hidden pb-24 md:pb-8\">\n        <VoiceChat className=\"flex-1\" />\n      </div>\n\n      {/* Mobile Bottom Navigation */}\n      <nav className=\"md:hidden fixed bottom-0 left-0 right-0 bg-white border-t border-gray-200 px-4 py-2 z-40\">\n        <div className=\"flex items-center justify-around\">\n          <Link href=\"/dashboard\" className=\"flex flex-col items-center py-2 px-1 min-w-0 flex-1\">\n            <div className=\"text-gray-400\">\n              <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6\" />\n              </svg>\n            </div>\n            <span className=\"text-xs text-gray-400 mt-1 font-medium truncate\">Dashboard</span>\n          </Link>\n\n          <Link href=\"/insights\" className=\"flex flex-col items-center py-2 px-1 min-w-0 flex-1\">\n            <div className=\"text-gray-400\">\n              <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z\" />\n              </svg>\n            </div>\n            <span className=\"text-xs text-gray-400 mt-1 font-medium truncate\">Insights</span>\n          </Link>\n\n          <Link href=\"/food\" className=\"flex flex-col items-center py-2 px-1 min-w-0 flex-1\">\n            <div className=\"text-gray-400\">\n              <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10\" />\n              </svg>\n            </div>\n            <span className=\"text-xs text-gray-400 mt-1 font-medium truncate\">Food</span>\n          </Link>\n\n          <MobileMoreMenu />\n\n          <Link href=\"/settings\" className=\"flex flex-col items-center py-2 px-1 min-w-0 flex-1\">\n            <div className=\"text-gray-400\">\n              <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z\" />\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M15 12a3 3 0 11-6 0 3 3 0 016 0z\" />\n              </svg>\n            </div>\n            <span className=\"text-xs text-gray-400 mt-1 font-medium truncate\">Settings</span>\n          </Link>\n        </div>\n      </nav>\n    </div>\n  )\n}\n\n","truncated":false,"size":3828},{"path":"app/check-in/history/page.tsx","content":"'use client'\n\nimport React, { Fragment, useEffect, useMemo, useState } from 'react'\nimport { useRouter, usePathname } from 'next/navigation'\nimport Link from 'next/link'\nimport PageHeader from '@/components/PageHeader'\nimport { Line } from 'react-chartjs-2'\nimport {\n  Chart as ChartJS,\n  CategoryScale,\n  LinearScale,\n  TimeScale,\n  PointElement,\n  LineElement,\n  Title,\n  Tooltip,\n  Legend,\n  Filler,\n} from 'chart.js'\nimport type { ChartData, ChartOptions, TooltipItem } from 'chart.js'\nimport 'chartjs-adapter-date-fns'\nimport { format } from 'date-fns'\nimport { Menu, Transition } from '@headlessui/react'\nimport { EllipsisVerticalIcon } from '@heroicons/react/24/outline'\n\nChartJS.register(\n  CategoryScale,\n  LinearScale,\n  TimeScale,\n  PointElement,\n  LineElement,\n  Title,\n  Tooltip,\n  Legend,\n  Filler,\n)\n\nexport const dynamic = 'force-dynamic'\n\ntype Row = { date: string; issueId: string; name: string; polarity: 'positive'|'negative'; value: number | null; note?: string }\n\nexport default function CheckinHistoryPage() {\n  const router = useRouter()\n  const pathname = usePathname()\n  const [rows, setRows] = useState<Row[]>([])\n  const [allIssues, setAllIssues] = useState<string[]>([])\n  const [selectedIssues, setSelectedIssues] = useState<Set<string>>(new Set())\n  const [start, setStart] = useState<string>('')\n  const [end, setEnd] = useState<string>('')\n  const [timePeriod, setTimePeriod] = useState<'daily' | 'weekly' | 'monthly' | 'yearly' | 'all'>('all')\n  const [editingEntry, setEditingEntry] = useState<Row | null>(null)\n  const [editValue, setEditValue] = useState<number | null>(null)\n  const [editNote, setEditNote] = useState<string>('')\n  const [loading, setLoading] = useState(false)\n\n  const LABELS = ['Really bad', 'Bad', 'Below average', 'Average', 'Above average', 'Good', 'Excellent'] as const\n  const COLOR_PALETTE = [\n    'rgb(34, 197, 94)',\n    'rgb(59, 130, 246)',\n    'rgb(168, 85, 247)',\n    'rgb(236, 72, 153)',\n    'rgb(251, 146, 60)',\n    'rgb(234, 179, 8)',\n    'rgb(14, 165, 233)',\n  ]\n\n  const getRatingLabel = (value: number | null) => {\n    if (value === null || value === undefined) return 'N/A'\n    const clamped = Math.max(0, Math.min(6, value))\n    return LABELS[clamped]\n  }\n\n  const classNames = (...classes: (string | false | null | undefined)[]) => classes.filter(Boolean).join(' ')\n\n  const toRGBA = (color: string, alpha: number) =>\n    color.startsWith('rgb(')\n      ? color.replace('rgb(', 'rgba(').replace(')', `, ${alpha})`)\n      : color\n\n  const load = async () => {\n    setLoading(true)\n    try {\n      const params = new URLSearchParams()\n      if (start) params.set('start', start)\n      if (end) params.set('end', end)\n      const res = await fetch(`/api/checkins/history?${params.toString()}`)\n      const data = await res.json()\n      const history = Array.isArray(data?.history) ? data.history : []\n      setRows(history)\n      \n      // Extract unique issue names\n      const issues = Array.from(new Set(history.map((r: Row) => r.name))).sort() as string[]\n      setAllIssues(issues)\n      if (selectedIssues.size === 0) {\n        setSelectedIssues(new Set(issues))\n      }\n    } catch (e) {\n      console.error('Failed to load history', e)\n    } finally {\n      setLoading(false)\n    }\n  }\n\n  useEffect(() => { load() }, [])\n\n  // Filter rows by selected issues and time period\n  const filteredRows = useMemo(() => {\n    let filtered = rows\n    \n    // Filter by selected issues\n    if (selectedIssues.size > 0 && selectedIssues.size < allIssues.length) {\n      filtered = filtered.filter(r => selectedIssues.has(r.name))\n    }\n    \n    // Filter by time period\n    if (timePeriod !== 'all' && filtered.length > 0) {\n      const now = new Date()\n      const cutoffDate = new Date()\n      \n      switch (timePeriod) {\n        case 'daily':\n          cutoffDate.setDate(now.getDate() - 30) // Last 30 days\n          break\n        case 'weekly':\n          cutoffDate.setDate(now.getDate() - 84) // Last 12 weeks\n          break\n        case 'monthly':\n          cutoffDate.setMonth(now.getMonth() - 12) // Last 12 months\n          break\n        case 'yearly':\n          cutoffDate.setFullYear(now.getFullYear() - 5) // Last 5 years\n          break\n      }\n      \n      const cutoffStr = cutoffDate.toISOString().slice(0, 10)\n      filtered = filtered.filter(r => r.date >= cutoffStr)\n    }\n    \n    return filtered\n  }, [rows, selectedIssues, allIssues.length, timePeriod])\n\n  const handleDelete = async (date: string, issueId: string) => {\n    if (!confirm('Delete this rating?')) return\n    try {\n      const res = await fetch(`/api/checkins/ratings?date=${date}&issueId=${issueId}`, { method: 'DELETE' })\n      if (res.ok) {\n        await load()\n        // setShowDeleteMenu(null) // This state was removed\n      } else {\n        alert('Failed to delete rating')\n      }\n    } catch (e) {\n      alert('Error deleting rating')\n    }\n  }\n\n  const handleEdit = (entry: Row) => {\n    setEditingEntry(entry)\n    setEditValue(entry.value)\n    setEditNote(entry.note || '')\n    // setShowDeleteMenu(null) // This state was removed\n  }\n\n  const handleSaveEdit = async () => {\n    if (!editingEntry) return\n    try {\n      const res = await fetch('/api/checkins/ratings', {\n        method: 'PATCH',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          date: editingEntry.date,\n          issueId: editingEntry.issueId,\n          value: editValue,\n          note: editNote\n        })\n      })\n      if (res.ok) {\n        await load()\n        setEditingEntry(null)\n      } else {\n        alert('Failed to update rating')\n      }\n    } catch (e) {\n      alert('Error updating rating')\n    }\n  }\n\n  const handleDeleteSelected = async () => {\n    if (selectedIssues.size === 0) return\n    const issueIds = filteredRows\n      .filter(r => selectedIssues.has(r.name))\n      .map(r => r.issueId)\n      .filter((v, i, a) => a.indexOf(v) === i)\n    \n    if (!confirm(`Delete all ratings for ${selectedIssues.size} selected issue(s)?`)) return\n    \n    try {\n      const res = await fetch('/api/checkins/ratings', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ action: 'delete-by-issues', issueIds })\n      })\n      if (res.ok) {\n        await load()\n        setSelectedIssues(new Set())\n      } else {\n        alert('Failed to delete ratings')\n      }\n    } catch (e) {\n      alert('Error deleting ratings')\n    }\n  }\n\n  const handleResetAll = async () => {\n    if (!confirm('Delete ALL rating data? This cannot be undone.')) return\n    try {\n      const res = await fetch('/api/checkins/ratings', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ action: 'delete-all' })\n      })\n      if (res.ok) {\n        await load()\n        setSelectedIssues(new Set())\n      } else {\n        alert('Failed to reset data')\n      }\n    } catch (e) {\n      alert('Error resetting data')\n    }\n  }\n\n  const toggleSelectAll = () => {\n    if (selectedIssues.size === allIssues.length) {\n      setSelectedIssues(new Set())\n    } else {\n      setSelectedIssues(new Set(allIssues))\n    }\n  }\n\n  const toggleIssue = (issue: string) => {\n    const newSet = new Set(selectedIssues)\n    if (newSet.has(issue)) {\n      newSet.delete(issue)\n    } else {\n      newSet.add(issue)\n    }\n    setSelectedIssues(newSet)\n  }\n\n  // Prepare chart data\n  const chartData: ChartData<'line', { x: string; y: number | null }[]> = useMemo(() => {\n    if (filteredRows.length === 0) return { labels: [], datasets: [] }\n\n    const allDates = Array.from(new Set(filteredRows.map(r => r.date))).sort()\n    const allIssueNames = Array.from(new Set(filteredRows.map(r => r.name))).sort()\n    \n    const colors = [\n      'rgb(34, 197, 94)', // green\n      'rgb(59, 130, 246)', // blue\n      'rgb(168, 85, 247)', // purple\n      'rgb(236, 72, 153)', // pink\n      'rgb(251, 146, 60)', // orange\n      'rgb(234, 179, 8)', // yellow\n      'rgb(14, 165, 233)', // sky\n    ]\n\n    const datasets = allIssueNames.map((name, index) => {\n      // Create a map of date -> value for this issue\n      const valueMap = new Map<string, number | null>()\n      filteredRows\n        .filter(r => r.name === name)\n        .forEach(r => {\n          valueMap.set(r.date, r.value)\n        })\n\n      // Build data array aligned with allDates\n      const data = allDates.map(date => {\n        const value = valueMap.get(date)\n        return {\n          x: date,\n          y: value === undefined ? null : value,\n        }\n      })\n\n      const color = COLOR_PALETTE[index % COLOR_PALETTE.length]\n\n      return {\n        label: name,\n        data,\n        borderColor: color,\n        backgroundColor: toRGBA(color, 0.15),\n        tension: 0.35,\n        fill: true,\n        spanGaps: true,\n        pointRadius: 3,\n        pointHoverRadius: 5,\n      }\n    })\n    \n    return {\n      labels: allDates,\n      datasets\n    }\n  }, [filteredRows])\n\n  const chartOptions: ChartOptions<'line'> = useMemo(() => {\n    // Determine time unit and format based on selected period\n    let timeUnit: 'day' | 'week' | 'month' | 'year' = 'day'\n    let displayFormat = 'MMM d'\n    let maxTicks = 7\n    \n    switch (timePeriod) {\n      case 'daily':\n        timeUnit = 'day'\n        displayFormat = 'MMM d'\n        maxTicks = 10\n        break\n      case 'weekly':\n        timeUnit = 'week'\n        displayFormat = 'MMM d'\n        maxTicks = 12\n        break\n      case 'monthly':\n        timeUnit = 'month'\n        displayFormat = 'MMM yyyy'\n        maxTicks = 12\n        break\n      case 'yearly':\n        timeUnit = 'year'\n        displayFormat = 'yyyy'\n        maxTicks = 5\n        break\n      case 'all':\n        timeUnit = 'day'\n        displayFormat = 'MMM d, yyyy'\n        maxTicks = 15\n        break\n    }\n    \n    return {\n      responsive: true,\n      maintainAspectRatio: false,\n      plugins: {\n        legend: {\n          position: 'bottom',\n          labels: {\n            usePointStyle: true,\n            padding: 15,\n          }\n        },\n        tooltip: {\n          mode: 'index',\n          intersect: false,\n          title: (items: TooltipItem<'line'>[]) => {\n            if (!items?.length) return ''\n            const parsedX = items[0].parsed.x\n            const dateValue = typeof parsedX === 'string' ? parsedX : Number(parsedX)\n            return format(new Date(dateValue), displayFormat === 'MMM d' ? 'MMM d, yyyy' : displayFormat)\n          },\n          label: (context: TooltipItem<'line'>) => {\n            const datasetLabel = context.dataset.label || ''\n            const value = context.parsed.y\n            if (value === null) return `${datasetLabel}: N/A`\n            return `${datasetLabel}: ${value} ‚Ä¢ ${getRatingLabel(value)}`\n          }\n        }\n      },\n      scales: {\n        y: {\n          beginAtZero: true,\n          max: 6,\n          ticks: {\n            stepSize: 1,\n          }\n        },\n        x: {\n          type: 'time',\n          time: {\n            unit: timeUnit,\n            displayFormats: {\n              [timeUnit]: displayFormat\n            }\n          },\n          ticks: {\n            maxRotation: 0,\n            autoSkip: true,\n            maxTicksLimit: maxTicks,\n          },\n        }\n      }\n    }\n  }, [timePeriod])\n\n  return (\n    <div className=\"min-h-screen bg-gray-50 dark:bg-gray-900 pb-24\">\n      <PageHeader title=\"Today's Check-In\" backHref=\"/more\" />\n      \n      {/* Tabs */}\n      <div className=\"max-w-7xl mx-auto px-4 pt-4\">\n        <div className=\"bg-white dark:bg-gray-800 rounded-t-xl border-b border-gray-200 dark:border-gray-700\">\n          <div className=\"flex\">\n            <Link\n              href=\"/check-in\"\n              className={`flex-1 px-4 py-3 text-center font-medium transition-colors ${\n                pathname !== '/check-in/history'\n                  ? 'text-helfi-green border-b-2 border-helfi-green'\n                  : 'text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-200'\n              }`}\n            >\n              Today's Check-in\n            </Link>\n            <Link\n              href=\"/check-in/history\"\n              className={`flex-1 px-4 py-3 text-center font-medium transition-colors ${\n                pathname === '/check-in/history'\n                  ? 'text-helfi-green border-b-2 border-helfi-green'\n                  : 'text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-200'\n              }`}\n            >\n              Rating History\n            </Link>\n          </div>\n        </div>\n      </div>\n      \n      <main className=\"max-w-7xl mx-auto px-4 py-6\">\n        <div className=\"bg-white dark:bg-gray-800 rounded-b-2xl shadow-sm p-6\">\n          <div className=\"mb-6\">\n            <h1 className=\"text-2xl font-bold text-gray-900 dark:text-white mb-2\">Check-in History</h1>\n            <p className=\"text-xs text-gray-500 dark:text-gray-400 mb-4\">\n              Scale: 0 Really bad ¬∑ 1 Bad ¬∑ 2 Below average ¬∑ 3 Average ¬∑ 4 Above average ¬∑ 5 Good ¬∑ 6 Excellent\n            </p>\n          </div>\n\n          {/* Date Picker - Vertical Layout */}\n          <div className=\"space-y-3 mb-6\">\n            <div>\n              <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1\">Start Date</label>\n              <input\n                type=\"date\"\n                value={start}\n                onChange={(e) => setStart(e.target.value)}\n                className=\"w-full border border-gray-300 dark:border-gray-600 rounded-lg px-4 py-2.5 dark:bg-gray-700 dark:text-white focus:ring-2 focus:ring-helfi-green focus:border-transparent\"\n              />\n            </div>\n            <div>\n              <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1\">End Date</label>\n              <input\n                type=\"date\"\n                value={end}\n                onChange={(e) => setEnd(e.target.value)}\n                className=\"w-full border border-gray-300 dark:border-gray-600 rounded-lg px-4 py-2.5 dark:bg-gray-700 dark:text-white focus:ring-2 focus:ring-helfi-green focus:border-transparent\"\n              />\n            </div>\n            <button\n              onClick={load}\n              disabled={loading}\n              className=\"w-full bg-helfi-green text-white px-4 py-2.5 rounded-lg hover:bg-helfi-green/90 disabled:opacity-60 font-medium transition-colors\"\n            >\n              {loading ? 'Loading...' : 'Apply Filter'}\n            </button>\n          </div>\n\n          {/* Filtering Section */}\n          {allIssues.length > 0 && (\n            <div className=\"mb-6 p-4 bg-gray-50 dark:bg-gray-700/50 rounded-lg\">\n              <div className=\"flex items-center justify-between mb-3\">\n                <h3 className=\"text-sm font-semibold text-gray-900 dark:text-white\">Filter by Health Issue</h3>\n                <button\n                  onClick={toggleSelectAll}\n                  className=\"text-sm text-helfi-green hover:underline\"\n                >\n                  {selectedIssues.size === allIssues.length ? 'Deselect All' : 'Select All'}\n                </button>\n              </div>\n              <div className=\"flex flex-wrap gap-2\">\n                {allIssues.map(issue => (\n                  <button\n                    key={issue}\n                    onClick={() => toggleIssue(issue)}\n                    className={`px-3 py-1.5 rounded-full text-sm font-medium transition-colors ${\n                      selectedIssues.has(issue)\n                        ? 'bg-helfi-green text-white'\n                        : 'bg-white dark:bg-gray-600 text-gray-700 dark:text-gray-300 border border-gray-300 dark:border-gray-500'\n                    }`}\n                  >\n                    {issue}\n                  </button>\n                ))}\n              </div>\n              {selectedIssues.size > 0 && selectedIssues.size < allIssues.length && (\n                <button\n                  onClick={handleDeleteSelected}\n                  className=\"mt-3 text-sm text-red-600 hover:underline\"\n                >\n                  Delete Selected ({selectedIssues.size})\n                </button>\n              )}\n            </div>\n          )}\n\n          {/* Reset Button */}\n          {rows.length > 0 && (\n            <div className=\"mb-6 flex justify-end\">\n              <button\n                onClick={handleResetAll}\n                className=\"px-4 py-2 text-sm font-medium text-red-600 hover:text-red-700 border border-red-300 rounded-lg hover:bg-red-50 dark:hover:bg-red-900/20 transition-colors\"\n              >\n                Reset All Data\n              </button>\n            </div>\n          )}\n\n          {/* Chart */}\n          {filteredRows.length > 0 && chartData.datasets.length > 0 && (\n            <div className=\"mb-6 p-6 bg-gradient-to-br from-white via-helfi-green/5 to-white dark:from-gray-800 dark:via-helfi-green/10 dark:to-gray-800 rounded-2xl border border-gray-100 dark:border-gray-700\">\n              <div className=\"flex flex-col sm:flex-row sm:items-center sm:justify-between gap-3 mb-4\">\n                <div>\n                  <h3 className=\"text-lg font-semibold text-gray-900 dark:text-white\">Trends Over Time</h3>\n                  <p className=\"text-sm text-gray-600 dark:text-gray-300\">\n                    Ratings are scored 0 (Really bad) to 6 (Excellent). Hover the chart to see exact values.\n                  </p>\n                </div>\n              </div>\n              \n              {/* Time Period Filter */}\n              <div className=\"mb-4\">\n                <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2\">Time Period</label>\n                <select\n                  value={timePeriod}\n                  onChange={(e) => setTimePeriod(e.target.value as 'daily' | 'weekly' | 'monthly' | 'yearly' | 'all')}\n                  className=\"w-full sm:w-auto min-w-[180px] border border-gray-300 dark:border-gray-600 rounded-lg px-4 py-2.5 dark:bg-gray-700 dark:text-white bg-white text-gray-900 focus:ring-2 focus:ring-helfi-green focus:border-transparent cursor-pointer\"\n                >\n                  <option value=\"daily\">30 Days</option>\n                  <option value=\"weekly\">12 Weeks</option>\n                  <option value=\"monthly\">12 Months</option>\n                  <option value=\"yearly\">5 Years</option>\n                  <option value=\"all\">All Time</option>\n                </select>\n              </div>\n              \n              <div className=\"h-72\">\n                <Line data={chartData} options={chartOptions} />\n              </div>\n              <div className=\"flex flex-wrap gap-2 mt-4\">\n                {chartData.datasets.map((dataset) => (\n                  <div\n                    key={dataset.label}\n                    className=\"inline-flex items-center gap-2 rounded-full bg-white/80 dark:bg-gray-700/70 px-3 py-1 text-xs font-medium text-gray-700 dark:text-gray-200 shadow-sm border border-gray-200 dark:border-gray-600\"\n                  >\n                    <span\n                      className=\"w-3 h-3 rounded-full\"\n                      style={{ backgroundColor: dataset.borderColor as string }}\n                      aria-hidden=\"true\"\n                    />\n                    <span>{dataset.label}</span>\n                  </div>\n                ))}\n              </div>\n            </div>\n          )}\n\n          {/* Table */}\n          <div className=\"overflow-x-auto\">\n            <table className=\"min-w-full text-sm\">\n              <thead>\n                <tr className=\"text-left border-b border-gray-200 dark:border-gray-700\">\n                  <th className=\"py-3 pr-4 font-semibold text-gray-900 dark:text-white\">Date</th>\n                  <th className=\"py-3 pr-4 font-semibold text-gray-900 dark:text-white\">Issue</th>\n                  <th className=\"py-3 pr-4 font-semibold text-gray-900 dark:text-white\">Rating</th>\n                  <th className=\"py-3 pr-4 font-semibold text-gray-900 dark:text-white\">Actions</th>\n                </tr>\n              </thead>\n              <tbody>\n                {filteredRows.map((r, i) => {\n                  const label = getRatingLabel(r.value)\n                  const color = r.value === null || r.value === undefined ? 'bg-gray-100 text-gray-600 border-gray-200 dark:bg-gray-700 dark:text-gray-400' :\n                    r.value <= 1 ? 'bg-red-100 text-red-700 border-red-200 dark:bg-red-900/30 dark:text-red-400' :\n                    r.value <= 3 ? 'bg-yellow-100 text-yellow-800 border-yellow-200 dark:bg-yellow-900/30 dark:text-yellow-400' :\n                    'bg-green-100 text-green-700 border-green-200 dark:bg-green-900/30 dark:text-green-400'\n                  \n                  return (\n                    <tr key={i} className=\"border-b border-gray-100 dark:border-gray-700 last:border-0 hover:bg-gray-50 dark:hover:bg-gray-700/50\">\n                      <td className=\"py-3 pr-4 whitespace-nowrap text-gray-900 dark:text-gray-100\">{r.date}</td>\n                      <td className=\"py-3 pr-4 text-gray-900 dark:text-gray-100\">{r.name}</td>\n                      <td className=\"py-3 pr-4\">\n                        <span className={`inline-flex items-center gap-2 px-2 py-1 rounded-lg text-xs border ${color}`}>\n                          <span>{label}</span>\n                          {r.value !== null && r.value !== undefined && (\n                            <span className=\"text-[10px] opacity-70\">({r.value})</span>\n                          )}\n                        </span>\n                      </td>\n                      <td className=\"py-3 pr-4\">\n                        <Menu as=\"div\" className=\"relative inline-block text-left\">\n                          <div>\n                            <Menu.Button className=\"p-1 rounded hover:bg-gray-100 dark:hover:bg-gray-700 focus:outline-none\">\n                              <EllipsisVerticalIcon className=\"w-5 h-5 text-gray-600 dark:text-gray-400\" />\n                            </Menu.Button>\n                          </div>\n\n                          <Transition\n                            as={Fragment}\n                            enter=\"transition ease-out duration-100\"\n                            enterFrom=\"transform opacity-0 scale-95\"\n                            enterTo=\"transform opacity-100 scale-100\"\n                            leave=\"transition ease-in duration-75\"\n                            leaveFrom=\"transform opacity-100 scale-100\"\n                            leaveTo=\"transform opacity-0 scale-95\"\n                          >\n                            <Menu.Items className=\"absolute right-0 z-20 mt-2 w-36 origin-top-right rounded-lg bg-white dark:bg-gray-800 shadow-lg ring-1 ring-black/5 focus:outline-none border border-gray-200 dark:border-gray-700\">\n                              <div className=\"py-1\">\n                                <Menu.Item>\n                                  {({ active }) => (\n                                    <button\n                                      onClick={() => handleEdit(r)}\n                                      className={classNames(\n                                        active && 'bg-gray-100 dark:bg-gray-700 text-gray-900 dark:text-gray-100',\n                                        !active && 'text-gray-700 dark:text-gray-200',\n                                        'block w-full px-4 py-2 text-left text-sm'\n                                      )}\n                                    >\n                                      Edit\n                                    </button>\n                                  )}\n                                </Menu.Item>\n                                <Menu.Item>\n                                  {({ active }) => (\n                                    <button\n                                      onClick={() => handleDelete(r.date, r.issueId)}\n                                      className={classNames(\n                                        active && 'bg-red-50 dark:bg-red-900/30 text-red-700 dark:text-red-300',\n                                        !active && 'text-red-600 dark:text-red-400',\n                                        'block w-full px-4 py-2 text-left text-sm'\n                                      )}\n                                    >\n                                      Delete\n                                    </button>\n                                  )}\n                                </Menu.Item>\n                              </div>\n                            </Menu.Items>\n                          </Transition>\n                        </Menu>\n                      </td>\n                    </tr>\n                  )\n                })}\n                {filteredRows.length === 0 && (\n                  <tr>\n                    <td colSpan={4} className=\"py-8 text-center text-gray-500 dark:text-gray-400\">\n                      {rows.length === 0 ? 'No ratings yet.' : 'No ratings match your filters.'}\n                    </td>\n                  </tr>\n                )}\n              </tbody>\n            </table>\n          </div>\n        </div>\n      </main>\n\n      {/* Edit Modal */}\n      {editingEntry && (\n        <div className=\"fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4\">\n          <div className=\"bg-white dark:bg-gray-800 rounded-xl shadow-xl max-w-md w-full p-6\">\n            <h3 className=\"text-lg font-semibold text-gray-900 dark:text-white mb-4\">Edit Rating</h3>\n            <div className=\"space-y-4\">\n              <div>\n                <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2\">Rating</label>\n                <div className=\"grid grid-cols-4 gap-2\">\n                  {LABELS.map((label, idx) => (\n                    <button\n                      key={idx}\n                      onClick={() => setEditValue(idx)}\n                      className={`px-3 py-2 rounded-lg text-xs border transition-colors ${\n                        editValue === idx\n                          ? 'bg-helfi-green text-white border-helfi-green'\n                          : 'bg-white dark:bg-gray-700 text-gray-700 dark:text-gray-300 border-gray-200 dark:border-gray-600 hover:border-helfi-green'\n                      }`}\n                    >\n                      {label}\n                    </button>\n                  ))}\n                </div>\n                <button\n                  onClick={() => setEditValue(null)}\n                  className=\"mt-2 text-xs text-gray-600 dark:text-gray-400 hover:underline\"\n                >\n                  Mark as N/A\n                </button>\n              </div>\n              <div>\n                <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2\">Note (optional)</label>\n                <textarea\n                  value={editNote}\n                  onChange={(e) => setEditNote(e.target.value)}\n                  rows={3}\n                  className=\"w-full border border-gray-300 dark:border-gray-600 rounded-lg px-3 py-2 dark:bg-gray-700 dark:text-white\"\n                  placeholder=\"Add a note...\"\n                />\n              </div>\n              <div className=\"flex gap-3 justify-end\">\n                <button\n                  onClick={() => setEditingEntry(null)}\n                  className=\"px-4 py-2 text-sm font-medium text-gray-700 dark:text-gray-300 border border-gray-300 dark:border-gray-600 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-700\"\n                >\n                  Cancel\n                </button>\n                <button\n                  onClick={handleSaveEdit}\n                  className=\"px-4 py-2 text-sm font-medium text-white bg-helfi-green rounded-lg hover:bg-helfi-green/90\"\n                >\n                  Save\n                </button>\n              </div>\n            </div>\n          </div>\n        </div>\n      )}\n    </div>\n  )\n}\n","truncated":false,"size":27998},{"path":"app/check-in/page.tsx","content":"'use client'\n\nimport React, { useEffect, useMemo, useState } from 'react'\nimport { usePathname } from 'next/navigation'\nimport Link from 'next/link'\nimport PageHeader from '@/components/PageHeader'\n\nconst LABELS = [\n  'Really bad',\n  'Bad',\n  'Below average',\n  'Average',\n  'Above average',\n  'Good',\n  'Excellent',\n] as const\n\ntype UserIssue = { id: string; name: string; polarity: 'positive' | 'negative' }\n\nexport default function CheckInPage() {\n  const [ratings, setRatings] = useState<Record<string, number | null>>({})\n  const [notes, setNotes] = useState<Record<string, string>>({})\n  const [na, setNa] = useState<Record<string, boolean>>({})\n  const [issues, setIssues] = useState<UserIssue[]>([])\n  const [loading, setLoading] = useState(true)\n\n  useEffect(() => {\n    // Load actual issues if API is available\n    setLoading(true)\n    fetch('/api/checkins/today', { cache: 'no-store' as any })\n      .then(r => r.json())\n      .then((data) => {\n        if (Array.isArray(data?.issues)) {\n          const seen = new Set<string>()\n          const unique = [] as UserIssue[]\n          for (const it of data.issues as UserIssue[]) {\n            const key = (it.name || '').toLowerCase().trim()\n            if (!seen.has(key)) { seen.add(key); unique.push(it) }\n          }\n          if (unique.length > 0) setIssues(unique)\n        }\n        if (Array.isArray(data?.ratings)) {\n          const map: Record<string, number> = {}\n          for (const r of data.ratings) map[r.issueId] = r.value\n          setRatings(map)\n        }\n      })\n      .catch(() => {})\n      .finally(() => setLoading(false))\n  }, [])\n\n  const setRating = (issueId: string, value: number) => {\n    setRatings((r) => {\n      const updated = { ...r, [issueId]: value }\n      return updated\n    })\n    setNa((n) => {\n      const updated = { ...n, [issueId]: false }\n      return updated\n    })\n  }\n\n  const handleSave = async () => {\n    try {\n      const payload = issues.map((it) => ({\n        issueId: it.id,\n        value: na[it.id] ? null : (ratings[it.id] ?? null),\n        note: notes[it.id] || '',\n        isNa: !!na[it.id],\n      }))\n      const res = await fetch('/api/checkins/today', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ ratings: payload }) })\n      if (!res.ok) throw new Error('save failed')\n      // Navigate after save\n      try {\n        const search = typeof window !== 'undefined' ? window.location.search : ''\n        const params = new URLSearchParams(search)\n        const ret = params.get('return') || ''\n        const ref = document.referrer || ''\n        const isEditMode = !!params.get('new')\n        const cameFromOnboarding = ret.includes('/onboarding') || ref.includes('/onboarding')\n        if (isEditMode) {\n          // When adding issues after onboarding, go straight to dashboard\n          window.location.assign('/dashboard')\n          return\n        }\n        if (cameFromOnboarding) {\n          // First-time onboarding flow\n          window.location.assign('/onboarding?step=5')\n          return\n        }\n        // Default\n        window.location.assign('/dashboard')\n        return\n      } catch {}\n      alert('Saved today\\'s ratings.')\n    } catch (e) {\n      alert('Failed to save. Please try again.')\n    }\n  }\n\n  const pathname = usePathname()\n  const isHistoryPage = pathname === '/check-in/history'\n\n  return (\n    <div className=\"min-h-screen bg-gray-50 dark:bg-gray-900 pb-24\">\n      <PageHeader title=\"Today's Check-In\" backHref=\"/more\" />\n      \n      {/* Tabs */}\n      <div className=\"max-w-3xl mx-auto px-4 pt-4\">\n        <div className=\"bg-white dark:bg-gray-800 rounded-t-xl border-b border-gray-200 dark:border-gray-700\">\n          <div className=\"flex\">\n            <Link\n              href=\"/check-in\"\n              className={`flex-1 px-4 py-3 text-center font-medium transition-colors ${\n                !isHistoryPage\n                  ? 'text-helfi-green border-b-2 border-helfi-green'\n                  : 'text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-200'\n              }`}\n            >\n              Today's Check-in\n            </Link>\n            <Link\n              href=\"/check-in/history\"\n              className={`flex-1 px-4 py-3 text-center font-medium transition-colors ${\n                isHistoryPage\n                  ? 'text-helfi-green border-b-2 border-helfi-green'\n                  : 'text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-200'\n              }`}\n            >\n              Rating History\n            </Link>\n          </div>\n        </div>\n      </div>\n\n      {!isHistoryPage ? (\n        <main className=\"max-w-3xl mx-auto px-4 py-6\">\n          <div className=\"bg-white dark:bg-gray-800 rounded-b-2xl shadow-sm p-6\">\n            <div className=\"mb-2\">\n              <h1 className=\"text-2xl font-bold text-gray-900 dark:text-white\">Today's check‚Äëin</h1>\n            </div>\n            <p className=\"text-sm text-gray-600 dark:text-gray-400 mb-6\">Rate how you went today. One tap per item, then Save.</p>\n\n        {loading ? (\n          <div className=\"flex items-center justify-center py-12\">\n            <div className=\"animate-spin rounded-full h-8 w-8 border-b-2 border-helfi-green\"></div>\n          </div>\n        ) : (\n          <div className=\"space-y-6\">\n            {issues.length === 0 && (\n              <div className=\"border border-yellow-200 bg-yellow-50 text-yellow-800 rounded-xl p-4 text-sm\">\n                No issues selected yet. Go to <a className=\"underline\" href=\"/onboarding?step=4\">Health Setup</a> to choose what you want to track.\n              </div>\n            )}\n          {issues\n            // Filter only for ?new= parameter, otherwise show all issues so users can see and edit their ratings\n            .filter((it) => {\n              try {\n                const params = new URLSearchParams(window.location.search || '')\n                // If ?new= is present, show only those newly added issues\n                const onlyNew = params.get('new')\n                if (onlyNew) {\n                  const set = new Set(onlyNew.split('|').map(s => s.toLowerCase()))\n                  return set.has((it.name || '').toLowerCase())\n                }\n                // Always show all issues - users should see what they've rated\n                return true\n              } catch {}\n              return true\n            })\n            .map((issue) => {\n            const isPlural = () => {\n              const n = (issue.name || '').trim()\n              // Simple plural detection with common exceptions\n              // Treat words like \"Bowel Movements\", \"Movements\", \"Allergies\" as plural\n              if (/\\b(movements|allergies|bowels|bowel movements)\\b/i.test(n)) return true\n              // Ends with 's' and not 'ss' ‚Üí likely plural (e.g., \"Headaches\", \"Rashes\")\n              return /[^s]s$/i.test(n)\n            }\n            const question = issue.polarity === 'negative'\n              ? `How were your ${issue.name} levels today?`\n              : (isPlural() ? `How were your ${issue.name} today?` : `How was your ${issue.name} today?`)\n            const selectedRating = ratings[issue.id]\n            const isNotApplicable = na[issue.id]\n            return (\n              <div key={issue.id} className=\"border border-gray-200 dark:border-gray-700 rounded-xl p-4 dark:bg-gray-800/50\">\n                <div className=\"font-medium mb-3 text-gray-900 dark:text-white\">{question}</div>\n                <div className=\"grid grid-cols-2 sm:grid-cols-4 lg:grid-cols-7 gap-2\">\n                  {LABELS.map((label, idx) => {\n                    const isSelected = selectedRating === idx && !isNotApplicable\n                    return (\n                      <button\n                        key={idx}\n                        type=\"button\"\n                        onClick={(e) => {\n                          e.preventDefault()\n                          e.stopPropagation()\n                          setRating(issue.id, idx)\n                        }}\n                        className={`text-xs px-2 py-2 rounded-lg border transition-all duration-200 font-medium ${\n                          isSelected\n                            ? 'bg-[#4CAF50] text-white border-[#4CAF50] shadow-md'\n                            : 'bg-white dark:bg-gray-700 text-gray-700 dark:text-gray-300 border-gray-200 dark:border-gray-600 hover:border-[#4CAF50] hover:bg-gray-50 dark:hover:bg-gray-600'\n                        }`}\n                        style={isSelected ? { backgroundColor: '#4CAF50', color: 'white', borderColor: '#4CAF50' } : undefined}\n                      >\n                        {label}\n                      </button>\n                    )\n                  })}\n                </div>\n                {/* Optional details accordion */}\n                <details className=\"mt-3\">\n                  <summary className=\"text-sm text-gray-600 cursor-pointer select-none\">Add details (optional)</summary>\n                  <textarea\n                    value={notes[issue.id] || ''}\n                    onChange={(e)=>setNotes((m)=>({ ...m, [issue.id]: e.target.value }))}\n                    rows={3}\n                    placeholder=\"Anything notable today?\"\n                    className=\"mt-2 w-full border rounded-lg p-2 text-sm\"\n                  />\n                </details>\n                <div className=\"mt-3\">\n                  <label className=\"inline-flex items-center gap-2 text-sm text-gray-700\">\n                    <input type=\"checkbox\" checked={!!na[issue.id]} onChange={(e)=> setNa((m)=>({ ...m, [issue.id]: e.target.checked }))} />\n                    Not applicable for this time\n                  </label>\n                </div>\n              </div>\n            )\n          })}\n          </div>\n        )}\n\n        {!loading && (\n          <div className=\"mt-6 flex justify-end\">\n            <button onClick={handleSave} className=\"bg-helfi-green text-white px-4 py-2 rounded-lg hover:bg-helfi-green/90\">Save today's ratings</button>\n          </div>\n        )}\n          </div>\n        </main>\n      ) : null}\n    </div>\n  )\n}\n\n\n","truncated":false,"size":10170},{"path":"app/dashboard/page.tsx","content":"'use client'\nimport { Cog6ToothIcon, UserIcon } from '@heroicons/react/24/outline'\n\nimport React, { useState, useEffect, useRef } from 'react'\nimport { useSession, signOut } from 'next-auth/react'\nimport Image from 'next/image'\nimport Link from 'next/link'\nimport { usePathname } from 'next/navigation'\nimport { useUserData } from '@/components/providers/UserDataProvider'\nimport MobileMoreMenu from '@/components/MobileMoreMenu'\nimport UsageMeter from '@/components/UsageMeter'\nimport FitbitSummary from '@/components/devices/FitbitSummary'\n\nexport default function Dashboard() {\n  // ‚ö†Ô∏è HEALTH SETUP GUARD RAIL\n  // Dashboard onboarding logic is tightly coupled to HEALTH_SETUP_PROTECTION.md:\n  // - Onboarding is \"complete\" only when gender, weight, height, and at least one health goal exist.\n  // - Brand-new users may be redirected to /onboarding, but only if\n  //   sessionStorage.onboardingDeferredThisSession !== '1' (user has NOT chosen \"I'll do it later\").\n  // - The green \"Onboarding Complete\" card must only show when onboardingComplete === true.\n  // Do NOT loosen these checks or remove the deferral flag without reading\n  // HEALTH_SETUP_PROTECTION.md and getting explicit user approval.\n  const { data: session } = useSession()\n  const pathname = usePathname()\n  const { profileImage: providerProfileImage } = useUserData()\n  const [onboardingData, setOnboardingData] = useState<any>(null)\n  const [showResetConfirm, setShowResetConfirm] = useState(false)\n  const [dropdownOpen, setDropdownOpen] = useState(false)\n  const [affiliateMenu, setAffiliateMenu] = useState<{ label: string; href: string } | null>(null)\n  const [profileImage, setProfileImage] = useState<string | null>(null)\n  const [deviceInterest, setDeviceInterest] = useState<{ appleWatch?: boolean; fitbit?: boolean; garmin?: boolean; samsung?: boolean; googleFit?: boolean; oura?: boolean; polar?: boolean }>({})\n  const [savingInterest, setSavingInterest] = useState<string | null>(null)\n  const [fitbitConnected, setFitbitConnected] = useState(false)\n  const [fitbitLoading, setFitbitLoading] = useState(false)\n  const [garminConnected, setGarminConnected] = useState(false)\n  const garminConnectEnabled = process.env.NEXT_PUBLIC_GARMIN_CONNECT_ENABLED !== 'false'\n  const popupRef = useRef<Window | null>(null)\n  const checkIntervalRef = useRef<NodeJS.Timeout | null>(null)\n\n  // Profile data - prefer real photos; fall back to professional icon instead of inline SVG\n  const hasProfileImage = !!(providerProfileImage || profileImage || session?.user?.image)\n  const userImage = (providerProfileImage || profileImage || session?.user?.image || '') as string\n  const userName = session?.user?.name || 'User';\n\n  // Close dropdown on outside click\n  useEffect(() => {\n    function handleClick(e: MouseEvent) {\n      const target = e.target as HTMLElement;\n      // Check if click is outside both the button and the dropdown content\n      if (!target.closest('.dropdown-container')) {\n        setDropdownOpen(false);\n      }\n    }\n    if (dropdownOpen) {\n      document.addEventListener('mousedown', handleClick);\n      return () => document.removeEventListener('mousedown', handleClick);\n    }\n  }, [dropdownOpen]);\n\n  useEffect(() => {\n    if (!session?.user?.email) {\n      setAffiliateMenu(null)\n      return\n    }\n    let cancelled = false\n    setAffiliateMenu({ label: 'Become an Affiliate', href: '/affiliate/apply' })\n    const loadAffiliateMenu = async () => {\n      try {\n        const res = await fetch('/api/affiliate/application', { cache: 'no-store' })\n        const data = await res.json().catch(() => ({} as any))\n        if (!res.ok) return\n        const hasAffiliate = !!data?.affiliate\n        const hasApplication = !!data?.application\n        const menu = hasAffiliate\n          ? { label: 'Affiliate Portal', href: '/affiliate' }\n          : hasApplication\n            ? { label: 'Affiliate Application', href: '/affiliate/apply' }\n            : { label: 'Become an Affiliate', href: '/affiliate/apply' }\n        if (!cancelled) setAffiliateMenu(menu)\n      } catch {\n        // ignore\n      }\n    }\n    loadAffiliateMenu()\n    return () => {\n      cancelled = true\n    }\n  }, [session?.user?.email])\n\n  // Load existing data from database (cross-device sync)\n  useEffect(() => {\n    const loadUserData = async () => {\n      try {\n        // üîç DASHBOARD PERFORMANCE MEASUREMENT START\n        console.log('üöÄ DASHBOARD LOADING PERFORMANCE TRACKING')\n        console.time('‚è±Ô∏è Dashboard Data Loading')\n        const dashboardStartTime = Date.now()\n        \n        console.log('üì§ Loading user data from database...');\n        const response = await fetch('/api/user-data', {\n          cache: 'no-cache',\n          headers: {\n            'Cache-Control': 'no-cache'\n          }\n        });\n        \n        const dataLoadTime = Date.now() - dashboardStartTime\n        console.log('üìà Dashboard API Response:', {\n          duration: dataLoadTime + 'ms',\n          status: response.status,\n          statusText: response.statusText\n        })\n        \n        if (response.ok) {\n          const result = await response.json();\n          if (result.data) {\n            console.log('‚úÖ Successfully loaded data from database');\n            console.log('üìä Dashboard Data Summary:', {\n              hasProfileImage: !!result.data.profileImage,\n              hasHealthGoals: !!result.data.goals?.length,\n              hasSupplements: !!result.data.supplements?.length,\n              hasMedications: !!result.data.medications?.length,\n              dataSize: JSON.stringify(result.data).length + ' characters'\n            });\n            \n            // Define onboarding completion using the same rule as Insights:\n            // 1) basic profile data present, and 2) at least one health goal selected.\n            const hasBasicProfile = !!(result.data.gender && result.data.weight && result.data.height)\n            const hasHealthGoals = !!(result.data.goals && result.data.goals.length > 0)\n            const onboardingComplete = hasBasicProfile && hasHealthGoals\n\n            // For truly brand-new users with no meaningful data at all, redirect\n            // into onboarding on first visit, but respect \"I'll do it later\"\n            // for the current browser session.\n            if (!onboardingComplete && !hasBasicProfile && !hasHealthGoals && !result.data.supplements?.length && !result.data.medications?.length) {\n              const deferred = typeof window !== 'undefined' && sessionStorage.getItem('onboardingDeferredThisSession') === '1'\n              if (!deferred) {\n                console.log('üéØ Brand new user detected - redirecting to onboarding')\n                window.location.href = '/onboarding'\n                return\n              } else {\n                console.log('‚è≥ Onboarding deferred this session ‚Äî staying on dashboard')\n              }\n            }\n\n            setOnboardingData({ ...result.data, onboardingComplete });\n            // Load device interest flags if present\n            if (result.data.deviceInterest && typeof result.data.deviceInterest === 'object') {\n              setDeviceInterest(result.data.deviceInterest)\n            }\n            \n            // Check Fitbit connection status\n            checkFitbitStatus()\n            // Check Garmin connection status\n            if (garminConnectEnabled) checkGarminStatus()\n            \n            // Load profile image from database and cache it\n            if (result.data.profileImage) {\n              setProfileImage(result.data.profileImage);\n              // Cache in localStorage for instant loading on other pages (user-specific)\n              if (session?.user?.id) {\n                localStorage.setItem(`cachedProfileImage_${session.user.id}`, result.data.profileImage);\n              }\n            }\n          } else {\n            // No data at all - definitely a new user\n            const deferred = typeof window !== 'undefined' && sessionStorage.getItem('onboardingDeferredThisSession') === '1';\n            if (!deferred) {\n              console.log('üéØ No user data found - redirecting new user to onboarding');\n              window.location.href = '/onboarding';\n              return;\n            } else {\n              console.log('‚è≥ Onboarding deferred with no data ‚Äî staying on dashboard');\n            }\n          }\n        } else if (response.status === 404) {\n          console.log('‚ÑπÔ∏è No existing data found for user in database - redirecting to onboarding');\n          window.location.href = '/onboarding';\n          return;\n        } else if (response.status === 401) {\n          console.log('‚ö†Ô∏è User not authenticated - redirecting to login');\n          // Don't use localStorage fallback, force proper authentication\n          setOnboardingData(null);\n        } else {\n          console.error('‚ùå Failed to load data from database:', response.status, response.statusText);\n          setOnboardingData(null);\n        }\n        \n        console.timeEnd('‚è±Ô∏è Dashboard Data Loading')\n        console.log('üèÅ Dashboard loading completed in', Date.now() - dashboardStartTime + 'ms')\n      } catch (error) {\n        console.timeEnd('‚è±Ô∏è Dashboard Data Loading')\n        console.error('üí• Error loading user data from database:', error);\n        // No localStorage fallback - force database-only approach\n        setOnboardingData(null);\n      }\n    };\n\n    // Load cached profile image immediately for instant display (user-specific)\n    if (session?.user?.id) {\n      const cachedImage = localStorage.getItem(`cachedProfileImage_${session.user.id}`);\n      if (cachedImage) {\n        setProfileImage(cachedImage);\n      }\n    }\n\n    if (session) {\n      loadUserData();\n    }\n\n    // Listen for messages from popup window (Fitbit OAuth)\n    const handleMessage = (event: MessageEvent) => {\n      if (event.data?.type === 'FITBIT_CONNECTED' && event.data.success) {\n        checkFitbitStatus()\n        setFitbitLoading(false)\n      } else if (event.data?.type === 'FITBIT_ERROR') {\n        alert('Fitbit connection failed: ' + event.data.error)\n        setFitbitLoading(false)\n      }\n    }\n    window.addEventListener('message', handleMessage)\n    \n    return () => {\n      window.removeEventListener('message', handleMessage)\n    }\n  }, [session]);\n\n  const handleEditOnboarding = () => {\n    // Navigate directly to onboarding - data will be loaded from database\n    console.log('Navigating to edit onboarding, data will be loaded from database')\n    window.location.href = '/onboarding'\n  }\n\n  const handleResetData = async () => {\n    try {\n      // Delete from database\n      const response = await fetch('/api/user-data', {\n        method: 'DELETE',\n        headers: { 'Content-Type': 'application/json' }\n      });\n      \n      if (response.ok) {\n        console.log('Data successfully deleted from database');\n        setOnboardingData(null)\n        setShowResetConfirm(false)\n        // Redirect to onboarding to start fresh\n        window.location.href = '/onboarding'\n      } else {\n        console.error('Failed to delete from database:', response.status, response.statusText);\n        alert('Failed to reset data. Please try again.');\n      }\n    } catch (error) {\n      console.error('Error deleting from database:', error);\n      alert('Failed to reset data. Please try again.');\n    }\n  }\n\n  const saveDeviceInterest = async (next: any) => {\n    try {\n      setSavingInterest('saving')\n      await fetch('/api/user-data', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ deviceInterest: next })\n      })\n      // Reload from server to ensure persistence and UI stays selected\n      try {\n        const res = await fetch('/api/user-data', { cache: 'no-cache' })\n        if (res.ok) {\n          const json = await res.json()\n          if (json?.data?.deviceInterest) setDeviceInterest(json.data.deviceInterest)\n        }\n      } catch {}\n    } catch (e) {\n      console.error('Failed to save device interest', e)\n    } finally {\n      setSavingInterest(null)\n    }\n  }\n\n  const checkFitbitStatus = async () => {\n    try {\n      const response = await fetch('/api/fitbit/status')\n      if (response.ok) {\n        const data = await response.json()\n        setFitbitConnected(data.connected)\n        return data.connected\n      }\n      return false\n    } catch (error) {\n      console.error('Error checking Fitbit status:', error)\n      return false\n    }\n  }\n\n  const checkGarminStatus = async () => {\n    if (!garminConnectEnabled) {\n      setGarminConnected(false)\n      return false\n    }\n    try {\n      const response = await fetch('/api/garmin/status')\n      if (response.ok) {\n        const data = await response.json()\n        setGarminConnected(!!data.connected)\n        return !!data.connected\n      }\n      return false\n    } catch (error) {\n      console.error('Error checking Garmin status:', error)\n      return false\n    }\n  }\n\n  const handleConnectFitbit = async () => {\n    setFitbitLoading(true)\n    try {\n      // Open Fitbit OAuth in a popup window so users can still see Helfi\n      const width = 600\n      const height = 700\n      const left = window.screen.width / 2 - width / 2\n      const top = window.screen.height / 2 - height / 2\n      \n      const popup = window.open(\n        '/api/auth/fitbit/authorize',\n        'Fitbit Authorization',\n        `width=${width},height=${height},left=${left},top=${top},toolbar=no,menubar=no,scrollbars=yes,resizable=yes`\n      )\n\n      if (!popup) {\n        alert('Please allow popups for this site to connect Fitbit')\n        setFitbitLoading(false)\n        return\n      }\n\n      popupRef.current = popup\n\n      // Check if popup is closed (user cancelled)\n      const checkClosed = setInterval(() => {\n        if (popup.closed) {\n          clearInterval(checkClosed)\n          if (checkIntervalRef.current) {\n            clearInterval(checkIntervalRef.current)\n            checkIntervalRef.current = null\n          }\n          setFitbitLoading(false)\n          // Check status in case they completed it quickly\n          setTimeout(() => checkFitbitStatus(), 1000)\n        }\n      }, 500)\n\n      // Poll for connection status - check every 2 seconds\n      checkIntervalRef.current = setInterval(async () => {\n        const connected = await checkFitbitStatus()\n        if (connected) {\n          clearInterval(checkClosed)\n          if (checkIntervalRef.current) {\n            clearInterval(checkIntervalRef.current)\n            checkIntervalRef.current = null\n          }\n          // Try to close popup if still open\n          if (popup && !popup.closed) {\n            try {\n              popup.close()\n            } catch (e) {\n              // Popup might be on different origin, ignore\n            }\n          }\n          setFitbitLoading(false)\n        }\n      }, 2000)\n\n      // Cleanup after 5 minutes\n      setTimeout(() => {\n        clearInterval(checkClosed)\n        if (checkIntervalRef.current) {\n          clearInterval(checkIntervalRef.current)\n          checkIntervalRef.current = null\n        }\n        setFitbitLoading(false)\n      }, 300000)\n    } catch (error) {\n      console.error('Error connecting Fitbit:', error)\n      alert('Failed to connect Fitbit. Please try again.')\n      setFitbitLoading(false)\n    }\n  }\n\n  // Cleanup intervals on unmount\n  useEffect(() => {\n    return () => {\n      if (checkIntervalRef.current) {\n        clearInterval(checkIntervalRef.current)\n      }\n    }\n  }, [])\n\n  const toggleInterest = (key: 'appleWatch' | 'fitbit' | 'garmin' | 'samsung' | 'googleFit' | 'oura' | 'polar') => {\n    // Don't toggle Fitbit interest if it's already connected\n    if (key === 'fitbit' && fitbitConnected) {\n      return\n    }\n    setDeviceInterest((prev) => {\n      const next = { ...prev, [key]: !prev?.[key] }\n      // Fire-and-forget save; keep UI responsive even if request is slow\n      saveDeviceInterest(next)\n      return next\n    })\n  }\n\n  const handleSignOut = async () => {\n    // Clear user-specific localStorage before signing out\n    if (session?.user?.id) {\n      localStorage.removeItem(`profileImage_${session.user.id}`);\n      localStorage.removeItem(`cachedProfileImage_${session.user.id}`);\n    }\n    await signOut({ callbackUrl: '/auth/signin' })\n  }\n\n  return (\n    <div className=\"min-h-screen bg-gray-50 dark:bg-gray-900\">\n      {/* Navigation Header - Mobile: Logo + Profile Row, Desktop: Logo + Actions Row */}\n      <nav className=\"bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700 px-3 sm:px-4 py-3\">\n        <div className=\"max-w-7xl mx-auto\">\n          {/* Mobile: Logo and Profile Row */}\n          <div className=\"md:hidden flex items-center justify-between mb-3\">\n            <Link href=\"/\" className=\"w-20 h-20 cursor-pointer hover:opacity-80 transition-opacity\">\n              <Image\n                src=\"/mobile-assets/LOGOS/helfi-01-01.png\"\n                alt=\"Helfi Logo\"\n                width={72}\n                height={72}\n                className=\"w-full h-full object-contain dark:hidden\"\n                priority\n              />\n              <Image\n                src=\"/mobile-assets/LOGOS/helfi-01-06.png\"\n                alt=\"Helfi Logo\"\n                width={72}\n                height={72}\n                className=\"w-full h-full object-contain hidden dark:block\"\n                priority\n              />\n            </Link>\n            <div className=\"flex items-center gap-2\">\n              <Link \n                href=\"/billing\" \n                className=\"inline-flex items-center gap-1 px-2.5 py-1 text-xs font-medium text-helfi-green border border-helfi-green/30 rounded-md hover:bg-helfi-green/5 transition-all\"\n              >\n                <svg className=\"w-3 h-3\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M13 10V3L4 14h7v7l9-11h-7z\" />\n                </svg>\n                Upgrade\n              </Link>\n              <div className=\"relative dropdown-container\" id=\"profile-dropdown\">\n                <button\n                  onClick={() => setDropdownOpen((v) => !v)}\n                  className=\"focus:outline-none\"\n                  aria-label=\"Open profile menu\"\n                >\n                  {hasProfileImage ? (\n                    <Image\n                      src={userImage}\n                      alt=\"Profile\"\n                      width={40}\n                      height={40}\n                      className=\"w-10 h-10 rounded-full border-2 border-helfi-green shadow-sm object-cover\"\n                    />\n                  ) : (\n                    <div className=\"w-10 h-10 rounded-full bg-helfi-green shadow-sm flex items-center justify-center\">\n                      <UserIcon className=\"w-5 h-5 text-white\" aria-hidden=\"true\" />\n                    </div>\n                  )}\n                </button>\n                {dropdownOpen && (\n                  <div className=\"absolute right-0 mt-2 w-64 bg-white rounded-xl shadow-lg py-2 z-50 border border-gray-100 animate-fade-in\">\n                    <div className=\"flex items-center px-4 py-3 border-b border-gray-100\">\n                      {hasProfileImage ? (\n                        <Image\n                          src={userImage}\n                          alt=\"Profile\"\n                          width={40}\n                          height={40}\n                          className=\"w-10 h-10 rounded-full object-cover mr-3\"\n                        />\n                      ) : (\n                        <div className=\"w-10 h-10 rounded-full bg-helfi-green flex items-center justify-center mr-3\">\n                          <UserIcon className=\"w-5 h-5 text-white\" aria-hidden=\"true\" />\n                        </div>\n                      )}\n                      <div>\n                        <div className=\"font-semibold text-gray-900\">{userName}</div>\n                        <div className=\"text-xs text-gray-500\">{session?.user?.email || 'user@email.com'}</div>\n                      </div>\n                    </div>\n                    <Link href=\"/profile\" className=\"block px-4 py-2 text-gray-700 hover:bg-gray-50\">Profile</Link>\n                    <Link href=\"/account\" className=\"block px-4 py-2 text-gray-700 hover:bg-gray-50\">Account Settings</Link>\n                    <Link href=\"/profile/image\" className=\"block px-4 py-2 text-gray-700 hover:bg-gray-50\">Upload/Change Profile Photo</Link>\n                    <Link href=\"/billing\" className=\"block px-4 py-2 text-gray-700 hover:bg-gray-50\">Subscription & Billing</Link>\n                    {affiliateMenu && (\n                      <Link href={affiliateMenu.href} className=\"block px-4 py-2 text-gray-700 hover:bg-gray-50\">\n                        {affiliateMenu.label}\n                      </Link>\n                    )}\n                    <Link href=\"/notifications\" className=\"block px-4 py-2 text-gray-700 hover:bg-gray-50\">Notifications</Link>\n                    <Link href=\"/privacy\" className=\"block px-4 py-2 text-gray-700 hover:bg-gray-50\">Privacy Settings</Link>\n                    <Link href=\"/support\" className=\"block px-4 py-2 text-gray-700 hover:bg-gray-50\">Help & Support</Link>\n                    <div className=\"border-t border-gray-100 my-2\"></div>\n                    <Link href=\"/reports\" className=\"block px-4 py-2 text-gray-700 hover:bg-gray-50\">Reports</Link>\n                    <button \n                      onClick={handleSignOut}\n                      className=\"block w-full text-left px-4 py-2 text-red-600 hover:bg-gray-50 font-semibold\"\n                    >\n                      Logout\n                    </button>\n                  </div>\n                )}\n              </div>\n            </div>\n          </div>\n          \n          {/* Desktop: Logo + Actions Row */}\n          <div className=\"hidden md:flex justify-between items-center\">\n            <div className=\"flex items-center\">\n            <Link href=\"/\" className=\"w-20 h-20 md:w-24 md:h-24 cursor-pointer hover:opacity-80 transition-opacity\">\n              <Image\n                src=\"/mobile-assets/LOGOS/helfi-01-01.png\"\n                alt=\"Helfi Logo\"\n                width={96}\n                height={96}\n                className=\"w-full h-full object-contain dark:hidden\"\n                priority\n              />\n              <Image\n                src=\"/mobile-assets/LOGOS/helfi-01-06.png\"\n                alt=\"Helfi Logo\"\n                width={96}\n                height={96}\n                className=\"w-full h-full object-contain hidden dark:block\"\n                priority\n              />\n            </Link>\n            </div>\n            \n            <div className=\"flex items-center gap-3\">\n              <Link \n                href=\"/billing\" \n                className=\"inline-flex items-center gap-1.5 px-4 py-2 text-sm font-medium text-helfi-green border border-helfi-green/30 rounded-md hover:bg-helfi-green/5 hover:border-helfi-green/50 transition-all\"\n              >\n                <svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M13 10V3L4 14h7v7l9-11h-7z\" />\n                </svg>\n                Upgrade\n              </Link>\n              <div className=\"relative dropdown-container\" id=\"profile-dropdown-desktop\">\n                <button\n                  onClick={() => setDropdownOpen((v) => !v)}\n                  className=\"focus:outline-none\"\n                  aria-label=\"Open profile menu\"\n                >\n                  {hasProfileImage ? (\n                    <Image\n                      src={userImage}\n                      alt=\"Profile\"\n                      width={48}\n                      height={48}\n                      className=\"w-12 h-12 rounded-full border-2 border-helfi-green shadow-sm object-cover\"\n                    />\n                  ) : (\n                    <div className=\"w-12 h-12 rounded-full bg-helfi-green shadow-sm flex items-center justify-center\">\n                      <UserIcon className=\"w-6 h-6 text-white\" aria-hidden=\"true\" />\n                    </div>\n                  )}\n                </button>\n                {dropdownOpen && (\n                  <div className=\"absolute right-0 mt-2 w-64 bg-white rounded-xl shadow-lg py-2 z-50 border border-gray-100 animate-fade-in\">\n                    <div className=\"flex items-center px-4 py-3 border-b border-gray-100\">\n                      {hasProfileImage ? (\n                        <Image\n                          src={userImage}\n                          alt=\"Profile\"\n                          width={40}\n                          height={40}\n                          className=\"w-10 h-10 rounded-full object-cover mr-3\"\n                        />\n                      ) : (\n                        <div className=\"w-10 h-10 rounded-full bg-helfi-green flex items-center justify-center mr-3\">\n                          <UserIcon className=\"w-5 h-5 text-white\" aria-hidden=\"true\" />\n                        </div>\n                      )}\n                      <div>\n                        <div className=\"font-semibold text-gray-900\">{userName}</div>\n                        <div className=\"text-xs text-gray-500\">{session?.user?.email || 'user@email.com'}</div>\n                      </div>\n                    </div>\n                    <Link href=\"/profile\" className=\"block px-4 py-2 text-gray-700 hover:bg-gray-50\">Profile</Link>\n                    <Link href=\"/account\" className=\"block px-4 py-2 text-gray-700 hover:bg-gray-50\">Account Settings</Link>\n                    <Link href=\"/profile/image\" className=\"block px-4 py-2 text-gray-700 hover:bg-gray-50\">Upload/Change Profile Photo</Link>\n                    <Link href=\"/billing\" className=\"block px-4 py-2 text-gray-700 hover:bg-gray-50\">Subscription & Billing</Link>\n                    {affiliateMenu && (\n                      <Link href={affiliateMenu.href} className=\"block px-4 py-2 text-gray-700 hover:bg-gray-50\">\n                        {affiliateMenu.label}\n                      </Link>\n                    )}\n                    <Link href=\"/notifications\" className=\"block px-4 py-2 text-gray-700 hover:bg-gray-50\">Notifications</Link>\n                    <Link href=\"/privacy\" className=\"block px-4 py-2 text-gray-700 hover:bg-gray-50\">Privacy Settings</Link>\n                    <Link href=\"/support\" className=\"block px-4 py-2 text-gray-700 hover:bg-gray-50\">Help & Support</Link>\n                    <div className=\"border-t border-gray-100 my-2\"></div>\n                    <Link href=\"/reports\" className=\"block px-4 py-2 text-gray-700 hover:bg-gray-50\">Reports</Link>\n                    <button \n                      onClick={handleSignOut}\n                      className=\"block w-full text-left px-4 py-2 text-red-600 hover:bg-gray-50 font-semibold\"\n                    >\n                      Logout\n                    </button>\n                  </div>\n                )}\n              </div>\n            </div>\n          </div>\n        </div>\n      </nav>\n\n      {/* Page Title Row - Mobile: Below Logo/Profile, Desktop: Centered */}\n      <div className=\"bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700 px-3 sm:px-4 py-3 md:py-4\">\n        <div className=\"max-w-7xl mx-auto\">\n          {/* Mobile: Credits Meter + Dashboard Title */}\n          <div className=\"md:hidden space-y-2\">\n            <div className=\"flex justify-center\">\n              <UsageMeter compact={true} />\n            </div>\n            <div className=\"text-center\">\n              <h1 className=\"text-lg font-semibold text-gray-900 dark:text-white\">Dashboard</h1>\n            </div>\n          </div>\n          \n          {/* Desktop: Centered Title */}\n          <div className=\"hidden md:block text-center\">\n            <h1 className=\"text-xl font-semibold text-gray-900\">Dashboard</h1>\n            <p className=\"text-sm text-gray-500 mt-1\">Welcome back, {userName}</p>\n          </div>\n        </div>\n      </div>\n\n      {/* Main Content - Add padding bottom for mobile nav */}\n      <main className=\"flex-1 pb-24 md:pb-8\">\n        <div className=\"max-w-7xl mx-auto px-3 sm:px-4 py-6 md:py-8\">\n          <div className=\"bg-white rounded-lg shadow-sm p-8\">\n            <div className=\"text-center mb-8\">\n              <h1 className=\"text-3xl font-bold text-helfi-black dark:text-white mb-4\">\n                Welcome to Your Health Dashboard\n              </h1>\n              <p className=\"text-gray-600\">\n                Your personalized health intelligence platform is being built!\n              </p>\n            </div>\n\n            <div className=\"grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4 md:gap-6 mb-8\">\n              <Link href=\"/check-in\" className=\"block\">\n              <div className=\"bg-white md:bg-emerald-50 p-5 md:p-6 rounded-2xl border border-gray-100 md:border-2 md:border-emerald-200 hover:md:border-emerald-300 shadow-sm md:shadow-none transition-colors\">\n                <h3 className=\"text-[17px] font-semibold text-helfi-black dark:text-white mb-1.5\">‚úÖ Daily Check-In</h3>\n                <p className=\"text-[13px] text-gray-600\">Rate your health issues for today</p>\n                <div className=\"mt-3\">\n                  <span className=\"inline-flex items-center px-2.5 py-0.5 rounded-full text-[11px] font-medium bg-emerald-100 text-emerald-700\">Active</span>\n                </div>\n              </div>\n              </Link>\n\n              <Link href=\"/health-tracking\" className=\"block\">\n              <div className=\"bg-white md:bg-helfi-green/5 p-5 md:p-6 rounded-2xl border border-gray-100 md:border-2 md:border-helfi-green/20 hover:md:border-helfi-green/40 shadow-sm md:shadow-none transition-colors\">\n                <h3 className=\"text-[17px] font-semibold text-helfi-black dark:text-white mb-1.5\">üéØ Health Tracking</h3>\n                <p className=\"text-[13px] text-gray-600\">Track your daily metrics and progress</p>\n                <div className=\"mt-3\">\n                  <span className=\"inline-flex items-center px-2.5 py-0.5 rounded-full text-[11px] font-medium bg-helfi-green/10 text-helfi-green\">Coming Soon</span>\n                </div>\n              </div>\n              </Link>\n\n              <Link href=\"/insights\" className=\"block\">\n              <div className=\"bg-white md:bg-blue-50 p-5 md:p-6 rounded-2xl border border-gray-100 md:border-2 md:border-blue-200 hover:md:border-blue-300 shadow-sm md:shadow-none transition-colors\">\n                <h3 className=\"text-[17px] font-semibold text-helfi-black dark:text-white mb-1.5\">ü§ñ AI Insights</h3>\n                <p className=\"text-[13px] text-gray-600\">Personalized health recommendations</p>\n                <div className=\"mt-3\">\n                  <span className=\"inline-flex items-center px-2.5 py-0.5 rounded-full text-[11px] font-medium bg-blue-100 text-blue-600\">Coming Soon</span>\n                </div>\n              </div>\n              </Link>\n\n              <Link href=\"/reports\" className=\"block\">\n              <div className=\"bg-white md:bg-purple-50 p-5 md:p-6 rounded-2xl border border-gray-100 md:border-2 md:border-purple-200 hover:md:border-purple-300 shadow-sm md:shadow-none transition-colors\">\n                <h3 className=\"text-[17px] font-semibold text-helfi-black dark:text-white mb-1.5\">üìä Reports</h3>\n                <p className=\"text-[13px] text-gray-600\">Weekly health analysis and trends</p>\n                <div className=\"mt-3\">\n                  <span className=\"inline-flex items-center px-2.5 py-0.5 rounded-full text-[11px] font-medium bg-purple-100 text-purple-600\">Coming Soon</span>\n                </div>\n              </div>\n              </Link>\n            </div>\n\n            {/* Fitbit Mini Summary */}\n            {fitbitConnected && (\n              <div className=\"mb-6\">\n                <FitbitSummary rangeDays={7} />\n              </div>\n            )}\n\n            {/* Device Integration Section */}\n            {onboardingData && (\n              <div className=\"mb-8 bg-gradient-to-r from-blue-50 to-green-50 dark:bg-none dark:bg-gray-800 rounded-lg p-4 md:p-6 border border-blue-200 dark:border-gray-700\">\n                <div className=\"mb-3 md:mb-4\">\n                  {/* Mobile: centered heading and badge */}\n                  <div className=\"md:hidden text-center\">\n                    <h3 className=\"text-[17px] font-semibold text-helfi-black dark:text-white\">üì± Connect Your Devices</h3>\n                    <div className=\"text-[12px] text-green-600 font-medium mt-1\">Enhanced Analytics</div>\n                  </div>\n                  {/* Desktop: left title, right badge */}\n                  <div className=\"hidden md:flex items-center justify-between\">\n                    <h3 className=\"text-[17px] font-semibold text-helfi-black dark:text-white\">üì± Connect Your Devices</h3>\n                    <span className=\"text-[12px] md:text-sm text-green-600 font-medium whitespace-nowrap\">Enhanced Analytics</span>\n                  </div>\n                  <p className=\"text-[13px] text-gray-600 text-center mt-2\">Sync your smartwatch and fitness devices for better health insights</p>\n                </div>\n                \n                {/* Mobile grouped list */}\n                <div className=\"md:hidden mb-4\">\n                  <div className=\"bg-white rounded-2xl border border-gray-100 shadow-sm divide-y divide-gray-100\">\n                    {/* Fitbit - First since it's the only working integration */}\n                    <div className=\"px-4 py-3\">\n                      <div className=\"flex items-center gap-3\">\n                        <div className=\"text-2xl\">üèÉ</div>\n                        <div className=\"flex-1\">\n                          <div className=\"text-[15px] font-medium text-gray-900\">Fitbit</div>\n                          <div className=\"text-[12px] text-gray-500\">Activity & sleep</div>\n                        </div>\n                        {fitbitConnected && (\n                          <div className=\"w-2 h-2 bg-green-500 rounded-full\"></div>\n                        )}\n                      </div>\n                      {fitbitConnected ? (\n                        <Link href=\"/devices\" className=\"mt-3 w-full text-center text-[13px] px-3.5 py-2 rounded-full bg-emerald-600 text-white block\">Connected ‚úì</Link>\n                      ) : (\n                        <button onClick={handleConnectFitbit} className={`mt-3 w-full text-center text-[13px] px-3.5 py-2 rounded-full bg-helfi-green text-white hover:bg-green-600 transition-colors`} disabled={fitbitLoading}>\n                          {fitbitLoading ? 'Connecting...' : 'Connect Fitbit'}\n                        </button>\n                      )}\n                    </div>\n                    {/* Apple Watch */}\n                    <div className=\"px-4 py-3\">\n                      <div className=\"flex items-center gap-3\">\n                        <div className=\"text-2xl\">‚åö</div>\n                        <div>\n                          <div className=\"text-[15px] font-medium text-gray-900\">Apple Watch</div>\n                          <div className=\"text-[12px] text-gray-500\">Sync with Apple Health</div>\n                        </div>\n                      </div>\n                      <button onClick={() => toggleInterest('appleWatch')} className={`mt-3 w-full text-center text-[13px] px-3.5 py-2 rounded-full ${deviceInterest.appleWatch ? 'bg-emerald-600 text-white' : 'bg-gray-100 text-gray-700 hover:bg-gray-200'}`} disabled={!!savingInterest}>{deviceInterest.appleWatch ? 'Interested ‚úì' : \"I'm interested\"}</button>\n                    </div>\n                  {/* Garmin */}\n                  <div className=\"px-4 py-3\">\n                    <div className=\"flex items-center gap-3\">\n                      <Image src=\"/brands/garmin-connect.jpg\" alt=\"Garmin Connect\" width={24} height={24} className=\"rounded-md\" />\n                      <div>\n                        <div className=\"text-[15px] font-medium text-gray-900\">Garmin Connect</div>\n                        <div className=\"text-[12px] text-gray-500\">Training metrics</div>\n                      </div>\n                    </div>\n                    {!garminConnectEnabled ? (\n                      <button\n                        onClick={() => toggleInterest('garmin')}\n                        className={`mt-3 w-full text-center text-[13px] px-3.5 py-2 rounded-full ${\n                          deviceInterest.garmin ? 'bg-emerald-600 text-white' : 'bg-gray-100 text-gray-700 hover:bg-gray-200'\n                        }`}\n                        disabled={!!savingInterest}\n                      >\n                        {deviceInterest.garmin ? 'Interested ‚úì' : \"I'm interested\"}\n                      </button>\n                    ) : garminConnected ? (\n                      <Link href=\"/devices\" className=\"mt-3 w-full text-center text-[13px] px-3.5 py-2 rounded-full bg-emerald-600 text-white block\">\n                        Connected ‚úì\n                      </Link>\n                    ) : (\n                      <Link href=\"/devices\" className=\"mt-3 w-full text-center text-[13px] px-3.5 py-2 rounded-full bg-helfi-green text-white block hover:bg-green-600 transition-colors\">\n                        Connect Garmin Connect\n                      </Link>\n                    )}\n                  </div>\n                    {/* Samsung Health */}\n                    <div className=\"px-4 py-3\">\n                      <div className=\"flex items-center gap-3\">\n                        <div className=\"text-2xl\">üì±</div>\n                        <div>\n                          <div className=\"text-[15px] font-medium text-gray-900\">Samsung Health</div>\n                          <div className=\"text-[12px] text-gray-500\">Android health sync</div>\n                        </div>\n                      </div>\n                      <button onClick={() => toggleInterest('samsung')} className={`mt-3 w-full text-center text-[13px] px-3.5 py-2 rounded-full ${deviceInterest.samsung ? 'bg-emerald-600 text-white' : 'bg-gray-100 text-gray-700 hover:bg-gray-200'}`} disabled={!!savingInterest}>{deviceInterest.samsung ? 'Interested ‚úì' : \"I'm interested\"}</button>\n                    </div>\n                    {/* Google Fit */}\n                    <div className=\"px-4 py-3\">\n                      <div className=\"flex items-center gap-3\">\n                        <div className=\"text-2xl\">ü§ñ</div>\n                        <div>\n                          <div className=\"text-[15px] font-medium text-gray-900\">Google Fit</div>\n                          <div className=\"text-[12px] text-gray-500\">Android fitness</div>\n                        </div>\n                      </div>\n                      <button onClick={() => toggleInterest('googleFit')} className={`mt-3 w-full text-center text-[13px] px-3.5 py-2 rounded-full ${deviceInterest.googleFit ? 'bg-emerald-600 text-white' : 'bg-gray-100 text-gray-700 hover:bg-gray-200'}`} disabled={!!savingInterest}>{deviceInterest.googleFit ? 'Interested ‚úì' : \"I'm interested\"}</button>\n                    </div>\n                    {/* Oura Ring */}\n                    <div className=\"px-4 py-3\">\n                      <div className=\"flex items-center gap-3\">\n                        <div className=\"text-2xl\">üíç</div>\n                        <div>\n                          <div className=\"text-[15px] font-medium text-gray-900\">Oura Ring</div>\n                          <div className=\"text-[12px] text-gray-500\">Recovery & sleep</div>\n                        </div>\n                      </div>\n                      <button onClick={() => toggleInterest('oura')} className={`mt-3 w-full text-center text-[13px] px-3.5 py-2 rounded-full ${deviceInterest.oura ? 'bg-emerald-600 text-white' : 'bg-gray-100 text-gray-700 hover:bg-gray-200'}`} disabled={!!savingInterest}>{deviceInterest.oura ? 'Interested ‚úì' : \"I'm interested\"}</button>\n                    </div>\n                    {/* Polar */}\n                    <div className=\"px-4 py-3\">\n                      <div className=\"flex items-center gap-3\">\n                        <div className=\"text-2xl\">üß≠</div>\n                        <div>\n                          <div className=\"text-[15px] font-medium text-gray-900\">Polar</div>\n                          <div className=\"text-[12px] text-gray-500\">Heart rate & sport</div>\n                        </div>\n                      </div>\n                      <button onClick={() => toggleInterest('polar')} className={`mt-3 w-full text-center text-[13px] px-3.5 py-2 rounded-full ${deviceInterest.polar ? 'bg-emerald-600 text-white' : 'bg-gray-100 text-gray-700 hover:bg-gray-200'}`} disabled={!!savingInterest}>{deviceInterest.polar ? 'Interested ‚úì' : \"I'm interested\"}</button>\n                    </div>\n                  </div>\n                </div>\n\n                {/* Desktop grid */}\n                <div className=\"hidden md:grid grid-cols-4 gap-4 mb-4\">\n                  {/* Fitbit - First since it's the only working integration */}\n                  <div className={`bg-white p-4 rounded-2xl border ${fitbitConnected ? 'border-emerald-300 ring-1 ring-emerald-200' : 'border-gray-100'} shadow-sm transition-colors`}>\n                    <div className=\"text-center\">\n                      <div className=\"text-2xl mb-1\">üèÉ</div>\n                      <div className=\"text-xs font-medium text-gray-700 mb-2 flex items-center justify-center gap-1\">\n                        Fitbit\n                        {fitbitConnected && <span className=\"w-1.5 h-1.5 bg-green-500 rounded-full\"></span>}\n                      </div>\n                      {fitbitConnected ? (\n                        <Link\n                          href=\"/devices\"\n                          className=\"w-full inline-flex items-center justify-center text-[12px] px-3.5 py-1.5 rounded-full bg-emerald-600 text-white\"\n                        >\n                          Connected ‚úì\n                        </Link>\n                      ) : (\n                        <button\n                          onClick={handleConnectFitbit}\n                          className=\"w-full inline-flex items-center justify-center text-[12px] px-3.5 py-1.5 rounded-full bg-helfi-green text-white hover:bg-green-600 transition-colors\"\n                          disabled={fitbitLoading}\n                        >\n                          {fitbitLoading ? 'Connecting...' : 'Connect Fitbit'}\n                        </button>\n                      )}\n                    </div>\n                  </div>\n\n                  {/* Apple Watch */}\n                  <div className={`bg-white p-4 rounded-2xl border ${deviceInterest.appleWatch ? 'border-emerald-300 ring-1 ring-emerald-200' : 'border-gray-100'} shadow-sm transition-colors`}> \n                    <div className=\"text-center\">\n                      <div className=\"text-2xl mb-1\">‚åö</div>\n                      <div className=\"text-xs font-medium text-gray-700 mb-2\">Apple Watch</div>\n                      <button\n                        onClick={() => toggleInterest('appleWatch')}\n                        className={`w-full inline-flex items-center justify-center text-[12px] px-3.5 py-1.5 rounded-full ${\n                          deviceInterest.appleWatch ? 'bg-emerald-600 text-white' : 'bg-gray-100 text-gray-700 hover:bg-gray-200'\n                        }`}\n                        disabled={!!savingInterest}\n                      >\n                        {deviceInterest.appleWatch ? 'Interested ‚úì' : \"I'm interested\"}\n                      </button>\n                    </div>\n                  </div>\n\n                  {/* Garmin */}\n                  <div className={`bg-white p-4 rounded-2xl border ${garminConnected ? 'border-emerald-300 ring-1 ring-emerald-200' : 'border-gray-100'} shadow-sm transition-colors`}>\n                    <div className=\"text-center\">\n                      <div className=\"flex justify-center mb-2\">\n                        <Image src=\"/brands/garmin-connect.jpg\" alt=\"Garmin Connect\" width={28} height={28} className=\"rounded-md\" />\n                      </div>\n                      <div className=\"text-xs font-medium text-gray-700 mb-2 flex items-center justify-center gap-1\">\n                        Garmin Connect\n                        {garminConnected && <span className=\"w-1.5 h-1.5 bg-green-500 rounded-full\"></span>}\n                      </div>\n                      {!garminConnectEnabled ? (\n                        <button\n                          onClick={() => toggleInterest('garmin')}\n                          className={`w-full inline-flex items-center justify-center text-[12px] px-3.5 py-1.5 rounded-full ${\n                            deviceInterest.garmin ? 'bg-emerald-600 text-white' : 'bg-gray-100 text-gray-700 hover:bg-gray-200'\n                          }`}\n                          disabled={!!savingInterest}\n                        >\n                          {deviceInterest.garmin ? 'Interested ‚úì' : \"I'm interested\"}\n                        </button>\n                      ) : garminConnected ? (\n                        <Link\n                          href=\"/devices\"\n                          className=\"w-full inline-flex items-center justify-center text-[12px] px-3.5 py-1.5 rounded-full bg-emerald-600 text-white\"\n                        >\n                          Connected ‚úì\n                        </Link>\n                      ) : (\n                        <Link\n                          href=\"/devices\"\n                          className=\"w-full inline-flex items-center justify-center text-[12px] px-3.5 py-1.5 rounded-full bg-helfi-green text-white hover:bg-green-600 transition-colors\"\n                        >\n                          Connect Garmin Connect\n                        </Link>\n                      )}\n                    </div>\n                  </div>\n\n                  {/* Samsung Health */}\n                  <div className={`bg-white p-4 rounded-2xl border ${deviceInterest.samsung ? 'border-emerald-300 ring-1 ring-emerald-200' : 'border-gray-100'} shadow-sm transition-colors`}>\n                    <div className=\"text-center\">\n                      <div className=\"text-2xl mb-1\">üì±</div>\n                      <div className=\"text-xs font-medium text-gray-700 mb-2\">Samsung Health</div>\n                      <button\n                        onClick={() => toggleInterest('samsung')}\n                        className={`w-full inline-flex items-center justify-center text-[12px] px-3.5 py-1.5 rounded-full ${\n                          deviceInterest.samsung ? 'bg-emerald-600 text-white' : 'bg-gray-100 text-gray-700 hover:bg-gray-200'\n                        }`}\n                        disabled={!!savingInterest}\n                      >\n                        {deviceInterest.samsung ? 'Interested ‚úì' : \"I'm interested\"}\n                      </button>\n                    </div>\n                  </div>\n\n                  {/* Google Fit */}\n                  <div className={`bg-white p-4 rounded-2xl border ${deviceInterest.googleFit ? 'border-emerald-300 ring-1 ring-emerald-200' : 'border-gray-100'} shadow-sm transition-colors`}>\n                    <div className=\"text-center\">\n                      <div className=\"text-2xl mb-1\">ü§ñ</div>\n                      <div className=\"text-xs font-medium text-gray-700 mb-2\">Google Fit</div>\n                      <button\n                        onClick={() => toggleInterest('googleFit')}\n                        className={`w-full inline-flex items-center justify-center text-[12px] px-3.5 py-1.5 rounded-full ${\n                          deviceInterest.googleFit ? 'bg-emerald-600 text-white' : 'bg-gray-100 text-gray-700 hover:bg-gray-200'\n                        }`}\n                        disabled={!!savingInterest}\n                      >\n                        {deviceInterest.googleFit ? 'Interested ‚úì' : \"I'm interested\"}\n                      </button>\n                    </div>\n                  </div>\n\n                  {/* Oura Ring */}\n                  <div className={`bg-white p-4 rounded-2xl border ${deviceInterest.oura ? 'border-emerald-300 ring-1 ring-emerald-200' : 'border-gray-100'} shadow-sm transition-colors`}>\n                    <div className=\"text-center\">\n                      <div className=\"text-2xl mb-1\">üíç</div>\n                      <div className=\"text-xs font-medium text-gray-700 mb-2\">Oura Ring</div>\n                      <button\n                        onClick={() => toggleInterest('oura')}\n                        className={`w-full inline-flex items-center justify-center text-[12px] px-3.5 py-1.5 rounded-full ${\n                          deviceInterest.oura ? 'bg-emerald-600 text-white' : 'bg-gray-100 text-gray-700 hover:bg-gray-200'\n                        }`}\n                        disabled={!!savingInterest}\n                      >\n                        {deviceInterest.oura ? 'Interested ‚úì' : \"I'm interested\"}\n                      </button>\n                    </div>\n                  </div>\n\n                  {/* Polar */}\n                  <div className={`bg-white p-4 rounded-2xl border ${deviceInterest.polar ? 'border-emerald-300 ring-1 ring-emerald-200' : 'border-gray-100'} shadow-sm transition-colors`}>\n                    <div className=\"text-center\">\n                      <div className=\"text-2xl mb-1\">üß≠</div>\n                      <div className=\"text-xs font-medium text-gray-700 mb-2\">Polar</div>\n                      <button\n                        onClick={() => toggleInterest('polar')}\n                        className={`w-full inline-flex items-center justify-center text-[12px] px-3.5 py-1.5 rounded-full ${\n                          deviceInterest.polar ? 'bg-emerald-600 text-white' : 'bg-gray-100 text-gray-700 hover:bg-gray-200'\n                        }`}\n                        disabled={!!savingInterest}\n                      >\n                        {deviceInterest.polar ? 'Interested ‚úì' : \"I'm interested\"}\n                      </button>\n                    </div>\n                  </div>\n                </div>\n                \n                <div className=\"text-xs text-gray-500 text-center\">\n                  Device integration coming soon - enhanced health monitoring with real-time data\n                </div>\n              </div>\n            )}\n\n            {/* Data Status Section */}\n            <div className=\"mb-8\">\n              {onboardingData?.onboardingComplete ? (\n                <div className=\"bg-green-50 border border-green-200 rounded-xl p-6\">\n                  <div className=\"flex items-center justify-between\">\n                    <div>\n                      <h3 className=\"text-lg font-semibold text-green-900 mb-2\">‚úÖ Onboarding Complete</h3>\n                      <p className=\"text-green-700 mb-4\">\n                        Your health profile has been created and synced across all devices\n                      </p>\n                      <div className=\"flex flex-wrap gap-2 mb-4\">\n                        {onboardingData.personalInfo && (\n                          <span className=\"bg-green-100 text-green-800 px-2 py-1 rounded-full text-xs\">\n                            Personal Info ‚úì\n                          </span>\n                        )}\n                        {onboardingData.physicalMetrics && (\n                          <span className=\"bg-green-100 text-green-800 px-2 py-1 rounded-full text-xs\">\n                            Physical Metrics ‚úì\n                          </span>\n                        )}\n                        {onboardingData.healthGoals && (\n                          <span className=\"bg-green-100 text-green-800 px-2 py-1 rounded-full text-xs\">\n                            Health Goals ‚úì\n                          </span>\n                        )}\n                        {onboardingData.medications && onboardingData.medications.length > 0 && (\n                          <span className=\"bg-green-100 text-green-800 px-2 py-1 rounded-full text-xs\">\n                            Medications ‚úì\n                          </span>\n                        )}\n                        {onboardingData.supplements && onboardingData.supplements.length > 0 && (\n                          <span className=\"bg-green-100 text-green-800 px-2 py-1 rounded-full text-xs\">\n                            Supplements ‚úì\n                          </span>\n                        )}\n                      </div>\n                    </div>\n                    <div className=\"text-green-600\">\n                      <svg className=\"w-12 h-12\" fill=\"currentColor\" viewBox=\"0 0 24 24\">\n                        <path d=\"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z\"/>\n                      </svg>\n                    </div>\n                  </div>\n                  \n                  <div className=\"flex flex-wrap gap-3 mt-4\">\n                    <button \n                      onClick={handleEditOnboarding}\n                      className=\"bg-green-600 text-white px-4 py-2 rounded-lg hover:bg-green-700 transition-colors\"\n                    >\n                      Edit Health Information\n                    </button>\n                    <button \n                      onClick={() => setShowResetConfirm(true)}\n                      className=\"bg-gray-600 text-white px-4 py-2 rounded-lg hover:bg-gray-700 transition-colors\"\n                    >\n                      Reset All Data\n                    </button>\n                  </div>\n                </div>\n              ) : (\n                <div className=\"bg-blue-50 border border-blue-200 rounded-xl p-6\">\n                  <div className=\"flex items-center justify-between\">\n                    <div>\n                      <h3 className=\"text-lg font-semibold text-blue-900 mb-2\">üöÄ Complete your Health Setup</h3>\n                      <p className=\"text-blue-700 mb-4\">\n                        Finish your health profile to unlock personalized insights and tracking\n                      </p>\n                    </div>\n                    <div className=\"text-blue-600\">\n                      <svg className=\"w-12 h-12\" fill=\"currentColor\" viewBox=\"0 0 24 24\">\n                        <path d=\"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17h-2v-2h2v2zm2.07-7.75l-.9.92C13.45 12.9 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25z\"/>\n                      </svg>\n                    </div>\n                  </div>\n                  \n                  <Link \n                    href=\"/onboarding\"\n                    className=\"inline-block bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700 transition-colors font-medium\"\n                  >\n                    {onboardingData ? 'Continue Health Setup' : 'Start Health Profile Setup'}\n                  </Link>\n                </div>\n              )}\n            </div>\n\n            {/* Reset Confirmation Modal */}\n            {showResetConfirm && (\n              <div className=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50\">\n                <div className=\"bg-white rounded-lg p-6 max-w-md mx-4\">\n                  <h3 className=\"text-lg font-bold text-red-900 mb-4\">‚ö†Ô∏è Reset All Data</h3>\n                  <p className=\"text-gray-700 mb-6\">\n                    This will permanently delete all your health data, including:\n                  </p>\n                  <ul className=\"text-sm text-gray-600 mb-6 space-y-1\">\n                    <li>‚Ä¢ Personal information</li>\n                    <li>‚Ä¢ Physical metrics</li>\n                    <li>‚Ä¢ Health goals</li>\n                    <li>‚Ä¢ Medications and supplements</li>\n                    <li>‚Ä¢ Profile image</li>\n                  </ul>\n                  <p className=\"text-red-600 font-medium mb-6\">\n                    This action cannot be undone.\n                  </p>\n                  <div className=\"flex gap-3\">\n                    <button \n                      onClick={handleResetData}\n                      className=\"bg-red-600 text-white px-4 py-2 rounded-lg hover:bg-red-700 transition-colors\"\n                    >\n                      Yes, Reset Everything\n                    </button>\n                    <button \n                      onClick={() => setShowResetConfirm(false)}\n                      className=\"bg-gray-300 text-gray-700 px-4 py-2 rounded-lg hover:bg-gray-400 transition-colors\"\n                    >\n                      Cancel\n                    </button>\n                  </div>\n                </div>\n              </div>\n            )}\n          </div>\n        </div>\n      </main>\n\n      {/* Mobile Bottom Navigation - with pressed, ripple and active states */}\n      <nav className=\"md:hidden fixed bottom-0 left-0 right-0 bg-white border-t border-gray-200 px-4 py-2 z-40\">\n        <div className=\"flex items-center justify-around\">\n          \n          {/* Dashboard (Active) */}\n          <Link href=\"/dashboard\" className={`pressable ripple flex flex-col items-center py-2 px-1 min-w-0 flex-1`} onClick={() => {\n            try {\n              const reduced = window.matchMedia('(prefers-reduced-motion: reduce)')?.matches\n              const pref = localStorage.getItem('hapticsEnabled')\n              const enabled = pref === null ? true : pref === 'true'\n              if (enabled && !reduced && 'vibrate' in navigator) navigator.vibrate(10)\n            } catch {}\n          }}>\n            <div className={`icon ${pathname === '/dashboard' ? 'text-helfi-green' : 'text-gray-400'}`}>\n              <svg className=\"w-6 h-6\" fill=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path d=\"M3 13h8V3H3v10zm0 8h8v-6H3v6zm10 0h8V11h-8v10zm0-18v6h8V3h-8z\"/>\n              </svg>\n            </div>\n            <span className={`label text-xs mt-1 truncate ${pathname === '/dashboard' ? 'text-helfi-green font-bold' : 'text-gray-400 font-medium'}`}>Dashboard</span>\n          </Link>\n\n          {/* Insights */}\n          <Link href=\"/insights\" className=\"pressable ripple flex flex-col items-center py-2 px-1 min-w-0 flex-1\" onClick={() => {\n            try { const reduced = window.matchMedia('(prefers-reduced-motion: reduce)')?.matches; const pref = localStorage.getItem('hapticsEnabled'); const enabled = pref === null ? true : pref === 'true'; if (enabled && !reduced && 'vibrate' in navigator) navigator.vibrate(10) } catch {}\n          }}>\n            <div className={`icon ${pathname === '/insights' ? 'text-helfi-green' : 'text-gray-400'}`}>\n              <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z\" />\n              </svg>\n            </div>\n            <span className={`label text-xs mt-1 truncate ${pathname === '/insights' ? 'text-helfi-green font-bold' : 'text-gray-400 font-medium'}`}>Insights</span>\n          </Link>\n\n          {/* Food */}\n          <Link href=\"/food\" className=\"pressable ripple flex flex-col items-center py-2 px-1 min-w-0 flex-1\" onClick={() => {\n            try { const reduced = window.matchMedia('(prefers-reduced-motion: reduce)')?.matches; const pref = localStorage.getItem('hapticsEnabled'); const enabled = pref === null ? true : pref === 'true'; if (enabled && !reduced && 'vibrate' in navigator) navigator.vibrate(10) } catch {}\n          }}>\n            <div className={`icon ${pathname === '/food' ? 'text-helfi-green' : 'text-gray-400'}`}>\n              <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10\" />\n              </svg>\n            </div>\n            <span className={`label text-xs mt-1 truncate ${pathname === '/food' ? 'text-helfi-green font-bold' : 'text-gray-400 font-medium'}`}>Food</span>\n          </Link>\n\n          {/* Intake (Onboarding) */}\n          <MobileMoreMenu />\n\n          {/* Settings */}\n          <Link href=\"/settings\" className=\"pressable ripple flex flex-col items-center py-2 px-1 min-w-0 flex-1\" onClick={() => {\n            try { const reduced = window.matchMedia('(prefers-reduced-motion: reduce)')?.matches; const pref = localStorage.getItem('hapticsEnabled'); const enabled = pref === null ? true : pref === 'true'; if (enabled && !reduced && 'vibrate' in navigator) navigator.vibrate(10) } catch {}\n          }}>\n            <div className={`icon ${pathname === '/settings' ? 'text-helfi-green' : 'text-gray-400'}`}>\n              <Cog6ToothIcon className=\"w-6 h-6 flex-shrink-0\" style={{ minWidth: '24px', minHeight: '24px' }} />\n            </div>\n            <span className={`label text-xs mt-1 truncate ${pathname === '/settings' ? 'text-helfi-green font-bold' : 'text-gray-400 font-medium'}`}>Settings</span>\n          </Link>\n\n        </div>\n      </nav>\n    </div>\n  )\n} \n","truncated":false,"size":61690},{"path":"app/devices/page.tsx","content":"'use client'\n\nimport { useState, useEffect, useRef } from 'react'\nimport Image from 'next/image'\nimport Link from 'next/link'\nimport MobileMoreMenu from '@/components/MobileMoreMenu'\nimport PageHeader from '@/components/PageHeader'\nimport FitbitSummary from '@/components/devices/FitbitSummary'\nimport FitbitCharts from '@/components/devices/FitbitCharts'\nimport FitbitCorrelations from '@/components/devices/FitbitCorrelations'\n\nexport default function DevicesPage() {\n  const garminConnectEnabled = process.env.NEXT_PUBLIC_GARMIN_CONNECT_ENABLED !== 'false'\n  const [fitbitConnected, setFitbitConnected] = useState(false)\n  const [fitbitLoading, setFitbitLoading] = useState(false)\n  const [syncingFitbit, setSyncingFitbit] = useState(false)\n  const [popupOpen, setPopupOpen] = useState(false)\n  const [checkingStatus, setCheckingStatus] = useState(false)\n  const [garminConnected, setGarminConnected] = useState(false)\n  const [garminLoading, setGarminLoading] = useState(false)\n  const [garminPopupOpen, setGarminPopupOpen] = useState(false)\n  const [garminCheckingStatus, setGarminCheckingStatus] = useState(false)\n  const [deviceInterest, setDeviceInterest] = useState<Record<string, boolean>>({})\n  const [savingInterest, setSavingInterest] = useState(false)\n  const [loadingDemo, setLoadingDemo] = useState(false)\n  const [clearingDemo, setClearingDemo] = useState(false)\n  const [adminToken, setAdminToken] = useState<string | null>(null)\n  const popupRef = useRef<Window | null>(null)\n  const checkIntervalRef = useRef<NodeJS.Timeout | null>(null)\n  const closedCheckRef = useRef<NodeJS.Timeout | null>(null)\n  const garminPopupRef = useRef<Window | null>(null)\n  const garminCheckIntervalRef = useRef<NodeJS.Timeout | null>(null)\n  const garminClosedCheckRef = useRef<NodeJS.Timeout | null>(null)\n\n  useEffect(() => {\n    checkFitbitStatus()\n    if (garminConnectEnabled) {\n      checkGarminStatus()\n    } else {\n      setGarminConnected(false)\n      setGarminLoading(false)\n      setGarminPopupOpen(false)\n      setGarminCheckingStatus(false)\n      loadDeviceInterest()\n    }\n\n    try {\n      const storedAdminToken = sessionStorage.getItem('adminToken')\n      if (storedAdminToken) {\n        setAdminToken(storedAdminToken)\n      }\n    } catch (error) {\n      console.warn('Admin token lookup skipped:', error)\n    }\n    \n    // Check URL params for Fitbit connection result\n    const params = new URLSearchParams(window.location.search)\n    if (params.get('fitbit_connected') === 'true') {\n      setFitbitConnected(true)\n      window.history.replaceState({}, '', '/devices')\n    }\n    if (params.get('fitbit_error')) {\n      alert('Fitbit connection failed: ' + params.get('fitbit_error'))\n      window.history.replaceState({}, '', '/devices')\n    }\n    if (params.get('garmin_connected') === 'true') {\n      if (garminConnectEnabled) setGarminConnected(true)\n      window.history.replaceState({}, '', '/devices')\n    }\n    if (params.get('garmin_error')) {\n      const err = params.get('garmin_error')\n      if (err === 'disabled') {\n        alert('Garmin Connect is temporarily unavailable while production access is pending.')\n      } else {\n        alert('Garmin connection failed: ' + err)\n      }\n      window.history.replaceState({}, '', '/devices')\n    }\n\n    // Listen for messages from popup window\n    const handleMessage = (event: MessageEvent) => {\n      if (event.data?.type === 'FITBIT_CONNECTED' && event.data.success) {\n        checkFitbitStatus()\n        setFitbitLoading(false)\n      } else if (event.data?.type === 'FITBIT_ERROR') {\n        alert('Fitbit connection failed: ' + event.data.error)\n        setFitbitLoading(false)\n      } else if (event.data?.type === 'GARMIN_CONNECTED' && event.data.success) {\n        if (garminConnectEnabled) checkGarminStatus()\n        setGarminLoading(false)\n      } else if (event.data?.type === 'GARMIN_ERROR') {\n        alert('Garmin connection failed: ' + event.data.error)\n        setGarminLoading(false)\n      }\n    }\n\n    window.addEventListener('message', handleMessage)\n    return () => window.removeEventListener('message', handleMessage)\n  }, [])\n\n  const loadDeviceInterest = async () => {\n    try {\n      const res = await fetch('/api/user-data', { cache: 'no-cache' })\n      if (!res.ok) return\n      const json = await res.json()\n      if (json?.data?.deviceInterest && typeof json.data.deviceInterest === 'object') {\n        setDeviceInterest(json.data.deviceInterest)\n      }\n    } catch {}\n  }\n\n  const saveDeviceInterest = async (next: Record<string, boolean>) => {\n    try {\n      setSavingInterest(true)\n      await fetch('/api/user-data', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ deviceInterest: next }),\n      })\n      setDeviceInterest(next)\n    } catch (e) {\n      console.error('Failed to save device interest', e)\n    } finally {\n      setSavingInterest(false)\n    }\n  }\n\n  const checkFitbitStatus = async () => {\n    try {\n      const response = await fetch('/api/fitbit/status')\n      if (response.ok) {\n        const data = await response.json()\n        setFitbitConnected(data.connected)\n        return data.connected\n      }\n      return false\n    } catch (error) {\n      console.error('Error checking Fitbit status:', error)\n      return false\n    }\n  }\n\n  const checkGarminStatus = async () => {\n    if (!garminConnectEnabled) {\n      setGarminConnected(false)\n      return false\n    }\n    try {\n      const response = await fetch('/api/garmin/status')\n      if (response.ok) {\n        const data = await response.json()\n        setGarminConnected(data.connected)\n        return data.connected\n      }\n      return false\n    } catch (error) {\n      console.error('Error checking Garmin status:', error)\n      return false\n    }\n  }\n\n  const handleConnectFitbit = async () => {\n    setFitbitLoading(true)\n    setPopupOpen(true)\n    setCheckingStatus(true)\n    try {\n      // Open Fitbit OAuth in a popup window so users can still see Helfi\n      const width = 600\n      const height = 700\n      const left = window.screen.width / 2 - width / 2\n      const top = window.screen.height / 2 - height / 2\n      \n      const popup = window.open(\n        '/api/auth/fitbit/authorize',\n        'Fitbit Authorization',\n        `width=${width},height=${height},left=${left},top=${top},toolbar=no,menubar=no,scrollbars=yes,resizable=yes`\n      )\n\n      if (!popup) {\n        alert('Please allow popups for this site to connect Fitbit')\n        setFitbitLoading(false)\n        setPopupOpen(false)\n        setCheckingStatus(false)\n        return\n      }\n\n      popupRef.current = popup\n\n      // Check if popup is closed (user cancelled)\n      closedCheckRef.current = setInterval(() => {\n        if (popup.closed) {\n          if (closedCheckRef.current) {\n            clearInterval(closedCheckRef.current)\n            closedCheckRef.current = null\n          }\n          if (checkIntervalRef.current) {\n            clearInterval(checkIntervalRef.current)\n            checkIntervalRef.current = null\n          }\n          setFitbitLoading(false)\n          setPopupOpen(false)\n          setCheckingStatus(false)\n          // Check status in case they completed it quickly\n          setTimeout(() => checkFitbitStatus(), 1000)\n        }\n      }, 500)\n\n      // Poll for connection status - check every 1 second (more frequent)\n      checkIntervalRef.current = setInterval(async () => {\n        setCheckingStatus(true)\n        const connected = await checkFitbitStatus()\n        if (connected) {\n          if (closedCheckRef.current) {\n            clearInterval(closedCheckRef.current)\n            closedCheckRef.current = null\n          }\n          if (checkIntervalRef.current) {\n            clearInterval(checkIntervalRef.current)\n            checkIntervalRef.current = null\n          }\n          // Try to close popup if still open\n          if (popup && !popup.closed) {\n            try {\n              popup.close()\n            } catch (e) {\n              // Popup might be on different origin, ignore\n            }\n          }\n          setFitbitLoading(false)\n          setPopupOpen(false)\n          setCheckingStatus(false)\n        }\n      }, 1000)\n\n      // Cleanup after 3 minutes\n      setTimeout(() => {\n        if (closedCheckRef.current) {\n          clearInterval(closedCheckRef.current)\n          closedCheckRef.current = null\n        }\n        if (checkIntervalRef.current) {\n          clearInterval(checkIntervalRef.current)\n          checkIntervalRef.current = null\n        }\n        setFitbitLoading(false)\n        setPopupOpen(false)\n        setCheckingStatus(false)\n      }, 180000)\n    } catch (error) {\n      console.error('Error connecting Fitbit:', error)\n      alert('Failed to connect Fitbit. Please try again.')\n      setFitbitLoading(false)\n      setPopupOpen(false)\n      setCheckingStatus(false)\n    }\n  }\n\n  const handleClosePopupAndCheck = async () => {\n    // Close popup if still open\n    if (popupRef.current && !popupRef.current.closed) {\n      try {\n        popupRef.current.close()\n      } catch (e) {\n        // Ignore errors\n      }\n    }\n    \n    // Clean up intervals\n    if (closedCheckRef.current) {\n      clearInterval(closedCheckRef.current)\n      closedCheckRef.current = null\n    }\n    if (checkIntervalRef.current) {\n      clearInterval(checkIntervalRef.current)\n      checkIntervalRef.current = null\n    }\n    \n    setPopupOpen(false)\n    setCheckingStatus(true)\n    \n    // Check status\n    const connected = await checkFitbitStatus()\n    if (connected) {\n      setFitbitLoading(false)\n      setCheckingStatus(false)\n    } else {\n      setFitbitLoading(false)\n      setCheckingStatus(false)\n      alert('Fitbit connection not detected. Please try connecting again.')\n    }\n  }\n\n  const handleConnectGarmin = async () => {\n    if (!garminConnectEnabled) {\n      alert('Garmin Connect is temporarily unavailable while production access is pending.')\n      return\n    }\n    setGarminLoading(true)\n    setGarminPopupOpen(true)\n    setGarminCheckingStatus(true)\n\n    try {\n      const width = 600\n      const height = 700\n      const left = window.screen.width / 2 - width / 2\n      const top = window.screen.height / 2 - height / 2\n\n      const popup = window.open(\n        '/api/auth/garmin/authorize',\n        'Garmin Authorization',\n        `width=${width},height=${height},left=${left},top=${top},toolbar=no,menubar=no,scrollbars=yes,resizable=yes`\n      )\n\n      if (!popup) {\n        alert('Please allow popups for this site to connect Garmin')\n        setGarminLoading(false)\n        setGarminPopupOpen(false)\n        setGarminCheckingStatus(false)\n        return\n      }\n\n      garminPopupRef.current = popup\n\n      garminClosedCheckRef.current = setInterval(() => {\n        if (popup.closed) {\n          if (garminClosedCheckRef.current) {\n            clearInterval(garminClosedCheckRef.current)\n            garminClosedCheckRef.current = null\n          }\n          if (garminCheckIntervalRef.current) {\n            clearInterval(garminCheckIntervalRef.current)\n            garminCheckIntervalRef.current = null\n          }\n          setGarminLoading(false)\n          setGarminPopupOpen(false)\n          setGarminCheckingStatus(false)\n          setTimeout(() => checkGarminStatus(), 1000)\n        }\n      }, 500)\n\n      garminCheckIntervalRef.current = setInterval(async () => {\n        setGarminCheckingStatus(true)\n        const connected = await checkGarminStatus()\n        if (connected) {\n          if (garminClosedCheckRef.current) {\n            clearInterval(garminClosedCheckRef.current)\n            garminClosedCheckRef.current = null\n          }\n          if (garminCheckIntervalRef.current) {\n            clearInterval(garminCheckIntervalRef.current)\n            garminCheckIntervalRef.current = null\n          }\n          if (popup && !popup.closed) {\n            try {\n              popup.close()\n            } catch (e) {}\n          }\n          setGarminLoading(false)\n          setGarminPopupOpen(false)\n          setGarminCheckingStatus(false)\n        }\n      }, 1000)\n\n      setTimeout(() => {\n        if (garminClosedCheckRef.current) {\n          clearInterval(garminClosedCheckRef.current)\n          garminClosedCheckRef.current = null\n        }\n        if (garminCheckIntervalRef.current) {\n          clearInterval(garminCheckIntervalRef.current)\n          garminCheckIntervalRef.current = null\n        }\n        setGarminLoading(false)\n        setGarminPopupOpen(false)\n        setGarminCheckingStatus(false)\n      }, 180000)\n    } catch (error) {\n      console.error('Error connecting Garmin:', error)\n      alert('Failed to connect Garmin. Please try again.')\n      setGarminLoading(false)\n      setGarminPopupOpen(false)\n      setGarminCheckingStatus(false)\n    }\n  }\n\n  const handleCloseGarminPopupAndCheck = async () => {\n    if (garminPopupRef.current && !garminPopupRef.current.closed) {\n      try {\n        garminPopupRef.current.close()\n      } catch (e) {}\n    }\n\n    if (garminClosedCheckRef.current) {\n      clearInterval(garminClosedCheckRef.current)\n      garminClosedCheckRef.current = null\n    }\n    if (garminCheckIntervalRef.current) {\n      clearInterval(garminCheckIntervalRef.current)\n      garminCheckIntervalRef.current = null\n    }\n\n    setGarminPopupOpen(false)\n    setGarminCheckingStatus(true)\n\n    const connected = await checkGarminStatus()\n    if (connected) {\n      setGarminLoading(false)\n      setGarminCheckingStatus(false)\n    } else {\n      setGarminLoading(false)\n      setGarminCheckingStatus(false)\n      alert('Garmin connection not detected. Please try connecting again.')\n    }\n  }\n\n  // Cleanup intervals on unmount\n  useEffect(() => {\n    return () => {\n      if (checkIntervalRef.current) {\n        clearInterval(checkIntervalRef.current)\n      }\n      if (closedCheckRef.current) {\n        clearInterval(closedCheckRef.current)\n      }\n      if (garminCheckIntervalRef.current) {\n        clearInterval(garminCheckIntervalRef.current)\n      }\n      if (garminClosedCheckRef.current) {\n        clearInterval(garminClosedCheckRef.current)\n      }\n    }\n  }, [])\n\n  const handleDisconnectFitbit = async () => {\n    if (!confirm('Are you sure you want to disconnect your Fitbit account? This will also delete all synced Fitbit data.')) {\n      return\n    }\n    \n    setFitbitLoading(true)\n    try {\n      const response = await fetch('/api/fitbit/status', { method: 'DELETE' })\n      if (response.ok) {\n        setFitbitConnected(false)\n        alert('Fitbit account disconnected successfully')\n      } else {\n        throw new Error('Failed to disconnect')\n      }\n    } catch (error) {\n      console.error('Error disconnecting Fitbit:', error)\n      alert('Failed to disconnect Fitbit. Please try again.')\n    } finally {\n      setFitbitLoading(false)\n    }\n  }\n\n  const handleDisconnectGarmin = async () => {\n    if (!confirm('Disconnect Garmin? This will stop new data from reaching Helfi.')) {\n      return\n    }\n\n    setGarminLoading(true)\n    try {\n      const response = await fetch('/api/garmin/status', { method: 'DELETE' })\n      if (response.ok) {\n        setGarminConnected(false)\n        alert('Garmin account disconnected successfully')\n      } else {\n        throw new Error('Failed to disconnect Garmin')\n      }\n    } catch (error) {\n      console.error('Error disconnecting Garmin:', error)\n      alert('Failed to disconnect Garmin. Please try again.')\n    } finally {\n      setGarminLoading(false)\n    }\n  }\n\n  const handleSyncFitbit = async () => {\n    setSyncingFitbit(true)\n    try {\n      const response = await fetch('/api/fitbit/sync', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          date: new Date().toISOString().split('T')[0],\n          dataTypes: ['steps', 'heartrate', 'sleep', 'weight'],\n        }),\n      })\n      \n      if (response.ok) {\n        const data = await response.json()\n        alert('Fitbit data synced successfully!')\n        // Refresh page to show new data\n        window.location.reload()\n      } else {\n        throw new Error('Sync failed')\n      }\n    } catch (error) {\n      console.error('Error syncing Fitbit:', error)\n      alert('Failed to sync Fitbit data. Please try again.')\n    } finally {\n      setSyncingFitbit(false)\n    }\n  }\n\n  const handleLoadDemoData = async () => {\n    if (!adminToken) {\n      alert('Admin access required to load demo data.')\n      return\n    }\n    if (!confirm('This will create 30 days of demo Fitbit data for testing. Continue?')) {\n      return\n    }\n    \n    setLoadingDemo(true)\n    try {\n      const response = await fetch('/api/fitbit/demo/seed', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${adminToken}`,\n        },\n      })\n      \n      if (response.ok) {\n        const data = await response.json()\n        alert(`‚úÖ ${data.message}\\n\\n${data.recordsCreated} records created for dates ${data.dateRange.start} to ${data.dateRange.end}`)\n        // Refresh page to show demo data\n        window.location.reload()\n      } else {\n        const errorData = await response.json()\n        const errorMsg = errorData.details \n          ? `${errorData.error}: ${errorData.details}` \n          : errorData.error || 'Failed to load demo data'\n        throw new Error(errorMsg)\n      }\n    } catch (error: any) {\n      console.error('Error loading demo data:', error)\n      alert(`Failed to load demo data: ${error.message || 'Unknown error'}`)\n    } finally {\n      setLoadingDemo(false)\n    }\n  }\n\n  const handleClearDemoData = async () => {\n    if (!adminToken) {\n      alert('Admin access required to clear demo data.')\n      return\n    }\n    if (!confirm('This will delete all Fitbit demo data. Continue?')) {\n      return\n    }\n    \n    setClearingDemo(true)\n    try {\n      const response = await fetch('/api/fitbit/demo/seed', {\n        method: 'DELETE',\n        headers: {\n          'Authorization': `Bearer ${adminToken}`,\n        },\n      })\n      \n      if (response.ok) {\n        const data = await response.json()\n        alert(`‚úÖ Demo data cleared successfully\\n\\n${data.recordsDeleted} records deleted`)\n        // Refresh page\n        window.location.reload()\n      } else {\n        const error = await response.json()\n        throw new Error(error.error || 'Failed to clear demo data')\n      }\n    } catch (error: any) {\n      console.error('Error clearing demo data:', error)\n      alert(`Failed to clear demo data: ${error.message}`)\n    } finally {\n      setClearingDemo(false)\n    }\n  }\n\n  return (\n    <div className=\"min-h-screen bg-gray-50 dark:bg-gray-900 pb-24\">\n      <PageHeader title=\"Devices\" />\n\n      <main className=\"max-w-7xl mx-auto px-4 py-6\">\n        <div className=\"mb-6\">\n          <p className=\"text-gray-600 dark:text-gray-400\">\n            Connect your fitness devices to sync activity, sleep, and health data into Helfi.\n          </p>\n        </div>\n\n        {/* Fitbit Device Card */}\n        <div className=\"bg-white dark:bg-gray-800 rounded-lg shadow-sm p-6 mb-6\">\n          <div className=\"flex items-start justify-between mb-4\">\n            <div className=\"flex items-center gap-4\">\n              <div className=\"text-4xl\">üèÉ</div>\n              <div>\n                <h2 className=\"text-xl font-bold text-gray-900 dark:text-white mb-1\">Fitbit</h2>\n                <p className=\"text-sm text-gray-600 dark:text-gray-400\">Activity, heart rate, sleep, and weight tracking</p>\n              </div>\n            </div>\n            {fitbitConnected && (\n              <div className=\"flex items-center gap-2\">\n                <div className=\"w-2 h-2 bg-green-500 rounded-full\"></div>\n                <span className=\"text-sm text-green-600 dark:text-green-400 font-medium\">Connected</span>\n              </div>\n            )}\n          </div>\n\n          {popupOpen && (\n            <div className=\"mb-4 p-4 bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg\">\n              <div className=\"flex items-start gap-3\">\n                <div className=\"flex-shrink-0\">\n                  {checkingStatus ? (\n                    <svg className=\"animate-spin h-5 w-5 text-blue-600 dark:text-blue-400\" xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\">\n                      <circle className=\"opacity-25\" cx=\"12\" cy=\"12\" r=\"10\" stroke=\"currentColor\" strokeWidth=\"4\"></circle>\n                      <path className=\"opacity-75\" fill=\"currentColor\" d=\"M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z\"></path>\n                    </svg>\n                  ) : (\n                    <div className=\"w-5 h-5 bg-blue-600 dark:bg-blue-400 rounded-full\"></div>\n                  )}\n                </div>\n                <div className=\"flex-1\">\n                  <p className=\"text-sm font-medium text-blue-900 dark:text-blue-100 mb-1\">\n                    {checkingStatus ? 'Checking connection status...' : 'Popup window is open'}\n                  </p>\n                  <p className=\"text-xs text-blue-700 dark:text-blue-300 mb-3\">\n                    Complete the Fitbit login in the popup window. If the popup gets stuck, click the button below to close it and check your connection status.\n                  </p>\n                  <button\n                    onClick={handleClosePopupAndCheck}\n                    disabled={checkingStatus}\n                    className=\"text-xs px-3 py-1.5 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed\"\n                  >\n                    {checkingStatus ? 'Checking...' : 'Close Popup & Check Status'}\n                  </button>\n                </div>\n              </div>\n            </div>\n          )}\n\n          {fitbitConnected ? (\n            <div className=\"space-y-6\">\n              <div className=\"p-4 bg-green-50 dark:bg-green-900/20 border border-green-200 dark:border-green-800 rounded-lg\">\n                <p className=\"text-sm text-gray-700 dark:text-gray-300\">\n                  Your Fitbit account is connected. Data will sync automatically, or you can manually sync below.\n                </p>\n              </div>\n              \n              <FitbitSummary rangeDays={7} />\n\n              <div className=\"flex gap-3\">\n                <button\n                  onClick={handleSyncFitbit}\n                  disabled={syncingFitbit}\n                  className=\"flex-1 px-4 py-2 bg-helfi-green text-white rounded-lg hover:bg-green-600 transition-colors disabled:opacity-50 disabled:cursor-not-allowed font-medium\"\n                >\n                  {syncingFitbit ? 'Syncing...' : 'Sync Data Now'}\n                </button>\n                <button\n                  onClick={handleDisconnectFitbit}\n                  disabled={fitbitLoading}\n                  className=\"px-4 py-2 border border-red-300 dark:border-red-700 text-red-600 dark:text-red-400 rounded-lg hover:bg-red-50 dark:hover:bg-red-900/20 transition-colors disabled:opacity-50 disabled:cursor-not-allowed font-medium\"\n                >\n                  Disconnect\n                </button>\n              </div>\n\n              {/* Developer Demo Data Section */}\n              <div className=\"mt-4 pt-4 border-t border-gray-200 dark:border-gray-700\">\n                <p className=\"text-xs text-gray-500 dark:text-gray-400 mb-2\">Developer Tools:</p>\n                <div className=\"flex gap-2\">\n                  <button\n                    onClick={handleLoadDemoData}\n                    disabled={loadingDemo}\n                    className=\"flex-1 px-3 py-1.5 text-xs bg-blue-100 dark:bg-blue-900/30 text-blue-700 dark:text-blue-300 rounded-md hover:bg-blue-200 dark:hover:bg-blue-900/50 transition-colors disabled:opacity-50 disabled:cursor-not-allowed font-medium\"\n                  >\n                    {loadingDemo ? 'Loading...' : 'Load Demo Data'}\n                  </button>\n                  <button\n                    onClick={handleClearDemoData}\n                    disabled={clearingDemo}\n                    className=\"flex-1 px-3 py-1.5 text-xs bg-orange-100 dark:bg-orange-900/30 text-orange-700 dark:text-orange-300 rounded-md hover:bg-orange-200 dark:hover:bg-orange-900/50 transition-colors disabled:opacity-50 disabled:cursor-not-allowed font-medium\"\n                  >\n                    {clearingDemo ? 'Clearing...' : 'Clear Demo Data'}\n                  </button>\n                </div>\n              </div>\n\n              <FitbitCharts rangeDays={30} />\n              <FitbitCorrelations rangeDays={30} />\n            </div>\n          ) : (\n            <div className=\"space-y-4\">\n              <div className=\"p-4 bg-gray-50 dark:bg-gray-700/50 border border-gray-200 dark:border-gray-700 rounded-lg\">\n                <p className=\"text-sm text-gray-600 dark:text-gray-400 mb-4\">\n                  Connect your Fitbit account to automatically sync your activity, heart rate, sleep, and weight data.\n                </p>\n                <button\n                  onClick={handleConnectFitbit}\n                  disabled={fitbitLoading}\n                  className=\"w-full sm:w-auto px-4 py-2 bg-helfi-green text-white rounded-lg hover:bg-green-600 transition-colors disabled:opacity-50 disabled:cursor-not-allowed font-medium flex items-center justify-center gap-2\"\n                >\n                  {fitbitLoading ? (\n                    <>\n                      <svg className=\"animate-spin h-5 w-5\" xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\">\n                        <circle className=\"opacity-25\" cx=\"12\" cy=\"12\" r=\"10\" stroke=\"currentColor\" strokeWidth=\"4\"></circle>\n                        <path className=\"opacity-75\" fill=\"currentColor\" d=\"M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z\"></path>\n                      </svg>\n                      Connecting...\n                    </>\n                  ) : (\n                    <>\n                      <svg className=\"w-5 h-5\" fill=\"currentColor\" viewBox=\"0 0 24 24\">\n                        <path d=\"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z\"/>\n                      </svg>\n                      Connect Fitbit\n                    </>\n                  )}\n                </button>\n              </div>\n\n              {adminToken && (\n                <div className=\"mt-4 pt-4 border-t border-gray-200 dark:border-gray-700\">\n                  <p className=\"text-xs text-gray-500 dark:text-gray-400 mb-2\">Developer Tools (Test UI without connecting):</p>\n                  <div className=\"flex gap-2\">\n                    <button\n                      onClick={handleLoadDemoData}\n                      disabled={loadingDemo}\n                      className=\"flex-1 px-3 py-1.5 text-xs bg-blue-100 dark:bg-blue-900/30 text-blue-700 dark:text-blue-300 rounded-md hover:bg-blue-200 dark:hover:bg-blue-900/50 transition-colors disabled:opacity-50 disabled:cursor-not-allowed font-medium\"\n                    >\n                      {loadingDemo ? 'Loading...' : 'Load Demo Data'}\n                    </button>\n                    <button\n                      onClick={handleClearDemoData}\n                      disabled={clearingDemo}\n                      className=\"flex-1 px-3 py-1.5 text-xs bg-orange-100 dark:bg-orange-900/30 text-orange-700 dark:text-orange-300 rounded-md hover:bg-orange-200 dark:hover:bg-orange-900/50 transition-colors disabled:opacity-50 disabled:cursor-not-allowed font-medium\"\n                    >\n                      {clearingDemo ? 'Clearing...' : 'Clear Demo Data'}\n                    </button>\n                  </div>\n                  <p className=\"text-xs text-gray-400 dark:text-gray-500 mt-2\">\n                    üí° Tip: Load demo data to see how Fitbit data displays without connecting a real account.\n                  </p>\n                </div>\n              )}\n            </div>\n          )}\n        </div>\n\n        {/* Garmin Device Card */}\n        <div className=\"bg-white dark:bg-gray-800 rounded-lg shadow-sm p-6 mb-6\">\n          <div className=\"flex items-start justify-between mb-4\">\n            <div className=\"flex items-center gap-4\">\n              <Image src=\"/brands/garmin-connect.jpg\" alt=\"Garmin Connect\" width={44} height={44} className=\"rounded-lg\" />\n              <div>\n                <h2 className=\"text-xl font-bold text-gray-900 dark:text-white mb-1\">Garmin Connect</h2>\n                <p className=\"text-sm text-gray-600 dark:text-gray-400\">\n                  Connect Garmin Connect to start receiving wellness data via secure webhooks.\n                </p>\n              </div>\n            </div>\n            {garminConnected && (\n              <div className=\"flex items-center gap-2\">\n                <div className=\"w-2 h-2 bg-green-500 rounded-full\"></div>\n                <span className=\"text-sm text-green-600 dark:text-green-400 font-medium\">Connected</span>\n              </div>\n            )}\n          </div>\n\n          {garminPopupOpen && garminConnectEnabled && (\n            <div className=\"mb-4 p-4 bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg\">\n              <div className=\"flex items-start gap-3\">\n                <div className=\"flex-shrink-0\">\n                  {garminCheckingStatus ? (\n                    <svg className=\"animate-spin h-5 w-5 text-blue-600 dark:text-blue-400\" xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\">\n                      <circle className=\"opacity-25\" cx=\"12\" cy=\"12\" r=\"10\" stroke=\"currentColor\" strokeWidth=\"4\"></circle>\n                      <path className=\"opacity-75\" fill=\"currentColor\" d=\"M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z\"></path>\n                    </svg>\n                  ) : (\n                    <div className=\"w-5 h-5 bg-blue-600 dark:bg-blue-400 rounded-full\"></div>\n                  )}\n                </div>\n                <div className=\"flex-1\">\n                  <p className=\"text-sm font-medium text-blue-900 dark:text-blue-100 mb-1\">\n                    {garminCheckingStatus ? 'Checking connection status...' : 'Popup window is open'}\n                  </p>\n                  <p className=\"text-xs text-blue-700 dark:text-blue-300 mb-3\">\n                    Complete the Garmin login in the popup window. If it gets stuck, click below to close it and re-check.\n                  </p>\n                  <button\n                    onClick={handleCloseGarminPopupAndCheck}\n                    disabled={garminCheckingStatus}\n                    className=\"text-xs px-3 py-1.5 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed\"\n                  >\n                    {garminCheckingStatus ? 'Checking...' : 'Close Popup & Check Status'}\n                  </button>\n                </div>\n              </div>\n            </div>\n          )}\n\n          {!garminConnectEnabled ? (\n            <div className=\"space-y-4\">\n              <div className=\"p-4 bg-yellow-50 dark:bg-yellow-900/20 border border-yellow-200 dark:border-yellow-800 rounded-lg\">\n                <p className=\"text-sm text-gray-700 dark:text-gray-300\">\n                  Garmin Connect access is temporarily unavailable while production approval is pending.\n                  You can register interest and we‚Äôll notify you when it‚Äôs live.\n                </p>\n              </div>\n              <button\n                onClick={() => {\n                  const next = { ...deviceInterest, garmin: !deviceInterest.garmin }\n                  saveDeviceInterest(next)\n                }}\n                disabled={savingInterest}\n                className={`w-full sm:w-auto px-4 py-2 rounded-lg font-medium transition-colors ${\n                  deviceInterest.garmin\n                    ? 'bg-emerald-600 text-white'\n                    : 'bg-gray-100 text-gray-700 hover:bg-gray-200'\n                } ${savingInterest ? 'opacity-60 cursor-not-allowed' : ''}`}\n              >\n                {deviceInterest.garmin ? 'Interested ‚úì' : \"I'm interested\"}\n              </button>\n            </div>\n          ) : garminConnected ? (\n            <div className=\"space-y-4\">\n              <div className=\"p-4 bg-green-50 dark:bg-green-900/20 border border-green-200 dark:border-green-800 rounded-lg\">\n                <p className=\"text-sm text-gray-700 dark:text-gray-300\">\n                  Garmin Connect is connected. Data will be delivered automatically via webhooks and logged for processing.\n                </p>\n              </div>\n\n              <div className=\"flex gap-3\">\n                <button\n                  onClick={handleDisconnectGarmin}\n                  disabled={garminLoading}\n                  className=\"px-4 py-2 border border-red-300 dark:border-red-700 text-red-600 dark:text-red-400 rounded-lg hover:bg-red-50 dark:hover:bg-red-900/20 transition-colors disabled:opacity-50 disabled:cursor-not-allowed font-medium\"\n                >\n                  Disconnect\n                </button>\n              </div>\n\n              <p className=\"text-xs text-gray-500 dark:text-gray-400\">\n                Webhook endpoint: <span className=\"font-mono\">/api/garmin/webhook</span> (auto-registered). Data is stored in raw form for downstream mapping.\n              </p>\n            </div>\n          ) : (\n            <div className=\"space-y-3\">\n              <div className=\"p-4 bg-gray-50 dark:bg-gray-700/50 border border-gray-200 dark:border-gray-700 rounded-lg\">\n                <p className=\"text-sm text-gray-600 dark:text-gray-400 mb-3\">\n                  Connect your Garmin Connect account to allow Helfi to receive daily, sleep, and activity data directly from the Garmin Health API.\n                </p>\n                <button\n                  onClick={handleConnectGarmin}\n                  disabled={garminLoading}\n                  className=\"w-full sm:w-auto px-4 py-2 bg-helfi-green text-white rounded-lg hover:bg-green-600 transition-colors disabled:opacity-50 disabled:cursor-not-allowed font-medium flex items-center justify-center gap-2\"\n                >\n                  {garminLoading ? (\n                    <>\n                      <svg className=\"animate-spin h-5 w-5\" xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\">\n                        <circle className=\"opacity-25\" cx=\"12\" cy=\"12\" r=\"10\" stroke=\"currentColor\" strokeWidth=\"4\"></circle>\n                        <path className=\"opacity-75\" fill=\"currentColor\" d=\"M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z\"></path>\n                      </svg>\n                      Connecting...\n                    </>\n                  ) : (\n                    <>\n                      <svg className=\"w-5 h-5\" fill=\"currentColor\" viewBox=\"0 0 24 24\">\n                        <path d=\"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z\"/>\n                      </svg>\n                      Connect Garmin Connect\n                    </>\n                  )}\n                </button>\n              </div>\n              <p className=\"text-xs text-gray-500 dark:text-gray-400\">\n                You&apos;ll be redirected to Garmin Connect to approve access. We keep the popup open so you can continue browsing while you authorize.\n              </p>\n            </div>\n          )}\n\n          <p className=\"mt-4 text-xs text-gray-500 dark:text-gray-400\">\n            Garmin and the Garmin logo are trademarks of Garmin Ltd. or its subsidiaries.\n          </p>\n        </div>\n\n        {/* Coming Soon Devices */}\n        <div className=\"bg-white dark:bg-gray-800 rounded-lg shadow-sm p-6\">\n          <h3 className=\"text-lg font-semibold text-gray-900 dark:text-white mb-4\">Coming Soon</h3>\n          <div className=\"grid grid-cols-2 md:grid-cols-4 gap-4\">\n            {[\n              { icon: '‚åö', name: 'Apple Watch' },\n              { icon: 'üì±', name: 'Samsung Health' },\n              { icon: 'üíç', name: 'Oura Ring' },\n              { icon: 'üèÉ', name: 'Google Fit' },\n            ].map((device) => (\n              <div key={device.name} className=\"text-center p-4 border border-gray-200 dark:border-gray-700 rounded-lg opacity-50\">\n                <div className=\"text-3xl mb-2\">{device.icon}</div>\n                <div className=\"text-sm font-medium text-gray-600 dark:text-gray-400\">{device.name}</div>\n              </div>\n            ))}\n          </div>\n        </div>\n      </main>\n\n      {/* Mobile Bottom Navigation */}\n      <nav className=\"md:hidden fixed bottom-0 left-0 right-0 bg-white dark:bg-gray-800 border-t border-gray-200 dark:border-gray-700 px-4 py-2 z-40\">\n        <div className=\"flex items-center justify-around\">\n          <Link href=\"/dashboard\" className=\"flex flex-col items-center py-2 px-1 min-w-0 flex-1\">\n            <div className=\"text-gray-400\">\n              <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6\" />\n              </svg>\n            </div>\n            <span className=\"text-xs text-gray-400 mt-1 font-medium truncate\">Dashboard</span>\n          </Link>\n\n          <Link href=\"/insights\" className=\"flex flex-col items-center py-2 px-1 min-w-0 flex-1\">\n            <div className=\"text-gray-400\">\n              <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z\" />\n              </svg>\n            </div>\n            <span className=\"text-xs text-gray-400 mt-1 font-medium truncate\">Insights</span>\n          </Link>\n\n          <Link href=\"/food\" className=\"flex flex-col items-center py-2 px-1 min-w-0 flex-1\">\n            <div className=\"text-gray-400\">\n              <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10\" />\n              </svg>\n            </div>\n            <span className=\"text-xs text-gray-400 mt-1 font-medium truncate\">Food</span>\n          </Link>\n\n          <MobileMoreMenu />\n\n          <Link href=\"/settings\" className=\"flex flex-col items-center py-2 px-1 min-w-0 flex-1\">\n            <div className=\"text-gray-400\">\n              <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z\" />\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M15 12a3 3 0 11-6 0 3 3 0 016 0z\" />\n              </svg>\n            </div>\n            <span className=\"text-xs text-gray-400 mt-1 font-medium truncate\">Settings</span>\n          </Link>\n        </div>\n      </nav>\n    </div>\n  )\n}\n","truncated":false,"size":40252},{"path":"app/faq/page.tsx","content":"'use client'\n\nimport React from 'react'\nimport Image from 'next/image'\nimport Link from 'next/link'\nimport { useSession } from 'next-auth/react'\n\nexport default function FAQPage() {\n  const { data: session } = useSession()\n\n  const faqs = [\n    {\n      category: \"Getting Started\",\n      questions: [\n        {\n          q: \"How do I get started with Helfi?\",\n          a: \"Simply sign up for an account and complete our comprehensive onboarding process. We'll guide you through setting up your health profile, including your physical metrics, health goals, medications, and supplements. This helps our AI provide personalized recommendations from day one.\"\n        },\n        {\n          q: \"What information do I need to provide during onboarding?\",\n          a: \"You'll provide basic information like height, weight, age, activity level, health goals, current medications, supplements, and any dietary preferences or restrictions. All information is kept secure and private.\"\n        },\n        {\n          q: \"How long does it take to see results?\",\n          a: \"You'll start seeing personalized insights immediately after completing your profile. More detailed patterns and recommendations develop as you track your food and health metrics over 1-2 weeks.\"\n        }\n      ]\n    },\n    {\n      category: \"Food Tracking & AI Analysis\",\n      questions: [\n        {\n          q: \"How does the AI food analysis work?\",\n          a: \"Simply take a photo of your meal and our AI will analyze the food items, estimate portions, calculate nutritional content, and provide personalized recommendations based on your health goals and dietary needs.\"\n        },\n        {\n          q: \"How accurate is the nutritional analysis?\",\n          a: \"Our AI uses advanced computer vision and a comprehensive nutritional database to provide highly accurate estimates. While not 100% perfect, it's significantly more accurate and convenient than manual logging.\"\n        },\n        {\n          q: \"Can I track meals without photos?\",\n          a: \"Yes! You can manually log meals, search our food database, or use voice notes. However, photo analysis is the most convenient and accurate method.\"\n        },\n        {\n          q: \"What if the AI gets something wrong?\",\n          a: \"You can always edit or correct the AI's analysis. Premium users get reanalysis credits to have meals re-analyzed for better accuracy.\"\n        }\n      ]\n    },\n    {\n      category: \"Premium Features & Billing\",\n      questions: [\n        {\n          q: \"What's included in the Premium plan?\",\n          a: \"Premium includes 30 daily AI food analyses, 30 reanalysis credits per day, 30 medical image analyses per day, advanced insights, priority support, and export capabilities. It's $20/month.\"\n        },\n        {\n          q: \"What happens if I exceed my daily limits?\",\n          a: \"You can purchase additional credits: $5 for 100 credits or $10 for 150 credits. Credits don't expire and can be used for any type of analysis.\"\n        },\n        {\n          q: \"Can I cancel my subscription anytime?\",\n          a: \"Yes, you can cancel anytime from your billing settings. You'll continue to have Premium access until the end of your billing period.\"\n        },\n        {\n          q: \"Is there a free trial?\",\n          a: \"No, we no longer offer free trials. However, you can try each AI feature once for free. After that, you'll need a subscription or credits to continue using AI features. Non-AI features remain free for all users.\"\n        }\n      ]\n    },\n    {\n      category: \"Privacy & Data Security\",\n      questions: [\n        {\n          q: \"How is my health data protected?\",\n          a: \"We use enterprise-grade encryption, secure cloud storage, and strict access controls. Your data is never sold or shared with third parties. We comply with healthcare privacy standards.\"\n        },\n        {\n          q: \"Can I delete my data?\",\n          a: \"Yes, you can delete your account and all associated data at any time from your account settings. We provide data export options before deletion.\"\n        },\n        {\n          q: \"Where is my data stored?\",\n          a: \"Your data is stored securely in the cloud with automatic backups and redundancy to ensure it's never lost while maintaining the highest security standards.\"\n        }\n      ]\n    },\n    {\n      category: \"Technical Support\",\n      questions: [\n        {\n          q: \"What devices does Helfi work on?\",\n          a: \"Helfi works on any device with a web browser - smartphones, tablets, laptops, and desktops. We're optimized for mobile use with responsive design.\"\n        },\n        {\n          q: \"Do I need to download an app?\",\n          a: \"No, Helfi is a web application that works in your browser. You can add it to your home screen for an app-like experience.\"\n        },\n        {\n          q: \"What if I'm having technical issues?\",\n          a: \"Contact our support team through the support form, and we'll help resolve any issues quickly. Premium users get priority support.\"\n        },\n        {\n          q: \"Can I use Helfi offline?\",\n          a: \"Some features work offline, but AI analysis and syncing require an internet connection. We're working on enhanced offline capabilities.\"\n        }\n      ]\n    }\n  ]\n\n  return (\n    <div className=\"min-h-screen bg-gray-50\">\n      {/* Navigation Header */}\n      <nav className=\"bg-white border-b border-gray-200 px-4 py-3\">\n        <div className=\"max-w-7xl mx-auto flex justify-between items-center\">\n          {/* Logo on the left */}\n          <div className=\"flex items-center\">\n            <Link href=\"/\" className=\"w-16 h-16 md:w-20 md:h-20 cursor-pointer hover:opacity-80 transition-opacity\">\n              <Image\n                src=\"/mobile-assets/LOGOS/helfi-01-01.png\"\n                alt=\"Helfi Logo\"\n                width={80}\n                height={80}\n                className=\"w-full h-full object-contain\"\n                priority\n              />\n            </Link>\n          </div>\n          \n          {/* Navigation Links */}\n          <div className=\"flex items-center space-x-4\">\n            {session ? (\n              <Link \n                href=\"/dashboard\" \n                className=\"bg-helfi-green text-white px-4 py-2 rounded-lg hover:bg-helfi-green/90 transition-colors font-medium\"\n              >\n                Back to Dashboard\n              </Link>\n            ) : (\n              <Link \n                href=\"/\" \n                className=\"bg-helfi-green text-white px-4 py-2 rounded-lg hover:bg-helfi-green/90 transition-colors font-medium\"\n              >\n                Back to Home\n              </Link>\n            )}\n          </div>\n        </div>\n      </nav>\n\n      {/* Page Title */}\n      <div className=\"bg-white border-b border-gray-200 px-4 py-4\">\n        <div className=\"max-w-7xl mx-auto text-center\">\n          <h1 className=\"text-lg md:text-xl font-semibold text-gray-900\">Frequently Asked Questions</h1>\n          <p className=\"text-sm text-gray-500 hidden sm:block\">Find answers to common questions about Helfi</p>\n        </div>\n      </div>\n\n      {/* Main Content */}\n      <div className=\"max-w-4xl mx-auto px-4 py-8\">\n        <div className=\"bg-white rounded-lg shadow-sm p-6\">\n          <div className=\"text-center mb-8\">\n            <h2 className=\"text-2xl font-bold text-gray-900 mb-2\">How can we help you?</h2>\n            <p className=\"text-gray-600\">\n              Can't find what you're looking for? <Link href=\"/support\" className=\"text-helfi-green hover:text-helfi-green/80 font-medium\">Contact our support team</Link>\n            </p>\n          </div>\n\n          <div className=\"space-y-8\">\n            {faqs.map((category, categoryIndex) => (\n              <div key={categoryIndex}>\n                <h3 className=\"text-xl font-semibold text-gray-900 mb-4 pb-2 border-b border-gray-200\">\n                  {category.category}\n                </h3>\n                <div className=\"space-y-4\">\n                  {category.questions.map((faq, faqIndex) => (\n                    <div key={faqIndex} className=\"border border-gray-200 rounded-lg p-4 hover:border-helfi-green/50 transition-colors\">\n                      <h4 className=\"font-medium text-gray-900 mb-2\">{faq.q}</h4>\n                      <p className=\"text-gray-600 text-sm leading-relaxed\">{faq.a}</p>\n                    </div>\n                  ))}\n                </div>\n              </div>\n            ))}\n          </div>\n\n          {/* Contact Support CTA */}\n          <div className=\"mt-12 text-center bg-gray-50 rounded-lg p-6\">\n            <h3 className=\"text-lg font-semibold text-gray-900 mb-2\">Still have questions?</h3>\n            <p className=\"text-gray-600 mb-4\">Our support team is here to help you succeed with your health journey.</p>\n            <Link \n              href=\"/support\" \n              className=\"inline-block bg-helfi-green text-white px-6 py-3 rounded-lg hover:bg-helfi-green/90 transition-colors font-medium\"\n            >\n              Contact Support\n            </Link>\n          </div>\n        </div>\n      </div>\n    </div>\n  )\n} ","truncated":false,"size":9132},{"path":"app/food/add-ingredient/AddIngredientClient.tsx","content":"'use client'\n\nimport { useEffect, useMemo, useRef, useState } from 'react'\nimport { useRouter, useSearchParams } from 'next/navigation'\nimport UsageMeter from '@/components/UsageMeter'\n\ntype MealCategory = 'breakfast' | 'lunch' | 'dinner' | 'snacks' | 'uncategorized'\ntype SearchKind = 'packaged' | 'single'\n\ntype NormalizedFoodItem = {\n  source: 'openfoodfacts' | 'usda' | 'fatsecret'\n  id: string\n  name: string\n  brand?: string | null\n  serving_size?: string | null\n  calories?: number | null\n  protein_g?: number | null\n  carbs_g?: number | null\n  fat_g?: number | null\n  fiber_g?: number | null\n  sugar_g?: number | null\n}\n\nconst CATEGORY_LABELS: Record<MealCategory, string> = {\n  breakfast: 'Breakfast',\n  lunch: 'Lunch',\n  dinner: 'Dinner',\n  snacks: 'Snacks',\n  uncategorized: 'Other',\n}\n\nconst normalizeCategory = (raw: any): MealCategory => {\n  const v = typeof raw === 'string' ? raw.toLowerCase() : ''\n  if (v.includes('breakfast')) return 'breakfast'\n  if (v.includes('lunch')) return 'lunch'\n  if (v.includes('dinner')) return 'dinner'\n  if (v.includes('snack')) return 'snacks'\n  if (v.includes('uncat') || v.includes('other')) return 'uncategorized'\n  return 'uncategorized'\n}\n\nconst buildTodayIso = () => {\n  const d = new Date()\n  const y = d.getFullYear()\n  const m = String(d.getMonth() + 1).padStart(2, '0')\n  const day = String(d.getDate()).padStart(2, '0')\n  return `${y}-${m}-${day}`\n}\n\nconst safeNumber = (n: any) => (typeof n === 'number' && Number.isFinite(n) ? n : null)\nconst round3 = (n: number) => Math.round(n * 1000) / 1000\n\nconst alignTimestampToLocalDate = (iso: string, localDate: string) => {\n  try {\n    if (!localDate || localDate.length < 8) return iso\n    const d = new Date(iso)\n    if (Number.isNaN(d.getTime())) return iso\n    const time = d.toISOString().slice(11) // HH:mm:ss.sssZ\n    return `${localDate}T${time}`\n  } catch {\n    return iso\n  }\n}\n\nconst buildDefaultMealName = (names: string[]) => {\n  const cleaned = names.map((n) => String(n || '').trim()).filter(Boolean)\n  if (cleaned.length === 0) return 'Meal'\n  const head = cleaned.slice(0, 3).join(', ')\n  return cleaned.length > 3 ? `${head}‚Ä¶` : head\n}\n\nconst triggerHaptic = (duration = 10) => {\n  try {\n    if (typeof window === 'undefined') return\n    const reduced = window.matchMedia('(prefers-reduced-motion: reduce)')?.matches\n    const pref = localStorage.getItem('hapticsEnabled')\n    const enabled = pref === null ? true : pref === 'true'\n    if (enabled && !reduced && 'vibrate' in navigator) (navigator as any).vibrate(duration)\n  } catch {}\n}\n\nexport default function AddIngredientClient() {\n  const router = useRouter()\n  const searchParams = useSearchParams()\n\n  const selectedDate = searchParams.get('date') || buildTodayIso()\n  const category = normalizeCategory(searchParams.get('category'))\n\n  const [query, setQuery] = useState('')\n  const [kind, setKind] = useState<SearchKind>('packaged')\n  const [loading, setLoading] = useState(false)\n  const [addingId, setAddingId] = useState<string | null>(null)\n  const [error, setError] = useState<string | null>(null)\n  const [results, setResults] = useState<NormalizedFoodItem[]>([])\n  const [photoLoading, setPhotoLoading] = useState(false)\n  const [photoPreviewUrl, setPhotoPreviewUrl] = useState<string | null>(null)\n\n  const abortRef = useRef<AbortController | null>(null)\n  const seqRef = useRef(0)\n  const photoInputRef = useRef<HTMLInputElement | null>(null)\n\n  useEffect(() => {\n    return () => {\n      try {\n        if (photoPreviewUrl) URL.revokeObjectURL(photoPreviewUrl)\n      } catch {}\n    }\n  }, [photoPreviewUrl])\n\n  useEffect(() => {\n    // Keep /food on the same date when the user returns.\n    try {\n      const raw = sessionStorage.getItem('foodDiary:warmState')\n      const parsed = raw ? JSON.parse(raw) : {}\n      const next = { ...(parsed || {}), selectedDate }\n      sessionStorage.setItem('foodDiary:warmState', JSON.stringify(next))\n    } catch {}\n  }, [selectedDate])\n\n  const categoryLabel = CATEGORY_LABELS[category] || 'Other'\n\n  const runSearch = async (qOverride?: string, kindOverride?: SearchKind) => {\n    const q = String(qOverride ?? query).trim()\n    const k = kindOverride ?? kind\n    if (!q) {\n      setError('Please type a food name to search.')\n      return\n    }\n\n    setError(null)\n    setLoading(true)\n    setResults([])\n\n    try {\n      abortRef.current?.abort()\n    } catch {}\n    const controller = new AbortController()\n    abortRef.current = controller\n    const seq = ++seqRef.current\n\n    try {\n      const params = new URLSearchParams({\n        source: 'auto',\n        q,\n        kind: k,\n        limit: '20',\n      })\n      const res = await fetch(`/api/food-data?${params.toString()}`, { method: 'GET', signal: controller.signal })\n      const data = await res.json().catch(() => ({}))\n      if (!res.ok) {\n        const msg =\n          typeof data?.error === 'string'\n            ? data.error\n            : typeof data?.message === 'string'\n            ? data.message\n            : 'Search failed. Please try again.'\n        setError(msg)\n        return\n      }\n      if (seqRef.current !== seq) return\n      setResults(Array.isArray(data?.items) ? data.items : [])\n    } catch (e: any) {\n      if (e?.name === 'AbortError') return\n      setError('Search failed. Please try again.')\n    } finally {\n      if (seqRef.current === seq) setLoading(false)\n    }\n  }\n\n  const addFoodEntry = async (payload: any) => {\n    const res = await fetch('/api/food-log', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(payload),\n    })\n    const data = await res.json().catch(() => ({}))\n    if (!res.ok) {\n      const msg =\n        typeof data?.error === 'string'\n          ? data.error\n          : typeof data?.message === 'string'\n          ? data.message\n          : 'Saving failed. Please try again.'\n      throw new Error(msg)\n    }\n    return data\n  }\n\n  const addFromSearchResult = async (r: NormalizedFoodItem) => {\n    if (!r) return\n    setError(null)\n    triggerHaptic(10)\n    setAddingId(`${r.source}:${r.id}`)\n    try {\n      const item = {\n        name: String(r.name || 'Food'),\n        brand: r.brand ?? null,\n        serving_size: String(r.serving_size || '1 serving'),\n        calories: safeNumber(r.calories),\n        protein_g: safeNumber(r.protein_g),\n        carbs_g: safeNumber(r.carbs_g),\n        fat_g: safeNumber(r.fat_g),\n        fiber_g: safeNumber(r.fiber_g),\n        sugar_g: safeNumber(r.sugar_g),\n        servings: 1,\n      }\n\n      const nutrition = {\n        calories: Math.round(Number(item.calories || 0)),\n        protein: round3(Number(item.protein_g || 0)),\n        carbs: round3(Number(item.carbs_g || 0)),\n        fat: round3(Number(item.fat_g || 0)),\n        fiber: round3(Number(item.fiber_g || 0)),\n        sugar: round3(Number(item.sugar_g || 0)),\n      }\n\n      const createdAtIso = alignTimestampToLocalDate(new Date().toISOString(), selectedDate)\n\n      const payload = {\n        description: item.name,\n        nutrition,\n        imageUrl: null,\n        items: [item],\n        localDate: selectedDate,\n        meal: category,\n        category,\n        createdAt: createdAtIso,\n      }\n\n      const created = await addFoodEntry(payload)\n      try {\n        const createdId = typeof created?.id === 'string' ? created.id : null\n        if (createdId) {\n          sessionStorage.setItem(\n            'foodDiary:scrollToEntry',\n            JSON.stringify({ dbId: createdId, localDate: selectedDate, category }),\n          )\n        }\n      } catch {}\n      router.push('/food')\n    } catch (e: any) {\n      setError(e?.message || 'Could not add that ingredient. Please try again.')\n    } finally {\n      setAddingId(null)\n    }\n  }\n\n  const addByPhoto = async (file: File) => {\n    if (!file) return\n    setError(null)\n    triggerHaptic(10)\n    setPhotoLoading(true)\n    try {\n      try {\n        if (photoPreviewUrl) URL.revokeObjectURL(photoPreviewUrl)\n      } catch {}\n      try {\n        setPhotoPreviewUrl(URL.createObjectURL(file))\n      } catch {}\n    } catch {}\n    try {\n      const fd = new FormData()\n      fd.append('image', file)\n      fd.append('analysisMode', 'meal')\n      const res = await fetch('/api/analyze-food', { method: 'POST', body: fd })\n      const data = await res.json().catch(() => ({}))\n      if (!res.ok) {\n        const msg =\n          typeof data?.message === 'string'\n            ? data.message\n            : typeof data?.error === 'string'\n            ? data.error\n            : 'Photo analysis failed. Please try again.'\n        setError(msg)\n        return\n      }\n\n      const items = Array.isArray(data?.items) ? data.items : []\n      const total = data?.total || data?.nutrition || null\n\n      if (!items.length) {\n        setError('No ingredients were detected from that photo. Try a clearer photo or use search.')\n        return\n      }\n\n      const createdAtIso = alignTimestampToLocalDate(new Date().toISOString(), selectedDate)\n      const title = buildDefaultMealName(items.map((it: any) => it?.name || it?.food || 'Food'))\n\n      const nutrition = {\n        calories: Math.round(Number(total?.calories || 0)),\n        protein: round3(Number(total?.protein ?? total?.protein_g ?? 0)),\n        carbs: round3(Number(total?.carbs ?? total?.carbs_g ?? 0)),\n        fat: round3(Number(total?.fat ?? total?.fat_g ?? 0)),\n        fiber: round3(Number(total?.fiber ?? total?.fiber_g ?? 0)),\n        sugar: round3(Number(total?.sugar ?? total?.sugar_g ?? 0)),\n      }\n\n      const payload = {\n        description: title,\n        nutrition,\n        imageUrl: null,\n        items,\n        localDate: selectedDate,\n        meal: category,\n        category,\n        createdAt: createdAtIso,\n      }\n\n      const created = await addFoodEntry(payload)\n      try {\n        const createdId = typeof created?.id === 'string' ? created.id : null\n        if (createdId) {\n          sessionStorage.setItem(\n            'foodDiary:scrollToEntry',\n            JSON.stringify({ dbId: createdId, localDate: selectedDate, category }),\n          )\n        }\n      } catch {}\n      try {\n        window.dispatchEvent(new Event('credits:refresh'))\n      } catch {}\n      router.push('/food')\n    } catch (e: any) {\n      setError(e?.message || 'Photo analysis failed. Please try again.')\n    } finally {\n      setPhotoLoading(false)\n      try {\n        if (photoInputRef.current) photoInputRef.current.value = ''\n      } catch {}\n    }\n  }\n\n  const headerSubtitle = useMemo(() => `Add to ${categoryLabel}`, [categoryLabel])\n\n  return (\n    <div className=\"min-h-screen bg-white\">\n      <div className=\"sticky top-0 z-10 bg-white border-b border-gray-200\">\n        <div className=\"w-full max-w-3xl mx-auto px-4 py-3 flex items-center justify-between gap-3\">\n          <button\n            type=\"button\"\n            onClick={() => router.push('/food')}\n            className=\"p-2 rounded-full hover:bg-gray-100\"\n            aria-label=\"Back\"\n          >\n            <span aria-hidden>‚Üê</span>\n          </button>\n          <div className=\"flex-1 text-center\">\n            <div className=\"text-lg font-semibold text-gray-900\">Add ingredient</div>\n            <div className=\"text-xs text-gray-500\">{headerSubtitle}</div>\n          </div>\n          <button\n            type=\"button\"\n            onClick={() => router.push('/food')}\n            className=\"p-2 rounded-full hover:bg-gray-100\"\n            aria-label=\"Close\"\n          >\n            <span aria-hidden>‚úï</span>\n          </button>\n        </div>\n      </div>\n\n      <div className=\"px-4 py-4\">\n        <div className=\"w-full max-w-3xl mx-auto space-y-4\">\n          <div className=\"rounded-2xl border border-gray-200 bg-white p-3 sm:p-4 space-y-3\">\n            <div className=\"text-sm font-semibold text-gray-900\">\n              Search foods (USDA + FatSecret + OpenFoodFacts)\n            </div>\n\n            <div className=\"flex gap-2\">\n              <input\n                value={query}\n                onChange={(e) => setQuery(e.target.value)}\n                placeholder=\"e.g. pizza\"\n                className=\"flex-1 px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-emerald-500 focus:border-emerald-500\"\n              />\n              <button\n                type=\"button\"\n                disabled={loading || query.trim().length === 0}\n                onClick={() => runSearch()}\n                className=\"px-4 py-2 rounded-lg bg-slate-900 text-white text-sm font-semibold disabled:opacity-60\"\n              >\n                {loading ? 'Searching‚Ä¶' : 'Search'}\n              </button>\n            </div>\n\n            <div className=\"grid grid-cols-2 gap-2\">\n              <button\n                type=\"button\"\n                disabled={loading}\n                onClick={() => {\n                  setKind('packaged')\n                  if (query.trim().length >= 2) runSearch(query, 'packaged')\n                }}\n                className={`px-3 py-2 rounded-lg border text-sm font-semibold ${\n                  kind === 'packaged' ? 'bg-emerald-600 text-white border-emerald-600' : 'bg-white text-gray-700 border-gray-200'\n                } disabled:opacity-60`}\n              >\n                Packaged\n              </button>\n              <button\n                type=\"button\"\n                disabled={loading}\n                onClick={() => {\n                  setKind('single')\n                  if (query.trim().length >= 2) runSearch(query, 'single')\n                }}\n                className={`px-3 py-2 rounded-lg border text-sm font-semibold ${\n                  kind === 'single' ? 'bg-slate-800 text-white border-slate-800' : 'bg-white text-gray-700 border-gray-200'\n                } disabled:opacity-60`}\n              >\n                Single food\n              </button>\n            </div>\n\n            {error && <div className=\"text-sm text-red-600\">{error}</div>}\n\n            {!loading && !error && results.length === 0 && query.trim() && (\n              <div className=\"text-sm text-gray-500\">No results yet. Try a different search.</div>\n            )}\n\n            {results.length > 0 && (\n              <div className=\"max-h-[60vh] overflow-y-auto space-y-2 pt-1\">\n                {results.map((r, idx) => {\n                  const id = `${r.source}:${r.id}:${idx}`\n                  const busy = addingId === `${r.source}:${r.id}`\n                  return (\n                    <div key={id} className=\"flex items-start justify-between rounded-xl border border-gray-200 px-3 py-2\">\n                      <div className=\"min-w-0\">\n                        <div className=\"text-sm font-semibold text-gray-900 truncate\">\n                          {r.name}\n                          {r.brand ? ` ‚Äì ${r.brand}` : ''}\n                        </div>\n                        <div className=\"mt-0.5 text-xs text-gray-600\">\n                          {r.serving_size ? `Serving: ${r.serving_size} ‚Ä¢ ` : ''}\n                          {r.calories != null && !Number.isNaN(Number(r.calories)) && <span>{Math.round(Number(r.calories))} kcal</span>}\n                        </div>\n                        <div className=\"mt-1 text-[11px] text-gray-400\">\n                          Source: {r.source === 'usda' ? 'USDA' : r.source === 'fatsecret' ? 'FatSecret' : 'OpenFoodFacts'}\n                        </div>\n                      </div>\n                      <button\n                        type=\"button\"\n                        disabled={busy}\n                        onClick={() => addFromSearchResult(r)}\n                        className=\"ml-3 px-3 py-2 rounded-lg bg-emerald-600 text-white text-xs font-semibold hover:bg-emerald-700 disabled:opacity-60\"\n                      >\n                        {busy ? 'Adding‚Ä¶' : 'Add'}\n                      </button>\n                    </div>\n                  )\n                })}\n              </div>\n            )}\n          </div>\n\n          <div className=\"rounded-2xl border border-gray-200 bg-white p-3 sm:p-4 space-y-2\">\n            <div className=\"text-sm font-semibold text-gray-900\">Or use AI photo analysis</div>\n            <div className=\"text-sm text-gray-600\">Take a clear photo of the food or package.</div>\n\n            <div>\n              <UsageMeter inline={true} feature=\"foodAnalysis\" />\n            </div>\n\n            {photoPreviewUrl && (\n              <div className=\"rounded-xl border border-gray-200 bg-white overflow-hidden\">\n                {/* eslint-disable-next-line @next/next/no-img-element */}\n                <img src={photoPreviewUrl} alt=\"Selected food photo\" className=\"w-full max-h-64 object-cover\" />\n              </div>\n            )}\n\n            <div className=\"flex gap-2\">\n              <button\n                type=\"button\"\n                disabled={photoLoading}\n                onClick={() => photoInputRef.current?.click()}\n                className=\"flex-1 px-3 py-2 rounded-lg bg-emerald-600 text-white text-sm font-semibold hover:bg-emerald-700 disabled:opacity-60\"\n              >\n                {photoLoading ? 'Analyzing‚Ä¶' : 'Add image'}\n              </button>\n              <button\n                type=\"button\"\n                onClick={() => {\n                  setQuery('')\n                  setResults([])\n                  setError(null)\n                }}\n                className=\"px-3 py-2 rounded-lg border border-gray-200 bg-white text-sm font-semibold text-gray-800 hover:bg-gray-50\"\n              >\n                Reset\n              </button>\n            </div>\n\n            <input\n              ref={photoInputRef}\n              type=\"file\"\n              accept=\"image/*\"\n              className=\"hidden\"\n              onChange={(e) => {\n                const f = e.target.files?.[0]\n                if (f) addByPhoto(f)\n              }}\n            />\n          </div>\n        </div>\n      </div>\n    </div>\n  )\n}\n","truncated":false,"size":17891},{"path":"app/food/add-ingredient/page.tsx","content":"import AddIngredientClient from './AddIngredientClient'\n\nexport const dynamic = 'force-dynamic'\n\nexport default function AddIngredientPage() {\n  return <AddIngredientClient />\n}\n\n","truncated":false,"size":179},{"path":"app/food/build-meal/MealBuilderClient.tsx","content":"'use client'\n\nimport { useEffect, useMemo, useRef, useState } from 'react'\nimport { useRouter, useSearchParams } from 'next/navigation'\nimport { useUserData } from '@/components/providers/UserDataProvider'\nimport UsageMeter from '@/components/UsageMeter'\n\ntype MealCategory = 'breakfast' | 'lunch' | 'dinner' | 'snacks' | 'uncategorized'\n\ntype NormalizedFoodItem = {\n  source: 'openfoodfacts' | 'usda' | 'fatsecret'\n  id: string\n  name: string\n  brand?: string | null\n  serving_size?: string | null\n  calories?: number | null\n  protein_g?: number | null\n  carbs_g?: number | null\n  fat_g?: number | null\n  fiber_g?: number | null\n  sugar_g?: number | null\n}\n\ntype BuilderUnit = 'g' | 'oz' | 'ml'\n\ntype BuilderItem = {\n  id: string\n  name: string\n  brand?: string | null\n  serving_size?: string | null\n  calories?: number | null\n  protein_g?: number | null\n  carbs_g?: number | null\n  fat_g?: number | null\n  fiber_g?: number | null\n  sugar_g?: number | null\n  servings: number\n  __baseAmount: number | null\n  __baseUnit: BuilderUnit | null\n  __amount: number\n  __amountInput: string\n  __unit: BuilderUnit | null\n}\n\nconst CATEGORY_LABELS: Record<MealCategory, string> = {\n  breakfast: 'Breakfast',\n  lunch: 'Lunch',\n  dinner: 'Dinner',\n  snacks: 'Snacks',\n  uncategorized: 'Other',\n}\n\nconst normalizeCategory = (raw: any): MealCategory => {\n  const v = typeof raw === 'string' ? raw.toLowerCase() : ''\n  if (v.includes('breakfast')) return 'breakfast'\n  if (v.includes('lunch')) return 'lunch'\n  if (v.includes('dinner')) return 'dinner'\n  if (v.includes('snack')) return 'snacks'\n  if (v.includes('uncat') || v.includes('other')) return 'uncategorized'\n  return 'uncategorized'\n}\n\nconst buildTodayIso = () => {\n  const d = new Date()\n  const y = d.getFullYear()\n  const m = String(d.getMonth() + 1).padStart(2, '0')\n  const day = String(d.getDate()).padStart(2, '0')\n  return `${y}-${m}-${day}`\n}\n\nconst alignTimestampToLocalDate = (iso: string, localDate: string) => {\n  try {\n    if (!localDate || localDate.length < 8) return iso\n    const base = new Date(iso)\n    if (Number.isNaN(base.getTime())) return iso\n    const [y, m, d] = localDate.split('-').map((v) => parseInt(v, 10))\n    if (!Number.isFinite(y) || !Number.isFinite(m) || !Number.isFinite(d)) return iso\n    const anchored = new Date(y, m - 1, d, base.getHours(), base.getMinutes(), base.getSeconds(), base.getMilliseconds())\n    return anchored.toISOString()\n  } catch {\n    return iso\n  }\n}\n\nconst toNumber = (v: any): number | null => {\n  const n = typeof v === 'number' ? v : Number(v)\n  return Number.isFinite(n) ? n : null\n}\n\nconst round3 = (n: number) => Math.round(n * 1000) / 1000\n\nconst triggerHaptic = (duration = 10) => {\n  try {\n    if (typeof window === 'undefined') return\n    const reduced = window.matchMedia('(prefers-reduced-motion: reduce)')?.matches\n    const pref = localStorage.getItem('hapticsEnabled')\n    const enabled = pref === null ? true : pref === 'true'\n    if (enabled && !reduced && 'vibrate' in navigator) (navigator as any).vibrate(duration)\n  } catch {}\n}\n\nconst parseServingBase = (servingSize: any): { amount: number | null; unit: BuilderUnit | null } => {\n  const raw = String(servingSize || '').trim()\n  if (!raw) return { amount: null, unit: null }\n\n  // Prefer values inside parentheses: \"1 breast (187 g)\"\n  const paren = raw.match(/\\(([^)]*)\\)/)\n  const target = paren?.[1] ? paren[1] : raw\n\n  const m = target.match(/(\\d+(?:\\.\\d+)?)\\s*(g|grams?|ml|mL|oz|ounces?)/i)\n  if (!m) return { amount: null, unit: null }\n  const amount = parseFloat(m[1])\n  if (!Number.isFinite(amount) || amount <= 0) return { amount: null, unit: null }\n  const unitRaw = String(m[2] || '').toLowerCase()\n\n  if (unitRaw.startsWith('g')) return { amount, unit: 'g' }\n  if (unitRaw === 'ml' || unitRaw === 'ml'.toLowerCase() || unitRaw === 'mL'.toLowerCase()) return { amount, unit: 'ml' }\n  if (unitRaw.startsWith('oz') || unitRaw.startsWith('ounce')) return { amount, unit: 'oz' }\n  return { amount: null, unit: null }\n}\n\nconst convertAmount = (amount: number, from: BuilderUnit, to: BuilderUnit) => {\n  if (!Number.isFinite(amount)) return amount\n  if (from === to) return amount\n\n  // Weight conversions\n  if (from === 'g' && to === 'oz') return amount / 28.3495\n  if (from === 'oz' && to === 'g') return amount * 28.3495\n\n  // Volume conversions (US fl oz)\n  if (from === 'ml' && to === 'oz') return amount / 29.5735\n  if (from === 'oz' && to === 'ml') return amount * 29.5735\n\n  // Cross (g <-> ml) is not safe without density; keep as-is\n  return amount\n}\n\nconst allowedUnitsForBase = (baseUnit: BuilderUnit | null): BuilderUnit[] => {\n  if (baseUnit === 'g') return ['g', 'oz']\n  if (baseUnit === 'ml') return ['ml', 'oz']\n  if (baseUnit === 'oz') return ['oz', 'ml']\n  return []\n}\n\nconst macroOrZero = (v: any) => (typeof v === 'number' && Number.isFinite(v) ? v : 0)\n\nconst computeItemTotals = (item: BuilderItem) => {\n  const servings = typeof item.servings === 'number' && Number.isFinite(item.servings) ? item.servings : 0\n  return {\n    calories: macroOrZero(item.calories) * servings,\n    protein: macroOrZero(item.protein_g) * servings,\n    carbs: macroOrZero(item.carbs_g) * servings,\n    fat: macroOrZero(item.fat_g) * servings,\n    fiber: macroOrZero(item.fiber_g) * servings,\n    sugar: macroOrZero(item.sugar_g) * servings,\n  }\n}\n\nconst sanitizeMealTitle = (v: string) => v.replace(/\\s+/g, ' ').trim()\n\nconst buildDefaultMealName = (items: BuilderItem[]) => {\n  const names = items.map((i) => String(i?.name || '').trim()).filter(Boolean)\n  if (names.length === 0) return 'Meal'\n  const head = names.slice(0, 3).join(', ')\n  return names.length > 3 ? `${head}‚Ä¶` : head\n}\n\nexport default function MealBuilderClient() {\n  const router = useRouter()\n  const searchParams = useSearchParams()\n  const { userData, updateUserData } = useUserData()\n\n  const initialDate = searchParams.get('date') || buildTodayIso()\n  const initialCategory = normalizeCategory(searchParams.get('category'))\n  const editFavoriteId = (searchParams.get('editFavoriteId') || '').trim()\n  const sourceLogId = (searchParams.get('sourceLogId') || '').trim()\n\n  const [selectedDate] = useState<string>(initialDate)\n  const [category] = useState<MealCategory>(initialCategory)\n\n  const [mealName, setMealName] = useState('')\n  const mealNameBackupRef = useRef<string>('')\n  const mealNameEditedRef = useRef(false)\n  const mealNameWasClearedOnFocusRef = useRef(false)\n\n  const [query, setQuery] = useState('')\n  const queryBackupRef = useRef<string>('')\n  const queryEditedRef = useRef(false)\n  const queryWasClearedOnFocusRef = useRef(false)\n  const [kind, setKind] = useState<'packaged' | 'single'>('packaged')\n  const [searchLoading, setSearchLoading] = useState(false)\n  const [savingMeal, setSavingMeal] = useState(false)\n  const [photoLoading, setPhotoLoading] = useState(false)\n  const [barcodeLoading, setBarcodeLoading] = useState(false)\n  const [error, setError] = useState<string | null>(null)\n  const [results, setResults] = useState<NormalizedFoodItem[]>([])\n  const [photoPreviewUrl, setPhotoPreviewUrl] = useState<string | null>(null)\n  const [loadedFavoriteId, setLoadedFavoriteId] = useState<string | null>(null)\n  const [linkedFavoriteId, setLinkedFavoriteId] = useState<string>('')\n  const [favoriteSaving, setFavoriteSaving] = useState(false)\n\n  const [items, setItems] = useState<BuilderItem[]>([])\n  const itemsRef = useRef<BuilderItem[]>([])\n  const [expandedId, setExpandedId] = useState<string | null>(null)\n  const [lastRemoved, setLastRemoved] = useState<{ item: BuilderItem; index: number } | null>(null)\n  const undoRemoveTimeoutRef = useRef<any>(null)\n\n  const abortRef = useRef<AbortController | null>(null)\n  const seqRef = useRef(0)\n  const photoInputRef = useRef<HTMLInputElement | null>(null)\n\n  const [showBarcodeScanner, setShowBarcodeScanner] = useState(false)\n  const [barcodeError, setBarcodeError] = useState<string | null>(null)\n  const [barcodeStatusHint, setBarcodeStatusHint] = useState<string>('Ready')\n  const [manualBarcode, setManualBarcode] = useState('')\n  const manualBarcodeBackupRef = useRef<string>('')\n  const manualBarcodeEditedRef = useRef(false)\n  const manualBarcodeWasClearedOnFocusRef = useRef(false)\n  const barcodeScannerRef = useRef<any>(null)\n\n  const [showFavoritesPicker, setShowFavoritesPicker] = useState(false)\n  const [favoritesSearch, setFavoritesSearch] = useState('')\n  const [favoritesActiveTab, setFavoritesActiveTab] = useState<'all' | 'favorites' | 'custom'>('all')\n  const [favoritesToast, setFavoritesToast] = useState<string | null>(null)\n\n  const busy = searchLoading || savingMeal || photoLoading || barcodeLoading\n\n  useEffect(() => {\n    itemsRef.current = items\n  }, [items])\n\n  useEffect(() => {\n    // Cleanup blob preview URLs.\n    return () => {\n      try {\n        if (photoPreviewUrl) URL.revokeObjectURL(photoPreviewUrl)\n      } catch {}\n    }\n  }, [photoPreviewUrl])\n\n  const parseFavoriteItems = (fav: any): any[] | null => {\n    const candidate = fav?.items\n    if (Array.isArray(candidate)) return candidate\n    if (typeof candidate === 'string') {\n      try {\n        const parsed = JSON.parse(candidate)\n        return Array.isArray(parsed) ? parsed : null\n      } catch {\n        return null\n      }\n    }\n    return null\n  }\n\n  const convertToBuilderItems = (rawItems: any[]): BuilderItem[] => {\n    const next: BuilderItem[] = []\n    for (const raw of Array.isArray(rawItems) ? rawItems : []) {\n      const name = String(raw?.name || raw?.food || 'Food').trim() || 'Food'\n      const brand = raw?.brand ?? null\n      const serving_size = raw?.serving_size || raw?.servingSize || raw?.serving || ''\n      const servings = toNumber(raw?.servings) ?? 1\n      const base = parseServingBase(serving_size)\n      const baseAmount = base.amount\n      const baseUnit = base.unit\n      const id = `edit:${Date.now()}:${Math.random().toString(16).slice(2)}`\n      const resolvedServings = Number.isFinite(servings) && servings > 0 ? servings : 1\n      next.push({\n        id,\n        name,\n        brand,\n        serving_size: serving_size || null,\n        calories: toNumber(raw?.calories),\n        protein_g: toNumber(raw?.protein_g),\n        carbs_g: toNumber(raw?.carbs_g),\n        fat_g: toNumber(raw?.fat_g),\n        fiber_g: toNumber(raw?.fiber_g),\n        sugar_g: toNumber(raw?.sugar_g),\n        servings: resolvedServings,\n        __baseAmount: baseAmount,\n        __baseUnit: baseUnit,\n        __amount: baseAmount && baseUnit ? round3(baseAmount * resolvedServings) : round3(resolvedServings),\n        __amountInput: String(baseAmount && baseUnit ? round3(baseAmount * resolvedServings) : round3(resolvedServings)),\n        __unit: baseUnit,\n      })\n    }\n    return next\n  }\n\n  useEffect(() => {\n    // Editing mode: load a favorite meal into the builder for edits.\n    if (!editFavoriteId) return\n    if (loadedFavoriteId === editFavoriteId) return\n    const favorites = Array.isArray((userData as any)?.favorites) ? ((userData as any).favorites as any[]) : []\n    const fav = favorites.find((f: any) => String(f?.id || '') === editFavoriteId) || null\n    if (!fav) return\n\n    const label = normalizeMealLabel(fav?.label || fav?.description || '').trim()\n    if (label) setMealName(label)\n\n    const favItems = parseFavoriteItems(fav)\n    if (favItems && favItems.length > 0) {\n      const converted = convertToBuilderItems(favItems)\n      setItems(converted)\n      setExpandedId(converted[0]?.id || null)\n    }\n\n    setLoadedFavoriteId(editFavoriteId)\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [editFavoriteId, loadedFavoriteId, userData?.favorites])\n\n  useEffect(() => {\n    // Editing mode (diary): load a FoodLog row directly when a Build-a-meal diary entry is edited.\n    if (!sourceLogId) return\n    if (editFavoriteId) return\n    if (loadedFavoriteId === `log:${sourceLogId}`) return\n\n    let cancelled = false\n    const load = async () => {\n      try {\n        const res = await fetch(`/api/food-log?id=${encodeURIComponent(sourceLogId)}`, { method: 'GET' })\n        const data = await res.json().catch(() => ({} as any))\n        if (!res.ok) return\n        const log = (data as any)?.log || null\n        if (!log) return\n\n        const linked = (() => {\n          const n = log?.nutrients\n          if (n && typeof n === 'object') {\n            const raw = (n as any).__favoriteId\n            return typeof raw === 'string' ? raw.trim() : ''\n          }\n          return ''\n        })()\n        if (!cancelled) setLinkedFavoriteId(linked)\n\n        const label = normalizeMealLabel(log?.description || log?.name || '').trim()\n        if (!cancelled && label) setMealName(label)\n\n        const rawItems = Array.isArray(log?.items) ? log.items : null\n        if (!cancelled && rawItems && rawItems.length > 0) {\n          const converted = convertToBuilderItems(rawItems)\n          setItems(converted)\n          setExpandedId(converted[0]?.id || null)\n        }\n\n        if (!cancelled) setLoadedFavoriteId(`log:${sourceLogId}`)\n      } catch {\n        // non-blocking\n      }\n    }\n    load()\n    return () => {\n      cancelled = true\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [sourceLogId, editFavoriteId, loadedFavoriteId])\n\n  useEffect(() => {\n    // Keep /food on the same date when the user returns.\n    try {\n      const raw = sessionStorage.getItem('foodDiary:warmState')\n      const parsed = raw ? JSON.parse(raw) : {}\n      const next = { ...(parsed || {}), selectedDate }\n      sessionStorage.setItem('foodDiary:warmState', JSON.stringify(next))\n    } catch {}\n  }, [selectedDate])\n\n  const mealTotals = useMemo(() => {\n    const total = { calories: 0, protein: 0, carbs: 0, fat: 0, fiber: 0, sugar: 0 }\n    for (const it of items) {\n      const t = computeItemTotals(it)\n      total.calories += t.calories\n      total.protein += t.protein\n      total.carbs += t.carbs\n      total.fat += t.fat\n      total.fiber += t.fiber\n      total.sugar += t.sugar\n    }\n    return total\n  }, [items])\n\n  const addBuilderItem = (next: BuilderItem) => {\n    setItems((prev) => [...prev, next])\n    setExpandedId(next.id)\n    try {\n      if (typeof window !== 'undefined') {\n        const id = String(next.id || '')\n        const start = Date.now()\n        const escape = (v: string) => {\n          try {\n            return (window as any).CSS?.escape ? (window as any).CSS.escape(v) : v.replace(/[\"\\\\]/g, '\\\\$&')\n          } catch {\n            return v.replace(/[\"\\\\]/g, '\\\\$&')\n          }\n        }\n        const tick = () => {\n          const el = document.querySelector(`[data-builder-item-id=\"${escape(id)}\"]`) as HTMLElement | null\n          if (el) {\n            el.scrollIntoView({ behavior: 'smooth', block: 'start' })\n            return\n          }\n          if (Date.now() - start < 1500) window.requestAnimationFrame(tick)\n        }\n        window.requestAnimationFrame(tick)\n      }\n    } catch {}\n  }\n\n  const runSearch = async () => {\n    const q = query.trim()\n    if (!q) {\n      setError('Please type a food name to search.')\n      return\n    }\n\n    setError(null)\n    setSearchLoading(true)\n    setResults([])\n\n    try {\n      abortRef.current?.abort()\n    } catch {}\n    const controller = new AbortController()\n    abortRef.current = controller\n    const seq = ++seqRef.current\n\n    try {\n      const params = new URLSearchParams({\n        source: 'auto',\n        q: q,\n        kind,\n        limit: '20',\n      })\n      const res = await fetch(`/api/food-data?${params.toString()}`, {\n        method: 'GET',\n        signal: controller.signal,\n      })\n      if (!res.ok) {\n        setError('Search failed. Please try again.')\n        return\n      }\n      const data = await res.json()\n      if (seqRef.current !== seq) return\n      setResults(Array.isArray(data?.items) ? data.items : [])\n    } catch (e: any) {\n      if (e?.name === 'AbortError') return\n      setError('Search failed. Please try again.')\n    } finally {\n      if (seqRef.current === seq) setSearchLoading(false)\n    }\n  }\n\n  const addItem = (r: NormalizedFoodItem) => {\n    triggerHaptic(10)\n    const base = parseServingBase(r?.serving_size)\n    const baseAmount = base.amount\n    const baseUnit = base.unit\n\n    const defaultAmount =\n      baseAmount && baseUnit\n        ? baseAmount\n        : 1\n\n    const id = `${r.source}:${r.id}:${Date.now()}`\n\n    const next: BuilderItem = {\n      id,\n      name: r.name || 'Food',\n      brand: r.brand ?? null,\n      serving_size: r.serving_size ?? null,\n      calories: toNumber(r.calories),\n      protein_g: toNumber(r.protein_g),\n      carbs_g: toNumber(r.carbs_g),\n      fat_g: toNumber(r.fat_g),\n      fiber_g: toNumber(r.fiber_g),\n      sugar_g: toNumber(r.sugar_g),\n      servings: 1,\n      __baseAmount: baseAmount,\n      __baseUnit: baseUnit,\n      __amount: defaultAmount,\n      __amountInput: String(defaultAmount),\n      __unit: baseUnit,\n    }\n\n    // If we know the base amount, treat the amount as units in the base and compute servings.\n    if (baseAmount && baseUnit) {\n      next.servings = 1\n    }\n\n    addBuilderItem(next)\n  }\n\n  const addItemsFromAi = (aiItems: any[]) => {\n    if (!Array.isArray(aiItems) || aiItems.length === 0) return\n    // Add each detected ingredient as its own expandable card.\n    for (const ai of aiItems) {\n      const name = String(ai?.name || ai?.food || 'Food').trim() || 'Food'\n      const brand = ai?.brand ?? null\n      const serving_size = ai?.serving_size || ai?.servingSize || ai?.serving || ''\n      const servings = toNumber(ai?.servings) ?? 1\n\n      const base = parseServingBase(serving_size)\n      const baseAmount = base.amount\n      const baseUnit = base.unit\n\n      const id = `ai:${Date.now()}:${Math.random().toString(16).slice(2)}`\n      const next: BuilderItem = {\n        id,\n        name,\n        brand,\n        serving_size: serving_size || null,\n        calories: toNumber(ai?.calories),\n        protein_g: toNumber(ai?.protein_g),\n        carbs_g: toNumber(ai?.carbs_g),\n        fat_g: toNumber(ai?.fat_g),\n        fiber_g: toNumber(ai?.fiber_g),\n        sugar_g: toNumber(ai?.sugar_g),\n        servings: Number.isFinite(servings) && servings > 0 ? servings : 1,\n        __baseAmount: baseAmount,\n        __baseUnit: baseUnit,\n        __amount: baseAmount && baseUnit ? round3(baseAmount * (Number.isFinite(servings) ? servings : 1)) : round3(Number.isFinite(servings) ? servings : 1),\n        __amountInput: String(baseAmount && baseUnit ? round3(baseAmount * (Number.isFinite(servings) ? servings : 1)) : round3(Number.isFinite(servings) ? servings : 1)),\n        __unit: baseUnit,\n      }\n      addBuilderItem(next)\n    }\n  }\n\n  const addFromFavorite = (fav: any) => {\n    if (!fav) return\n    // Favorites are saved meals; prefer their ingredient cards when available.\n    let favItems: any[] | null = null\n    const candidate = (fav as any)?.items\n    if (Array.isArray(candidate)) {\n      favItems = candidate\n    } else if (typeof candidate === 'string') {\n      try {\n        const parsed = JSON.parse(candidate)\n        favItems = Array.isArray(parsed) ? parsed : null\n      } catch {\n        favItems = null\n      }\n    }\n\n    if (favItems && favItems.length > 0) {\n      addItemsFromAi(favItems)\n      return\n    }\n\n    // Fallback: add as a single ingredient using the favorite's totals.\n    const total = (fav as any)?.total || (fav as any)?.nutrition || null\n    const label = String((fav as any)?.label || (fav as any)?.description || 'Favorite').trim() || 'Favorite'\n    addItemsFromAi([\n      {\n        name: label,\n        brand: 'Favorite',\n        serving_size: '1 serving',\n        servings: 1,\n        calories: total?.calories ?? null,\n        protein_g: total?.protein ?? total?.protein_g ?? null,\n        carbs_g: total?.carbs ?? total?.carbs_g ?? null,\n        fat_g: total?.fat ?? total?.fat_g ?? null,\n        fiber_g: total?.fiber ?? total?.fiber_g ?? null,\n        sugar_g: total?.sugar ?? total?.sugar_g ?? null,\n      },\n    ])\n  }\n\n  const HISTORY_RESET_EPOCH_MS = 1765532876309 // Dec 12, 2025 09:47:56 UTC\n\n  const normalizeMealLabel = (raw: any) => {\n    const s = String(raw || '').trim()\n    if (!s) return ''\n    const firstLine = s.split('\\n')[0] || s\n    return firstLine.split('Calories:')[0].trim()\n  }\n\n  const favoriteDisplayLabel = (fav: any) => {\n    const raw = (fav?.label || fav?.description || '').toString()\n    return normalizeMealLabel(raw)\n  }\n\n  const looksLikeMealBuilderCreatedItemId = (rawId: any) => {\n    const id = typeof rawId === 'string' ? rawId : ''\n    if (!id) return false\n    if (/^(openfoodfacts|usda|fatsecret):[^:]+:\\d{9,}$/i.test(id)) return true\n    if (/^ai:\\d{9,}:[0-9a-f]+$/i.test(id)) return true\n    return false\n  }\n\n  const isLegacyMealBuilderFavorite = (fav: any) => {\n    if (!fav) return false\n    const items = parseFavoriteItems(fav)\n    if (!items || items.length === 0) return false\n    return items.some((it: any) => looksLikeMealBuilderCreatedItemId(it?.id))\n  }\n\n  const isCustomMealFavorite = (fav: any) => {\n    if (!fav) return false\n    if ((fav as any)?.customMeal === true) return true\n    const method = String((fav as any)?.method || '').toLowerCase()\n    if (method === 'meal-builder' || method === 'combined') return true\n    return false\n  }\n\n  const buildSourceTag = (entry: any) => {\n    if (!entry) return 'Custom'\n    if (entry?.sourceTag) return String(entry.sourceTag)\n    if ((entry as any)?.source) return String((entry as any).source).toUpperCase()\n    if ((entry as any)?.method === 'photo') return 'CRDB'\n    if ((entry as any)?.method === 'text') return 'Manual'\n    return 'CRDB'\n  }\n\n  const extractCalories = (entry: any) => {\n    const n = (entry?.total || entry?.nutrition || null) as any\n    const c = n?.calories\n    return typeof c === 'number' && Number.isFinite(c) ? Math.round(c) : null\n  }\n\n  const readWarmDiaryState = (): any | null => {\n    try {\n      const raw = sessionStorage.getItem('foodDiary:warmState')\n      if (!raw) return null\n      const parsed = JSON.parse(raw)\n      return parsed && typeof parsed === 'object' ? parsed : null\n    } catch {\n      return null\n    }\n  }\n\n  const readPersistentDiarySnapshot = (): any | null => {\n    try {\n      const raw = localStorage.getItem('foodDiary:persistentSnapshot')\n      if (!raw) return null\n      const parsed = JSON.parse(raw)\n      return parsed && typeof parsed === 'object' ? parsed : null\n    } catch {\n      return null\n    }\n  }\n\n  const buildFavoritesDatasets = () => {\n    const favorites = Array.isArray((userData as any)?.favorites) ? ((userData as any).favorites as any[]) : []\n    const pool: any[] = []\n\n    const todays = Array.isArray((userData as any)?.todaysFoods) ? ((userData as any).todaysFoods as any[]) : []\n    pool.push(...todays)\n\n    const warm = readWarmDiaryState()\n    const historyByDate = warm?.historyByDate\n    if (historyByDate && typeof historyByDate === 'object') {\n      Object.values(historyByDate).forEach((entries: any) => {\n        if (Array.isArray(entries)) pool.push(...entries)\n      })\n    }\n\n    const snap = readPersistentDiarySnapshot()\n    if (snap?.byDate && typeof snap.byDate === 'object') {\n      Object.values(snap.byDate).forEach((d: any) => {\n        if (Array.isArray(d?.entries)) pool.push(...d.entries)\n      })\n    }\n\n    const meetsShape = (entry: any) => {\n      if (!entry) return false\n      const desc = String(entry?.description || entry?.label || '').trim()\n      if (!desc) return false\n      const hasNutrition = Boolean(entry?.nutrition) || Boolean(entry?.total) || (Array.isArray(entry?.items) && entry.items.length > 0)\n      if (!hasNutrition) return false\n      const ts =\n        typeof entry?.createdAt === 'string'\n          ? new Date(entry.createdAt).getTime()\n          : typeof entry?.createdAt === 'number'\n          ? entry.createdAt\n          : typeof entry?.id === 'number'\n          ? entry.id\n          : Number(entry?.id)\n      return Number.isFinite(ts) ? ts >= HISTORY_RESET_EPOCH_MS : true\n    }\n\n    const allByKey = new Map<string, any>()\n    pool.filter(meetsShape).forEach((entry) => {\n      const key = normalizeMealLabel(entry?.description || entry?.label || '').toLowerCase()\n      if (!key) return\n      const existing = allByKey.get(key)\n      const created = Number(entry?.createdAt ? new Date(entry.createdAt).getTime() : entry?.id || 0)\n      const existingCreated = Number(existing?.createdAt ? new Date(existing.createdAt).getTime() : existing?.id || 0)\n      if (!existing || created > existingCreated) allByKey.set(key, entry)\n    })\n\n    favorites.forEach((fav: any) => {\n      const key = favoriteDisplayLabel(fav).toLowerCase()\n      if (!key) return\n      if (!allByKey.has(key)) allByKey.set(key, { ...fav, sourceTag: 'Favorite' })\n    })\n\n    const allMeals = Array.from(allByKey.values()).map((entry) => ({\n      id: entry?.id || `all-${Math.random()}`,\n      label: normalizeMealLabel(entry?.description || entry?.label || 'Meal') || 'Meal',\n      entry,\n      favorite: (entry as any)?.sourceTag === 'Favorite' ? entry : null,\n      createdAt: entry?.createdAt || entry?.id || Date.now(),\n      sourceTag: (entry as any)?.sourceTag === 'Favorite' ? 'Favorite' : buildSourceTag(entry),\n      calories: extractCalories(entry),\n      serving: entry?.items?.[0]?.serving_size || entry?.serving || '',\n    }))\n\n    const favoriteMeals = favorites.map((fav: any) => ({\n      id: fav?.id || `fav-${Math.random()}`,\n      label: favoriteDisplayLabel(fav) || normalizeMealLabel(fav?.description || fav?.label || 'Favorite meal') || 'Favorite meal',\n      favorite: fav,\n      createdAt: fav?.createdAt || fav?.id || Date.now(),\n      sourceTag: 'Favorite',\n      calories: extractCalories(fav),\n      serving: fav?.items?.[0]?.serving_size || fav?.serving || '',\n    }))\n\n    // Product request: \"Custom\" only shows meals the user created (Build-a-meal / Combined).\n    const customMeals = favoriteMeals.filter((m: any) => isCustomMealFavorite(m?.favorite))\n\n    return { allMeals, favoriteMeals, customMeals }\n  }\n\n  const favoritesKeySet = useMemo(() => {\n    const favorites = Array.isArray((userData as any)?.favorites) ? ((userData as any).favorites as any[]) : []\n    const set = new Set<string>()\n    favorites.forEach((fav: any) => {\n      const key = favoriteDisplayLabel(fav).toLowerCase()\n      if (key) set.add(key)\n    })\n    return set\n  }, [userData])\n\n  const persistFavorites = (nextFavorites: any[]) => {\n    updateUserData({ favorites: nextFavorites })\n    try {\n      fetch('/api/user-data', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ favorites: nextFavorites }),\n      }).catch(() => {})\n    } catch {}\n  }\n\n  const saveToFavorites = (entryLike: any) => {\n    const source = entryLike\n    if (!source) return\n    const labelRaw = source?.description || source?.label || 'Favorite meal'\n    const cleanLabel = normalizeMealLabel(labelRaw) || 'Favorite meal'\n\n    const clonedItems =\n      source?.items && Array.isArray(source.items) && source.items.length > 0 ? JSON.parse(JSON.stringify(source.items)) : null\n\n    const favoritePayload = {\n      id: `fav-${Date.now()}`,\n      sourceId: (source as any)?.id || (source as any)?.dbId || null,\n      label: cleanLabel,\n      description: String(source?.description || cleanLabel),\n      nutrition: source?.nutrition || source?.total || null,\n      total: source?.total || source?.nutrition || null,\n      items: clonedItems,\n      photo: source?.photo || null,\n      method: source?.method || 'text',\n      meal: normalizeCategory(source?.meal || source?.category || source?.mealType),\n      createdAt: Date.now(),\n    }\n\n    const prev = Array.isArray((userData as any)?.favorites) ? ((userData as any).favorites as any[]) : []\n    const existingIndex = prev.findIndex(\n      (fav: any) =>\n        (fav.sourceId && favoritePayload.sourceId && fav.sourceId === favoritePayload.sourceId) ||\n        (fav.label && favoritePayload.label && fav.label === favoritePayload.label),\n    )\n    const next =\n      existingIndex >= 0\n        ? prev.map((fav: any, idx: number) => (idx === existingIndex ? { ...favoritePayload, id: fav.id || favoritePayload.id } : fav))\n        : [...prev, favoritePayload]\n\n    persistFavorites(next)\n    setFavoritesToast('Saved to Favorites')\n    setTimeout(() => setFavoritesToast(null), 1400)\n  }\n\n  const deleteFavorite = (id: string) => {\n    const favId = String(id || '').trim()\n    if (!favId) return\n    const prev = Array.isArray((userData as any)?.favorites) ? ((userData as any).favorites as any[]) : []\n    const next = prev.filter((f: any) => String(f?.id || '') !== favId)\n    persistFavorites(next)\n    setFavoritesToast('Removed')\n    setTimeout(() => setFavoritesToast(null), 1400)\n  }\n\n  const openEditFavorite = (fav: any) => {\n    const id = String(fav?.id || '').trim()\n    if (!id) return\n    const favCategory = normalizeCategory(fav?.meal || fav?.category || category)\n    router.push(\n      `/food/build-meal?date=${encodeURIComponent(selectedDate)}&category=${encodeURIComponent(favCategory)}&editFavoriteId=${encodeURIComponent(id)}`,\n    )\n  }\n\n  const analyzePhotoAndAdd = async (file: File) => {\n    if (!file) return\n    setError(null)\n    setPhotoLoading(true)\n    try {\n      triggerHaptic(10)\n      try {\n        if (photoPreviewUrl) URL.revokeObjectURL(photoPreviewUrl)\n      } catch {}\n      try {\n        setPhotoPreviewUrl(URL.createObjectURL(file))\n      } catch {}\n      const fd = new FormData()\n      fd.append('image', file)\n      // Use the existing Food image analyzer. This can return multiple ingredients.\n      fd.append('analysisMode', 'meal')\n      const res = await fetch('/api/analyze-food', { method: 'POST', body: fd })\n      const data = await res.json().catch(() => ({}))\n      if (!res.ok) {\n        const msg =\n          typeof data?.message === 'string'\n            ? data.message\n            : typeof data?.error === 'string'\n            ? data.error\n            : 'Photo analysis failed. Please try again.'\n        setError(msg)\n        return\n      }\n      const detected = Array.isArray(data?.items) ? data.items : []\n      if (detected.length === 0) {\n        setError('No ingredients were detected from that photo. Try a clearer photo or use search/barcode.')\n        return\n      }\n      addItemsFromAi(detected)\n      try {\n        window.dispatchEvent(new Event('credits:refresh'))\n      } catch {}\n    } catch {\n      setError('Photo analysis failed. Please try again.')\n    } finally {\n      setPhotoLoading(false)\n      try {\n        if (photoInputRef.current) photoInputRef.current.value = ''\n      } catch {}\n    }\n  }\n\n  const stopBarcodeScanner = () => {\n    try {\n      const current = barcodeScannerRef.current\n      if (current?.controls?.stop) current.controls.stop()\n      if (current?.reader?.reset) current.reader.reset()\n    } catch {}\n    barcodeScannerRef.current = null\n  }\n\n  const lookupBarcode = async (codeRaw: string) => {\n    const code = String(codeRaw || '').trim().replace(/[^0-9A-Za-z]/g, '')\n    if (!code) {\n      setBarcodeError('Please enter a barcode.')\n      return\n    }\n    setBarcodeError(null)\n    setBarcodeLoading(true)\n    setBarcodeStatusHint('Looking up barcode‚Ä¶')\n    try {\n      const res = await fetch(`/api/barcode/lookup?code=${encodeURIComponent(code)}`, { method: 'GET' })\n      const data = await res.json().catch(() => ({}))\n      if (!res.ok) {\n        if (res.status === 402) {\n          setBarcodeError('Not enough credits for barcode scanning.')\n        } else if (res.status === 422) {\n          setBarcodeError(\n            data?.message ||\n              data?.error ||\n              'Nutrition data is missing for this barcode. Please scan the nutrition label instead.',\n          )\n        } else if (res.status === 404) {\n          setBarcodeError('No product found for that barcode. Try photo or search.')\n        } else if (res.status === 401) {\n          setBarcodeError('Please sign in again, then retry.')\n        } else {\n          setBarcodeError('Barcode lookup failed. Please try again.')\n        }\n        return\n      }\n      if (!data?.found || !data?.food) {\n        setBarcodeError('No product found for that barcode. Try photo or search.')\n        return\n      }\n      const food = data.food\n      const normalized: NormalizedFoodItem = {\n        source: food.source === 'fatsecret' ? 'fatsecret' : food.source === 'usda' ? 'usda' : 'openfoodfacts',\n        id: String(food.id || code),\n        name: String(food.name || 'Scanned food'),\n        brand: food.brand ?? null,\n        serving_size: String(food.serving_size || '1 serving'),\n        calories: toNumber(food.calories),\n        protein_g: toNumber(food.protein_g),\n        carbs_g: toNumber(food.carbs_g),\n        fat_g: toNumber(food.fat_g),\n        fiber_g: toNumber(food.fiber_g),\n        sugar_g: toNumber(food.sugar_g),\n      }\n      addItem(normalized)\n      setBarcodeStatusHint('Added')\n      setShowBarcodeScanner(false)\n    } catch {\n      setBarcodeError('Barcode lookup failed. Please try again.')\n    } finally {\n      setBarcodeLoading(false)\n    }\n  }\n\n  const startBarcodeScanner = async () => {\n    setBarcodeError(null)\n    setBarcodeStatusHint('Starting camera‚Ä¶')\n    try {\n      stopBarcodeScanner()\n      const region = document.getElementById('meal-builder-barcode-region')\n      if (!region) {\n        setBarcodeError('Camera area missing. Close and reopen the scanner.')\n        setBarcodeStatusHint('Camera error')\n        return\n      }\n      region.innerHTML = ''\n      const videoEl = document.createElement('video')\n      videoEl.setAttribute('playsinline', 'true')\n      videoEl.setAttribute('autoplay', 'true')\n      videoEl.muted = true\n      videoEl.playsInline = true\n      videoEl.autoplay = true\n      videoEl.style.width = '100%'\n      videoEl.style.height = '100%'\n      videoEl.style.objectFit = 'cover'\n      region.appendChild(videoEl)\n\n      const { BrowserMultiFormatReader, BarcodeFormat } = await import('@zxing/browser')\n      const { DecodeHintType } = await import('@zxing/library')\n      const hints = new Map()\n      hints.set(DecodeHintType.POSSIBLE_FORMATS, [\n        BarcodeFormat.EAN_13,\n        BarcodeFormat.EAN_8,\n        BarcodeFormat.UPC_A,\n        BarcodeFormat.UPC_E,\n        BarcodeFormat.CODE_128,\n        BarcodeFormat.CODE_39,\n        BarcodeFormat.CODE_93,\n        BarcodeFormat.ITF,\n      ])\n      hints.set(DecodeHintType.TRY_HARDER, true)\n      const reader = new BrowserMultiFormatReader()\n      reader.setHints(hints)\n\n      const constraints: any = {\n        video: {\n          facingMode: { ideal: 'environment' },\n          width: { ideal: 1280 },\n          height: { ideal: 720 },\n          advanced: [{ focusMode: 'continuous' }],\n        },\n      }\n\n      const controls = await reader.decodeFromConstraints(constraints, videoEl, (result: any) => {\n        const text = result?.getText ? result.getText() : result?.text\n        if (!text) return\n        // Stop quickly so we don't double-trigger.\n        stopBarcodeScanner()\n        lookupBarcode(text)\n      })\n\n      barcodeScannerRef.current = { reader, controls, videoEl }\n      setBarcodeStatusHint('Scanning‚Ä¶')\n    } catch {\n      setBarcodeError('Could not start the camera. Please allow camera access and retry.')\n      setBarcodeStatusHint('Camera error')\n      stopBarcodeScanner()\n    }\n  }\n\n  useEffect(() => {\n    if (!showBarcodeScanner) {\n      stopBarcodeScanner()\n      setBarcodeError(null)\n      setBarcodeStatusHint('Ready')\n      return\n    }\n    startBarcodeScanner()\n    return () => stopBarcodeScanner()\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [showBarcodeScanner])\n\n  const removeItem = (id: string) => {\n    const current = itemsRef.current\n    const idx = current.findIndex((x) => x.id === id)\n    if (idx >= 0) {\n      const removed = current[idx]\n      setLastRemoved({ item: removed, index: idx })\n      try {\n        if (undoRemoveTimeoutRef.current) clearTimeout(undoRemoveTimeoutRef.current)\n      } catch {}\n      undoRemoveTimeoutRef.current = setTimeout(() => setLastRemoved(null), 5000)\n    }\n    setItems((prev) => prev.filter((x) => x.id !== id))\n    setExpandedId((prev) => (prev === id ? null : prev))\n  }\n\n  const undoRemove = () => {\n    const payload = lastRemoved\n    if (!payload) return\n    try {\n      if (undoRemoveTimeoutRef.current) clearTimeout(undoRemoveTimeoutRef.current)\n    } catch {}\n    setItems((prev) => {\n      const next = [...prev]\n      const insertAt = Math.max(0, Math.min(payload.index, next.length))\n      next.splice(insertAt, 0, payload.item)\n      return next\n    })\n    setLastRemoved(null)\n  }\n\n  const setAmount = (id: string, raw: string) => {\n    const v = String(raw ?? '').replace(',', '.')\n    setItems((prev) =>\n      prev.map((it) => {\n        if (it.id !== id) return it\n        const num = v.trim() === '' ? NaN : Number(v)\n        const amount = Number.isFinite(num) && num >= 0 ? num : 0\n        const baseAmount = it.__baseAmount\n        const baseUnit = it.__baseUnit\n        const unit = it.__unit\n        let servings = it.servings\n\n        if (baseAmount && baseUnit && unit) {\n          const inBase = convertAmount(amount, unit, baseUnit)\n          servings = baseAmount > 0 ? inBase / baseAmount : 0\n        } else {\n          // Fallback: treat amount as servings\n          servings = amount\n        }\n\n        return { ...it, __amountInput: v, __amount: amount, servings: round3(Math.max(0, servings)) }\n      }),\n    )\n  }\n\n  const setUnit = (id: string, unit: BuilderUnit) => {\n    setItems((prev) =>\n      prev.map((it) => {\n        if (it.id !== id) return it\n        const baseAmount = it.__baseAmount\n        const baseUnit = it.__baseUnit\n        if (!baseAmount || !baseUnit) {\n          return { ...it, __unit: unit }\n        }\n        const currentUnit = it.__unit || baseUnit\n        const converted = convertAmount(it.__amount, currentUnit, unit)\n        const inBase = convertAmount(converted, unit, baseUnit)\n        const servings = baseAmount > 0 ? inBase / baseAmount : 0\n        const nextAmount = round3(Math.max(0, converted))\n        return { ...it, __unit: unit, __amount: nextAmount, __amountInput: String(nextAmount), servings: round3(Math.max(0, servings)) }\n      }),\n    )\n  }\n\n  const createMeal = async () => {\n    if (items.length === 0) {\n      setError('Add at least one ingredient first.')\n      return\n    }\n\n    setError(null)\n\n    const title = sanitizeMealTitle(mealName) || buildDefaultMealName(items)\n    const description = title\n    const favorites = Array.isArray((userData as any)?.favorites) ? ((userData as any).favorites as any[]) : []\n    const existingWithSameTitle =\n      favorites.find((f: any) => isCustomMealFavorite(f) && String(f?.label || f?.description || '').trim() === title.trim()) || null\n    const favoriteLinkId = (() => {\n      if (editFavoriteId) return editFavoriteId\n      if (linkedFavoriteId && linkedFavoriteId.trim().length > 0) return linkedFavoriteId.trim()\n      if (existingWithSameTitle?.id) return String(existingWithSameTitle.id)\n      return `fav-${Date.now()}`\n    })()\n\n    const cleanedItems = items.map((it) => {\n      const { __baseAmount, __baseUnit, __amount, __amountInput, __unit, ...rest } = it\n      return rest\n    })\n\n    const createdAtIso = alignTimestampToLocalDate(new Date().toISOString(), selectedDate)\n\n    const payload = {\n      description,\n      nutrition: {\n        calories: Math.round(mealTotals.calories),\n        protein: round3(mealTotals.protein),\n        carbs: round3(mealTotals.carbs),\n        fat: round3(mealTotals.fat),\n        fiber: round3(mealTotals.fiber),\n        sugar: round3(mealTotals.sugar),\n        __origin: 'meal-builder',\n        ...(favoriteLinkId ? { __favoriteId: favoriteLinkId } : {}),\n      },\n      imageUrl: null,\n      items: cleanedItems,\n      localDate: selectedDate,\n      meal: category,\n      category,\n      createdAt: createdAtIso,\n    }\n\n    setSavingMeal(true)\n    try {\n      // Editing a diary entry directly (no favorites template involved).\n      if (!editFavoriteId && sourceLogId) {\n        try {\n          await fetch('/api/food-log', {\n            method: 'PUT',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({\n              id: sourceLogId,\n              description,\n              nutrition: payload.nutrition,\n              items: cleanedItems,\n              meal: category,\n              category,\n            }),\n          })\n        } catch {}\n\n        // Keep the linked saved meal in sync (if one exists, or create one for future use).\n        try {\n          if (favoriteLinkId) {\n            const favoritePayload = {\n              id: favoriteLinkId,\n              sourceId: sourceLogId,\n              label: title,\n              description,\n              nutrition: payload.nutrition,\n              total: payload.nutrition,\n              items: cleanedItems,\n              photo: null,\n              method: 'meal-builder',\n              customMeal: true,\n              meal: category,\n              createdAt: Date.now(),\n            }\n            const existingIndex = favorites.findIndex((f: any) => String(f?.id || '') === favoriteLinkId)\n            const nextFavorites =\n              existingIndex >= 0\n                ? favorites.map((f: any, idx: number) => (idx === existingIndex ? { ...favoritePayload, id: f.id || favoritePayload.id } : f))\n                : [...favorites, favoritePayload]\n            persistFavorites(nextFavorites)\n          }\n        } catch {}\n\n        try {\n          sessionStorage.setItem(\n            'foodDiary:scrollToEntry',\n            JSON.stringify({ dbId: sourceLogId, localDate: selectedDate, category }),\n          )\n        } catch {}\n        router.push('/food')\n        return\n      }\n\n      if (editFavoriteId) {\n        setFavoriteSaving(true)\n        const prev = favorites\n        const existing = prev.find((f: any) => String(f?.id || '') === editFavoriteId) || null\n        if (!existing) {\n          setError('Could not find that saved meal to edit. Please reopen from Favorites ‚Üí Custom.')\n          return\n        }\n        if (!isCustomMealFavorite(existing)) {\n          setError('Only custom meals (Build-a-meal / Combined) can be edited here.')\n          return\n        }\n\n        const updatedFavorite = {\n          ...existing,\n          label: title,\n          description,\n          nutrition: payload.nutrition,\n          total: payload.nutrition,\n          items: cleanedItems,\n          method: existing?.method || 'meal-builder',\n          customMeal: true,\n          meal: existing?.meal || category,\n          createdAt: existing?.createdAt || Date.now(),\n        }\n        const nextFavorites = prev.map((f: any) => (String(f?.id || '') === editFavoriteId ? updatedFavorite : f))\n        persistFavorites(nextFavorites)\n\n        // If we were opened from a diary entry, update that FoodLog row too.\n        // Do NOT use favorite.sourceId here: favorites are reusable templates and may point to an older log.\n        const targetLogId = sourceLogId ? String(sourceLogId) : ''\n        if (targetLogId) {\n          try {\n            await fetch('/api/food-log', {\n              method: 'PUT',\n              headers: { 'Content-Type': 'application/json' },\n              body: JSON.stringify({\n                id: targetLogId,\n                description,\n                nutrition: payload.nutrition,\n                items: cleanedItems,\n                meal: existing?.meal || category,\n                category: existing?.meal || category,\n              }),\n            })\n          } catch {}\n          try {\n            sessionStorage.setItem(\n              'foodDiary:scrollToEntry',\n              JSON.stringify({ dbId: targetLogId, localDate: selectedDate, category: existing?.meal || category }),\n            )\n          } catch {}\n        }\n\n        router.push('/food')\n        return\n      }\n\n      const res = await fetch('/api/food-log', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(payload),\n      })\n      const data = await res.json().catch(() => ({} as any))\n      if (!res.ok) {\n        setError('Saving failed. Please try again.')\n        return\n      }\n\n      // Auto-save newly created meals into Favorites so they appear under Favorites ‚Üí Custom.\n      try {\n        const createdId = typeof data?.id === 'string' ? data.id : null\n        const favoritePayload = {\n          id: favoriteLinkId,\n          sourceId: createdId,\n          label: title,\n          description,\n          nutrition: payload.nutrition,\n          total: payload.nutrition,\n          items: cleanedItems,\n          photo: null,\n          method: 'meal-builder',\n          customMeal: true,\n          meal: category,\n          createdAt: Date.now(),\n        }\n        const existingIndex = favorites.findIndex(\n          (fav: any) =>\n            (fav.id && favoritePayload.id && String(fav.id) === String(favoritePayload.id)) ||\n            (fav.sourceId && favoritePayload.sourceId && fav.sourceId === favoritePayload.sourceId) ||\n            (fav.label && favoritePayload.label && fav.label === favoritePayload.label),\n        )\n        const nextFavorites =\n          existingIndex >= 0\n            ? favorites.map((fav: any, idx: number) =>\n                idx === existingIndex ? { ...favoritePayload, id: fav.id || favoritePayload.id } : fav,\n              )\n            : [...favorites, favoritePayload]\n        persistFavorites(nextFavorites)\n      } catch {}\n\n      // Scroll to the saved meal when returning to the diary.\n      try {\n        const createdId = typeof data?.id === 'string' ? data.id : null\n        if (createdId) {\n          sessionStorage.setItem(\n            'foodDiary:scrollToEntry',\n            JSON.stringify({ dbId: createdId, localDate: selectedDate, category }),\n          )\n        }\n      } catch {}\n\n      router.push('/food')\n    } catch {\n      setError('Saving failed. Please try again.')\n    } finally {\n      setFavoriteSaving(false)\n      setSavingMeal(false)\n    }\n  }\n\n  return (\n    <div className=\"min-h-screen bg-white\">\n      <div className=\"sticky top-0 z-10 bg-white border-b border-gray-200\">\n        <div className=\"flex items-center gap-3 px-4 py-3\">\n          <button\n            type=\"button\"\n            onClick={() => router.push('/food')}\n            className=\"p-2 rounded-full hover:bg-gray-100\"\n            aria-label=\"Back\"\n          >\n            <span aria-hidden>‚Üê</span>\n          </button>\n          <div className=\"flex-1 min-w-0\">\n            <div className=\"text-lg font-semibold text-gray-900 truncate\">{editFavoriteId ? 'Edit meal' : 'Build a meal'}</div>\n            <div className=\"text-xs text-gray-500\">\n              {CATEGORY_LABELS[category]} ‚Ä¢ {selectedDate}\n            </div>\n          </div>\n          <div className=\"flex flex-col items-end gap-1\">\n            <button\n              type=\"button\"\n              onClick={createMeal}\n              disabled={busy || favoriteSaving}\n              className=\"px-4 py-2 rounded-xl bg-emerald-600 text-white text-sm font-semibold disabled:opacity-60\"\n            >\n              {editFavoriteId ? (favoriteSaving ? 'Saving‚Ä¶' : 'Save changes') : 'Save meal'}\n            </button>\n            <div className=\"text-[11px] text-gray-500 text-right max-w-[240px]\">\n              Find this later in <span className=\"font-semibold\">Food Diary ‚Üí {CATEGORY_LABELS[category]}</span> (tap to edit) and <span className=\"font-semibold\">Favorites ‚Üí Custom</span>.\n            </div>\n          </div>\n        </div>\n      </div>\n\n      <div className=\"px-4 py-4\">\n        <div className=\"w-full max-w-4xl mx-auto space-y-4\">\n          {lastRemoved && (\n            <div className=\"fixed left-1/2 -translate-x-1/2 bottom-6 z-50 w-[min(92vw,520px)] px-3 py-3 rounded-2xl bg-slate-900 text-white shadow-lg flex items-center justify-between gap-3\">\n              <div className=\"min-w-0\">\n                <div className=\"text-sm font-semibold truncate\">Removed {String(lastRemoved.item?.name || 'item')}</div>\n                <div className=\"text-xs text-white/80\">Tap undo to restore</div>\n              </div>\n              <button\n                type=\"button\"\n                onClick={undoRemove}\n                className=\"px-3 py-2 rounded-xl bg-white text-slate-900 text-sm font-semibold\"\n              >\n                Undo\n              </button>\n            </div>\n          )}\n\n          {showFavoritesPicker && (\n            <div className=\"fixed inset-0 z-50 bg-white flex flex-col\">\n              <div className=\"flex items-center justify-between px-4 py-3 border-b border-gray-200\">\n                <button\n                  type=\"button\"\n                  onClick={() => setShowFavoritesPicker(false)}\n                  className=\"p-2 rounded-full hover:bg-gray-100\"\n                  aria-label=\"Back\"\n                >\n                  <span aria-hidden>‚Üê</span>\n                </button>\n                <div className=\"flex-1 text-center\">\n                  <div className=\"text-lg font-semibold text-gray-900\">Add from favorites</div>\n                  <div className=\"text-xs text-gray-500\">Pick from All / Favorites / Custom</div>\n                </div>\n                <button\n                  type=\"button\"\n                  onClick={() => setShowFavoritesPicker(false)}\n                  className=\"p-2 rounded-full hover:bg-gray-100\"\n                  aria-label=\"Close\"\n                >\n                  <span aria-hidden>‚úï</span>\n                </button>\n              </div>\n\n              <div className=\"px-4 py-3 border-b border-gray-200\">\n                <input\n                  value={favoritesSearch}\n                  onChange={(e) => setFavoritesSearch(e.target.value)}\n                  placeholder=\"Search all foods...\"\n                  className=\"w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-emerald-500 focus:border-emerald-500\"\n                />\n              </div>\n\n              <div className=\"px-4 py-3 border-b border-gray-200\">\n                <div className=\"grid grid-cols-3 gap-2\">\n                  {(['all', 'favorites', 'custom'] as const).map((tab) => (\n                    <button\n                      key={tab}\n                      type=\"button\"\n                      onClick={() => setFavoritesActiveTab(tab)}\n                      className={`py-2 text-sm font-semibold border rounded-lg ${\n                        favoritesActiveTab === tab ? 'bg-gray-200 text-gray-900 border-gray-300' : 'bg-white text-gray-700 border-gray-300'\n                      }`}\n                    >\n                      {tab === 'all' ? 'All' : tab === 'favorites' ? 'Favorites' : 'Custom'}\n                    </button>\n                  ))}\n                </div>\n              </div>\n\n              <div className=\"flex-1 overflow-y-auto px-4 py-3\">\n                {(() => {\n                  const search = favoritesSearch.trim().toLowerCase()\n                  const { allMeals, favoriteMeals, customMeals } = buildFavoritesDatasets()\n                  const filterBySearch = (item: any) => {\n                    if (!search) return true\n                    return (\n                      String(item?.label || '').toLowerCase().includes(search) ||\n                      String(item?.serving || '').toLowerCase().includes(search) ||\n                      String(item?.sourceTag || '').toLowerCase().includes(search)\n                    )\n                  }\n                  const sortList = (list: any[]) => [...list].sort((a, b) => (Number(b.createdAt) || 0) - (Number(a.createdAt) || 0))\n\n                  let data: any[] = []\n                  if (favoritesActiveTab === 'all') data = sortList(allMeals.filter(filterBySearch))\n                  if (favoritesActiveTab === 'favorites')\n                    data = sortList(favoriteMeals.filter((m: any) => !isCustomMealFavorite(m?.favorite)).filter(filterBySearch))\n                  if (favoritesActiveTab === 'custom') data = sortList(customMeals.filter(filterBySearch))\n\n                  if (data.length === 0) {\n                    return (\n                      <div className=\"text-sm text-gray-500 py-8 text-center\">\n                        {favoritesActiveTab === 'all'\n                          ? 'No meals yet. Add some entries to see them here.'\n                          : favoritesActiveTab === 'favorites'\n                          ? 'No favorites yet.'\n                          : 'No custom meals yet.'}\n                      </div>\n                    )\n                  }\n\n                  return (\n                    <div className=\"divide-y divide-gray-100 border border-gray-200 rounded-xl overflow-hidden\">\n                      {data.map((item, idx) => {\n                        const label = String(item?.label || 'Meal').trim() || 'Meal'\n                        const calories = typeof item?.calories === 'number' && Number.isFinite(item.calories) ? item.calories : null\n                        const tag = String(item?.sourceTag || (favoritesActiveTab === 'favorites' ? 'Favorite' : 'Custom'))\n                        const serving = String(item?.serving || '1 serving')\n                        const key = normalizeMealLabel(label).toLowerCase()\n                        const isSaved = Boolean(item?.favorite) || (key ? favoritesKeySet.has(key) : false)\n                        const canSaveFromAll = favoritesActiveTab === 'all' && !isSaved && Boolean(item?.entry)\n                        const favorite = item?.favorite || null\n                        const favoriteId = favorite?.id ? String(favorite.id) : null\n                        return (\n                          <div\n                            key={String(item?.id || idx)}\n                            className=\"w-full flex items-stretch gap-2\"\n                          >\n                            <button\n                              type=\"button\"\n                              onClick={() => {\n                                if (item?.favorite) addFromFavorite(item.favorite)\n                                else if (item?.entry) addFromFavorite(item.entry)\n                                else addFromFavorite(item)\n                                setShowFavoritesPicker(false)\n                                setFavoritesSearch('')\n                              }}\n                              className=\"flex-1 min-w-0 flex items-center justify-between gap-3 px-4 py-3 text-left hover:bg-gray-50\"\n                            >\n                              <div className=\"min-w-0\">\n                                <div className=\"text-sm font-semibold text-gray-900 truncate\">{label}</div>\n                                <div className=\"text-xs text-gray-500 truncate\">\n                                  {serving} ‚Ä¢ {tag}\n                                </div>\n                              </div>\n                              {calories !== null && <div className=\"text-sm font-semibold text-gray-900\">{calories} kcal</div>}\n                            </button>\n\n                            {favoritesActiveTab === 'all' && (\n                              <div className=\"flex items-center pr-2\">\n                                {isSaved ? (\n                                  <div className=\"px-2 py-1 text-[11px] font-semibold text-emerald-700 bg-emerald-50 border border-emerald-200 rounded-lg\">\n                                    Saved\n                                  </div>\n                                ) : (\n                                  <button\n                                    type=\"button\"\n                                    disabled={!canSaveFromAll}\n                                    onClick={(e) => {\n                                      e.preventDefault()\n                                      e.stopPropagation()\n                                      if (item?.entry) {\n                                        saveToFavorites(item.entry)\n                                      }\n                                    }}\n                                    className=\"px-3 py-2 rounded-lg border border-gray-200 bg-white text-xs font-semibold text-gray-800 hover:bg-gray-50 disabled:opacity-50\"\n                                    aria-label=\"Save to favorites\"\n                                  >\n                                    Save\n                                  </button>\n                                )}\n                              </div>\n                            )}\n\n                            {favoritesActiveTab !== 'all' && favoriteId && (\n                              <div className=\"flex items-center pr-2 gap-1\">\n                                {isCustomMealFavorite(favorite) && (\n                                  <button\n                                    type=\"button\"\n                                    onClick={(e) => {\n                                      e.preventDefault()\n                                      e.stopPropagation()\n                                      openEditFavorite(favorite)\n                                    }}\n                                    className=\"px-3 py-2 rounded-lg border border-gray-200 bg-white text-xs font-semibold text-gray-800 hover:bg-gray-50\"\n                                    title=\"Edit meal\"\n                                    aria-label=\"Edit meal\"\n                                  >\n                                    Edit\n                                  </button>\n                                )}\n                                <button\n                                  type=\"button\"\n                                  onClick={(e) => {\n                                    e.preventDefault()\n                                    e.stopPropagation()\n                                    deleteFavorite(favoriteId)\n                                  }}\n                                  className=\"px-3 py-2 rounded-lg border border-gray-200 bg-white text-xs font-semibold text-red-700 hover:bg-red-50\"\n                                  title=\"Delete meal\"\n                                  aria-label=\"Delete meal\"\n                                >\n                                  Delete\n                                </button>\n                              </div>\n                            )}\n                          </div>\n                        )\n                      })}\n                    </div>\n                  )\n                })()}\n              </div>\n\n              {favoritesToast && (\n                <div className=\"fixed left-1/2 -translate-x-1/2 bottom-6 z-50 px-4 py-2 rounded-full bg-slate-900 text-white text-sm font-semibold shadow-lg\">\n                  {favoritesToast}\n                </div>\n              )}\n            </div>\n          )}\n\n          {showBarcodeScanner && (\n            <div className=\"fixed inset-0 z-50 bg-black\">\n              <div className=\"absolute inset-0 flex flex-col\">\n                <div className=\"flex items-center justify-between px-4 py-3 bg-black/70 text-white\">\n                  <div className=\"text-sm font-semibold\">Scan barcode</div>\n                  <button\n                    type=\"button\"\n                    onClick={() => {\n                      setShowBarcodeScanner(false)\n                      stopBarcodeScanner()\n                    }}\n                    className=\"px-3 py-1.5 rounded-lg bg-white/10\"\n                  >\n                    Close\n                  </button>\n                </div>\n\n                <div className=\"flex-1 relative\">\n                  <div id=\"meal-builder-barcode-region\" className=\"absolute inset-0\" />\n                  <div className=\"absolute inset-0 pointer-events-none flex items-center justify-center\">\n                    <div className=\"w-64 h-40 border-2 border-white/70 rounded-xl\" />\n                  </div>\n                </div>\n\n                <div className=\"bg-black/85 text-white px-4 py-3 space-y-2\">\n                  <div className=\"text-xs text-white/80\">{barcodeStatusHint}</div>\n                  {barcodeError && <div className=\"text-xs text-red-300\">{barcodeError}</div>}\n\n                  <div className=\"flex gap-2\">\n                    <input\n                      value={manualBarcode}\n                      onFocus={() => {\n                        manualBarcodeBackupRef.current = manualBarcode\n                        manualBarcodeEditedRef.current = false\n                        manualBarcodeWasClearedOnFocusRef.current = manualBarcode.trim().length > 0\n                        if (manualBarcodeWasClearedOnFocusRef.current) setManualBarcode('')\n                      }}\n                      onChange={(e) => {\n                        manualBarcodeEditedRef.current = true\n                        setManualBarcode(e.target.value)\n                      }}\n                      onBlur={() => {\n                        if (manualBarcodeWasClearedOnFocusRef.current && !manualBarcodeEditedRef.current) {\n                          setManualBarcode(manualBarcodeBackupRef.current)\n                        }\n                        manualBarcodeWasClearedOnFocusRef.current = false\n                        manualBarcodeEditedRef.current = false\n                      }}\n                      placeholder=\"Enter barcode\"\n                      className=\"flex-1 px-3 py-2 rounded-lg bg-white text-gray-900 text-sm\"\n                    />\n                    <button\n                      type=\"button\"\n                      onClick={() => lookupBarcode(manualBarcode)}\n                      disabled={barcodeLoading}\n                      className=\"px-4 py-2 rounded-lg bg-emerald-600 text-white text-sm font-semibold disabled:opacity-60\"\n                    >\n                      Lookup\n                    </button>\n                  </div>\n\n                  <div className=\"flex gap-2\">\n                    <button\n                      type=\"button\"\n                      onClick={() => startBarcodeScanner()}\n                      className=\"flex-1 px-3 py-2 rounded-lg bg-white/10 text-white text-sm font-semibold\"\n                    >\n                      Restart camera\n                    </button>\n                    <button\n                      type=\"button\"\n                      onClick={() => {\n                        setShowBarcodeScanner(false)\n                        stopBarcodeScanner()\n                      }}\n                      className=\"flex-1 px-3 py-2 rounded-lg bg-white/10 text-white text-sm font-semibold\"\n                    >\n                      Cancel\n                    </button>\n                  </div>\n                </div>\n              </div>\n            </div>\n          )}\n\n        <div className=\"rounded-2xl border border-gray-200 bg-white p-3 sm:p-4 space-y-3\">\n          <div className=\"text-sm font-semibold text-gray-900\">Meal name (optional)</div>\n          <input\n            value={mealName}\n            onFocus={() => {\n              mealNameBackupRef.current = mealName\n              mealNameEditedRef.current = false\n              mealNameWasClearedOnFocusRef.current = mealName.trim().length > 0\n              if (mealNameWasClearedOnFocusRef.current) setMealName('')\n            }}\n            onChange={(e) => {\n              mealNameEditedRef.current = true\n              setMealName(e.target.value)\n            }}\n            onBlur={() => {\n              if (mealNameWasClearedOnFocusRef.current && !mealNameEditedRef.current) {\n                setMealName(mealNameBackupRef.current)\n              }\n              mealNameWasClearedOnFocusRef.current = false\n              mealNameEditedRef.current = false\n            }}\n            placeholder={buildDefaultMealName(items)}\n            className=\"w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-emerald-500 focus:border-emerald-500\"\n          />\n        </div>\n\n        <div className=\"rounded-2xl border border-gray-200 bg-white p-3 sm:p-4 space-y-3\">\n          <div className=\"text-sm font-semibold text-gray-900\">Search ingredients</div>\n          <div className=\"flex gap-2\">\n            <input\n              value={query}\n              onFocus={() => {\n                queryBackupRef.current = query\n                queryEditedRef.current = false\n                queryWasClearedOnFocusRef.current = query.trim().length > 0\n                if (queryWasClearedOnFocusRef.current) setQuery('')\n              }}\n              onChange={(e) => {\n                queryEditedRef.current = true\n                setQuery(e.target.value)\n              }}\n              onBlur={() => {\n                if (queryWasClearedOnFocusRef.current && !queryEditedRef.current) {\n                  setQuery(queryBackupRef.current)\n                }\n                queryWasClearedOnFocusRef.current = false\n                queryEditedRef.current = false\n              }}\n              placeholder=\"e.g. chicken breast\"\n              className=\"flex-1 px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-emerald-500 focus:border-emerald-500\"\n            />\n            <button\n              type=\"button\"\n              disabled={busy}\n              onClick={runSearch}\n              className=\"px-4 py-2 rounded-lg bg-slate-900 text-white text-sm font-semibold disabled:opacity-60\"\n            >\n              Search\n            </button>\n          </div>\n          <div className=\"flex gap-2\">\n            <button\n              type=\"button\"\n              onClick={() => setKind('packaged')}\n              className={`flex-1 px-3 py-2 rounded-lg border text-sm font-semibold ${\n                kind === 'packaged' ? 'bg-emerald-600 text-white border-emerald-600' : 'bg-white text-gray-700 border-gray-200'\n              }`}\n            >\n              Packaged\n            </button>\n            <button\n              type=\"button\"\n              onClick={() => setKind('single')}\n              className={`flex-1 px-3 py-2 rounded-lg border text-sm font-semibold ${\n                kind === 'single' ? 'bg-slate-800 text-white border-slate-800' : 'bg-white text-gray-700 border-gray-200'\n              }`}\n            >\n              Single food\n            </button>\n          </div>\n          <div className=\"flex flex-col gap-2 pt-1\">\n            <div className=\"grid grid-cols-2 sm:grid-cols-3 gap-2\">\n              <button\n                type=\"button\"\n                disabled={busy}\n                onClick={() => {\n                  triggerHaptic(10)\n                  photoInputRef.current?.click()\n                }}\n                className=\"px-3 py-2 rounded-lg border border-gray-200 bg-white text-sm font-semibold text-gray-800 hover:bg-gray-50 disabled:opacity-60\"\n              >\n                {photoLoading ? 'Adding photo‚Ä¶' : 'Add by photo'}\n              </button>\n              <button\n                type=\"button\"\n                disabled={busy}\n                onClick={() => setShowBarcodeScanner(true)}\n                className=\"px-3 py-2 rounded-lg border border-gray-200 bg-white text-sm font-semibold text-gray-800 hover:bg-gray-50 disabled:opacity-60\"\n              >\n                {barcodeLoading ? 'Looking up‚Ä¶' : 'Scan barcode'}\n              </button>\n              <button\n                type=\"button\"\n                disabled={busy}\n                onClick={() => {\n                  setFavoritesActiveTab('all')\n                  setFavoritesSearch('')\n                  setShowFavoritesPicker(true)\n                }}\n                className=\"col-span-2 sm:col-span-1 px-3 py-2 rounded-lg border border-gray-200 bg-white text-sm font-semibold text-gray-800 hover:bg-gray-50 disabled:opacity-60\"\n              >\n                Add from favorites\n              </button>\n            </div>\n            <input\n              ref={photoInputRef}\n              type=\"file\"\n              accept=\"image/*\"\n              className=\"hidden\"\n              onChange={(e) => {\n                const f = e.target.files?.[0]\n                if (f) analyzePhotoAndAdd(f)\n              }}\n            />\n          </div>\n\n          <UsageMeter inline className=\"mt-1\" feature=\"foodAnalysis\" />\n\n          {photoPreviewUrl && (\n            <div className=\"rounded-xl border border-gray-200 bg-gray-50 overflow-hidden\">\n              <div className=\"relative w-full max-w-sm mx-auto\">\n                {photoLoading && (\n                  <div className=\"absolute inset-0 bg-white/70 flex items-center justify-center\">\n                    <div className=\"w-10 h-10 border-4 border-emerald-100 border-t-emerald-500 rounded-full animate-spin\" />\n                  </div>\n                )}\n                {/* eslint-disable-next-line @next/next/no-img-element */}\n                <img\n                  src={photoPreviewUrl}\n                  alt=\"Analyzed food\"\n                  className=\"w-full aspect-square object-cover\"\n                />\n              </div>\n              <div className=\"px-3 py-2 text-xs text-gray-600 flex items-center justify-between gap-2\">\n                <span>{photoLoading ? 'Analyzing photo‚Ä¶' : 'Photo added'}</span>\n                <button\n                  type=\"button\"\n                  onClick={() => {\n                    try {\n                      if (photoPreviewUrl) URL.revokeObjectURL(photoPreviewUrl)\n                    } catch {}\n                    setPhotoPreviewUrl(null)\n                    try {\n                      if (photoInputRef.current) photoInputRef.current.value = ''\n                    } catch {}\n                  }}\n                  className=\"text-xs font-semibold text-gray-700 hover:text-gray-900\"\n                >\n                  Remove\n                </button>\n              </div>\n            </div>\n          )}\n\n          {error && <div className=\"text-xs text-red-600\">{error}</div>}\n          {(searchLoading || savingMeal || photoLoading || barcodeLoading) && (\n            <div className=\"text-xs text-gray-500\">\n              {searchLoading\n                ? 'Searching‚Ä¶'\n                : savingMeal\n                ? 'Saving‚Ä¶'\n                : photoLoading\n                ? 'Analyzing photo‚Ä¶'\n                : barcodeLoading\n                ? 'Looking up barcode‚Ä¶'\n                : 'Working‚Ä¶'}\n            </div>\n          )}\n\n          {results.length > 0 && (\n            <div className=\"max-h-72 overflow-y-auto space-y-2 pt-1\">\n              {results.map((r) => (\n                <div key={`${r.source}:${r.id}`} className=\"flex items-start justify-between rounded-xl border border-gray-200 px-3 py-2\">\n                  <div className=\"min-w-0\">\n                    <div className=\"text-sm font-semibold text-gray-900 truncate\">\n                      {r.name}\n                      {r.brand ? ` ‚Äì ${r.brand}` : ''}\n                    </div>\n                    <div className=\"text-[11px] text-gray-500\">\n                      {r.serving_size ? `Serving: ${r.serving_size}` : 'Serving: (unknown)'}\n                    </div>\n                  </div>\n                  <button\n                    type=\"button\"\n                    onClick={() => addItem(r)}\n                    className=\"ml-3 px-3 py-1.5 rounded-lg bg-emerald-600 text-white text-xs font-semibold\"\n                  >\n                    Add\n                  </button>\n                </div>\n              ))}\n            </div>\n          )}\n        </div>\n\n        <div className=\"rounded-2xl border border-gray-200 bg-white p-3 sm:p-4 space-y-3\">\n          <div className=\"flex items-center justify-between\">\n            <div className=\"text-sm font-semibold text-gray-900\">Your ingredients</div>\n            <div className=\"text-xs text-gray-500\">{items.length} item{items.length === 1 ? '' : 's'}</div>\n          </div>\n\n          {items.length === 0 ? (\n            <div className=\"text-sm text-gray-500\">Add ingredients using the search above.</div>\n          ) : (\n            <div className=\"space-y-2\">\n              {items.map((it) => {\n                const expanded = expandedId === it.id\n                const baseUnits = allowedUnitsForBase(it.__baseUnit)\n                const totals = computeItemTotals(it)\n                return (\n                  <div\n                    key={it.id}\n                    data-builder-item-id={it.id}\n                    className=\"rounded-2xl border border-gray-200 overflow-hidden\"\n                  >\n                    <button\n                      type=\"button\"\n                      onClick={() => setExpandedId(expanded ? null : it.id)}\n                      className=\"w-full flex items-center justify-between px-3 py-3 bg-white hover:bg-gray-50\"\n                    >\n                      <div className=\"min-w-0 text-left\">\n                        <div className=\"text-sm font-semibold text-gray-900 truncate\">\n                          {it.name}\n                          {it.brand ? ` ‚Äì ${it.brand}` : ''}\n                        </div>\n                        <div className=\"text-[11px] text-gray-500 truncate\">\n                          {it.serving_size ? `Serving: ${it.serving_size}` : 'Serving: (unknown)'} ‚Ä¢{' '}\n                          {it.__baseUnit ? `Amount: ${it.__amount} ${it.__unit || it.__baseUnit}` : `Servings: ${it.servings}`}\n                        </div>\n                      </div>\n                      <div className=\"flex items-center gap-2\">\n                        <span className=\"text-gray-400\">{expanded ? '‚ñæ' : '‚ñ∏'}</span>\n                      </div>\n                    </button>\n\n                    {expanded && (\n                      <div className=\"px-3 pb-3 bg-white space-y-3\">\n                        <div className=\"grid grid-cols-2 gap-2\">\n                          <div className=\"space-y-1\">\n                            <div className=\"text-xs font-semibold text-gray-700\">Amount</div>\n                            <input\n                              type=\"text\"\n                              inputMode=\"decimal\"\n                              value={it.__amountInput}\n                              onChange={(e) => setAmount(it.id, e.target.value)}\n                              onFocus={() => setAmount(it.id, '')}\n                              className=\"w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-emerald-500 focus:border-emerald-500\"\n                            />\n                          </div>\n                          <div className=\"space-y-1\">\n                            <div className=\"text-xs font-semibold text-gray-700\">Serving size</div>\n                            {baseUnits.length > 0 ? (\n                              <select\n                                value={it.__unit || it.__baseUnit || baseUnits[0]}\n                                onChange={(e) => setUnit(it.id, e.target.value as BuilderUnit)}\n                                className=\"w-full px-3 py-2 border border-gray-300 rounded-lg bg-white focus:ring-2 focus:ring-emerald-500 focus:border-emerald-500\"\n                              >\n                                {baseUnits.map((u) => (\n                                  <option key={u} value={u}>\n                                    {u}\n                                  </option>\n                                ))}\n                              </select>\n                            ) : (\n                              <div className=\"w-full px-3 py-2 border border-gray-200 rounded-lg bg-gray-50 text-sm text-gray-600\">\n                                servings\n                              </div>\n                            )}\n                          </div>\n                        </div>\n\n                        <div className=\"flex flex-wrap gap-2\">\n                          <div className=\"px-3 py-1 rounded-full bg-gray-100 border border-gray-200 text-[11px] font-medium text-gray-700\">\n                            <span className=\"font-semibold text-gray-900\">{Math.round(totals.calories)}</span> kcal\n                          </div>\n                          <div className=\"px-3 py-1 rounded-full bg-gray-100 border border-gray-200 text-[11px] font-medium text-gray-700\">\n                            <span className=\"font-semibold text-gray-900\">{round3(totals.protein)}</span> g protein\n                          </div>\n                          <div className=\"px-3 py-1 rounded-full bg-gray-100 border border-gray-200 text-[11px] font-medium text-gray-700\">\n                            <span className=\"font-semibold text-gray-900\">{round3(totals.carbs)}</span> g carbs\n                          </div>\n                          <div className=\"px-3 py-1 rounded-full bg-gray-100 border border-gray-200 text-[11px] font-medium text-gray-700\">\n                            <span className=\"font-semibold text-gray-900\">{round3(totals.fat)}</span> g fat\n                          </div>\n                          <div className=\"px-3 py-1 rounded-full bg-gray-100 border border-gray-200 text-[11px] font-medium text-gray-700\">\n                            <span className=\"font-semibold text-gray-900\">{round3(totals.fiber)}</span> g fibre\n                          </div>\n                          <div className=\"px-3 py-1 rounded-full bg-gray-100 border border-gray-200 text-[11px] font-medium text-gray-700\">\n                            <span className=\"font-semibold text-gray-900\">{round3(totals.sugar)}</span> g sugar\n                          </div>\n                        </div>\n\n                        <button\n                          type=\"button\"\n                          onClick={(e) => {\n                            e.preventDefault()\n                            e.stopPropagation()\n                            removeItem(it.id)\n                          }}\n                          className=\"w-full mt-2 px-3 py-2 rounded-lg border border-red-200 bg-red-50 text-sm font-semibold text-red-700 hover:bg-red-100\"\n                        >\n                          Remove ingredient\n                        </button>\n                      </div>\n                    )}\n                  </div>\n                )\n              })}\n            </div>\n          )}\n        </div>\n\n        <div className=\"rounded-2xl border border-gray-200 bg-white p-3 sm:p-4\">\n          <div className=\"text-sm font-semibold text-gray-900 mb-2\">Meal totals</div>\n          <div className=\"grid grid-cols-2 gap-2 text-sm\">\n            <div className=\"flex items-center justify-between px-3 py-2 rounded-xl bg-gray-50 border border-gray-200\">\n              <span className=\"text-gray-700\">Calories</span>\n              <span className=\"font-semibold text-gray-900\">{Math.round(mealTotals.calories)} kcal</span>\n            </div>\n            <div className=\"flex items-center justify-between px-3 py-2 rounded-xl bg-gray-50 border border-gray-200\">\n              <span className=\"text-gray-700\">Protein</span>\n              <span className=\"font-semibold text-gray-900\">{round3(mealTotals.protein)} g</span>\n            </div>\n            <div className=\"flex items-center justify-between px-3 py-2 rounded-xl bg-gray-50 border border-gray-200\">\n              <span className=\"text-gray-700\">Carbs</span>\n              <span className=\"font-semibold text-gray-900\">{round3(mealTotals.carbs)} g</span>\n            </div>\n            <div className=\"flex items-center justify-between px-3 py-2 rounded-xl bg-gray-50 border border-gray-200\">\n              <span className=\"text-gray-700\">Fat</span>\n              <span className=\"font-semibold text-gray-900\">{round3(mealTotals.fat)} g</span>\n            </div>\n            <div className=\"flex items-center justify-between px-3 py-2 rounded-xl bg-gray-50 border border-gray-200\">\n              <span className=\"text-gray-700\">Fibre</span>\n              <span className=\"font-semibold text-gray-900\">{round3(mealTotals.fiber)} g</span>\n            </div>\n            <div className=\"flex items-center justify-between px-3 py-2 rounded-xl bg-gray-50 border border-gray-200\">\n              <span className=\"text-gray-700\">Sugar</span>\n              <span className=\"font-semibold text-gray-900\">{round3(mealTotals.sugar)} g</span>\n            </div>\n          </div>\n        </div>\n\n        <button\n          type=\"button\"\n          onClick={createMeal}\n          disabled={busy}\n          className=\"w-full py-3 px-4 bg-emerald-600 hover:bg-emerald-700 disabled:opacity-60 text-white font-semibold rounded-2xl\"\n        >\n          Save meal\n        </button>\n\n        <div className=\"pb-10\" />\n        </div>\n      </div>\n    </div>\n  )\n}\n","truncated":false,"size":80745},{"path":"app/food/build-meal/page.tsx","content":"import MealBuilderClient from './MealBuilderClient'\n\nexport const dynamic = 'force-dynamic'\n\nexport default function BuildMealPage() {\n  return <MealBuilderClient />\n}\n\n","truncated":false,"size":169},{"path":"app/food/page.tsx","content":"'use client'\nimport { Cog6ToothIcon, HandThumbDownIcon, HandThumbUpIcon, UserIcon } from '@heroicons/react/24/outline'\n/**\n * ABSOLUTE GUARD RAIL ‚Äì READ BEFORE EDITING\n *\n * This file contains the main Food Analyzer + Food Diary experience. The user\n * considers this flow ‚Äúlocked‚Äù. Do NOT change analysis logic, nutrition math,\n * diary loading, or credit/billing behaviour here unless:\n *   1) You have read `GUARD_RAILS.md` (Food Diary + Credits sections), and\n *   2) The user has explicitly asked for the specific change you are making.\n *\n * It is safe to adjust small UI copy or layout around the feature, but any\n * deeper logic changes require written approval.\n *\n * This page expects AI responses to include ONE nutrition line exactly like:\n *   Calories: N, Protein: Ng, Carbs: Ng, Fat: Ng\n * The API enforces this and also has a fallback extractor.\n * If you change regexes or presentation, TEST that all four values still render.\n *\n * ‚ö†Ô∏è Additional lock (GUARD_RAILS.md ¬ß3.9):\n * - Do NOT change servings/pieces/weight sync or `piecesPerServing` defaults.\n * - Do NOT weaken patty/cheese/bacon/egg per-piece macros/weights.\n * - Keep the analyzed photo compact on desktop; keep category ‚Äú+‚Äù visible.\n * Any change requires explicit written approval from the user.\n */\n\nimport React, { useState, useEffect, useMemo, useRef, useCallback, Component } from 'react'\nimport { useSession, signOut } from 'next-auth/react'\nimport Link from 'next/link'\nimport Image from 'next/image'\nimport { usePathname, useRouter } from 'next/navigation'\nimport { useUserData } from '@/components/providers/UserDataProvider'\nimport MobileMoreMenu from '@/components/MobileMoreMenu'\nimport UsageMeter from '@/components/UsageMeter'\nimport FeatureUsageDisplay from '@/components/FeatureUsageDisplay'\nimport CreditPurchaseModal from '@/components/CreditPurchaseModal'\nimport { STARTER_FOODS } from '@/data/foods-starter'\nimport { COMMON_USDA_FOODS } from '@/data/usda-common'\nimport { calculateDailyTargets } from '@/lib/daily-targets'\nimport { AI_MEAL_RECOMMENDATION_CREDITS } from '@/lib/ai-meal-recommendation'\nimport { SolidMacroRing } from '@/components/SolidMacroRing'\nimport { checkMultipleDietCompatibility, normalizeDietTypes } from '@/lib/diets'\n\nconst NUTRIENT_DISPLAY_ORDER: Array<'calories' | 'protein' | 'carbs' | 'fat' | 'fiber' | 'sugar'> = ['calories', 'protein', 'carbs', 'fat', 'fiber', 'sugar']\n\nconst NUTRIENT_CARD_META: Record<typeof NUTRIENT_DISPLAY_ORDER[number], { label: string; unit?: string; gradient: string; accent: string }> = {\n  calories: { label: 'Calories', unit: '', gradient: 'from-orange-50 to-orange-100', accent: 'text-orange-500' },\n  protein: { label: 'Protein', unit: 'g', gradient: 'from-blue-50 to-blue-100', accent: 'text-blue-500' },\n  carbs: { label: 'Carbs', unit: 'g', gradient: 'from-green-50 to-green-100', accent: 'text-green-500' },\n  fat: { label: 'Fat', unit: 'g', gradient: 'from-purple-50 to-purple-100', accent: 'text-purple-500' },\n  fiber: { label: 'Fiber', unit: 'g', gradient: 'from-amber-50 to-amber-100', accent: 'text-amber-500' },\n  sugar: { label: 'Sugar', unit: 'g', gradient: 'from-pink-50 to-pink-100', accent: 'text-pink-500' },\n}\n\nconst ITEM_NUTRIENT_META = [\n  { key: 'calories', field: 'calories', label: 'Cal', unit: '', accent: 'text-orange-600' },\n  { key: 'protein', field: 'protein_g', label: 'Protein', unit: 'g', accent: 'text-blue-600' },\n  { key: 'carbs', field: 'carbs_g', label: 'Carbs', unit: 'g', accent: 'text-green-600' },\n  { key: 'fat', field: 'fat_g', label: 'Fat', unit: 'g', accent: 'text-purple-600' },\n  { key: 'fiber', field: 'fiber_g', label: 'Fiber', unit: 'g', accent: 'text-amber-600' },\n  { key: 'sugar', field: 'sugar_g', label: 'Sugar', unit: 'g', accent: 'text-pink-600' },\n] as const\n\ntype NutritionTotals = {\n  calories: number | null\n  protein: number | null\n  carbs: number | null\n  fat: number | null\n  fiber: number | null\n  sugar: number | null\n}\n\nconst formatServingsDisplay = (value: number | null | undefined) => {\n  const numeric = Number(value)\n  if (!Number.isFinite(numeric) || numeric <= 0) return '1'\n  // Normalize to 2dp but guard against floating drift (e.g. 1.249999 ‚Üí 1.25)\n  const normalized = Math.round(numeric * 1000) / 1000 // 3dp safety\n  const rounded = Math.round(normalized * 100) / 100\n  if (Number.isInteger(rounded)) return String(rounded)\n  return rounded.toFixed(2).replace(/\\.0+$/, '').replace(/(\\.[1-9])0$/, '$1')\n}\n\nconst buildMealSummaryFromItems = (items: any[] | null | undefined) => {\n  if (!Array.isArray(items) || items.length === 0) return ''\n\n  // Strip any embedded nutrition text from the item name so the green\n  // summary line stays clean (just names and portion sizes). Some LLM\n  // prompts have historically included things like \"(150 calories, 5g\n  // protein, 28g carbs, 3g fat)\" inside the name field ‚Äì we never want\n  // those repeated in the title area.\n  const stripNutritionFromName = (raw: string) =>\n    String(raw || '')\n      // Remove parenthetical groups that look like nutrition info\n      .replace(/\\([^)]*(calories?|protein|carbs?|fat|fibre|fiber|sugar)[^)]*\\)/gi, '')\n      .replace(/\\s+/g, ' ')\n      .trim()\n\n  const summaryParts = items.map((item) => {\n    const pieces: string[] = []\n    const servings = Number(item?.servings)\n    const piecesCount = Number((item as any)?.piecesPerServing) || Number((item as any)?.pieces)\n    if (Number.isFinite(piecesCount) && piecesCount > 1) {\n      pieces.push(`${Math.round(piecesCount)}`)\n    } else if (Number.isFinite(servings) && Math.abs(servings - 1) > 0.001) {\n      pieces.push(`${formatServingsDisplay(servings)}√ó`)\n    }\n    if (item?.brand) {\n      pieces.push(String(item.brand))\n    }\n    const cleanName = stripNutritionFromName(item?.name ? String(item.name) : 'Food item')\n    pieces.push(cleanName || 'Food item')\n    if (item?.serving_size) {\n      pieces.push(`(${item.serving_size})`)\n    }\n    return pieces.join(' ').replace(/\\s+/g, ' ').trim()\n  })\n\n  return summaryParts.join(', ')\n}\n\nconst stripNutritionFromServingSize = (raw: string) => {\n  return String(raw || '')\n    .replace(/\\([^)]*(calories?|kcal|kilojoules?|kj|protein|carbs?|fat|fibre|fiber|sugar)[^)]*\\)/gi, '')\n    .replace(/\\b\\d+(?:\\.\\d+)?\\s*(kcal|cal|kj)\\b[^,)]*(?:protein|carb|fat|fiber|fibre|sugar)[^,)]*/gi, '')\n    .replace(/\\s+/g, ' ')\n    .trim()\n}\n\nconst buildTodayIso = () => {\n  const d = new Date()\n  const y = d.getFullYear()\n  const m = String(d.getMonth() + 1).padStart(2, '0')\n  const day = String(d.getDate()).padStart(2, '0')\n  return `${y}-${m}-${day}`\n}\n\nconst alignTimestampToLocalDate = (rawCreatedAt: any, localDate?: string | null) => {\n  const base = rawCreatedAt ? new Date(rawCreatedAt) : new Date()\n  const safeBase = Number.isFinite(base.getTime()) ? base : new Date()\n  if (typeof localDate === 'string' && /^\\d{4}-\\d{2}-\\d{2}$/.test(localDate)) {\n    const [y, m, d] = localDate.split('-').map((v) => parseInt(v, 10))\n    if (Number.isFinite(y) && Number.isFinite(m) && Number.isFinite(d)) {\n      const anchored = new Date(\n        y,\n        (m || 1) - 1,\n        d || 1,\n        safeBase.getHours(),\n        safeBase.getMinutes(),\n        safeBase.getSeconds(),\n        safeBase.getMilliseconds(),\n      )\n      return anchored.toISOString()\n    }\n  }\n  return safeBase.toISOString()\n}\n\nconst BARCODE_REGION_ID = 'food-barcode-reader'\n// Reset older history items from showing in the \"All\" tab. Only entries created after this\n// timestamp will be included in the All list so we can start fresh after data corruption.\n// (Dec 12, 2025 09:47:56 UTC)\nconst HISTORY_RESET_EPOCH_MS = 1765532876309\nconst HISTORY_RESET_UTC_DATE = new Date(HISTORY_RESET_EPOCH_MS).toISOString().slice(0, 10) // 2025-12-12\nconst EMPTY_TOTALS = { calories: 0, protein: 0, carbs: 0, fat: 0, fiber: 0, sugar: 0 }\n\nclass DiaryErrorBoundary extends Component<{ children: React.ReactNode }, { hasError: boolean }> {\n  constructor(props: any) {\n    super(props)\n    this.state = { hasError: false }\n  }\n  static getDerivedStateFromError() {\n    return { hasError: true }\n  }\n  componentDidCatch(error: any, info: any) {\n    console.error('Diary render error', error, info)\n  }\n  render() {\n    if (this.state.hasError) {\n      return (\n        <div className=\"p-6 text-center text-sm text-red-700 bg-red-50 border border-red-200\">\n          Something went wrong loading this entry. Please reload. If it repeats, copy the console error and share it.\n        </div>\n      )\n    }\n    return this.props.children\n  }\n}\n\ntype WarmDiaryState = {\n  selectedDate?: string\n  todaysFoods?: any[]\n  historyByDate?: Record<string, any[]>\n  expandedCategories?: Record<string, boolean>\n}\n\nconst readWarmDiaryState = (): WarmDiaryState | null => {\n  if (typeof window === 'undefined') return null\n  try {\n    const raw = sessionStorage.getItem('foodDiary:warmState')\n    if (!raw) return null\n\n... [truncated] ...\n\n            onClick={(e) => e.stopPropagation()}\n          >\n            <div className=\"flex items-start justify-between mb-3\">\n              <div>\n                <h2 className=\"text-base sm:text-lg font-semibold text-gray-900\">\n                  {macroPopup.title}\n                </h2>\n                {macroPopup.energyLabel && (\n                  <p className=\"text-xs sm:text-sm text-gray-500 mt-0.5\">\n                    Total energy: {macroPopup.energyLabel}\n                  </p>\n                )}\n              </div>\n              <button\n                type=\"button\"\n                onClick={() => setMacroPopup(null)}\n                className=\"text-gray-400 hover:text-gray-600\"\n              >\n                <span className=\"sr-only\">Close</span>\n                <svg className=\"w-5 h-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M6 18L18 6M6 6l12 12\" />\n                </svg>\n              </button>\n            </div>\n            <div className=\"flex flex-col items-center\">\n              <MacroRing macros={macroPopup.macros} showLegend size=\"large\" />\n              <button\n                type=\"button\"\n                onClick={() => setMacroPopup(null)}\n                className=\"mt-4 inline-flex items-center justify-center px-4 py-2 text-sm font-medium rounded-full bg-gray-900 text-white hover:bg-gray-800\"\n              >\n                Close\n              </button>\n            </div>\n          </div>\n        </div>\n      )}\n\n        {/* Full Size Image Modal */}\n        {fullSizeImage && (\n          <div \n            className=\"fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4\"\n            onClick={() => setFullSizeImage(null)}\n          >\n            <div className=\"relative max-w-4xl max-h-full\">\n              <button\n                onClick={() => setFullSizeImage(null)}\n                className=\"absolute -top-12 right-0 text-white hover:text-gray-300 transition-colors\"\n              >\n                <svg className=\"w-8 h-8\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M6 18L18 6M6 6l12 12\" />\n                </svg>\n              </button>\n              <Image\n                src={fullSizeImage}\n                alt=\"Full size food image\"\n                width={800}\n                height={600}\n                className=\"max-w-full max-h-full object-contain rounded-lg\"\n                onClick={(e) => e.stopPropagation()}\n              />\n            </div>\n          </div>\n        )}\n        </div>\n      </div>\n\n      {/* Credit Purchase Modal */}\n      <CreditPurchaseModal\n        isOpen={showCreditsModal}\n        onClose={() => setShowCreditsModal(false)}\n        creditInfo={creditInfo}\n      />\n\n      {/* Mobile Bottom Navigation - with pressed, ripple and active states */}\n      <nav className=\"md:hidden fixed bottom-0 left-0 right-0 bg-white border-t border-gray-200 px-4 py-2 z-40\">\n        <div className=\"flex items-center justify-around\">\n          <Link href=\"/dashboard\" className=\"pressable ripple flex flex-col items-center py-2 px-1 min-w-0 flex-1\" onClick={() => { try { const reduced = window.matchMedia('(prefers-reduced-motion: reduce)')?.matches; const pref = localStorage.getItem('hapticsEnabled'); const enabled = pref === null ? true : pref === 'true'; if (enabled && !reduced && 'vibrate' in navigator) navigator.vibrate(10) } catch {} }}>\n            <div className={`icon ${pathname === '/dashboard' ? 'text-helfi-green' : 'text-gray-400'}`}>\n              <svg className=\"w-6 h-6\" fill=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path d=\"M3 13h8V3H3v10zm0 8h8v-6H3v6zm10 0h8V11h-8v10zm0-18v6h8V3h-8z\"/>\n              </svg>\n            </div>\n            <span className={`label text-xs mt-1 truncate ${pathname === '/dashboard' ? 'text-helfi-green font-bold' : 'text-gray-400 font-medium'}`}>Dashboard</span>\n          </Link>\n\n          <Link href=\"/insights\" className=\"pressable ripple flex flex-col items-center py-2 px-1 min-w-0 flex-1\" onClick={() => { try { const reduced = window.matchMedia('(prefers-reduced-motion: reduce)')?.matches; const pref = localStorage.getItem('hapticsEnabled'); const enabled = pref === null ? true : pref === 'true'; if (enabled && !reduced && 'vibrate' in navigator) navigator.vibrate(10) } catch {} }}>\n            <div className={`icon ${pathname === '/insights' ? 'text-helfi-green' : 'text-gray-400'}`}>\n              <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z\" />\n              </svg>\n            </div>\n            <span className={`label text-xs mt-1 truncate ${pathname === '/insights' ? 'text-helfi-green font-bold' : 'text-gray-400 font-medium'}`}>Insights</span>\n          </Link>\n\n          <Link href=\"/food\" className=\"pressable ripple flex flex-col items-center py-2 px-1 min-w-0 flex-1\" onClick={() => { try { const reduced = window.matchMedia('(prefers-reduced-motion: reduce)')?.matches; const pref = localStorage.getItem('hapticsEnabled'); const enabled = pref === null ? true : pref === 'true'; if (enabled && !reduced && 'vibrate' in navigator) navigator.vibrate(10) } catch {} }}>\n            <div className={`icon ${pathname === '/food' ? 'text-helfi-green' : 'text-gray-400'}`}>\n              <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10\" />\n              </svg>\n            </div>\n            <span className={`label text-xs mt-1 truncate ${pathname === '/food' ? 'text-helfi-green font-bold' : 'text-gray-400 font-medium'}`}>Food</span>\n          </Link>\n\n          <MobileMoreMenu />\n\n          <Link href=\"/settings\" className=\"pressable ripple flex flex-col items-center py-2 px-1 min-w-0 flex-1\" onClick={() => { try { const reduced = window.matchMedia('(prefers-reduced-motion: reduce)')?.matches; const pref = localStorage.getItem('hapticsEnabled'); const enabled = pref === null ? true : pref === 'true'; if (enabled && !reduced && 'vibrate' in navigator) navigator.vibrate(10) } catch {} }}>\n            <div className={`icon ${pathname === '/settings' ? 'text-helfi-green' : 'text-gray-400'}`}>\n              <Cog6ToothIcon className=\"w-6 h-6 flex-shrink-0\" style={{ minWidth: '24px', minHeight: '24px' }} />\n            </div>\n            <span className={`label text-xs mt-1 truncate ${pathname === '/settings' ? 'text-helfi-green font-bold' : 'text-gray-400 font-medium'}`}>Settings</span>\n          </Link>\n        </div>\n      </nav>\n      </div>\n    </div>\n    </DiaryErrorBoundary>\n  )\n}\n","truncated":true,"size":778941},{"path":"app/food/recommended/explain/page.tsx","content":"import RecommendedExplainClient from './RecommendedExplainClient'\n\nexport const dynamic = 'force-dynamic'\n\nexport default function RecommendedExplainPage() {\n  return <RecommendedExplainClient />\n}\n\n","truncated":false,"size":199},{"path":"app/food/recommended/explain/RecommendedExplainClient.tsx","content":"'use client'\n\nimport { useEffect, useMemo } from 'react'\nimport { useRouter, useSearchParams } from 'next/navigation'\nimport { AI_MEAL_RECOMMENDATION_CREDITS, CATEGORY_LABELS, normalizeMealCategory } from '@/lib/ai-meal-recommendation'\n\nconst buildTodayIso = () => {\n  const d = new Date()\n  const y = d.getFullYear()\n  const m = String(d.getMonth() + 1).padStart(2, '0')\n  const day = String(d.getDate()).padStart(2, '0')\n  return `${y}-${m}-${day}`\n}\n\nexport default function RecommendedExplainClient() {\n  const router = useRouter()\n  const searchParams = useSearchParams()\n\n  const date = searchParams.get('date') || buildTodayIso()\n  const category = normalizeMealCategory(searchParams.get('category'))\n  const categoryLabel = CATEGORY_LABELS[category]\n  const returnTo = searchParams.get('returnTo') || ''\n\n  const continueHref = useMemo(() => {\n    if (returnTo) return returnTo\n    const qs = new URLSearchParams()\n    qs.set('date', date)\n    qs.set('category', category)\n    qs.set('generate', '1')\n    return `/food/recommended?${qs.toString()}`\n  }, [date, category, returnTo])\n\n  // Mark as seen immediately so it never shows again for this user (server-persisted).\n  useEffect(() => {\n    try {\n      fetch('/api/ai-meal-recommendation', { method: 'PUT' }).catch(() => {})\n    } catch {}\n  }, [])\n\n  return (\n    <div className=\"min-h-screen bg-white\">\n      <div className=\"sticky top-0 z-10 bg-white border-b border-gray-200\">\n        <div className=\"flex items-center gap-3 px-4 py-3\">\n          <button\n            type=\"button\"\n            onClick={() => router.push('/food')}\n            className=\"p-2 rounded-full hover:bg-gray-100\"\n            aria-label=\"Back\"\n          >\n            <span aria-hidden>‚Üê</span>\n          </button>\n          <div className=\"flex-1 min-w-0\">\n            <div className=\"text-lg font-semibold text-gray-900 truncate\">AI Recommended {categoryLabel}</div>\n            <div className=\"text-xs text-gray-500\">{date}</div>\n          </div>\n        </div>\n      </div>\n\n      <div className=\"px-4 py-5\">\n        <div className=\"w-full max-w-3xl mx-auto space-y-4\">\n          <div className=\"rounded-2xl border border-gray-200 bg-white p-5\">\n            <p className=\"text-sm text-gray-700 leading-relaxed\">\n              Get a {categoryLabel.toLowerCase()} suggestion based on your health setup and today‚Äôs remaining calories/macros.\n            </p>\n            <p className=\"mt-2 text-sm text-gray-700 leading-relaxed\">\n              You‚Äôll get a complete meal, ingredient cards you can adjust, and a short explanation.\n            </p>\n            <div className=\"mt-4 rounded-xl border border-emerald-200 bg-emerald-50 px-4 py-3\">\n              <div className=\"text-sm font-semibold text-emerald-900\">\n                Cost: {AI_MEAL_RECOMMENDATION_CREDITS} credits per recommendation\n              </div>\n              <div className=\"text-xs text-emerald-800 mt-1\">Credits are only spent when a recommendation is generated.</div>\n              <div className=\"text-[11px] text-emerald-800 mt-2\">You‚Äôll only see this screen once.</div>\n            </div>\n          </div>\n\n          <div className=\"flex flex-col sm:flex-row gap-3\">\n            <button\n              type=\"button\"\n              onClick={() => router.push(continueHref)}\n              className=\"flex-1 px-4 py-3 rounded-2xl bg-emerald-600 text-white font-semibold hover:bg-emerald-700\"\n            >\n              Continue &amp; Generate Recommendation\n            </button>\n            <button\n              type=\"button\"\n              onClick={() => router.push('/food')}\n              className=\"flex-1 px-4 py-3 rounded-2xl bg-gray-100 text-gray-900 font-semibold hover:bg-gray-200\"\n            >\n              Cancel\n            </button>\n          </div>\n        </div>\n      </div>\n    </div>\n  )\n}\n","truncated":false,"size":3835},{"path":"app/food/recommended/page.tsx","content":"import RecommendedMealClient from './RecommendedMealClient'\n\nexport const dynamic = 'force-dynamic'\n\nexport default function RecommendedMealPage() {\n  return <RecommendedMealClient />\n}\n\n","truncated":false,"size":187},{"path":"app/food/recommended/RecommendedMealClient.tsx","content":"'use client'\n\nimport { useEffect, useMemo, useRef, useState } from 'react'\nimport Link from 'next/link'\nimport { useRouter, useSearchParams } from 'next/navigation'\nimport { useUserData } from '@/components/providers/UserDataProvider'\nimport RecommendedIngredientCard from '@/components/food/RecommendedIngredientCard'\nimport DailyMacroSummary from '@/components/food/DailyMacroSummary'\nimport {\n  AI_MEAL_RECOMMENDATION_CREDITS,\n  CATEGORY_LABELS,\n  MealCategory,\n  normalizeMealCategory,\n} from '@/lib/ai-meal-recommendation'\n\ntype MacroTotals = {\n  calories: number | null\n  protein_g: number | null\n  carbs_g: number | null\n  fat_g: number | null\n  fiber_g: number | null\n  sugar_g: number | null\n}\n\ntype RecommendedItem = {\n  id?: string\n  name: string\n  serving_size?: string | null\n  calories?: number | null\n  protein_g?: number | null\n  carbs_g?: number | null\n  fat_g?: number | null\n  fiber_g?: number | null\n  sugar_g?: number | null\n  servings: number\n}\n\ntype RecommendedMealRecord = {\n  id: string\n  createdAt: string\n  date: string\n  category: MealCategory\n  mealName: string\n  tags: string[]\n  why: string\n  recipe?: {\n    servings?: number | null\n    prepMinutes?: number | null\n    cookMinutes?: number | null\n    steps: string[]\n  } | null\n  items: RecommendedItem[]\n  totals: MacroTotals\n}\n\ntype RecommendationContext = {\n  targets: MacroTotals\n  used: MacroTotals\n  remaining: MacroTotals\n}\n\ntype ApiGetResponse = {\n  costCredits: number\n  context: RecommendationContext\n  history: RecommendedMealRecord[]\n  seenExplain?: boolean\n}\n\ntype ApiPostResponse = {\n  costCredits: number\n  context: RecommendationContext\n  history: RecommendedMealRecord[]\n  recommendation: RecommendedMealRecord\n  seenExplain?: boolean\n}\n\nconst buildTodayIso = () => {\n  const d = new Date()\n  const y = d.getFullYear()\n  const m = String(d.getMonth() + 1).padStart(2, '0')\n  const day = String(d.getDate()).padStart(2, '0')\n  return `${y}-${m}-${day}`\n}\n\nconst round3 = (n: number) => Math.round(n * 1000) / 1000\n\nconst macroOrZero = (v: any) => (typeof v === 'number' && Number.isFinite(v) ? v : 0)\n\nconst computeTotalsFromItems = (items: RecommendedItem[]): MacroTotals => {\n  const total = { calories: 0, protein_g: 0, carbs_g: 0, fat_g: 0, fiber_g: 0, sugar_g: 0 }\n  for (const item of items) {\n    const servings = typeof item.servings === 'number' && Number.isFinite(item.servings) ? item.servings : 0\n    total.calories += macroOrZero(item.calories) * servings\n    total.protein_g += macroOrZero(item.protein_g) * servings\n    total.carbs_g += macroOrZero(item.carbs_g) * servings\n    total.fat_g += macroOrZero(item.fat_g) * servings\n    total.fiber_g += macroOrZero(item.fiber_g) * servings\n    total.sugar_g += macroOrZero(item.sugar_g) * servings\n  }\n  return {\n    calories: Math.round(total.calories),\n    protein_g: round3(total.protein_g),\n    carbs_g: round3(total.carbs_g),\n    fat_g: round3(total.fat_g),\n    fiber_g: round3(total.fiber_g),\n    sugar_g: round3(total.sugar_g),\n  }\n}\n\nconst alignTimestampToLocalDate = (iso: string, localDate: string) => {\n  try {\n    if (!localDate || localDate.length < 8) return iso\n    const base = new Date(iso)\n    if (Number.isNaN(base.getTime())) return iso\n    const [y, m, d] = localDate.split('-').map((v) => parseInt(v, 10))\n    if (!Number.isFinite(y) || !Number.isFinite(m) || !Number.isFinite(d)) return iso\n    const anchored = new Date(y, m - 1, d, base.getHours(), base.getMinutes(), base.getSeconds(), base.getMilliseconds())\n    return anchored.toISOString()\n  } catch {\n    return iso\n  }\n}\n\nconst normalizeTotalsForFoodLog = (totals: MacroTotals) => ({\n  calories: typeof totals.calories === 'number' ? Math.round(totals.calories) : 0,\n  protein: typeof totals.protein_g === 'number' ? round3(totals.protein_g) : 0,\n  carbs: typeof totals.carbs_g === 'number' ? round3(totals.carbs_g) : 0,\n  fat: typeof totals.fat_g === 'number' ? round3(totals.fat_g) : 0,\n  fiber: typeof totals.fiber_g === 'number' ? round3(totals.fiber_g) : 0,\n  sugar: typeof totals.sugar_g === 'number' ? round3(totals.sugar_g) : 0,\n})\n\nconst formatNumber = (value: number | null | undefined, decimals = 0) => {\n  if (typeof value !== 'number' || !Number.isFinite(value)) return '‚Äî'\n  return decimals > 0 ? value.toFixed(decimals) : String(Math.round(value))\n}\n\nexport default function RecommendedMealClient() {\n  const router = useRouter()\n  const searchParams = useSearchParams()\n  const { userData, updateUserData } = useUserData()\n\n  const date = searchParams.get('date') || buildTodayIso()\n  const category = normalizeMealCategory(searchParams.get('category'))\n  const generateFlag = searchParams.get('generate') === '1'\n  const categoryLabel = CATEGORY_LABELS[category]\n\n  const [loadingContext, setLoadingContext] = useState(true)\n  const [generating, setGenerating] = useState(false)\n  const [error, setError] = useState<string | null>(null)\n  const [context, setContext] = useState<RecommendationContext | null>(null)\n  const [history, setHistory] = useState<RecommendedMealRecord[]>([])\n  const [active, setActive] = useState<RecommendedMealRecord | null>(null)\n  const [itemsDraft, setItemsDraft] = useState<RecommendedItem[] | null>(null)\n  const [savingDiary, setSavingDiary] = useState(false)\n  const [seenExplain, setSeenExplain] = useState<boolean | null>(null)\n  const [commitSaving, setCommitSaving] = useState(false)\n\n  const hasAutoGeneratedRef = useRef(false)\n  const hasReferrerAutoGeneratedRef = useRef(false)\n  const referrerRef = useRef<string>('')\n  const autoGenerateRequestedRef = useRef(false)\n  const hasStrippedGenerateFlagRef = useRef(false)\n\n  const tzOffsetMin = useMemo(() => String(new Date().getTimezoneOffset()), [])\n\n  const draftTotals = useMemo(() => {\n    const items = itemsDraft || active?.items || []\n    return computeTotalsFromItems(items)\n  }, [itemsDraft, active?.items])\n\n  const costCredits = AI_MEAL_RECOMMENDATION_CREDITS\n  const hasRecommendation = Boolean(active)\n  const activeIsCommitted = useMemo(() => {\n    if (!active?.id) return false\n    return history.some((h) => h && h.id === active.id)\n  }, [active?.id, history])\n\n  const load = async () => {\n    setLoadingContext(true)\n    setError(null)\n    try {\n      const qs = new URLSearchParams()\n      qs.set('date', date)\n      qs.set('category', category)\n      qs.set('tz', tzOffsetMin)\n      const res = await fetch(`/api/ai-meal-recommendation?${qs.toString()}`, { cache: 'no-store' })\n      if (!res.ok) {\n        const txt = await res.text().catch(() => '')\n        throw new Error(txt || `Load failed (${res.status})`)\n      }\n      const data = (await res.json()) as ApiGetResponse\n      setContext(data.context)\n      setSeenExplain(typeof data.seenExplain === 'boolean' ? data.seenExplain : null)\n      const nextHistory = Array.isArray(data.history) ? data.history : []\n      setHistory(nextHistory)\n      const defaultActive =\n        nextHistory.find((h) => h && h.category === category) || nextHistory[0] || null\n      setActive(defaultActive)\n    } catch (e: any) {\n      setError(e?.message || 'Unable to load recommendations right now.')\n    } finally {\n      setLoadingContext(false)\n    }\n  }\n\n  const generate = async () => {\n    setGenerating(true)\n    setError(null)\n    try {\n      const res = await fetch('/api/ai-meal-recommendation', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ date, category, tz: tzOffsetMin }),\n      })\n      if (res.status === 402) {\n        setError(`Not enough credits to generate. This costs ${costCredits} credits.`)\n        return\n      }\n      if (!res.ok) {\n        const payload = await res.json().catch(() => null)\n        const msgFromJson =\n          typeof payload?.error === 'string'\n            ? payload.error\n            : typeof payload?.message === 'string'\n              ? payload.message\n              : null\n        if (msgFromJson) throw new Error(msgFromJson)\n        const txt = await res.text().catch(() => '')\n        try {\n          const parsed = txt ? JSON.parse(txt) : null\n          const msgFromText =\n            typeof parsed?.error === 'string'\n              ? parsed.error\n              : typeof parsed?.message === 'string'\n                ? parsed.message\n                : null\n          if (msgFromText) throw new Error(msgFromText)\n        } catch {}\n        throw new Error(txt || `Generate failed (${res.status})`)\n      }\n      const data = (await res.json()) as ApiPostResponse\n      setContext(data.context)\n      setHistory(Array.isArray(data.history) ? data.history : [])\n      setActive(data.recommendation || null)\n      setSeenExplain(true)\n      setItemsDraft(null)\n      try {\n        window.dispatchEvent(new Event('credits:refresh'))\n      } catch {}\n    } catch (e: any) {\n      setError(e?.message || 'Unable to generate a recommendation right now.')\n    } finally {\n      setGenerating(false)\n    }\n  }\n\n  const setActiveFromHistory = (record: RecommendedMealRecord) => {\n    setError(null)\n    setActive(record)\n    setItemsDraft(null)\n  }\n\n  useEffect(() => {\n    load()\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [date, category])\n\n  useEffect(() => {\n    // New date/category should be treated as a fresh screen.\n    hasAutoGeneratedRef.current = false\n    hasReferrerAutoGeneratedRef.current = false\n    autoGenerateRequestedRef.current = false\n    hasStrippedGenerateFlagRef.current = false\n  }, [date, category])\n\n  useEffect(() => {\n    if (typeof document === 'undefined') return\n    try {\n      referrerRef.current = String(document.referrer || '')\n    } catch {}\n  }, [])\n\n  useEffect(() => {\n    if (!generateFlag) return\n    autoGenerateRequestedRef.current = true\n    if (hasStrippedGenerateFlagRef.current) return\n    hasStrippedGenerateFlagRef.current = true\n    // Strip ?generate=1 immediately so browser back/refresh can't repeatedly auto-trigger.\n    try {\n      const qs = new URLSearchParams()\n      qs.set('date', date)\n      qs.set('category', category)\n      router.replace(`/food/recommended?${qs.toString()}`)\n    } catch {}\n  }, [generateFlag, date, category, router])\n\n  useEffect(() => {\n    if (!autoGenerateRequestedRef.current) return\n    if (loadingContext) return\n    if (seenExplain === false) return\n    if (hasAutoGeneratedRef.current) return\n    if (hasRecommendation) return\n    if (history.length > 0) return\n    hasAutoGeneratedRef.current = true\n    autoGenerateRequestedRef.current = false\n    generate()\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [loadingContext, seenExplain, hasRecommendation, history.length])\n\n  useEffect(() => {\n    // UX: if the user navigated here from the Food Diary (same-origin referrer),\n    // auto-generate the first recommendation so there isn't a second \"Generate\" step.\n    if (generateFlag) return\n    if (loadingContext) return\n    if (generating) return\n    if (seenExplain === false) return\n    if (hasRecommendation) return\n    if (history.length > 0) return\n    if (hasReferrerAutoGeneratedRef.current) return\n\n    const ref = (referrerRef.current || '').toLowerCase()\n    const cameFromFoodDiary = ref.includes('/food')\n    if (!cameFromFoodDiary) return\n\n    hasReferrerAutoGeneratedRef.current = true\n    generate()\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [generateFlag, loadingContext, generating, seenExplain, hasRecommendation, history.length])\n\n  useEffect(() => {\n    if (loadingContext) return\n    if (seenExplain === null) return\n    if (seenExplain) return\n    // First-time: force the disclosure screen before generating anything.\n    const qs = new URLSearchParams()\n    qs.set('date', date)\n    qs.set('category', category)\n    qs.set('returnTo', `/food/recommended?date=${encodeURIComponent(date)}&category=${encodeURIComponent(category)}&generate=1`)\n    router.replace(`/food/recommended/explain?${qs.toString()}`)\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [loadingContext, seenExplain, date, category])\n\n  useEffect(() => {\n    setItemsDraft(null)\n  }, [active?.id])\n\n  const currentItems = itemsDraft || active?.items || []\n\n  const updateServings = (index: number, next: number) => {\n    const safe = Number.isFinite(next) ? Math.max(0, Math.min(20, next)) : 0\n    setItemsDraft((prev) => {\n      const base = prev ? [...prev] : currentItems.map((it) => ({ ...it }))\n      const nextItems = base.map((it, idx) => (idx === index ? { ...it, servings: safe } : it))\n      return nextItems\n    })\n  }\n\n  const saveToFavorites = async () => {\n    if (!active) return\n    const totals = draftTotals\n    const favorites = Array.isArray((userData as any)?.favorites) ? ((userData as any).favorites as any[]) : []\n    const payload = {\n      id: `fav-${Date.now()}`,\n      sourceId: null,\n      label: active.mealName || `AI Recommended ${categoryLabel}`,\n      description: active.mealName || `AI Recommended ${categoryLabel}`,\n      nutrition: normalizeTotalsForFoodLog(totals),\n      total: normalizeTotalsForFoodLog(totals),\n      items: currentItems,\n      recipe: active.recipe || null,\n      photo: null,\n      method: 'ai-recommended',\n      meal: category,\n      createdAt: Date.now(),\n    }\n    const existingIndex = favorites.findIndex((fav: any) => fav?.label && payload.label && fav.label === payload.label)\n    const nextFavorites = existingIndex >= 0 ? favorites.map((f: any, i: number) => (i === existingIndex ? { ...payload, id: f.id || payload.id } : f)) : [...favorites, payload]\n    updateUserData({ favorites: nextFavorites })\n    try {\n      await fetch('/api/user-data', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ favorites: nextFavorites }),\n      })\n    } catch {}\n\n    // Persist this recommendation into AI history only after the user saves.\n    try {\n      setCommitSaving(true)\n      const res = await fetch('/api/ai-meal-recommendation', {\n        method: 'PUT',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          action: 'commit',\n          recommendation: {\n            ...active,\n            items: currentItems,\n            totals: draftTotals,\n            date,\n            category,\n          },\n        }),\n      })\n      if (res.ok) {\n        const data = (await res.json().catch(() => null)) as any\n        if (data?.history && Array.isArray(data.history)) setHistory(data.history)\n      }\n    } catch {\n    } finally {\n      setCommitSaving(false)\n    }\n  }\n\n  const addToDiary = async () => {\n    if (!active) return\n    const totals = normalizeTotalsForFoodLog(draftTotals)\n    const createdAtIso = alignTimestampToLocalDate(new Date().toISOString(), date)\n    const payload = {\n      description: active.mealName || `AI Recommended ${categoryLabel}`,\n      nutrition: totals,\n      imageUrl: null,\n      items: currentItems,\n      localDate: date,\n      meal: category,\n      category,\n      createdAt: createdAtIso,\n    }\n    setSavingDiary(true)\n    try {\n      const res = await fetch('/api/food-log', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(payload),\n      })\n      if (!res.ok) {\n        setError('Saving failed. Please try again.')\n        return\n      }\n\n      // Persist this recommendation into AI history only after the user saves.\n      try {\n        setCommitSaving(true)\n        const commitRes = await fetch('/api/ai-meal-recommendation', {\n          method: 'PUT',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({\n            action: 'commit',\n            recommendation: {\n              ...active,\n              items: currentItems,\n              totals: draftTotals,\n              date,\n              category,\n            },\n          }),\n        })\n        if (commitRes.ok) {\n          const data = (await commitRes.json().catch(() => null)) as any\n          if (data?.history && Array.isArray(data.history)) setHistory(data.history)\n        }\n      } catch {}\n\n      router.push('/food')\n    } catch {\n      setError('Saving failed. Please try again.')\n    } finally {\n      setCommitSaving(false)\n      setSavingDiary(false)\n    }\n  }\n\n  const pageTitle = `AI Recommended ${categoryLabel}`\n\n  const recipeMeta = useMemo(() => {\n    const recipe = active?.recipe\n    if (!recipe) return null\n    const parts: string[] = []\n    if (typeof recipe.prepMinutes === 'number' && Number.isFinite(recipe.prepMinutes)) parts.push(`Prep ${Math.round(recipe.prepMinutes)} min`)\n    if (typeof recipe.cookMinutes === 'number' && Number.isFinite(recipe.cookMinutes)) parts.push(`Cook ${Math.round(recipe.cookMinutes)} min`)\n    if (typeof recipe.servings === 'number' && Number.isFinite(recipe.servings)) parts.push(`${Math.round(recipe.servings)} serving${Math.round(recipe.servings) === 1 ? '' : 's'}`)\n    return parts.length > 0 ? parts.join(' ‚Ä¢ ') : null\n  }, [active?.recipe])\n\n  return (\n    <div className=\"min-h-screen bg-white\">\n      <div className=\"sticky top-0 z-10 bg-white border-b border-gray-200\">\n        <div className=\"flex items-center gap-3 px-4 py-3\">\n          <button type=\"button\" onClick={() => router.push('/food')} className=\"p-2 rounded-full hover:bg-gray-100\" aria-label=\"Back\">\n            <span aria-hidden>‚Üê</span>\n          </button>\n          <div className=\"flex-1 min-w-0\">\n            <div className=\"text-lg font-semibold text-gray-900 truncate\">{pageTitle}</div>\n            <div className=\"text-xs text-gray-500\">{date}</div>\n          </div>\n          {hasRecommendation ? (\n            <button\n              type=\"button\"\n              onClick={generate}\n              disabled={generating || loadingContext}\n              className=\"px-4 py-2 rounded-xl bg-emerald-600 text-white text-sm font-semibold disabled:opacity-60\"\n              aria-label=\"Generate another recommendation\"\n            >\n              {generating ? 'Generating‚Ä¶' : `Generate another (${costCredits} credits)`}\n            </button>\n          ) : null}\n        </div>\n      </div>\n\n      <div className=\"px-4 py-4\">\n        <div className=\"w-full max-w-4xl mx-auto space-y-5\">\n          {error && (\n            <div className=\"rounded-2xl border border-red-200 bg-red-50 px-4 py-3 text-sm text-red-800\">\n              <div className=\"font-semibold\">Couldn‚Äôt generate</div>\n              <div className=\"mt-1\">{error}</div>\n              {activeIsCommitted && (\n                <div className=\"mt-2 text-xs text-red-700\">\n                  Showing your last saved recommendation below.\n                </div>\n              )}\n              {error.toLowerCase().includes('credits') && (\n                <div className=\"mt-2\">\n                  <Link href=\"/billing\" className=\"text-red-800 underline font-semibold\">\n                    Go to billing\n                  </Link>\n                </div>\n              )}\n            </div>\n          )}\n\n          <div className=\"rounded-2xl border border-gray-200 bg-white p-4\">\n            <div className=\"flex items-start justify-between gap-3\">\n              <div className=\"min-w-0\">\n                <div className=\"text-xs text-gray-500\">Credit usage</div>\n                <div className=\"text-sm font-semibold text-gray-900\">\n                  {costCredits} credits per recommendation\n                </div>\n                <div className=\"text-xs text-gray-500 mt-1\">Credits are only spent when a recommendation is generated.</div>\n              </div>\n              <button\n                type=\"button\"\n                onClick={() =>\n                  router.push(\n                    `/food/recommended/explain?date=${encodeURIComponent(date)}&category=${encodeURIComponent(\n                      category,\n                    )}&returnTo=${encodeURIComponent(`/food/recommended?date=${encodeURIComponent(date)}&category=${encodeURIComponent(category)}`)}`,\n                  )\n                }\n                className=\"px-3 py-2 rounded-xl bg-gray-100 text-gray-900 text-sm font-semibold hover:bg-gray-200\"\n              >\n                About\n              </button>\n            </div>\n          </div>\n\n          {loadingContext ? (\n            <div className=\"rounded-2xl border border-gray-200 bg-white p-6 text-sm text-gray-600\">Loading‚Ä¶</div>\n          ) : (\n            <>\n              {context && <DailyMacroSummary used={context.used} targets={context.targets} />}\n\n              {active ? (\n                <>\n                  <div className=\"rounded-2xl border border-gray-200 bg-white p-4\">\n                    <div className=\"flex items-start justify-between gap-3\">\n                      <div className=\"min-w-0\">\n                        <div className=\"text-xs text-gray-500\">Meal</div>\n                        <div className=\"text-xl font-semibold text-gray-900 truncate\">{active.mealName || pageTitle}</div>\n                        <div className=\"mt-2 text-sm text-gray-700\">\n                          <span className=\"font-semibold\">{formatNumber(draftTotals.calories)}</span> kcal ‚Ä¢{' '}\n                          Protein {formatNumber(draftTotals.protein_g, 1)}g ‚Ä¢ Carbs {formatNumber(draftTotals.carbs_g, 1)}g ‚Ä¢ Fat {formatNumber(draftTotals.fat_g, 1)}g\n                        </div>\n                        <div className=\"mt-1 text-xs text-gray-500\">\n                          Fiber {formatNumber(draftTotals.fiber_g, 1)}g ‚Ä¢ Sugar {formatNumber(draftTotals.sugar_g, 1)}g\n                        </div>\n                      </div>\n                      <div className=\"flex flex-col gap-2\">\n                        <button\n                          type=\"button\"\n                          onClick={addToDiary}\n                          disabled={savingDiary || generating}\n                          className=\"px-4 py-2 rounded-xl bg-emerald-600 text-white text-sm font-semibold disabled:opacity-60\"\n                        >\n                          {savingDiary ? 'Adding‚Ä¶' : 'Add to diary'}\n                        </button>\n                        <button\n                          type=\"button\"\n                          onClick={saveToFavorites}\n                          disabled={generating}\n                          className=\"px-4 py-2 rounded-xl bg-gray-100 text-gray-900 text-sm font-semibold hover:bg-gray-200 disabled:opacity-60\"\n                        >\n                          Save to favorites\n                        </button>\n                      </div>\n                    </div>\n\n                    {Array.isArray(active.tags) && active.tags.length > 0 && (\n                      <div className=\"mt-4 flex flex-wrap gap-2\">\n                        {active.tags.slice(0, 10).map((t) => (\n                          <span key={t} className=\"px-2.5 py-1 rounded-full text-xs font-semibold bg-emerald-50 text-emerald-800 border border-emerald-100\">\n                            {t}\n                          </span>\n                        ))}\n                      </div>\n                    )}\n                  </div>\n\n                  <div className=\"rounded-2xl border border-gray-200 bg-white p-4\">\n                    <div className=\"text-sm font-semibold text-gray-900\">Ingredients</div>\n                    <div className=\"mt-3 space-y-3\">\n                      {currentItems.length === 0 ? (\n                        <div className=\"text-sm text-gray-600\">No ingredients returned.</div>\n                      ) : (\n                        currentItems.map((item, idx) => (\n                          <RecommendedIngredientCard\n                            key={`${item.name}-${idx}`}\n                            item={item}\n                            index={idx}\n                            onServingsChange={updateServings}\n                          />\n                        ))\n                      )}\n                    </div>\n                  </div>\n\n                  <div className=\"rounded-2xl border border-gray-200 bg-white p-4\">\n                    <div className=\"flex items-start justify-between gap-3\">\n                      <div>\n                        <div className=\"text-sm font-semibold text-gray-900\">Recipe</div>\n                        {recipeMeta && <div className=\"text-xs text-gray-500 mt-1\">{recipeMeta}</div>}\n                      </div>\n                    </div>\n                    {active.recipe?.steps?.length ? (\n                      <ol className=\"mt-3 space-y-2 text-sm text-gray-700 list-decimal pl-5\">\n                        {active.recipe.steps.slice(0, 12).map((step, i) => (\n                          <li key={i} className=\"leading-relaxed\">\n                            {step}\n                          </li>\n                        ))}\n                      </ol>\n                    ) : (\n                      <div className=\"mt-2 text-sm text-gray-600\">No recipe steps returned.</div>\n                    )}\n                  </div>\n\n                  <div className=\"rounded-2xl border border-gray-200 bg-white p-4\">\n                    <div className=\"text-sm font-semibold text-gray-900\">Why this meal was chosen</div>\n                    <p className=\"mt-2 text-sm text-gray-700 leading-relaxed whitespace-pre-wrap\">{active.why || '‚Äî'}</p>\n                  </div>\n                </>\n              ) : (\n                <div className=\"rounded-2xl border border-gray-200 bg-white p-6\">\n                  <div className=\"text-sm font-semibold text-gray-900\">Get a recommendation</div>\n                  <div className=\"mt-1 text-sm text-gray-600\">\n                    Generate an AI meal suggestion for {categoryLabel.toLowerCase()}.\n                  </div>\n                  <button\n                    type=\"button\"\n                    onClick={generate}\n                    disabled={generating}\n                    className=\"mt-4 w-full sm:w-auto px-4 py-2.5 rounded-xl bg-emerald-600 text-white text-sm font-semibold disabled:opacity-60\"\n                  >\n                    {generating ? 'Generating‚Ä¶' : `Generate (${costCredits} credits)`}\n                  </button>\n                </div>\n              )}\n\n              <div className=\"rounded-2xl border border-gray-200 bg-white p-4\">\n                <div className=\"flex items-center justify-between gap-3\">\n                  <div>\n                    <div className=\"text-sm font-semibold text-gray-900\">History</div>\n                    <div className=\"text-xs text-gray-500\">Previously generated AI meals</div>\n                  </div>\n                </div>\n                <div className=\"mt-3 space-y-2\">\n                  {history.length === 0 ? (\n                    <div className=\"text-sm text-gray-600\">No recommendations yet.</div>\n                  ) : (\n                    history.slice(0, 12).map((rec) => (\n                      <button\n                        key={rec.id}\n                        type=\"button\"\n                        onClick={() => setActiveFromHistory(rec)}\n                        className=\"w-full text-left rounded-xl border border-gray-200 px-3 py-3 hover:bg-gray-50\"\n                      >\n                        <div className=\"flex items-start justify-between gap-3\">\n                          <div className=\"min-w-0\">\n                            <div className=\"text-sm font-semibold text-gray-900 truncate\">{rec.mealName || `AI Recommended ${CATEGORY_LABELS[rec.category]}`}</div>\n                            <div className=\"text-xs text-gray-500\">\n                              {CATEGORY_LABELS[rec.category]} ‚Ä¢ {new Date(rec.createdAt).toLocaleString()}\n                            </div>\n                          </div>\n                          <div className=\"text-xs text-gray-600\">\n                            {typeof rec.totals?.calories === 'number' ? `${Math.round(rec.totals.calories)} kcal` : ''}\n                          </div>\n                        </div>\n                      </button>\n                    ))\n                  )}\n                </div>\n              </div>\n            </>\n          )}\n        </div>\n      </div>\n    </div>\n  )\n}\n","truncated":false,"size":28105},{"path":"app/health-tips/history/page.tsx","content":"'use client'\n\nimport React, { useEffect, useState, useMemo } from 'react'\nimport Link from 'next/link'\nimport { usePathname } from 'next/navigation'\nimport PageHeader from '@/components/PageHeader'\nimport VoiceChat from '@/components/VoiceChat'\n\ntype HealthTip = {\n  id: string\n  tipDate: string\n  sentAt: string\n  title: string\n  body: string\n  category: string\n  suggestedQuestions?: string[]\n}\n\nexport default function HealthTipHistoryPage() {\n  const pathname = usePathname()\n  const [tips, setTips] = useState<HealthTip[]>([])\n  const [loading, setLoading] = useState(false)\n  const [expandedTipId, setExpandedTipId] = useState<string | null>(null)\n\n  useEffect(() => {\n    const load = async () => {\n      setLoading(true)\n      try {\n        const res = await fetch('/api/health-tips/history', { cache: 'no-store' as any })\n        if (res.ok) {\n          const data = await res.json()\n          setTips(Array.isArray(data?.tips) ? data.tips : [])\n        }\n      } catch {\n        // ignore ‚Äì UI will show friendly fallback\n      } finally {\n        setLoading(false)\n      }\n    }\n    load()\n  }, [])\n\n  const grouped = useMemo(() => {\n    const map = new Map<string, HealthTip[]>()\n    for (const tip of tips) {\n      const dateKey = tip.tipDate?.slice(0, 10) || 'Unknown date'\n      if (!map.has(dateKey)) map.set(dateKey, [])\n      map.get(dateKey)!.push(tip)\n    }\n    return Array.from(map.entries()).sort(([a], [b]) => (a < b ? 1 : -1))\n  }, [tips])\n\n  const isHistoryPage = pathname === '/health-tips/history'\n\n  return (\n    <div className=\"min-h-screen bg-gray-50 dark:bg-gray-900 pb-24\">\n      <PageHeader title=\"Health Tips\" backHref=\"/more\" />\n\n      {/* Tabs */}\n      <div className=\"max-w-3xl mx-auto px-4 pt-4\">\n        <div className=\"bg-white dark:bg-gray-800 rounded-t-xl border-b border-gray-200 dark:border-gray-700\">\n          <div className=\"flex\">\n            <Link\n              href=\"/health-tips\"\n              className={`flex-1 px-4 py-3 text-center font-medium transition-colors ${\n                !isHistoryPage\n                  ? 'text-helfi-green border-b-2 border-helfi-green'\n                  : 'text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-200'\n              }`}\n            >\n              Today&apos;s Tips\n            </Link>\n            <Link\n              href=\"/health-tips/history\"\n              className={`flex-1 px-4 py-3 text-center font-medium transition-colors ${\n                isHistoryPage\n                  ? 'text-helfi-green border-b-2 border-helfi-green'\n                  : 'text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-200'\n              }`}\n            >\n              Tip History\n            </Link>\n          </div>\n        </div>\n      </div>\n\n      <main className=\"max-w-3xl mx-auto px-4 py-6\">\n        <section className=\"bg-white dark:bg-gray-800 rounded-b-2xl shadow-sm p-6\">\n          <div className=\"mb-4\">\n            <h1 className=\"text-2xl font-bold text-gray-900 dark:text-white mb-1\">\n              Past AI health tips\n            </h1>\n            <p className=\"text-sm text-gray-600 dark:text-gray-400\">\n              Scroll back through previous days to revisit useful suggestions you&apos;ve already\n              received.\n            </p>\n          </div>\n\n          {loading ? (\n            <div className=\"flex items-center justify-center py-8\">\n              <div className=\"animate-spin rounded-full h-8 w-8 border-b-2 border-helfi-green\" />\n            </div>\n          ) : grouped.length === 0 ? (\n            <div className=\"border border-dashed border-gray-300 dark:border-gray-600 rounded-xl p-4 text-sm text-gray-600 dark:text-gray-300\">\n              No health tips have been recorded yet. Once Helfi has sent you some daily tips,\n              they&apos;ll appear here.\n            </div>\n          ) : (\n            <div className=\"space-y-6\">\n              {grouped.map(([date, dayTips]) => (\n                <div key={date}>\n                  <h2 className=\"text-sm font-semibold text-gray-700 dark:text-gray-300 mb-2\">\n                    {date}\n                  </h2>\n                  <div className=\"space-y-3\">\n                    {dayTips.map((tip) => (\n                      <article\n                        key={tip.id}\n                        className=\"border border-gray-200 dark:border-gray-700 rounded-xl p-4 bg-white dark:bg-gray-800/70\"\n                      >\n                        <div className=\"flex items-center justify-between mb-2\">\n                          <h3 className=\"text-base font-semibold text-gray-900 dark:text-white\">\n                            {tip.title}\n                          </h3>\n                          <span className=\"text-xs px-2 py-1 rounded-full bg-emerald-50 text-emerald-700 dark:bg-emerald-900/30 dark:text-emerald-300 border border-emerald-200 dark:border-emerald-700\">\n                            {tip.category === 'supplement'\n                              ? 'Supplement tip'\n                              : tip.category === 'lifestyle'\n                              ? 'Lifestyle tip'\n                              : 'Food tip'}\n                          </span>\n                        </div>\n                        <p className=\"text-sm text-gray-800 dark:text-gray-100 whitespace-pre-line\">\n                          {tip.body}\n                        </p>\n                        <div className=\"mt-3 flex flex-wrap items-center justify-between gap-2 border-t border-gray-100 dark:border-gray-700 pt-3\">\n                          <span className=\"text-xs text-gray-500 dark:text-gray-400\">\n                            Do you have any questions about this tip?\n                          </span>\n                          <button\n                            type=\"button\"\n                            onClick={() =>\n                              setExpandedTipId((current) => (current === tip.id ? null : tip.id))\n                            }\n                            className=\"inline-flex items-center px-3 py-1.5 rounded-full text-xs font-medium bg-helfi-green text-white hover:bg-helfi-green/90 transition-colors\"\n                          >\n                            Ask AI\n                          </button>\n                        </div>\n                        {expandedTipId === tip.id && (\n                          <div className=\"mt-3 border border-gray-200 dark:border-gray-700 rounded-xl bg-white dark:bg-gray-900/60 overflow-hidden\">\n                            <VoiceChat\n                              className=\"h-80\"\n                              context={{\n                                healthTipSummary: `${tip.title}. ${tip.body}`,\n                                healthTipTitle: tip.title,\n                                healthTipCategory: tip.category,\n                                healthTipSuggestedQuestions: tip.suggestedQuestions,\n                              }}\n                            />\n                          </div>\n                        )}\n                      </article>\n                    ))}\n                  </div>\n                </div>\n              ))}\n            </div>\n          )}\n        </section>\n      </main>\n    </div>\n  )\n}\n\n\n","truncated":false,"size":7232},{"path":"app/health-tips/page.tsx","content":"'use client'\n\nimport React, { useEffect, useMemo, useState } from 'react'\nimport Link from 'next/link'\nimport { usePathname } from 'next/navigation'\nimport PageHeader from '@/components/PageHeader'\nimport UsageMeter from '@/components/UsageMeter'\nimport FeatureUsageDisplay from '@/components/FeatureUsageDisplay'\nimport VoiceChat from '@/components/VoiceChat'\n\ntype HealthTip = {\n  id: string\n  tipDate: string\n  sentAt: string\n  title: string\n  body: string\n  category: string\n  suggestedQuestions?: string[]\n}\n\ntype HealthTipSettings = {\n  enabled: boolean\n  time1: string\n  time2: string\n  time3: string\n  timezone: string\n  frequency: number\n  focusFood: boolean\n  focusSupplements: boolean\n  focusLifestyle: boolean\n}\n\nexport default function HealthTipsPage() {\n  const pathname = usePathname()\n  const [tips, setTips] = useState<HealthTip[]>([])\n  const [loadingTips, setLoadingTips] = useState(true)\n  const [settings, setSettings] = useState<HealthTipSettings | null>(null)\n  const [loadingSettings, setLoadingSettings] = useState(true)\n  const [saving, setSaving] = useState(false)\n\n  // Local editable copies of settings\n  const [enabled, setEnabled] = useState(false)\n  const [time1, setTime1] = useState('11:30')\n  const [time2, setTime2] = useState('15:30')\n  const [time3, setTime3] = useState('20:30')\n  const [timezone, setTimezone] = useState('Australia/Melbourne')\n  const [frequency, setFrequency] = useState(1)\n  const [focusFood, setFocusFood] = useState(true)\n  const [focusSupplements, setFocusSupplements] = useState(true)\n  const [focusLifestyle, setFocusLifestyle] = useState(true)\n  const [timezoneOptions, setTimezoneOptions] = useState<string[]>([])\n  const [timezoneQuery, setTimezoneQuery] = useState('')\n  const [showTimezoneDropdown, setShowTimezoneDropdown] = useState(false)\n  const [expandedTipId, setExpandedTipId] = useState<string | null>(null)\n\n  useEffect(() => {\n    ;(async () => {\n      try {\n        const res = await fetch('/api/health-tips/today', { cache: 'no-store' as any })\n        if (res.ok) {\n          const data = await res.json()\n          setTips(Array.isArray(data?.tips) ? data.tips : [])\n        }\n      } catch {\n        // ignore ‚Äì UI will show friendly message\n      } finally {\n        setLoadingTips(false)\n      }\n    })()\n  }, [])\n\n  useEffect(() => {\n    ;(async () => {\n      try {\n        const res = await fetch('/api/health-tips/settings', { cache: 'no-store' as any })\n        if (res.ok) {\n          const data = (await res.json()) as HealthTipSettings\n          setSettings(data)\n          setEnabled(data.enabled)\n          setTime1(data.time1)\n          setTime2(data.time2)\n          setTime3(data.time3)\n          setTimezone(data.timezone)\n          setTimezoneQuery(data.timezone)\n          setFrequency(data.frequency)\n          setFocusFood(data.focusFood)\n          setFocusSupplements(data.focusSupplements)\n          setFocusLifestyle(data.focusLifestyle)\n        }\n      } catch {\n        // ignore ‚Äì UI will show fallback defaults\n      } finally {\n        setLoadingSettings(false)\n      }\n    })()\n  }, [])\n\n  // Populate timezone dropdown with all supported IANA timezones (with a safe fallback list)\n  useEffect(() => {\n    try {\n      const anyIntl = Intl as any\n      if (anyIntl && typeof anyIntl.supportedValuesOf === 'function') {\n        const supported = anyIntl.supportedValuesOf('timeZone') as string[]\n        if (Array.isArray(supported) && supported.length > 0) {\n          const sorted = [...supported].sort((a, b) => a.localeCompare(b))\n          setTimezoneOptions(sorted)\n          // If current timezone is not set, default to the environment's best guess\n          if (!timezone) {\n            const guessed =\n              Intl.DateTimeFormat().resolvedOptions().timeZone || sorted[0] || 'UTC'\n            setTimezone(guessed)\n          }\n          return\n        }\n      }\n    } catch {\n      // fall through to static fallback list\n    }\n\n    // Static curated fallback list (mirrors Settings page selection)\n    const fallback = [\n      'UTC',\n      'Europe/London',\n      'Europe/Paris',\n      'Europe/Berlin',\n      'Europe/Madrid',\n      'Europe/Rome',\n      'Europe/Amsterdam',\n      'Europe/Zurich',\n      'Europe/Stockholm',\n      'Europe/Athens',\n      'Africa/Johannesburg',\n      'Asia/Dubai',\n      'Asia/Kolkata',\n      'Asia/Bangkok',\n      'Asia/Singapore',\n      'Asia/Kuala_Lumpur',\n      'Asia/Hong_Kong',\n      'Asia/Tokyo',\n      'Asia/Seoul',\n      'Asia/Shanghai',\n      'Australia/Perth',\n      'Australia/Adelaide',\n      'Australia/Melbourne',\n      'Australia/Sydney',\n      'Pacific/Auckland',\n      'America/New_York',\n      'America/Chicago',\n      'America/Denver',\n      'America/Los_Angeles',\n      'America/Toronto',\n      'America/Vancouver',\n      'America/Mexico_City',\n      'America/Bogota',\n      'America/Sao_Paulo',\n    ]\n    setTimezoneOptions(fallback)\n    if (!timezone) {\n      setTimezone(fallback[0])\n      setTimezoneQuery(fallback[0])\n    }\n  }, [timezone])\n\n  const filteredTimezones = useMemo(() => {\n    if (!timezoneOptions.length) return []\n    const query = (timezoneQuery || '').trim().toLowerCase()\n    if (!query) {\n      return timezoneOptions.slice(0, 50)\n    }\n    return timezoneOptions\n      .filter((tz) => tz.toLowerCase().includes(query))\n      .slice(0, 50)\n  }, [timezoneOptions, timezoneQuery])\n\n  const handleSaveSettings = async () => {\n    setSaving(true)\n    try {\n      const res = await fetch('/api/health-tips/settings', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          enabled,\n          time1,\n          time2,\n          time3,\n          timezone,\n          frequency,\n          focusFood,\n          focusSupplements,\n          focusLifestyle,\n        }),\n      })\n      const data = await res.json().catch(() => ({}))\n      if (!res.ok) {\n        const msg = (data && (data.error || data.detail)) || 'Failed to save settings'\n        alert(msg)\n        return\n      }\n      alert('Health tip settings saved. Your next AI tips will follow this schedule.')\n    } catch {\n      alert('Could not save health tip settings. Please try again.')\n    } finally {\n      setSaving(false)\n    }\n  }\n\n  const isHistoryPage = pathname === '/health-tips/history'\n\n  const sortedTips = useMemo(() => {\n    return [...tips].sort((a, b) => {\n      const aTime = new Date(a.sentAt).getTime()\n      const bTime = new Date(b.sentAt).getTime()\n      return bTime - aTime\n    })\n  }, [tips])\n  const visibleTips = sortedTips.slice(0, 2)\n  const hasMoreTips = sortedTips.length > 2\n\n  return (\n    <div className=\"min-h-screen bg-gray-50 dark:bg-gray-900 pb-24\">\n      <PageHeader title=\"Health Tips\" backHref=\"/more\" />\n\n      {/* Tabs */}\n      <div className=\"max-w-3xl mx-auto px-4 pt-4\">\n        <div className=\"bg-white dark:bg-gray-800 rounded-t-xl border-b border-gray-200 dark:border-gray-700\">\n          <div className=\"flex\">\n            <Link\n              href=\"/health-tips\"\n              className={`flex-1 px-4 py-3 text-center font-medium transition-colors ${\n                !isHistoryPage\n                  ? 'text-helfi-green border-b-2 border-helfi-green'\n                  : 'text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-200'\n              }`}\n            >\n              Today&apos;s Tips\n            </Link>\n            <Link\n              href=\"/health-tips/history\"\n              className={`flex-1 px-4 py-3 text-center font-medium transition-colors ${\n                isHistoryPage\n                  ? 'text-helfi-green border-b-2 border-helfi-green'\n                  : 'text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-200'\n              }`}\n            >\n              Tip History\n            </Link>\n          </div>\n        </div>\n      </div>\n\n      <main className=\"max-w-3xl mx-auto px-4 py-6\">\n        {/* Today‚Äôs Tips */}\n        <section className=\"bg-white dark:bg-gray-800 rounded-b-2xl shadow-sm p-6 mb-6\">\n          <h1 className=\"text-2xl font-bold text-gray-900 dark:text-white mb-2\">\n            Today&apos;s AI health tips\n          </h1>\n          <p className=\"text-sm text-gray-600 dark:text-gray-400 mb-4\">\n            When you receive a notification and tap it, you&apos;ll land here to see the full tip,\n            plus any others sent today.\n          </p>\n\n          {loadingTips ? (\n            <div className=\"flex items-center justify-center py-8\">\n              <div className=\"animate-spin rounded-full h-8 w-8 border-b-2 border-helfi-green\" />\n            </div>\n          ) : tips.length === 0 ? (\n            <div className=\"border border-dashed border-gray-300 dark:border-gray-600 rounded-xl p-4 text-sm text-gray-600 dark:text-gray-300\">\n              No AI tips have been sent yet today. Once your schedule is set and you have credits,\n              Helfi will send you personalised health tips here.\n            </div>\n          ) : (\n            <div className=\"space-y-4\">\n              {visibleTips.map((tip) => (\n                <article\n                  key={tip.id}\n                  className=\"border border-gray-200 dark:border-gray-700 rounded-xl p-4 bg-white dark:bg-gray-800/70\"\n                >\n                  <div className=\"flex items-center justify-between mb-2\">\n                    <h2 className=\"text-base font-semibold text-gray-900 dark:text-white\">\n                      {tip.title}\n                    </h2>\n                    <span className=\"text-xs px-2 py-1 rounded-full bg-emerald-50 text-emerald-700 dark:bg-emerald-900/30 dark:text-emerald-300 border border-emerald-200 dark:border-emerald-700\">\n                      {tip.category === 'supplement'\n                        ? 'Supplement tip'\n                        : tip.category === 'lifestyle'\n                        ? 'Lifestyle tip'\n                        : 'Food tip'}\n                    </span>\n                  </div>\n                  <p className=\"text-sm text-gray-800 dark:text-gray-100 whitespace-pre-line\">\n                    {tip.body}\n                  </p>\n                  <div className=\"mt-3 flex flex-wrap items-center justify-between gap-2 border-t border-gray-100 dark:border-gray-700 pt-3\">\n                    <span className=\"text-xs text-gray-500 dark:text-gray-400\">\n                      Do you have any questions about this tip?\n                    </span>\n                    <button\n                      type=\"button\"\n                      onClick={() =>\n                        setExpandedTipId((current) => (current === tip.id ? null : tip.id))\n                      }\n                      className=\"inline-flex items-center px-3 py-1.5 rounded-full text-xs font-medium bg-helfi-green text-white hover:bg-helfi-green/90 transition-colors\"\n                    >\n                      Ask AI\n                    </button>\n                  </div>\n                  {expandedTipId === tip.id && (\n                    <div className=\"mt-3 border border-gray-200 dark:border-gray-700 rounded-xl bg-white dark:bg-gray-900/60 overflow-hidden\">\n                      <VoiceChat\n                        className=\"h-80\"\n                        context={{\n                          healthTipSummary: `${tip.title}. ${tip.body}`,\n                          healthTipTitle: tip.title,\n                          healthTipCategory: tip.category,\n                          healthTipSuggestedQuestions: tip.suggestedQuestions,\n                        }}\n                      />\n                    </div>\n                  )}\n                </article>\n              ))}\n              {hasMoreTips && (\n                <div className=\"pt-2\">\n                  <Link\n                    href=\"/health-tips/history\"\n                    className=\"block w-full text-center text-sm font-medium text-helfi-green hover:text-helfi-green/80 border border-helfi-green/40 rounded-lg py-2 bg-emerald-50/40 hover:bg-emerald-50 transition-colors\"\n                  >\n                    View more tips\n                  </Link>\n                </div>\n              )}\n            </div>\n          )}\n        </section>\n\n        {/* Settings */}\n        <section className=\"bg-white dark:bg-gray-800 rounded-2xl shadow-sm p-6\">\n          <div className=\"flex items-center justify-between mb-4\">\n            <h2 className=\"text-xl font-bold text-gray-900 dark:text-white\">\n              Health tip schedule\n            </h2>\n          </div>\n          <p className=\"text-sm text-gray-600 dark:text-gray-400 mb-4\">\n            Choose how many AI health tips you&apos;d like each day and when you&apos;d like to\n            receive them. Each tip uses your Helfi credits (we always charge more credits than the\n            raw AI cost so things stay in line with your subscription and top-ups).\n          </p>\n          <p className=\"text-sm text-gray-500 dark:text-gray-400 mb-4\">\n            Cost: 2 credits per tip dispatch.\n          </p>\n\n          {/* Credits usage for Health Tips */}\n          <div className=\"mb-4\">\n            <UsageMeter inline={true} feature=\"healthTips\" />\n            <FeatureUsageDisplay featureName=\"healthTips\" featureLabel=\"Health Tips\" />\n          </div>\n\n          {loadingSettings ? (\n            <div className=\"flex items-center justify-center py-4\">\n              <div className=\"animate-spin rounded-full h-6 w-6 border-b-2 border-helfi-green\" />\n            </div>\n          ) : (\n            <div className=\"space-y-5\">\n              <div className=\"flex items-center justify-between\">\n                <div>\n                  <h3 className=\"font-medium text-gray-900 dark:text-white\">AI Health Tips</h3>\n                  <p className=\"text-sm text-gray-600 dark:text-gray-400\">\n                    Turn daily AI health tips on or off for this account.\n                  </p>\n                </div>\n                <label className=\"relative inline-flex items-center cursor-pointer\">\n                  <input\n                    type=\"checkbox\"\n                    className=\"sr-only peer\"\n                    checked={enabled}\n                    onChange={(e) => setEnabled(e.target.checked)}\n                  />\n                  <div className=\"w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-helfi-green/20 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-helfi-green\" />\n                </label>\n              </div>\n\n              <div className=\"space-y-4\">\n                <div>\n                  <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2\">\n                    Number of tips per day\n                  </label>\n                  <select\n                    value={frequency}\n                    onChange={(e) => setFrequency(parseInt(e.target.value, 10))}\n                    className=\"w-full border border-gray-300 dark:border-gray-600 rounded-lg px-3 py-2 bg-white dark:bg-gray-700 text-gray-900 dark:text-white\"\n                    disabled={!enabled}\n                  >\n                    <option value={1}>1 tip per day</option>\n                    <option value={2}>2 tips per day</option>\n                    <option value={3}>3 tips per day</option>\n                  </select>\n                </div>\n\n                {frequency >= 1 && (\n                  <div>\n                    <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1\">\n                      Tip 1 time\n                    </label>\n                    <input\n                      type=\"time\"\n                      value={time1}\n                      onChange={(e) => setTime1(e.target.value)}\n                      className=\"w-full border border-gray-300 dark:border-gray-600 rounded-lg px-3 py-2 bg-white dark:bg-gray-700 text-gray-900 dark:text-white\"\n                      disabled={!enabled}\n                    />\n                  </div>\n                )}\n\n                {frequency >= 2 && (\n                  <div>\n                    <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1\">\n                      Tip 2 time\n                    </label>\n                    <input\n                      type=\"time\"\n                      value={time2}\n                      onChange={(e) => setTime2(e.target.value)}\n                      className=\"w-full border border-gray-300 dark:border-gray-600 rounded-lg px-3 py-2 bg-white dark:bg-gray-700 text-gray-900 dark:text-white\"\n                      disabled={!enabled}\n                    />\n                  </div>\n                )}\n\n                {frequency >= 3 && (\n                  <div>\n                    <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1\">\n                      Tip 3 time\n                    </label>\n                    <input\n                      type=\"time\"\n                      value={time3}\n                      onChange={(e) => setTime3(e.target.value)}\n                      className=\"w-full border border-gray-300 dark:border-gray-600 rounded-lg px-3 py-2 bg-white dark:bg-gray-700 text-gray-900 dark:text-white\"\n                      disabled={!enabled}\n                    />\n                  </div>\n                )}\n\n                <div>\n                  <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1\">\n                    Timezone\n                  </label>\n                  <div className=\"relative\">\n                    <input\n                      type=\"text\"\n                      value={timezoneQuery}\n                      onChange={(e) => {\n                        setTimezoneQuery(e.target.value)\n                        setShowTimezoneDropdown(true)\n                      }}\n                      onFocus={() => {\n                        if (enabled && timezoneOptions.length > 0) {\n                          setShowTimezoneDropdown(true)\n                        }\n                      }}\n                      placeholder=\"Start typing e.g. Australia/Melbourne\"\n                      className=\"w-full border border-gray-300 dark:border-gray-600 rounded-lg px-3 py-2 bg-white dark:bg-gray-700 text-gray-900 dark:text-white text-sm\"\n                      disabled={!enabled}\n                    />\n                    {enabled && showTimezoneDropdown && filteredTimezones.length > 0 && (\n                      <div className=\"absolute z-20 mt-1 w-full max-h-56 overflow-y-auto rounded-lg border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 shadow-lg\">\n                        {filteredTimezones.map((tzValue) => (\n                          <button\n                            key={tzValue}\n                            type=\"button\"\n                            onClick={() => {\n                              setTimezone(tzValue)\n                              setTimezoneQuery(tzValue)\n                              setShowTimezoneDropdown(false)\n                            }}\n                            className=\"w-full text-left px-3 py-2 text-xs text-gray-800 dark:text-gray-100 hover:bg-gray-100 dark:hover:bg-gray-700\"\n                          >\n                            {tzValue}\n                          </button>\n                        ))}\n                      </div>\n                    )}\n                  </div>\n                  <p className=\"mt-1 text-xs text-gray-500 dark:text-gray-400\">\n                    Start typing your city or region and pick the closest match (for example:{' '}\n                    <span className=\"font-mono\">Australia/Melbourne</span> or{' '}\n                    <span className=\"font-mono\">America/New_York</span>).\n                  </p>\n                </div>\n              </div>\n\n              <div className=\"border-t border-gray-200 dark:border-gray-700 pt-4 mt-2\">\n                <h3 className=\"font-medium text-gray-900 dark:text-white mb-2\">\n                  What would you like tips about?\n                </h3>\n                <p className=\"text-sm text-gray-600 dark:text-gray-400 mb-3\">\n                  Helfi will always look at your whole health picture, but you can gently steer the\n                  types of tips you receive.\n                </p>\n                <div className=\"space-y-2\">\n                  <label className=\"flex items-center gap-2 text-sm text-gray-800 dark:text-gray-200\">\n                    <input\n                      type=\"checkbox\"\n                      checked={focusFood}\n                      onChange={(e) => setFocusFood(e.target.checked)}\n                      disabled={!enabled}\n                    />\n                    Food & meals\n                  </label>\n                  <label className=\"flex items-center gap-2 text-sm text-gray-800 dark:text-gray-200\">\n                    <input\n                      type=\"checkbox\"\n                      checked={focusSupplements}\n                      onChange={(e) => setFocusSupplements(e.target.checked)}\n                      disabled={!enabled}\n                    />\n                    Supplements (with safety wording)\n                  </label>\n                  <label className=\"flex items-center gap-2 text-sm text-gray-800 dark:text-gray-200\">\n                    <input\n                      type=\"checkbox\"\n                      checked={focusLifestyle}\n                      onChange={(e) => setFocusLifestyle(e.target.checked)}\n                      disabled={!enabled}\n                    />\n                    Lifestyle & daily habits\n                  </label>\n                </div>\n              </div>\n\n              <button\n                onClick={handleSaveSettings}\n                disabled={saving}\n                className=\"w-full bg-helfi-green text-white px-4 py-2 rounded-lg hover:bg-helfi-green/90 disabled:opacity-60 disabled:cursor-not-allowed font-medium mt-2\"\n              >\n                {saving ? 'Saving‚Ä¶' : 'Save health tip settings'}\n              </button>\n\n              <p className=\"text-xs text-gray-500 dark:text-gray-400 mt-2\">\n                These AI tips are educational and do not replace medical advice. Always consider\n                your medications, allergies, and personal circumstances, and talk to your clinician\n                before making big changes or starting new supplements.\n              </p>\n            </div>\n          )}\n        </section>\n      </main>\n    </div>\n  )\n}\n","truncated":false,"size":22646},{"path":"app/health-tracking/page.tsx","content":"'use client'\nimport { Cog6ToothIcon, UserIcon } from '@heroicons/react/24/outline'\n\nimport React, { useState, useEffect } from 'react'\nimport { useSession, signOut } from 'next-auth/react'\nimport Link from 'next/link'\nimport { usePathname } from 'next/navigation'\nimport Image from 'next/image'\nimport { useUserData } from '@/components/providers/UserDataProvider'\nimport MobileMoreMenu from '@/components/MobileMoreMenu'\nimport FitbitSummary from '@/components/devices/FitbitSummary'\nimport FitbitCharts from '@/components/devices/FitbitCharts'\nimport FitbitCorrelations from '@/components/devices/FitbitCorrelations'\nimport GarminSummary from '@/components/devices/GarminSummary'\nimport GarminCharts from '@/components/devices/GarminCharts'\n\nexport default function HealthTracking() {\n  const { data: session } = useSession()\n  const pathname = usePathname()\n  const { profileImage: providerProfileImage } = useUserData()\n  const garminConnectEnabled = process.env.NEXT_PUBLIC_GARMIN_CONNECT_ENABLED !== 'false'\n  const [dropdownOpen, setDropdownOpen] = useState(false)\n  const [profileImage, setProfileImage] = useState<string>('')\n  const [fitbitConnected, setFitbitConnected] = useState(false)\n  const [garminStatus, setGarminStatus] = useState<{\n    connected: boolean\n    webhookCount: number\n    lastWebhookAt: string | null\n    lastDataType: string | null\n  } | null>(null)\n\n  // Profile data - prefer real photos; fall back to professional icon\n  const hasProfileImage = !!(providerProfileImage || profileImage || session?.user?.image)\n  const userImage = (providerProfileImage || profileImage || session?.user?.image || '') as string\n  const userName = session?.user?.name || 'User';\n\n  // Close dropdown on outside click\n  useEffect(() => {\n    function handleClick(e: MouseEvent) {\n      const target = e.target as HTMLElement;\n      // Check if click is outside both the button and the dropdown content\n      if (!target.closest('.dropdown-container')) {\n        setDropdownOpen(false);\n      }\n    }\n    if (dropdownOpen) {\n      document.addEventListener('mousedown', handleClick);\n      return () => document.removeEventListener('mousedown', handleClick);\n    }\n  }, [dropdownOpen]);\n\n  // Load profile image from database\n  useEffect(() => {\n    const loadProfileImage = async () => {\n      try {\n        const response = await fetch('/api/user-data');\n        if (response.ok) {\n          const result = await response.json();\n          if (result.data && result.data.profileImage) {\n            setProfileImage(result.data.profileImage);\n          }\n        }\n      } catch (error) {\n        console.error('Error loading profile image:', error);\n      }\n    };\n\n    if (session) {\n      loadProfileImage();\n    }\n  }, [session]);\n\n  useEffect(() => {\n    const checkFitbit = async () => {\n      try {\n        const res = await fetch('/api/fitbit/status')\n        if (res.ok) {\n          const j = await res.json()\n          setFitbitConnected(!!j.connected)\n        }\n      } catch {}\n    }\n    checkFitbit()\n  }, [])\n\n  useEffect(() => {\n    const checkGarmin = async () => {\n      if (!garminConnectEnabled) {\n        setGarminStatus({\n          connected: false,\n          webhookCount: 0,\n          lastWebhookAt: null,\n          lastDataType: null,\n        })\n        return\n      }\n      try {\n        const res = await fetch('/api/garmin/status')\n        if (res.ok) {\n          const j = await res.json()\n          setGarminStatus({\n            connected: !!j.connected,\n            webhookCount: Number(j.webhookCount || 0),\n            lastWebhookAt: j.lastWebhookAt || null,\n            lastDataType: j.lastDataType || null,\n          })\n        }\n      } catch {}\n    }\n    checkGarmin()\n  }, [])\n\n  return (\n    <div className=\"min-h-screen bg-gray-50\">\n      {/* Navigation Header - First Row */}\n      <nav className=\"bg-white border-b border-gray-200 px-4 py-3\">\n        <div className=\"max-w-7xl mx-auto flex justify-between items-center\">\n          <div className=\"flex items-center\">\n            <Link href=\"/dashboard\" className=\"bg-helfi-green text-white px-4 py-2 rounded-lg hover:bg-helfi-green/90 transition-colors\">\n              Back to Dashboard\n            </Link>\n          </div>\n          \n          {/* Desktop Navigation */}\n          <div className=\"hidden md:flex items-center space-x-6\">\n            <Link href=\"/dashboard\" className=\"text-gray-700 hover:text-helfi-green transition-colors font-medium\">\n              Dashboard\n            </Link>\n            <Link href=\"/health-tracking\" className=\"text-gray-700 hover:text-helfi-green transition-colors font-medium\">\n              Health Tracking\n            </Link>\n            <Link href=\"/insights\" className=\"text-gray-700 hover:text-helfi-green transition-colors font-medium\">\n              AI Insights\n            </Link>\n            <Link href=\"/reports\" className=\"text-gray-700 hover:text-helfi-green transition-colors font-medium\">\n              Reports\n            </Link>\n            <Link href=\"/onboarding?step=1\" className=\"text-gray-700 hover:text-helfi-green transition-colors font-medium\">\n              Health Info\n            </Link>\n          </div>\n\n          {/* Logo on the right */}\n          <div className=\"flex items-center\">\n            <Link href=\"/\" className=\"w-16 h-16 md:w-20 md:h-20 cursor-pointer hover:opacity-80 transition-opacity\">\n              <Image\n                src=\"/mobile-assets/LOGOS/helfi-01-01.png\"\n                alt=\"Helfi Logo\"\n                width={80}\n                height={80}\n                className=\"w-full h-full object-contain dark:hidden\"\n                priority\n              />\n              <Image\n                src=\"/mobile-assets/LOGOS/helfi-01-06.png\"\n                alt=\"Helfi Logo\"\n                width={80}\n                height={80}\n                className=\"w-full h-full object-contain hidden dark:block\"\n                priority\n              />\n            </Link>\n          </div>\n        </div>\n      </nav>\n\n      {/* Second Row - Page Title and Profile */}\n      <div className=\"bg-white border-b border-gray-200 px-4 py-4\">\n        <div className=\"max-w-7xl mx-auto flex justify-between items-center\">\n          <div></div> {/* Empty div for spacing */}\n          \n          {/* Centered Page Title */}\n          <div className=\"text-center\">\n            <h1 className=\"text-lg md:text-xl font-semibold text-gray-900\">Insights</h1>\n            <p className=\"text-sm text-gray-500 hidden sm:block\">Monitor your daily health metrics</p>\n          </div>\n          \n          {/* Desktop Profile Avatar & Dropdown */}\n          <div className=\"hidden md:flex\">\n            <div className=\"relative dropdown-container\" id=\"profile-dropdown\">\n              <button\n                onClick={() => setDropdownOpen((v) => !v)}\n                className=\"focus:outline-none\"\n                aria-label=\"Open profile menu\"\n              >\n                {hasProfileImage ? (\n                  <Image\n                    src={userImage}\n                    alt=\"Profile\"\n                    width={48}\n                    height={48}\n                    className=\"w-12 h-12 rounded-full border-2 border-helfi-green shadow-sm object-cover\"\n                  />\n                ) : (\n                  <div className=\"w-12 h-12 rounded-full bg-helfi-green shadow-sm flex items-center justify-center\">\n                    <UserIcon className=\"w-6 h-6 text-white\" aria-hidden=\"true\" />\n                  </div>\n                )}\n              </button>\n              {dropdownOpen && (\n                <div className=\"absolute right-0 mt-2 w-64 bg-white rounded-xl shadow-lg py-2 z-50 border border-gray-100 animate-fade-in\">\n                  <div className=\"flex items-center px-4 py-3 border-b border-gray-100\">\n                    {hasProfileImage ? (\n                      <Image\n                        src={userImage}\n                        alt=\"Profile\"\n                        width={40}\n                        height={40}\n                        className=\"w-10 h-10 rounded-full object-cover mr-3\"\n                      />\n                    ) : (\n                      <div className=\"w-10 h-10 rounded-full bg-helfi-green flex items-center justify-center mr-3\">\n                        <UserIcon className=\"w-5 h-5 text-white\" aria-hidden=\"true\" />\n                      </div>\n                    )}\n                    <div>\n                      <div className=\"font-semibold text-gray-900\">{userName}</div>\n                      <div className=\"text-xs text-gray-500\">{session?.user?.email || 'user@email.com'}</div>\n                    </div>\n                  </div>\n                  <Link href=\"/profile\" className=\"block px-4 py-2 text-gray-700 hover:bg-gray-50\">Profile</Link>\n                  <Link href=\"/account\" className=\"block px-4 py-2 text-gray-700 hover:bg-gray-50\">Account Settings</Link>\n                  <Link href=\"/profile/image\" className=\"block px-4 py-2 text-gray-700 hover:bg-gray-50\">Upload/Change Profile Photo</Link>\n                  <Link href=\"/billing\" className=\"block px-4 py-2 text-gray-700 hover:bg-gray-50\">Subscription & Billing</Link>\n                  <Link href=\"/notifications\" className=\"block px-4 py-2 text-gray-700 hover:bg-gray-50\">Notifications</Link>\n                  <Link href=\"/privacy\" className=\"block px-4 py-2 text-gray-700 hover:bg-gray-50\">Privacy Settings</Link>\n                  <Link href=\"/help\" className=\"block px-4 py-2 text-gray-700 hover:bg-gray-50\">Help & Support</Link>\n                  <button\n                    onClick={() => signOut({ callbackUrl: '/auth/signin' })}\n                    className=\"block w-full text-left px-4 py-2 text-red-600 hover:bg-gray-50 font-semibold\"\n                  >\n                    Logout\n                  </button>\n                </div>\n              )}\n            </div>\n          </div>\n\n          {/* Mobile Profile - Show on mobile */}\n          <div className=\"md:hidden\">\n            <div className=\"relative dropdown-container\" id=\"mobile-profile-dropdown\">\n              <button\n                onClick={() => setDropdownOpen((v) => !v)}\n                className=\"focus:outline-none\"\n                aria-label=\"Open profile menu\"\n              >\n                <Image\n                  src={userImage}\n                  alt=\"Profile\"\n                  width={36}\n                  height={36}\n                  className=\"w-9 h-9 rounded-full border-2 border-helfi-green shadow-sm object-cover\"\n                />\n              </button>\n              {dropdownOpen && (\n                <div className=\"absolute right-0 mt-2 w-64 bg-white rounded-xl shadow-lg py-2 z-50 border border-gray-100\">\n                  <div className=\"flex items-center px-4 py-3 border-b border-gray-100\">\n                    <Image\n                      src={userImage}\n                      alt=\"Profile\"\n                      width={40}\n                      height={40}\n                      className=\"w-10 h-10 rounded-full object-cover mr-3\"\n                    />\n                    <div>\n                      <div className=\"font-semibold text-gray-900\">{userName}</div>\n                      <div className=\"text-xs text-gray-500\">{session?.user?.email || 'user@email.com'}</div>\n                    </div>\n                  </div>\n                  <Link href=\"/profile\" className=\"block px-4 py-2 text-gray-700 hover:bg-gray-50\">Profile</Link>\n                  <Link href=\"/account\" className=\"block px-4 py-2 text-gray-700 hover:bg-gray-50\">Account Settings</Link>\n                  <Link href=\"/profile/image\" className=\"block px-4 py-2 text-gray-700 hover:bg-gray-50\">Upload/Change Profile Photo</Link>\n                  <Link href=\"/billing\" className=\"block px-4 py-2 text-gray-700 hover:bg-gray-50\">Subscription & Billing</Link>\n                  <Link href=\"/notifications\" className=\"block px-4 py-2 text-gray-700 hover:bg-gray-50\">Notifications</Link>\n                  <Link href=\"/privacy\" className=\"block px-4 py-2 text-gray-700 hover:bg-gray-50\">Privacy Settings</Link>\n                  <Link href=\"/help\" className=\"block px-4 py-2 text-gray-700 hover:bg-gray-50\">Help & Support</Link>\n                  <button\n                    onClick={() => signOut({ callbackUrl: '/auth/signin' })}\n                    className=\"block w-full text-left px-4 py-2 text-red-600 hover:bg-gray-50 font-semibold\"\n                  >\n                    Logout\n                  </button>\n                </div>\n              )}\n            </div>\n          </div>\n        </div>\n      </div>\n\n\n\n      {/* Main Content */}\n              <div className=\"max-w-7xl mx-auto px-4 py-8 pb-24 md:pb-8\">\n        <div className=\"bg-white rounded-lg shadow-sm p-8\">\n          <div className=\"mb-6\">\n            <h1 className=\"text-2xl md:text-3xl font-bold text-helfi-black dark:text-white\">Health Tracking</h1>\n            <p className=\"text-gray-600\">Monitor your steps, heart rate, sleep, and more ‚Äî alongside your check-ins.</p>\n          </div>\n\n          <div className=\"mb-6 p-6 rounded-xl border bg-gray-50\">\n            <div className=\"flex flex-col md:flex-row md:items-center md:justify-between gap-3\">\n              <div>\n                <div className=\"flex items-center gap-2 text-lg font-semibold text-gray-900\">\n                  <Image src=\"/brands/garmin-connect.jpg\" alt=\"Garmin Connect\" width={22} height={22} className=\"rounded-md\" />\n                  <span>Garmin Connect</span>\n                </div>\n                {!garminConnectEnabled ? (\n                  <div className=\"text-sm text-gray-600\">\n                    Garmin Connect is temporarily unavailable while production approval is pending.\n                  </div>\n                ) : garminStatus?.connected ? (\n                  <div className=\"text-sm text-gray-700\">\n                    Connected{garminStatus.webhookCount ? ` ‚Ä¢ ${garminStatus.webhookCount} data deliveries received` : ''}.\n                    <div className=\"text-xs text-gray-500 mt-1\">\n                      {garminStatus.lastWebhookAt\n                        ? `Last delivery: ${new Date(garminStatus.lastWebhookAt).toLocaleString()}${garminStatus.lastDataType ? ` (${garminStatus.lastDataType})` : ''}`\n                        : 'No data has arrived yet. Open the Garmin Connect app and sync the watch, then check again in a minute.'}\n                    </div>\n                  </div>\n                ) : (\n                  <div className=\"text-sm text-gray-600\">Connect Garmin Connect to start receiving wellness data.</div>\n                )}\n              </div>\n              {!garminConnectEnabled ? (\n                <Link\n                  href=\"/devices\"\n                  className=\"px-4 py-2 bg-gray-100 text-gray-700 rounded-lg hover:bg-gray-200 transition-colors text-sm text-center\"\n                >\n                  I'm interested\n                </Link>\n              ) : (\n                <Link\n                  href=\"/devices\"\n                  className=\"px-4 py-2 bg-helfi-green text-white rounded-lg hover:bg-green-600 transition-colors text-sm text-center\"\n                >\n                  {garminStatus?.connected ? 'Manage Garmin Connect' : 'Connect Garmin Connect'}\n                </Link>\n              )}\n            </div>\n            <p className=\"mt-3 text-xs text-gray-500\">\n              Garmin and the Garmin logo are trademarks of Garmin Ltd. or its subsidiaries.\n            </p>\n          </div>\n\n          {garminConnectEnabled && garminStatus?.connected && (\n            <div className=\"space-y-6 mb-10\">\n              <GarminSummary rangeDays={7} />\n              <GarminCharts rangeDays={30} />\n              <p className=\"text-xs text-gray-500\">\n                Tip: New data arrives after the watch syncs in the Garmin Connect mobile app.\n              </p>\n            </div>\n          )}\n\n          <div className=\"pt-2 border-t border-gray-100\">\n            <div className=\"text-lg font-semibold text-gray-900 mb-3\">Fitbit</div>\n            {fitbitConnected ? (\n              <div className=\"space-y-6\">\n                <FitbitSummary rangeDays={7} />\n                <FitbitCharts rangeDays={30} />\n                <FitbitCorrelations rangeDays={30} />\n                <p className=\"text-xs text-gray-500\">\n                  Tip: For best results, sync your Fitbit daily so Helfi can align your activity and sleep with your check-ins.\n                </p>\n              </div>\n            ) : (\n              <div className=\"p-6 rounded-xl border bg-gray-50\">\n                <div className=\"flex flex-col md:flex-row md:items-center md:justify-between gap-3\">\n                  <div>\n                    <div className=\"text-lg font-semibold text-gray-900\">Connect your Fitbit</div>\n                    <div className=\"text-sm text-gray-600\">See your steps, heart rate, sleep, and weight here once connected.</div>\n                  </div>\n                  <Link href=\"/devices\" className=\"px-4 py-2 bg-helfi-green text-white rounded-lg hover:bg-green-600 transition-colors text-sm text-center\">\n                    Connect Fitbit\n                  </Link>\n                </div>\n              </div>\n            )}\n          </div>\n        </div>\n      </div>\n\n      {/* Mobile Bottom Navigation - with pressed, ripple and active states */}\n      <nav className=\"md:hidden fixed bottom-0 left-0 right-0 bg-white border-t border-gray-200 px-4 py-2 z-40\">\n        <div className=\"flex items-center justify-around\">\n          \n          {/* Dashboard */}\n          <Link href=\"/dashboard\" className=\"pressable ripple flex flex-col items-center py-2 px-1 min-w-0 flex-1\" onClick={() => { try { const reduced = window.matchMedia('(prefers-reduced-motion: reduce)')?.matches; const pref = localStorage.getItem('hapticsEnabled'); const enabled = pref === null ? true : pref === 'true'; if (enabled && !reduced && 'vibrate' in navigator) navigator.vibrate(10) } catch {} }}>\n            <div className={`icon ${pathname === '/dashboard' ? 'text-helfi-green' : 'text-gray-400'}`}>\n              <svg className=\"w-6 h-6\" fill=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path d=\"M3 13h8V3H3v10zm0 8h8v-6H3v6zm10 0h8V11h-8v10zm0-18v6h8V3h-8z\"/>\n              </svg>\n            </div>\n            <span className={`label text-xs mt-1 truncate ${pathname === '/dashboard' ? 'text-helfi-green font-bold' : 'text-gray-400 font-medium'}`}>Dashboard</span>\n          </Link>\n\n          {/* Insights (Active) - renamed from Health */}\n          <Link href=\"/health-tracking\" className=\"pressable ripple flex flex-col items-center py-2 px-1 min-w-0 flex-1\" onClick={() => { try { const reduced = window.matchMedia('(prefers-reduced-motion: reduce)')?.matches; const pref = localStorage.getItem('hapticsEnabled'); const enabled = pref === null ? true : pref === 'true'; if (enabled && !reduced && 'vibrate' in navigator) navigator.vibrate(10) } catch {} }}>\n            <div className={`icon ${pathname === '/health-tracking' ? 'text-helfi-green' : 'text-gray-400'}`}>\n              <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z\" />\n              </svg>\n            </div>\n            <span className={`label text-xs mt-1 truncate ${pathname === '/health-tracking' ? 'text-helfi-green font-bold' : 'text-gray-400 font-medium'}`}>Insights</span>\n          </Link>\n\n          {/* Food */}\n          <Link href=\"/food\" className=\"pressable ripple flex flex-col items-center py-2 px-1 min-w-0 flex-1\" onClick={() => { try { const reduced = window.matchMedia('(prefers-reduced-motion: reduce)')?.matches; const pref = localStorage.getItem('hapticsEnabled'); const enabled = pref === null ? true : pref === 'true'; if (enabled && !reduced && 'vibrate' in navigator) navigator.vibrate(10) } catch {} }}>\n            <div className={`icon ${pathname === '/food' ? 'text-helfi-green' : 'text-gray-400'}`}>\n              <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10\" />\n              </svg>\n            </div>\n            <span className={`label text-xs mt-1 truncate ${pathname === '/food' ? 'text-helfi-green font-bold' : 'text-gray-400 font-medium'}`}>Food</span>\n          </Link>\n\n          {/* Intake (Onboarding) */}\n          <MobileMoreMenu />\n\n          {/* Settings */}\n          <Link href=\"/settings\" className=\"pressable ripple flex flex-col items-center py-2 px-1 min-w-0 flex-1\" onClick={() => { try { const reduced = window.matchMedia('(prefers-reduced-motion: reduce)')?.matches; const pref = localStorage.getItem('hapticsEnabled'); const enabled = pref === null ? true : pref === 'true'; if (enabled && !reduced && 'vibrate' in navigator) navigator.vibrate(10) } catch {} }}>\n            <div className={`icon ${pathname === '/settings' ? 'text-helfi-green' : 'text-gray-400'}`}>\n              <Cog6ToothIcon className=\"w-6 h-6 flex-shrink-0\" style={{ minWidth: '24px', minHeight: '24px' }} />\n            </div>\n            <span className={`label text-xs mt-1 truncate ${pathname === '/settings' ? 'text-helfi-green font-bold' : 'text-gray-400 font-medium'}`}>Settings</span>\n          </Link>\n\n        </div>\n      </nav>\n    </div>\n  )\n} \n","truncated":false,"size":21788},{"path":"app/healthapp/page.tsx","content":"'use client'\n\nimport { useEffect } from 'react'\nimport { useRouter } from 'next/navigation'\n\nexport default function HealthApp() {\n  const router = useRouter()\n\n  useEffect(() => {\n    if (typeof window === 'undefined') return\n    router.replace('/auth/signin')\n  }, [router])\n\n  return (\n    <div className=\"min-h-screen flex items-center justify-center bg-gradient-to-b from-white to-green-50 p-4\">\n      <div className=\"text-center text-gray-700\">Redirecting‚Ä¶</div>\n    </div>\n  )\n}\n","truncated":false,"size":488},{"path":"app/help/page.tsx","content":"'use client'\nimport { Cog6ToothIcon, UserIcon } from '@heroicons/react/24/outline'\n\nimport React, { useState, useEffect } from 'react'\nimport { useSession, signOut } from 'next-auth/react'\nimport Link from 'next/link'\nimport Image from 'next/image'\nimport { useUserData } from '@/components/providers/UserDataProvider'\nimport MobileMoreMenu from '@/components/MobileMoreMenu'\n\nexport default function Help() {\n  const { data: session } = useSession()\n  const { profileImage: providerProfileImage } = useUserData()\n  const [dropdownOpen, setDropdownOpen] = useState(false)\n\n  // Profile data - prefer real photos; fall back to professional icon\n  const hasProfileImage = !!(providerProfileImage || session?.user?.image)\n  const userImage = (providerProfileImage || session?.user?.image || '') as string\n  const userName = session?.user?.name || 'User';\n\n  // Close dropdown on outside click\n  useEffect(() => {\n    function handleClick(e: MouseEvent) {\n      const target = e.target as HTMLElement;\n      // Check if click is outside both the button and the dropdown content\n      if (!target.closest('.dropdown-container')) {\n        setDropdownOpen(false);\n      }\n    }\n    if (dropdownOpen) {\n      document.addEventListener('mousedown', handleClick);\n      return () => document.removeEventListener('mousedown', handleClick);\n    }\n  }, [dropdownOpen]);\n\n  return (\n    <div className=\"min-h-screen bg-gray-50\">\n      {/* Navigation Header - First Row */}\n      <nav className=\"bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700 px-4 py-3\">\n        <div className=\"max-w-7xl mx-auto flex justify-between items-center\">\n          {/* Logo on the left */}\n          <div className=\"flex items-center\">\n            <Link href=\"/\" className=\"w-16 h-16 md:w-20 md:h-20 cursor-pointer hover:opacity-80 transition-opacity\">\n              <Image\n                src=\"/mobile-assets/LOGOS/helfi-01-01.png\"\n                alt=\"Helfi Logo\"\n                width={80}\n                height={80}\n                className=\"w-full h-full object-contain\"\n                priority\n              />\n            </Link>\n          </div>\n          \n          {/* Profile Avatar & Dropdown on the right */}\n          <div className=\"relative dropdown-container\" id=\"profile-dropdown\">\n            <button\n              onClick={() => setDropdownOpen((v) => !v)}\n              className=\"focus:outline-none\"\n              aria-label=\"Open profile menu\"\n            >\n              {hasProfileImage ? (\n                <Image\n                  src={userImage}\n                  alt=\"Profile\"\n                  width={48}\n                  height={48}\n                  className=\"w-12 h-12 rounded-full border-2 border-helfi-green shadow-sm object-cover\"\n                />\n              ) : (\n                <div className=\"w-12 h-12 rounded-full bg-helfi-green shadow-sm flex items-center justify-center\">\n                  <UserIcon className=\"w-6 h-6 text-white\" aria-hidden=\"true\" />\n                </div>\n              )}\n            </button>\n            {dropdownOpen && (\n              <div className=\"absolute right-0 mt-2 w-64 bg-white dark:bg-gray-800 rounded-xl shadow-lg py-2 z-50 border border-gray-100 dark:border-gray-700 animate-fade-in\">\n                <div className=\"flex items-center px-4 py-3 border-b border-gray-100 dark:border-gray-700\">\n                  {hasProfileImage ? (\n                    <Image\n                      src={userImage}\n                      alt=\"Profile\"\n                      width={40}\n                      height={40}\n                      className=\"w-10 h-10 rounded-full object-cover mr-3\"\n                    />\n                  ) : (\n                    <div className=\"w-10 h-10 rounded-full bg-helfi-green flex items-center justify-center mr-3\">\n                      <UserIcon className=\"w-5 h-5 text-white\" aria-hidden=\"true\" />\n                    </div>\n                  )}\n                  <div>\n                    <div className=\"font-semibold text-gray-900 dark:text-white\">{userName}</div>\n                    <div className=\"text-xs text-gray-500 dark:text-gray-400\">{session?.user?.email || 'user@email.com'}</div>\n                  </div>\n                </div>\n                <Link href=\"/settings\" className=\"block px-4 py-2 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-700 font-medium\">‚Üê Back to Settings</Link>\n                <div className=\"border-t border-gray-100 dark:border-gray-700 my-2\"></div>\n                <Link href=\"/profile\" className=\"block px-4 py-2 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-700\">Profile</Link>\n                <Link href=\"/account\" className=\"block px-4 py-2 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-700\">Account Settings</Link>\n                <Link href=\"/profile/image\" className=\"block px-4 py-2 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-700\">Upload/Change Profile Photo</Link>\n                <Link href=\"/billing\" className=\"block px-4 py-2 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-700\">Subscription & Billing</Link>\n                <Link href=\"/support\" className=\"block px-4 py-2 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-700 bg-gray-50 dark:bg-gray-700 font-medium\">Help & Support</Link>\n                <button\n                  onClick={() => signOut({ callbackUrl: '/auth/signin' })}\n                  className=\"block w-full text-left px-4 py-2 text-red-600 dark:text-red-400 hover:bg-gray-50 dark:hover:bg-gray-700 font-semibold\"\n                >\n                  Logout\n                </button>\n              </div>\n            )}\n          </div>\n        </div>\n      </nav>\n\n      {/* Second Row - Page Title Centered */}\n      <div className=\"bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700 px-4 py-4\">\n        <div className=\"max-w-7xl mx-auto text-center\">\n          <h1 className=\"text-lg md:text-xl font-semibold text-gray-900 dark:text-white\">Help & Support</h1>\n          <p className=\"text-sm text-gray-500 dark:text-gray-400 hidden sm:block\">Get help with your health journey</p>\n        </div>\n      </div>\n\n      {/* Main Content */}\n      <div className=\"max-w-3xl mx-auto px-4 py-8 pb-24 md:pb-8\">\n        <div className=\"bg-white rounded-lg shadow-sm p-6\">\n          <h2 className=\"text-2xl font-bold text-gray-900 mb-6\">How can we help you?</h2>\n          \n          {/* Quick Actions */}\n          <div className=\"grid grid-cols-1 md:grid-cols-2 gap-6 mb-8\">\n            <div className=\"p-4 border border-gray-200 rounded-lg hover:border-helfi-green transition-colors\">\n              <h3 className=\"font-semibold text-gray-900 mb-2\">Contact Support</h3>\n              <p className=\"text-gray-600 text-sm mb-3\">Get personalized help from our team</p>\n              <Link href=\"/support\" className=\"inline-block bg-helfi-green text-white px-4 py-2 rounded-lg hover:bg-helfi-green/90 transition-colors\">\n                Contact Us\n              </Link>\n            </div>\n            \n            <div className=\"p-4 border border-gray-200 rounded-lg hover:border-helfi-green transition-colors\">\n              <h3 className=\"font-semibold text-gray-900 mb-2\">FAQ</h3>\n              <p className=\"text-gray-600 text-sm mb-3\">Find answers to common questions</p>\n              <Link href=\"/faq\" className=\"inline-block bg-gray-100 text-gray-700 px-4 py-2 rounded-lg hover:bg-gray-200 transition-colors\">\n                View FAQ\n              </Link>\n            </div>\n          </div>\n\n\n        </div>\n      </div>\n\n      {/* Mobile Bottom Navigation */}\n      <nav className=\"md:hidden fixed bottom-0 left-0 right-0 bg-white border-t border-gray-200 px-4 py-2 z-40\">\n        <div className=\"flex items-center justify-around\">\n          \n          {/* Dashboard */}\n          <Link href=\"/dashboard\" className=\"flex flex-col items-center py-2 px-1 min-w-0 flex-1\">\n            <div className=\"text-gray-400\">\n              <svg className=\"w-6 h-6\" fill=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path d=\"M3 13h8V3H3v10zm0 8h8v-6H3v6zm10 0h8V11h-8v10zm0-18v6h8V3h-8z\"/>\n              </svg>\n            </div>\n            <span className=\"text-xs text-gray-400 mt-1 font-medium truncate\">Dashboard</span>\n          </Link>\n\n          {/* Insights */}\n          <Link href=\"/insights\" className=\"flex flex-col items-center py-2 px-1 min-w-0 flex-1\">\n            <div className=\"text-gray-400\">\n              <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z\" />\n              </svg>\n            </div>\n            <span className=\"text-xs text-gray-400 mt-1 font-medium truncate\">Insights</span>\n          </Link>\n\n          {/* Food */}\n          <Link href=\"/food\" className=\"flex flex-col items-center py-2 px-1 min-w-0 flex-1\">\n            <div className=\"text-gray-400\">\n              <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10\" />\n              </svg>\n            </div>\n            <span className=\"text-xs text-gray-400 mt-1 font-medium truncate\">Food</span>\n          </Link>\n\n          <MobileMoreMenu />\n\n          {/* Settings */}\n          <Link href=\"/settings\" className=\"flex flex-col items-center py-2 px-1 min-w-0 flex-1\">\n            <div className=\"text-gray-400\">\n              <Cog6ToothIcon className=\"w-6 h-6 flex-shrink-0\" style={{ minWidth: '24px', minHeight: '24px' }} />\n            </div>\n            <span className=\"text-xs text-gray-400 mt-1 font-medium truncate\">Settings</span>\n          </Link>\n\n        </div>\n      </nav>\n    </div>\n  )\n} ","truncated":false,"size":10226},{"path":"app/insights/[id]/page.tsx","content":"'use client'\n\nimport React, { useEffect, useState } from 'react'\nimport Link from 'next/link'\nimport { useParams, useRouter } from 'next/navigation'\n\nexport default function InsightDetail() {\n  const params = useParams() as { id?: string }\n  const router = useRouter()\n  const [item, setItem] = useState<any | null>(null)\n\n  useEffect(() => {\n    async function load() {\n      const res = await fetch('/api/insights/list?preview=1', { cache: 'no-cache' })\n      const data = await res.json().catch(() => ({}))\n      const it = (data?.items || []).find((x: any) => String(x.id) === String(params?.id))\n      setItem(it || null)\n    }\n    load()\n  }, [params?.id])\n\n  if (!item) {\n    return (\n      <div className=\"min-h-screen bg-gray-50\">\n        <div className=\"bg-white border-b border-gray-200 px-4 py-4\">\n          <div className=\"max-w-4xl mx-auto flex items-center gap-3\">\n            <button onClick={() => router.back()} className=\"text-helfi-green\">‚Äπ Back</button>\n            <h1 className=\"text-lg font-semibold\">Insight</h1>\n          </div>\n        </div>\n        <div className=\"max-w-4xl mx-auto px-4 py-6 text-sm text-gray-600\">Loading‚Ä¶</div>\n      </div>\n    )\n  }\n\n  const actions: string[] = Array.isArray(item.actions) ? item.actions : []\n  const reason: string = item.reason || ''\n\n  return (\n    <div className=\"min-h-screen bg-gray-50\">\n      <div className=\"bg-white border-b border-gray-200 px-4 py-4\">\n        <div className=\"max-w-4xl mx-auto flex items-center gap-3\">\n          <button onClick={() => router.back()} className=\"text-helfi-green\">‚Äπ Back</button>\n          <h1 className=\"text-lg font-semibold\">{item.title}</h1>\n        </div>\n      </div>\n      <div className=\"max-w-4xl mx-auto px-4 py-6 space-y-4\">\n        <div className=\"bg-white border border-gray-200 rounded-lg p-4\">\n          <div className=\"text-sm text-gray-700\">{item.summary}</div>\n          {reason && (\n            <div className=\"text-xs text-gray-500 mt-2\">Why: {reason}</div>\n          )}\n        </div>\n\n        {actions.length > 0 && (\n          <div className=\"bg-white border border-gray-200 rounded-lg p-4\">\n            <div className=\"font-semibold mb-2\">Actions</div>\n            <ul className=\"list-disc pl-5 space-y-2 text-sm text-gray-800\">\n              {actions.map((a, i) => (<li key={i}>{a}</li>))}\n            </ul>\n          </div>\n        )}\n\n        <div className=\"flex gap-3\">\n          <button onClick={async () => {\n            await fetch('/api/insights/state', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ action: 'pin', id: item.id }) })\n          }} className=\"flex-1 py-2 rounded-md bg-helfi-green text-white font-medium\">Pin</button>\n          <button onClick={async () => {\n            await fetch('/api/insights/state', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ action: 'dismiss', id: item.id }) })\n            router.back()\n          }} className=\"flex-1 py-2 rounded-md bg-gray-100 text-gray-800 font-medium\">Dismiss</button>\n        </div>\n\n        <div className=\"text-xs text-gray-500\">\n          Related: <Link className=\"text-helfi-green\" href=\"/food\">Log food</Link> ¬∑ <Link className=\"text-helfi-green\" href=\"/settings\">Set reminder</Link>\n        </div>\n      </div>\n    </div>\n  )\n}\n\n\n","truncated":false,"size":3338},{"path":"app/insights/goals/page.tsx","content":"'use client'\n\nimport React, { useEffect, useState } from 'react'\nimport Link from 'next/link'\n\nexport default function GoalsInsights() {\n  const [items, setItems] = useState<any[]>([])\n  const [loading, setLoading] = useState<boolean>(true)\n\n  async function load() {\n    try {\n      setLoading(true)\n      // Primary source: user's selected health issues (step 4)\n      const issuesRes = await fetch('/api/checkins/issues', { cache: 'no-cache' })\n      const issuesData = await issuesRes.json().catch(()=>({}))\n      const issueNames: string[] = Array.isArray(issuesData?.issues) ? issuesData.issues.map((i:any)=>i.name).filter(Boolean) : []\n      if (issueNames.length) {\n        setItems(issueNames.map((g) => ({ id: `goal:${g}`, title: g, summary: 'Open details', tags: ['goals'] })))\n      } else {\n        // Fallback: legacy goals from profile if issues are empty\n        const ud = await fetch('/api/user-data', { cache: 'no-cache' }).then(r=>r.json())\n        const goals: string[] = Array.isArray(ud?.data?.goals) ? ud.data.goals : []\n        setItems(goals.map((g) => ({ id: `goal:${g}`, title: g, summary: 'Open details', tags: ['goals'] })))\n      }\n    } catch {\n      setItems([])\n    } finally { setLoading(false) }\n  }\n\n  useEffect(() => { load() }, [])\n\n  return (\n    <div className=\"min-h-screen bg-gray-50\">\n      <div className=\"bg-white border-b border-gray-200 px-4 py-4\">\n        <div className=\"max-w-4xl mx-auto flex items-center gap-3\">\n          <Link href=\"/insights\" className=\"text-helfi-green\">‚Äπ Back</Link>\n          <h1 className=\"text-lg font-semibold\">Goals</h1>\n        </div>\n      </div>\n      <div className=\"max-w-4xl mx-auto px-4 py-6 space-y-4\">\n        <div className=\"flex items-center justify-between mb-2\">\n          <Link href=\"/insights\" className=\"text-helfi-green text-lg\">‚Üê Back</Link>\n          <button onClick={async()=>{ fetch('/api/insights/generate?preview=1', { method: 'POST' }).catch(()=>{}); await load() }} className=\"px-3 py-2 bg-helfi-green text-white rounded-md text-sm\">Refresh</button>\n        </div>\n        {loading && (\n          <div className=\"flex items-center gap-2 text-gray-500 text-sm\">\n            <span className=\"h-4 w-4 border-2 border-gray-300 border-t-transparent rounded-full animate-spin\"></span>\n            Loading‚Ä¶\n          </div>\n        )}\n        {!loading && items.map((it) => (\n          <Link href={String(it.id).startsWith('goal:') ? `/insights/issue/${encodeURIComponent(it.title)}` : `/insights/${encodeURIComponent(it.id)}`} key={it.id} className=\"bg-white border border-gray-200 rounded-lg p-4 block\">\n            <div className=\"font-semibold text-gray-900 mb-1\">{it.title}</div>\n            <div className=\"text-sm text-gray-700\">{it.summary}</div>\n          </Link>\n        ))}\n        {!loading && items.length === 0 && (\n          <div className=\"text-sm text-gray-600\">No goals found in your profile yet.</div>\n        )}\n      </div>\n    </div>\n  )\n}\n\n\n","truncated":false,"size":2967},{"path":"app/insights/InsightLandingClient.tsx","content":"'use client'\n\nimport Link from 'next/link'\nimport { useEffect, useMemo, useState, useTransition, type MouseEvent } from 'react'\nimport { useRouter } from 'next/navigation'\nimport type { IssueSummary, InsightDataNeed } from '@/lib/insights/issue-engine'\nimport InsightsTopNav from './InsightsTopNav'\nimport InsightsBottomNav from './InsightsBottomNav'\n\ninterface InsightsLandingClientProps {\n  sessionUser: {\n    name: string | null\n    email: string | null\n    image: string | null\n  }\n  issues: IssueSummary[]\n  generatedAt: string\n  onboardingComplete: boolean\n  dataNeeds: InsightDataNeed[]\n}\n\nexport default function InsightsLandingClient({ sessionUser, issues, generatedAt, onboardingComplete, dataNeeds }: InsightsLandingClientProps) {\n  const router = useRouter()\n  const [pendingSlug, setPendingSlug] = useState<string | null>(null)\n  const [isNavigating, startTransition] = useTransition()\n  const [isUpdating, setIsUpdating] = useState(false)\n  const [updateMessage, setUpdateMessage] = useState<string | null>(null)\n  const lastLoaded = generatedAt\n\n  const actionableNeeds = dataNeeds.filter((need) => need.status !== 'complete')\n  const completedNeeds = dataNeeds.filter((need) => need.status === 'complete')\n  const primaryIssueSlug = issues[0]?.slug\n  const pendingIssueName = useMemo(() => issues.find((issue) => issue.slug === pendingSlug)?.name ?? null, [issues, pendingSlug])\n\n  useEffect(() => {\n    if (issues.length === 0) return\n    issues.slice(0, 3).forEach((issue) => {\n      try {\n        router.prefetch(`/insights/issues/${issue.slug}`)\n      } catch {\n        // prefetch failures are non-blocking\n      }\n    })\n  }, [issues, router])\n\n  async function handleUpdateInsights() {\n    if (isUpdating) return\n    \n    setIsUpdating(true)\n    setUpdateMessage('Regenerating insights...')\n    \n    try {\n      const response = await fetch('/api/insights/regenerate', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n      })\n      \n      const data = await response.json()\n      \n      if (response.ok) {\n        setUpdateMessage('Insights are being regenerated. This may take a few minutes. Refresh the page to see updates.')\n        // Refresh the page after a delay to show updated insights\n        setTimeout(() => {\n          router.refresh()\n        }, 3000)\n      } else {\n        setUpdateMessage(data.message || 'Failed to regenerate insights. Please try again.')\n        setIsUpdating(false)\n      }\n    } catch (error) {\n      setUpdateMessage('Failed to regenerate insights. Please try again.')\n      setIsUpdating(false)\n    }\n  }\n\n  const deepDiveSections = [\n    {\n      key: 'nutrition',\n      title: 'Nutrition & Food',\n      description: 'See how meals and macros support each issue.',\n      href: '/insights/nutrition',\n    },\n    {\n      key: 'supplements',\n      title: 'Supplements & Medications',\n      description: 'Track timing, gaps, and backup plans.',\n      href: '/insights/supplements',\n    },\n    {\n      key: 'sleep',\n      title: 'Sleep & Recovery',\n      description: 'Review sleep trends tied to your goals.',\n      href: '/insights/sleep',\n    },\n    {\n      key: 'safety',\n      title: 'Safety Flags',\n      description: 'Spot potential interactions or red flags early.',\n      href: '/insights/safety',\n    },\n  ]\n\n  function triggerHaptic() {\n    try {\n      const reduced = window.matchMedia('(prefers-reduced-motion: reduce)')?.matches\n      const pref = localStorage.getItem('hapticsEnabled')\n      const enabled = pref === null ? true : pref === 'true'\n      if (!reduced && enabled && 'vibrate' in navigator) {\n        navigator.vibrate(10)\n      }\n    } catch {\n      // ignore haptic errors\n    }\n  }\n\n  function handleIssueClick(event: MouseEvent<HTMLAnchorElement>, slug: string) {\n    event.preventDefault()\n    triggerHaptic()\n    const href = `/insights/issues/${slug}`\n    setPendingSlug(slug)\n    startTransition(() => {\n      router.push(href)\n    })\n  }\n\n  return (\n    <div className=\"min-h-screen bg-gray-50\" aria-busy={isNavigating}>\n      <InsightsTopNav sessionUser={sessionUser} />\n\n      <header className=\"bg-white border-b border-gray-200 px-4 py-6\">\n        <div className=\"max-w-7xl mx-auto text-center md:text-left\">\n          <div className=\"flex flex-col md:flex-row md:items-center md:justify-between gap-4\">\n            <div>\n              <h1 className=\"text-3xl font-bold text-gray-900\">Your health focus areas</h1>\n              <p className=\"text-sm text-gray-500 mt-2\">Start with your tracked issues, then unlock deeper reports.</p>\n            </div>\n            <div className=\"flex flex-col items-center md:items-end gap-2\">\n              {/* Update Insights button removed - insights update automatically when health data changes */}\n              <div className=\"text-xs text-gray-400 md:text-right\">\n                Updated {new Date(lastLoaded).toLocaleString()}\n              </div>\n            </div>\n          </div>\n        </div>\n      </header>\n\n      <main className=\"max-w-6xl mx-auto px-4 py-10 pb-24 md:pb-10 space-y-10\">\n        {issues.length === 0 ? (\n          !onboardingComplete ? (\n            <EmptyState\n              emoji=\"üìù\"\n              title=\"Finish onboarding to unlock insights\"\n              description=\"Complete your intake so we can analyse the health concerns that matter most to you.\"\n              actionLabel=\"Resume onboarding\"\n              actionHref=\"/onboarding\"\n            />\n          ) : (\n            <EmptyState\n              emoji=\"üîç\"\n              title=\"No health issues tracked yet\"\n              description=\"Add issues through onboarding or Health Tracking so we can generate focused insights for you.\"\n            />\n          )\n        ) : (\n          <section className=\"space-y-4\">\n            <div className=\"flex items-center justify-between\">\n              <h2 className=\"text-lg font-semibold text-gray-900\">Tracked issues</h2>\n              <span className=\"text-xs uppercase tracking-wide text-gray-500\">Tap to open workspace</span>\n            </div>\n            <div className=\"bg-white border border-gray-200 rounded-2xl divide-y\">\n              {issues.map((issue) => (\n                <Link\n                  key={issue.id}\n                  href={`/insights/issues/${issue.slug}`}\n                  className={`flex flex-col gap-3 px-5 py-5 transition-colors md:flex-row md:items-center md:justify-between ${\n                    isNavigating ? 'pointer-events-none opacity-60' : 'hover:bg-gray-50'\n                  }`}\n                  onClick={(event) => handleIssueClick(event, issue.slug)}\n                >\n                  <div className=\"flex items-start gap-3\">\n                    <span className=\"inline-flex h-10 w-10 shrink-0 items-center justify-center rounded-full bg-helfi-green/10 text-lg\">üí°</span>\n                    <div className=\"space-y-1\">\n                      <div className=\"flex flex-wrap items-center gap-2 text-xs uppercase tracking-wide font-semibold\">\n                        <StatusBadge issue={issue} />\n                        {issue.currentRating !== null && (\n                          <span className=\"text-gray-400\">{issue.currentRating}/{issue.ratingScaleMax ?? 6}</span>\n                        )}\n                      </div>\n                      <h3 className=\"text-lg font-semibold text-gray-900\">{issue.name}</h3>\n                      <p className=\"text-sm text-gray-600 leading-relaxed\">\n                        {issue.highlight || 'Open the workspace to see personalised guidance.'}\n                      </p>\n                      {issue.lastUpdated && (\n                        <p className=\"text-xs text-gray-400\">Last updated {new Date(issue.lastUpdated).toLocaleDateString()}</p>\n                      )}\n                    </div>\n                  </div>\n                  <div className=\"flex items-center justify-between md:justify-end md:gap-4\">\n                    {issue.blockers.length > 0 && (\n                      <p className=\"text-xs text-amber-600 max-w-xs md:text-right\">Next step: {issue.blockers[0]}</p>\n                    )}\n                    <span className=\"text-2xl text-gray-400\">‚Ä∫</span>\n                  </div>\n                </Link>\n              ))}\n            </div>\n          </section>\n        )}\n\n        {/* Unlock / Deep-dive sections removed per request */}\n      </main>\n\n        <InsightsBottomNav />\n      {isNavigating && (\n        <div className=\"fixed inset-0 z-50 flex flex-col items-center justify-center bg-white/80 backdrop-blur-sm\">\n          <span className=\"h-10 w-10 animate-spin rounded-full border-4 border-helfi-green border-t-transparent\" />\n          <p className=\"mt-3 text-sm font-semibold text-gray-700\">\n            {pendingIssueName ? `Opening ${pendingIssueName} workspace‚Ä¶` : 'Loading workspace‚Ä¶'}\n          </p>\n        </div>\n      )}\n    </div>\n  )\n}\n\nfunction formatNeedStatus(status: InsightDataNeed['status']) {\n  switch (status) {\n    case 'complete':\n      return 'Complete'\n    case 'in-progress':\n      return 'In progress'\n    default:\n      return 'Needs attention'\n  }\n}\n\nfunction EmptyState({ emoji, title, description, actionLabel, actionHref }: { emoji: string; title: string; description: string; actionLabel?: string; actionHref?: string }) {\n  return (\n    <div className=\"bg-white border border-dashed border-gray-300 rounded-2xl p-10 text-center\">\n      <div className=\"text-5xl mb-4\" aria-hidden>{emoji}</div>\n      <h2 className=\"text-xl font-semibold text-gray-900 mb-2\">{title}</h2>\n      <p className=\"text-gray-600 mb-6 max-w-xl mx-auto\">{description}</p>\n      {actionLabel && actionHref && (\n        <Link href={actionHref} className=\"inline-block px-4 py-2 rounded-md bg-helfi-green text-white text-sm font-semibold\">\n          {actionLabel}\n        </Link>\n      )}\n    </div>\n  )\n}\n\nfunction StatusBadge({ issue }: { issue: IssueSummary }) {\n  const palette: Record<IssueSummary['status'], string> = {\n    'focus': 'bg-rose-100 text-rose-700 border border-rose-200',\n    'monitor': 'bg-amber-100 text-amber-700 border border-amber-200',\n    'on-track': 'bg-emerald-100 text-emerald-700 border border-emerald-200',\n    'needs-data': 'bg-gray-100 text-gray-600 border border-gray-200',\n  }\n\n  const className = palette[issue.status] ?? 'bg-gray-100 text-gray-600 border border-gray-200'\n  const label = issue.severityLabel || 'Needs data'\n\n  return <span className={`inline-flex items-center rounded-full px-3 py-1 text-xs font-semibold ${className}`}>{label}</span>\n}\n\nfunction resolveNeedHref(need: InsightDataNeed, firstIssueSlug?: string) {\n  // Health-setup related needs should always go to Health Setup pages.\n  if (need.key === 'blood-results') return '/onboarding?step=9'\n  if (need.key === 'health-situations') return '/onboarding?step=health-situations'\n  if (need.key === 'supplements-backup' || need.key === 'supplements-emergency') return '/onboarding?step=1'\n  return need.href\n}\n","truncated":false,"size":10970},{"path":"app/insights/InsightsBottomNav.tsx","content":"'use client'\nimport { Cog6ToothIcon } from '@heroicons/react/24/outline'\n\nimport Link from 'next/link'\nimport { usePathname } from 'next/navigation'\n\nfunction triggerHaptic() {\n  try {\n    const reduced = window.matchMedia('(prefers-reduced-motion: reduce)')?.matches\n    const pref = typeof window !== 'undefined' ? localStorage.getItem('hapticsEnabled') : null\n    const enabled = pref === null ? true : pref === 'true'\n    if (!reduced && enabled && typeof navigator !== 'undefined' && 'vibrate' in navigator) {\n      navigator.vibrate(10)\n    }\n  } catch {\n    // ignore haptic errors\n  }\n}\n\nexport default function InsightsBottomNav() {\n  const pathname = usePathname()\n  const items: Array<{ href: string; label: string; svg: JSX.Element; active: boolean }> = [\n    {\n      href: '/dashboard',\n      label: 'Dashboard',\n      svg: (\n        <svg className=\"w-6 h-6\" fill=\"currentColor\" viewBox=\"0 0 24 24\">\n          <path d=\"M3 13h8V3H3v10zm0 8h8v-6H3v6zm10 0h8V11h-8v10zm0-18v6h8V3h-8z\" />\n        </svg>\n      ),\n      active: pathname === '/dashboard',\n    },\n    {\n      href: '/insights',\n      label: 'Insights',\n      svg: (\n        <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n          <path\n            strokeLinecap=\"round\"\n            strokeLinejoin=\"round\"\n            strokeWidth={2}\n            d=\"M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z\"\n          />\n        </svg>\n      ),\n      active: pathname.startsWith('/insights'),\n    },\n    {\n      href: '/food',\n      label: 'Food',\n      svg: (\n        <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n          <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10\" />\n        </svg>\n      ),\n      active: pathname === '/food',\n    },\n    // Intake moved to More menu\n    {\n      href: '/settings',\n      label: 'Settings',\n      svg: (<Cog6ToothIcon className=\"w-6 h-6 flex-shrink-0\" style={{ minWidth: '24px', minHeight: '24px' }} />),\n      active: pathname === '/settings',\n    },\n  ]\n\n  return (\n    <nav className=\"md:hidden fixed bottom-0 left-0 right-0 bg-white border-t border-gray-200 px-4 py-2 z-40\">\n      <div className=\"flex items-center justify-around\">\n        {items.map((item) => (\n          <Link\n            key={item.href}\n            href={item.href}\n            className=\"pressable ripple flex flex-col items-center py-2 px-1 min-w-0 flex-1\"\n            onClick={triggerHaptic}\n          >\n            <div className={`icon ${item.active ? 'text-helfi-green' : 'text-gray-400'}`}>{item.svg}</div>\n            <span className={`label text-xs mt-1 truncate ${item.active ? 'text-helfi-green font-bold' : 'text-gray-400 font-medium'}`}>\n              {item.label}\n            </span>\n          </Link>\n        ))}\n        <Link\n          href=\"/more\"\n          className=\"pressable ripple flex flex-col items-center py-2 px-1 min-w-0 flex-1\"\n          onClick={triggerHaptic}\n        >\n          <div className={`icon ${pathname === '/more' ? 'text-helfi-green' : 'text-gray-400'}`}>\n            <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M12 6.75a1.5 1.5 0 110-3 1.5 1.5 0 010 3zm0 6a1.5 1.5 0 110-3 1.5 1.5 0 010 3zm0 6a1.5 1.5 0 110-3 1.5 1.5 0 010 3z\"/>\n            </svg>\n          </div>\n          <span className={`label text-xs mt-1 truncate ${pathname === '/more' ? 'text-helfi-green font-bold' : 'text-gray-400 font-medium'}`}>More</span>\n        </Link>\n      </div>\n    </nav>\n  )\n}\n","truncated":false,"size":3910},{"path":"app/insights/InsightsTopNav.tsx","content":"'use client'\n\nimport { useEffect, useMemo, useState } from 'react'\nimport Link from 'next/link'\nimport Image from 'next/image'\nimport { signOut } from 'next-auth/react'\nimport { useUserData } from '@/components/providers/UserDataProvider'\nimport { UserIcon } from '@heroicons/react/24/outline'\n\nexport const DEFAULT_INSIGHTS_AVATAR = '' // no longer used; kept for backward compatibility\n\ninterface InsightsTopNavProps {\n  sessionUser: {\n    name: string | null\n    email: string | null\n    image: string | null\n  }\n}\n\nexport default function InsightsTopNav({ sessionUser }: InsightsTopNavProps) {\n  const { profileImage: providerProfileImage } = useUserData()\n  const [dropdownOpen, setDropdownOpen] = useState(false)\n  const [affiliateMenu, setAffiliateMenu] = useState<{ label: string; href: string } | null>(null)\n\n  const hasProfileImage = useMemo(\n    () => !!(providerProfileImage || sessionUser.image),\n    [providerProfileImage, sessionUser.image]\n  )\n  const avatarSrc = useMemo(() => {\n    return (providerProfileImage || sessionUser.image || '') as string\n  }, [providerProfileImage, sessionUser.image])\n\n  useEffect(() => {\n    function handleClick(e: MouseEvent) {\n      const target = e.target as HTMLElement\n      if (!target.closest('.dropdown-container')) {\n        setDropdownOpen(false)\n      }\n    }\n    if (dropdownOpen) {\n      document.addEventListener('mousedown', handleClick)\n      return () => document.removeEventListener('mousedown', handleClick)\n    }\n  }, [dropdownOpen])\n\n  useEffect(() => {\n    if (!sessionUser?.email) {\n      setAffiliateMenu(null)\n      return\n    }\n    let cancelled = false\n    setAffiliateMenu({ label: 'Become an Affiliate', href: '/affiliate/apply' })\n    const loadAffiliateMenu = async () => {\n      try {\n        const res = await fetch('/api/affiliate/application', { cache: 'no-store' })\n        const data = await res.json().catch(() => ({} as any))\n        if (!res.ok) return\n        const hasAffiliate = !!data?.affiliate\n        const hasApplication = !!data?.application\n        const menu = hasAffiliate\n          ? { label: 'Affiliate Portal', href: '/affiliate' }\n          : hasApplication\n            ? { label: 'Affiliate Application', href: '/affiliate/apply' }\n            : { label: 'Become an Affiliate', href: '/affiliate/apply' }\n        if (!cancelled) setAffiliateMenu(menu)\n      } catch {\n        // ignore\n      }\n    }\n    loadAffiliateMenu()\n    return () => {\n      cancelled = true\n    }\n  }, [sessionUser?.email])\n\n  return (\n    <nav className=\"bg-white border-b border-gray-200 px-4 py-3\">\n      <div className=\"max-w-7xl mx-auto flex justify-between items-center\">\n        {/* Page Title - Mobile only (desktop has sidebar) */}\n        <h1 className=\"md:hidden flex-1 text-center text-lg font-semibold text-gray-900\">Insights</h1>\n        <div className=\"hidden md:block\"></div>\n\n        {/* Profile Avatar & Dropdown */}\n        <div className=\"relative dropdown-container\" id=\"insights-profile-dropdown\">\n          <button\n            onClick={() => setDropdownOpen((v) => !v)}\n            className=\"focus:outline-none\"\n            aria-label=\"Open profile menu\"\n          >\n            {hasProfileImage ? (\n              <Image\n                src={avatarSrc}\n                alt=\"Profile\"\n                width={48}\n                height={48}\n                className=\"w-12 h-12 rounded-full border-2 border-helfi-green shadow-sm object-cover\"\n              />\n            ) : (\n              <div className=\"w-12 h-12 rounded-full bg-helfi-green shadow-sm flex items-center justify-center\">\n                <UserIcon className=\"w-6 h-6 text-white\" aria-hidden=\"true\" />\n              </div>\n            )}\n          </button>\n          {dropdownOpen && (\n            <div className=\"absolute right-0 mt-2 w-64 bg-white rounded-xl shadow-lg py-2 z-50 border border-gray-100\">\n              <div className=\"flex items-center px-4 py-3 border-b border-gray-100\">\n                {hasProfileImage ? (\n                  <Image\n                    src={avatarSrc}\n                    alt=\"Profile\"\n                    width={40}\n                    height={40}\n                    className=\"w-10 h-10 rounded-full object-cover mr-3\"\n                  />\n                ) : (\n                  <div className=\"w-10 h-10 rounded-full bg-helfi-green flex items-center justify-center mr-3\">\n                    <UserIcon className=\"w-6 h-6 text-white\" aria-hidden=\"true\" />\n                  </div>\n                )}\n                <div>\n                  <div className=\"font-semibold text-gray-900\">{sessionUser.name || 'User'}</div>\n                  <div className=\"text-xs text-gray-500\">{sessionUser.email || 'user@email.com'}</div>\n                </div>\n              </div>\n              <Link href=\"/profile\" className=\"block px-4 py-2 text-gray-700 hover:bg-gray-50\">Profile</Link>\n              <Link href=\"/account\" className=\"block px-4 py-2 text-gray-700 hover:bg-gray-50\">Account Settings</Link>\n              <Link href=\"/profile/image\" className=\"block px-4 py-2 text-gray-700 hover:bg-gray-50\">Upload/Change Profile Photo</Link>\n              <Link href=\"/billing\" className=\"block px-4 py-2 text-gray-700 hover:bg-gray-50\">Subscription & Billing</Link>\n              {affiliateMenu && (\n                <Link href={affiliateMenu.href} className=\"block px-4 py-2 text-gray-700 hover:bg-gray-50\">\n                  {affiliateMenu.label}\n                </Link>\n              )}\n              <Link href=\"/notifications\" className=\"block px-4 py-2 text-gray-700 hover:bg-gray-50\">Notifications</Link>\n              <Link href=\"/help\" className=\"block px-4 py-2 text-gray-700 hover:bg-gray-50\">Help & Support</Link>\n              <button\n                onClick={() => signOut({ callbackUrl: '/auth/signin' })}\n                className=\"block w-full text-left px-4 py-2 text-red-600 hover:bg-gray-50 font-semibold\"\n              >\n                Logout\n              </button>\n            </div>\n          )}\n        </div>\n      </div>\n    </nav>\n  )\n}\n","truncated":false,"size":6069},{"path":"app/insights/issue/[name]/page.tsx","content":"'use client'\n\nimport React, { useEffect, useState } from 'react'\nimport Link from 'next/link'\nimport { useParams, useSearchParams } from 'next/navigation'\n\nexport default function IssueDetail() {\n  const { name } = useParams() as { name?: string }\n  const search = useSearchParams()\n  const tab = search.get('tab') || 'overview'\n  const [item, setItem] = useState<any | null>(null)\n  const [loading, setLoading] = useState<boolean>(true)\n  const [range, setRange] = useState<'daily'|'weekly'|'custom'>('daily')\n  const [from, setFrom] = useState<string>('')\n  const [to, setTo] = useState<string>('')\n  const [lastUpdated, setLastUpdated] = useState<string>('')\n  const [items, setItems] = useState<any[]>([])\n  const [generating, setGenerating] = useState<boolean>(false)\n\n  useEffect(() => {\n    async function load() {\n      try {\n        setLoading(true)\n        const res = await fetch(`/api/insights/detail?issue=${encodeURIComponent(String(name||''))}`, { cache: 'no-cache' })\n        const js = await res.json().catch(()=>({}))\n        const d = js?.data || {}\n        setItem({\n          id: `issue:${name}`,\n          title: d.title || String(name || '').replace(/%20/g,' '),\n          summary: d.what || (tab === 'nutrition' ? 'Nutrition guidance for this issue.' : 'Recommendations for this issue.'),\n          reason: d.reason,\n          actions: Array.isArray(d.actions) ? d.actions : []\n        })\n        setLastUpdated(new Date().toLocaleTimeString())\n      } finally { setLoading(false) }\n    }\n    load()\n  }, [name, tab])\n\n  if (!item) return null\n\n  return (\n    <div className=\"min-h-screen bg-gray-50\">\n      <div className=\"bg-white border-b border-gray-200 px-4 py-4\">\n        <div className=\"max-w-4xl mx-auto flex items-center gap-3\">\n          <Link href=\"/insights/goals\" className=\"text-helfi-green\">‚Üê Back</Link>\n          <h1 className=\"text-lg font-semibold\">{item.title}</h1>\n        </div>\n      </div>\n      <div className=\"max-w-4xl mx-auto px-4 py-6 space-y-4\">\n        {/* Report options */}\n        <div className=\"bg-white border border-gray-200 rounded-lg p-4\">\n          <div className=\"font-semibold mb-2\">Generate report</div>\n          <div className=\"flex flex-wrap items-center gap-2 mb-3\">\n            <button onClick={()=>setRange('daily')} className={`px-3 py-1.5 rounded-md text-sm border ${range==='daily'?'bg-helfi-green text-white border-helfi-green':'bg-white text-gray-800 border-gray-200'}`}>Daily</button>\n            <button onClick={()=>setRange('weekly')} className={`px-3 py-1.5 rounded-md text-sm border ${range==='weekly'?'bg-helfi-green text-white border-helfi-green':'bg-white text-gray-800 border-gray-200'}`}>Weekly</button>\n            <button onClick={()=>setRange('custom')} className={`px-3 py-1.5 rounded-md text-sm border ${range==='custom'?'bg-helfi-green text-white border-helfi-green':'bg-white text-gray-800 border-gray-200'}`}>Custom</button>\n          </div>\n          {range==='custom' && (\n            <div className=\"flex flex-wrap items-center gap-2 mb-2\">\n              <input type=\"date\" value={from} onChange={(e)=>setFrom(e.target.value)} className=\"border border-gray-300 rounded-md px-2 py-1 text-sm\"/>\n              <span className=\"text-gray-500 text-sm\">to</span>\n              <input type=\"date\" value={to} onChange={(e)=>setTo(e.target.value)} className=\"border border-gray-300 rounded-md px-2 py-1 text-sm\"/>\n            </div>\n          )}\n          <div className=\"flex items-center gap-2\">\n            <button onClick={async()=>{ \n              try {\n                setGenerating(true)\n                // Kick off generation (preview uses cached pipeline and avoids cost if disabled)\n                await fetch('/api/insights/generate?preview=1', { method: 'POST' }).catch(()=>{})\n                // Load the latest list immediately after\n                const res = await fetch('/api/insights/list?preview=1', { cache: 'no-cache' })\n                const js = await res.json().catch(()=>({}))\n                const arr: any[] = Array.isArray(js?.items) ? js.items : []\n                setItems(arr)\n                setLastUpdated(new Date().toLocaleTimeString())\n              } finally {\n                setGenerating(false)\n              }\n            }} className=\"px-3 py-2 bg-helfi-green text-white rounded-md text-sm disabled:opacity-50\" disabled={generating}>{generating ? 'Generating‚Ä¶' : 'Generate'}</button>\n            {lastUpdated && <div className=\"text-xs text-gray-500\">Last updated: {lastUpdated}</div>}\n          </div>\n        </div>\n\n        {loading && (\n          <div className=\"flex items-center gap-2 text-gray-500 text-sm\">\n            <span className=\"h-4 w-4 border-2 border-gray-300 border-t-transparent rounded-full animate-spin\"></span>\n            Loading‚Ä¶\n          </div>\n        )}\n        {!loading && (\n          <>\n            <div className=\"bg-white border border-gray-200 rounded-lg p-4\">\n              <div className=\"text-sm text-gray-700\">{item.summary}</div>\n              {item.reason && <div className=\"text-xs text-gray-500 mt-2\">Why: {item.reason}</div>}\n            </div>\n            <div className=\"bg-white border border-gray-200 rounded-lg p-4\">\n              <div className=\"font-semibold mb-2\">Actions</div>\n              <ul className=\"list-disc pl-5 space-y-2 text-sm text-gray-800\">\n                {item.actions?.length ? item.actions.map((a:string, i:number)=>(<li key={i}>{a}</li>)) : <li>No actions yet.</li>}\n              </ul>\n            </div>\n\n            {/* Render generated insights list */}\n            <div className=\"bg-white border border-gray-200 rounded-lg p-4\">\n              <div className=\"font-semibold mb-2\">Report</div>\n              {items.length === 0 ? (\n                <div className=\"text-sm text-gray-600\">No report yet. Tap Generate above.</div>\n              ) : (\n                <div className=\"space-y-4\">\n                  {items.map((it:any)=> (\n                    <div key={it.id} className=\"border border-gray-200 rounded-lg p-3\">\n                      <div className=\"text-xs text-gray-500 mb-1\">{Array.isArray(it.tags) ? it.tags.slice(0,3).join(' ‚Ä¢ ') : ''}</div>\n                      <div className=\"font-semibold text-gray-900 mb-1\">{it.title}</div>\n                      <div className=\"text-sm text-gray-700 mb-2\">{it.summary}</div>\n                      {it.reason && <div className=\"text-xs text-gray-500 mb-2\">Why: {it.reason}</div>}\n                      {Array.isArray(it.actions) && it.actions.length > 0 && (\n                        <ul className=\"list-disc pl-5 space-y-1 text-sm text-gray-800\">\n                          {it.actions.slice(0,5).map((a:string, idx:number)=>(<li key={idx}>{a}</li>))}\n                        </ul>\n                      )}\n                    </div>\n                  ))}\n                </div>\n              )}\n            </div>\n          </>\n        )}\n      </div>\n    </div>\n  )\n}\n\n\n","truncated":false,"size":6945},{"path":"app/insights/issues/[issueSlug]/exercise/avoid/page.tsx","content":"'use client'\n\nimport { useExerciseContext } from '../ExerciseShell'\n\nexport default function ExerciseAvoidPage() {\n  const { extras } = useExerciseContext()\n  const items = extras.avoidActivities ?? []\n\n  if (!items.length) {\n    return (\n      <div className=\"bg-white border border-gray-200 rounded-2xl shadow-sm p-6 text-sm text-gray-700\">\n        Nothing in your current log is signalling as counterproductive. Keep spacing intense sessions with recovery days.\n      </div>\n    )\n  }\n\n  return (\n    <div className=\"space-y-3\">\n      {items.map((activity, index) => (\n        <div key={`${activity.title}-${index}`} className=\"border border-rose-200 bg-rose-50/70 rounded-2xl p-5\">\n          <h3 className=\"text-base font-semibold text-rose-700\">{activity.title}</h3>\n          <p className=\"text-sm text-rose-700 mt-1 leading-relaxed\">{activity.reason}</p>\n          <p className=\"text-xs text-rose-700 mt-3\">Check in with your coach or clinician before continuing this pattern.</p>\n        </div>\n      ))}\n    </div>\n  )\n}\n","truncated":false,"size":1030},{"path":"app/insights/issues/[issueSlug]/exercise/ExerciseShell.tsx","content":"'use client'\n\nimport { createContext, ReactNode, useContext, useEffect, useMemo, useState } from 'react'\nimport Link from 'next/link'\nimport { useSelectedLayoutSegments } from 'next/navigation'\nimport SectionChat from '../SectionChat'\nimport type { IssueSectionResult } from '@/lib/insights/issue-engine'\n\n// Progress bar component: indeterminate shimmer to avoid misleading ‚Äústuck‚Äù states\nfunction ProgressBar() {\n  return (\n    <div className=\"w-full bg-gray-200 rounded-full h-2 overflow-hidden relative\">\n      <div className=\"absolute inset-0 bg-gradient-to-r from-helfi-green/30 via-helfi-green to-helfi-green/30 animate-pulse\" />\n    </div>\n  )\n}\n\ntype TabKey = 'working' | 'suggested' | 'avoid'\n\ntype ExerciseExtras = {\n  workingActivities?: Array<{ title: string; reason: string; summary: string; lastLogged: string }>\n  suggestedActivities?: Array<{ title: string; reason: string }>\n  avoidActivities?: Array<{ title: string; reason: string }>\n  totalLogged?: number\n}\n\ninterface ExerciseContextValue {\n  result: IssueSectionResult\n  loading: boolean\n  error: string | null\n  handleGenerate: (mode: 'daily' | 'weekly' | 'custom', range?: { from?: string; to?: string }) => Promise<void>\n  issueSlug: string\n  extras: ExerciseExtras\n}\n\nconst ExerciseContext = createContext<ExerciseContextValue | null>(null)\n\nexport function useExerciseContext() {\n  const ctx = useContext(ExerciseContext)\n  if (!ctx) {\n    throw new Error('useExerciseContext must be used within ExerciseShell')\n  }\n  return ctx\n}\n\ninterface ExerciseShellProps {\n  children: ReactNode\n  initialResult: IssueSectionResult | null\n  issueSlug: string\n}\n\nexport default function ExerciseShell({ children, initialResult, issueSlug }: ExerciseShellProps) {\n  const [result, setResult] = useState<IssueSectionResult | null>(initialResult)\n  const [loading, setLoading] = useState(!initialResult)\n  const [error, setError] = useState<string | null>(null)\n  const segments = useSelectedLayoutSegments()\n  const activeTab = (segments?.[0] as TabKey | undefined) ?? 'working'\n  const DEBUG = process.env.NEXT_PUBLIC_DEBUG_INSIGHTS === '1' || process.env.NEXT_PUBLIC_DEBUG_INSIGHTS === 'true'\n\n  // Fetch data client-side if SSR returned null (cache miss)\n  useEffect(() => {\n    if (!initialResult) {\n      setLoading(true)\n      const scrollPosition = window.scrollY || document.documentElement.scrollTop\n      // Save scroll position to prevent any scrolling\n      sessionStorage.setItem(`scroll-${issueSlug}-exercise`, scrollPosition.toString())\n      \n      fetch(`/api/insights/issues/${issueSlug}/sections/exercise`)\n        .then((res) => {\n          if (!res.ok) {\n            throw new Error('Failed to load section')\n          }\n          return res.json()\n        })\n        .then((data) => {\n          setResult(data)\n          setLoading(false)\n          // Prevent scroll - restore original position multiple times to ensure it sticks\n          const preventScroll = () => {\n            window.scrollTo(0, scrollPosition)\n            document.documentElement.scrollTop = scrollPosition\n            document.body.scrollTop = scrollPosition\n          }\n          preventScroll()\n          requestAnimationFrame(preventScroll)\n          setTimeout(preventScroll, 0)\n          setTimeout(preventScroll, 50)\n          setTimeout(preventScroll, 100)\n          setTimeout(preventScroll, 200)\n        })\n        .catch((err) => {\n          setError((err as Error).message)\n          setLoading(false)\n          const preventScroll = () => {\n            window.scrollTo(0, scrollPosition)\n            document.documentElement.scrollTop = scrollPosition\n            document.body.scrollTop = scrollPosition\n          }\n          preventScroll()\n          requestAnimationFrame(preventScroll)\n          setTimeout(preventScroll, 0)\n          setTimeout(preventScroll, 50)\n        })\n    }\n  }, [initialResult, issueSlug])\n  \n  // Additional scroll prevention when result loads\n  useEffect(() => {\n    if (result && !loading) {\n      // Prevent any auto-scrolling when result finishes loading\n      const preventScroll = () => {\n        const savedPosition = sessionStorage.getItem(`scroll-${issueSlug}-exercise`)\n        if (savedPosition) {\n          const position = parseInt(savedPosition, 10)\n          window.scrollTo(0, position)\n          document.documentElement.scrollTop = position\n          document.body.scrollTop = position\n        }\n      }\n      preventScroll()\n      requestAnimationFrame(preventScroll)\n      setTimeout(preventScroll, 0)\n      setTimeout(preventScroll, 100)\n      setTimeout(preventScroll, 200)\n    }\n  }, [result, loading, issueSlug])\n\n  async function handleGenerate(mode: 'daily' | 'weekly' | 'custom', range?: { from?: string; to?: string }) {\n    // This function is kept for backward compatibility but is no longer used\n    // Insights are now updated via Update button on health data pages\n  }\n\n  const extras = useMemo<ExerciseExtras>(() => {\n    if (!result) {\n      return {\n        workingActivities: [],\n        suggestedActivities: [],\n        avoidActivities: [],\n        totalLogged: 0,\n      }\n    }\n    const raw = (result.extras ?? {}) as ExerciseExtras\n    return {\n      workingActivities: raw.workingActivities ?? [],\n      suggestedActivities: raw.suggestedActivities ?? [],\n      avoidActivities: raw.avoidActivities ?? [],\n      totalLogged: raw.totalLogged ?? 0,\n    }\n  }, [result])\n\n  const tabs: Array<{ key: TabKey; label: string; href: string }> = [\n    { key: 'working', label: \"Exercise That's Working\", href: `/insights/issues/${issueSlug}/exercise/working` },\n    { key: 'suggested', label: 'Suggested Exercise', href: `/insights/issues/${issueSlug}/exercise/suggested` },\n    { key: 'avoid', label: 'Exercise to Avoid', href: `/insights/issues/${issueSlug}/exercise/avoid` },\n  ]\n\n  const contextValue = useMemo<ExerciseContextValue>(() => {\n    // Create minimal dummy result when null to satisfy context type\n    const dummyResult: IssueSectionResult = result || {\n      issue: { id: '', slug: issueSlug, name: '', polarity: 'negative', severityLabel: '', severityScore: null, currentRating: null, ratingScaleMax: null, trend: 'stable', trendDelta: null, lastUpdated: null, highlight: '', blockers: [], status: 'monitor' },\n      section: 'exercise',\n      generatedAt: new Date().toISOString(),\n      confidence: 0,\n      summary: '',\n      highlights: [],\n      dataPoints: [],\n      recommendations: [],\n      mode: 'latest',\n      extras: {},\n    }\n    return {\n      result: dummyResult,\n      loading,\n      error,\n      handleGenerate,\n      issueSlug,\n      extras,\n    }\n  }, [result, loading, error, issueSlug, extras])\n\n  if (!result && loading) {\n    return (\n      <ExerciseContext.Provider value={contextValue}>\n        <div className=\"space-y-6\">\n          <section className=\"bg-white border border-gray-200 rounded-2xl shadow-sm p-6\">\n            <div className=\"flex flex-col md:flex-row md:items-start md:justify-between gap-4\">\n              <div className=\"flex-1\">\n                <h2 className=\"text-lg font-semibold text-gray-900 mb-2\">Exercise report</h2>\n                <p className=\"text-sm text-gray-700 leading-relaxed mb-3\">Preparing initial guidance...</p>\n                <ProgressBar />\n              </div>\n            </div>\n            {DEBUG && (\n              <div className=\"mt-3 rounded-md border border-dashed border-gray-300 bg-gray-50 p-3 text-xs text-gray-600\">\n                <div>DEBUG: loading initial result‚Ä¶</div>\n              </div>\n            )}\n          </section>\n          <nav className=\"space-y-2\">\n            {tabs.map((tab) => (\n              <Link\n                key={tab.key}\n                href={tab.href}\n                className={`block rounded-xl border px-4 py-3 text-left text-sm font-semibold transition-colors ${\n                  tab.key === activeTab\n                    ? 'border-helfi-green bg-helfi-green text-white shadow-sm'\n                    : 'border-gray-200 bg-white text-gray-700 hover:border-helfi-green/70 hover:bg-gray-50'\n                }`}\n              >\n                {tab.label}\n              </Link>\n            ))}\n          </nav>\n          <div>{children}</div>\n        </div>\n      </ExerciseContext.Provider>\n    )\n  }\n\n  if (!result) {\n    return (\n      <ExerciseContext.Provider value={contextValue}>\n        <div className=\"space-y-6\">\n          <section className=\"bg-white border border-gray-200 rounded-2xl shadow-sm p-6\">\n            <div className=\"flex flex-col md:flex-row md:items-start md:justify-between gap-4\">\n              <div>\n                <h2 className=\"text-lg font-semibold text-gray-900 mb-2\">Exercise report</h2>\n                <p className=\"text-sm text-red-600\">{error || 'Failed to load section data'}</p>\n              </div>\n            </div>\n          </section>\n          <nav className=\"space-y-2\">\n            {tabs.map((tab) => (\n              <Link\n                key={tab.key}\n                href={tab.href}\n                className={`block rounded-xl border px-4 py-3 text-left text-sm font-semibold transition-colors ${\n                  tab.key === activeTab\n                    ? 'border-helfi-green bg-helfi-green text-white shadow-sm'\n                    : 'border-gray-200 bg-white text-gray-700 hover:border-helfi-green/70 hover:bg-gray-50'\n                }`}\n              >\n                {tab.label}\n              </Link>\n            ))}\n          </nav>\n          <div>{children}</div>\n        </div>\n      </ExerciseContext.Provider>\n    )\n  }\n\n  return (\n    <ExerciseContext.Provider value={contextValue}>\n      <div className=\"space-y-6\">\n        <section className=\"bg-white border border-gray-200 rounded-2xl shadow-sm p-6\">\n          <div className=\"flex flex-col md:flex-row md:items-start md:justify-between gap-4\">\n            <div>\n              <h2 className=\"text-lg font-semibold text-gray-900 mb-2\">Exercise report</h2>\n              <p className=\"text-sm text-gray-700 leading-relaxed\">{result.summary}</p>\n              <p className=\"text-xs text-gray-500 mt-3\">\n                Generated {new Date(result.generatedAt).toLocaleString()} ‚Ä¢ Confidence {(result.confidence * 100).toFixed(0)}%\n              </p>\n            </div>\n          </div>\n          {DEBUG && (\n            <div className=\"mt-3 rounded-md border border-dashed border-gray-300 bg-gray-50 p-3 text-xs text-gray-600\">\n              <div>DEBUG: extras.workingActivities = {extras.workingActivities?.length || 0}</div>\n              <div className=\"mt-1 truncate\">Titles: {(extras.workingActivities || []).map((w) => w.title).join(', ') || '‚Äî'}</div>\n              <div className=\"mt-1\">Source flags: quickUsed={(result.extras as any)?.quickUsed ? '1' : '0'}, cacheHit={(result.extras as any)?.cacheHit ? '1' : '0'}</div>\n            </div>\n          )}\n        </section>\n\n        <nav className=\"space-y-2\">\n          {tabs.map((tab) => (\n            <Link\n              key={tab.key}\n              href={tab.href}\n              className={`block rounded-xl border px-4 py-3 text-left text-sm font-semibold transition-colors ${\n                tab.key === activeTab\n                  ? 'border-helfi-green bg-helfi-green text-white shadow-sm'\n                  : 'border-gray-200 bg-white text-gray-700 hover:border-helfi-green/70 hover:bg-gray-50'\n              }`}\n            >\n              {tab.label}\n            </Link>\n          ))}\n        </nav>\n\n        <div>{children}</div>\n\n        <SectionChat issueSlug={issueSlug} section=\"exercise\" issueName={result?.issue?.name ?? ''} />\n      </div>\n    </ExerciseContext.Provider>\n  )\n}\n","truncated":false,"size":11645},{"path":"app/insights/issues/[issueSlug]/exercise/layout.tsx","content":"import { ReactNode } from 'react'\nimport { getServerSession } from 'next-auth'\nimport { redirect } from 'next/navigation'\nimport { authOptions } from '@/lib/auth'\nimport { getCachedIssueSection } from '@/lib/insights/issue-engine'\nimport ExerciseShell from './ExerciseShell'\n\ninterface ExerciseLayoutProps {\n  children: ReactNode\n  params: { issueSlug: string }\n}\n\nexport default async function ExerciseLayout({ children, params }: ExerciseLayoutProps) {\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.id) {\n    redirect('/auth/signin')\n  }\n\n  // Cache-only read - never blocks on LLM during SSR\n  const result = await getCachedIssueSection(session.user.id, params.issueSlug, 'exercise', { mode: 'latest' })\n\n  return (\n    <ExerciseShell initialResult={result} issueSlug={params.issueSlug}>\n      {children}\n    </ExerciseShell>\n  )\n}\n","truncated":false,"size":865},{"path":"app/insights/issues/[issueSlug]/exercise/page.tsx","content":"import { redirect } from 'next/navigation'\n\ninterface ExercisePageProps {\n  params: { issueSlug: string }\n}\n\nexport default function ExercisePage({ params }: ExercisePageProps) {\n  redirect(`/insights/issues/${params.issueSlug}/exercise/working`)\n}\n","truncated":false,"size":249},{"path":"app/insights/issues/[issueSlug]/exercise/suggested/page.tsx","content":"'use client'\n\nimport { useExerciseContext } from '../ExerciseShell'\n\nexport default function ExerciseSuggestedPage() {\n  const { extras } = useExerciseContext()\n  const items = extras.suggestedActivities ?? []\n\n  if (!items.length) {\n    return (\n      <div className=\"bg-white border border-gray-200 rounded-2xl shadow-sm p-6 text-sm text-gray-700\">\n        Nice work‚Äîyour current training covers the key movements we recommend. Keep logging intensity and recovery notes.\n      </div>\n    )\n  }\n\n  return (\n    <div className=\"space-y-3\">\n      {items.map((activity, index) => (\n        <div key={`${activity.title}-${index}`} className=\"border border-gray-200 bg-white rounded-2xl p-5\">\n          <h3 className=\"text-base font-semibold text-gray-900\">{activity.title}</h3>\n          <p className=\"text-sm text-gray-700 mt-1 leading-relaxed\">{activity.reason}</p>\n          <p className=\"mt-3 text-xs text-gray-500\">Schedule this for the coming week and log how you feel afterwards.</p>\n        </div>\n      ))}\n    </div>\n  )\n}\n","truncated":false,"size":1032},{"path":"app/insights/issues/[issueSlug]/exercise/working/page.tsx","content":"'use client'\n\nimport { useEffect } from 'react'\nimport { useExerciseContext } from '../ExerciseShell'\n\nexport default function ExerciseWorkingPage() {\n  const { extras } = useExerciseContext()\n  const items = extras.workingActivities ?? []\n  const DEBUG = process.env.NEXT_PUBLIC_DEBUG_INSIGHTS === '1' || process.env.NEXT_PUBLIC_DEBUG_INSIGHTS === 'true'\n\n  useEffect(() => {\n    if (DEBUG) {\n      try {\n        // Log minimal, safe snapshot for debugging\n        // eslint-disable-next-line no-console\n        console.log('[ExerciseWorkingPage] workingActivities', { count: items.length, titles: items.map((i) => i.title) })\n      } catch {}\n    }\n  }, [DEBUG, items])\n\n  if (!items.length) {\n    return (\n      <div className=\"bg-white border border-gray-200 rounded-2xl shadow-sm p-6 text-sm text-gray-700\">\n        We haven't spotted any logged workouts that clearly support this issue yet. Explore the ‚ÄúSuggested Exercise‚Äù tab to plan your next sessions.\n        {DEBUG && (\n          <div className=\"mt-3 rounded-md border border-dashed border-gray-300 bg-gray-50 p-3 text-xs text-gray-600\">\n            DEBUG: workingActivities empty\n          </div>\n        )}\n      </div>\n    )\n  }\n\n  return (\n    <div className=\"space-y-3\">\n      {items.map((activity, index) => (\n        <div key={`${activity.title}-${index}`} className=\"border border-emerald-200 bg-emerald-50/70 rounded-2xl p-5\">\n          <h3 className=\"text-base font-semibold text-gray-900\">{activity.title}</h3>\n          <p className=\"text-sm text-emerald-800 mt-1 leading-relaxed\">{activity.reason}</p>\n          <dl className=\"mt-4 grid grid-cols-1 sm:grid-cols-2 gap-3 text-sm text-gray-700\">\n            <div>\n              <dt className=\"text-xs uppercase text-gray-500 tracking-wide\">Most recent session</dt>\n              <dd>{activity.summary}</dd>\n            </div>\n            <div>\n              <dt className=\"text-xs uppercase text-gray-500 tracking-wide\">Logged</dt>\n              <dd>{activity.lastLogged}</dd>\n            </div>\n          </dl>\n        </div>\n      ))}\n    </div>\n  )\n}\n","truncated":false,"size":2081},{"path":"app/insights/issues/[issueSlug]/interactions/page.tsx","content":"import { getServerSession } from 'next-auth'\nimport { redirect, notFound } from 'next/navigation'\nimport { authOptions } from '@/lib/auth'\nimport { getIssueSection } from '@/lib/insights/issue-engine'\nimport SectionRenderer from '../SectionRenderer'\n\ninterface IssueInteractionsPageProps {\n  params: { issueSlug: string }\n}\n\nexport default async function IssueInteractionsPage({ params }: IssueInteractionsPageProps) {\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.id) {\n    redirect('/auth/signin')\n  }\n\n  const result = await getIssueSection(session.user.id, params.issueSlug, 'interactions')\n  if (!result) {\n    notFound()\n  }\n\n  return <SectionRenderer issueSlug={params.issueSlug} section=\"interactions\" initialResult={result} />\n}\n","truncated":false,"size":768},{"path":"app/insights/issues/[issueSlug]/IssueBackButton.tsx","content":"'use client'\n\nimport Link from 'next/link'\nimport { useSelectedLayoutSegments } from 'next/navigation'\n\ninterface IssueBackButtonProps {\n  issueSlug: string\n}\n\nexport default function IssueBackButton({ issueSlug }: IssueBackButtonProps) {\n  const segments = useSelectedLayoutSegments()\n  const isNestedRoute = segments.length > 0\n  const href = isNestedRoute ? `/insights/issues/${issueSlug}` : '/insights'\n\n  return (\n    <Link\n      href={href}\n      className=\"inline-flex items-center gap-2 text-helfi-green font-semibold\"\n    >\n      <span className=\"text-lg\">‚Üê</span> Back\n    </Link>\n  )\n}\n","truncated":false,"size":599},{"path":"app/insights/issues/[issueSlug]/IssueOverviewClient.tsx","content":"'use client'\n\nimport Link from 'next/link'\nimport type { IssueSummary, IssueSectionKey } from '@/lib/insights/issue-engine'\n\nconst SECTION_ORDER: IssueSectionKey[] = ['supplements', 'medications', 'labs', 'nutrition']\n\ninterface IssueOverviewClientProps {\n  issue: IssueSummary\n  issueSlug: string\n}\n\nexport default function IssueOverviewClient({ issue, issueSlug }: IssueOverviewClientProps) {\n  const sectionDescriptions: Record<string, string> = {\n    supplements: 'Review current regimen, identify gaps, and spot potential additions.',\n    medications: 'Track prescriptions, capture timing, and see what is actually helping.',\n    labs: 'Track bloodwork targets and know when to upload or re-test.',\n    nutrition: 'See how logged meals support this issue and what to tweak next.',\n  }\n\n  const navigationOrder = SECTION_ORDER as IssueSectionKey[]\n\n  return (\n    <div className=\"space-y-6\">\n      <section className=\"bg-emerald-50 border border-emerald-200 rounded-2xl shadow-sm p-4\">\n        <div className=\"flex items-center gap-2\">\n          <svg className=\"w-5 h-5 text-emerald-600\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n            <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z\" />\n          </svg>\n          <p className=\"text-sm text-emerald-700\">\n            Insights refresh automatically when you click ‚ÄúUpdate Insights‚Äù in Health Setup. Open any section below to view the latest guidance.\n          </p>\n        </div>\n      </section>\n\n      {/* Section Links */}\n      <section className=\"bg-white border border-gray-200 rounded-2xl shadow-sm\">\n        {navigationOrder.map((section) => (\n          <Link\n            key={section}\n            href={`/insights/issues/${issueSlug}/${section}`}\n            className=\"block px-5 py-4 border-b last:border-b-0 hover:bg-gray-50 transition-colors\"\n          >\n            <div className=\"flex items-center justify-between gap-3\">\n              <div>\n                <h3 className=\"text-lg font-semibold text-gray-900 capitalize\">\n                  {section}\n                </h3>\n                <p className=\"text-sm text-gray-600 mt-1\">\n                  {sectionDescriptions[section] || 'Open detailed insights for this area.'}\n                </p>\n              </div>\n              <span className=\"text-2xl text-gray-400\">‚Ä∫</span>\n            </div>\n          </Link>\n        ))}\n      </section>\n    </div>\n  )\n}\n","truncated":false,"size":2476},{"path":"app/insights/issues/[issueSlug]/IssueSectionNav.tsx","content":"'use client'\n\nimport Link from 'next/link'\nimport { usePathname } from 'next/navigation'\nimport type { IssueSectionKey } from '@/lib/insights/issue-engine'\n\ninterface IssueSectionNavProps {\n  issueSlug: string\n  sections: IssueSectionKey[]\n}\n\nconst LABELS: Record<IssueSectionKey, string> = {\n  overview: 'Overview',\n  exercise: 'Exercise',\n  supplements: 'Supplements',\n  medications: 'Medications',\n  interactions: 'Supplements √ó Meds',\n  labs: 'Labs & Bloodwork',\n  nutrition: 'Nutrition & Food',\n  lifestyle: 'Lifestyle',\n}\n\nexport default function IssueSectionNav({ issueSlug, sections }: IssueSectionNavProps) {\n  const pathname = usePathname()\n  return (\n    <div className=\"flex items-center gap-2 overflow-x-auto pb-2\">\n      {sections.map((section) => {\n        const overviewPath = `/insights/issues/${issueSlug}`\n        const href = section === 'overview' ? `${overviewPath}/overview` : `/insights/issues/${issueSlug}/${section}`\n        const isOverviewActive = section === 'overview' && (pathname === overviewPath || pathname === `${overviewPath}/overview`)\n        const isSectionActive = pathname === href || pathname.startsWith(`${href}/`)\n        const isActive = isOverviewActive || isSectionActive\n        return (\n          <Link\n            key={section}\n            href={href}\n            className={`px-4 py-2 rounded-full border text-sm font-semibold whitespace-nowrap transition-colors ${\n              isActive ? 'bg-helfi-green text-white border-helfi-green shadow-sm' : 'bg-white text-gray-700 border-gray-200 hover:border-helfi-green hover:text-helfi-green'\n            }`}\n            onClick={() => {\n              try {\n                const reduced = window.matchMedia('(prefers-reduced-motion: reduce)')?.matches\n                const pref = localStorage.getItem('hapticsEnabled')\n                const enabled = pref === null ? true : pref === 'true'\n                if (!reduced && enabled && 'vibrate' in navigator) {\n                  navigator.vibrate(8)\n                }\n              } catch {\n                // ignore haptic errors\n              }\n            }}\n          >\n            {LABELS[section] ?? section}\n          </Link>\n        )\n      })}\n    </div>\n  )\n}\n","truncated":false,"size":2219},{"path":"app/insights/issues/[issueSlug]/labs/page.tsx","content":"import { getServerSession } from 'next-auth'\nimport { redirect, notFound } from 'next/navigation'\nimport { authOptions } from '@/lib/auth'\nimport { getIssueSection } from '@/lib/insights/issue-engine'\nimport SectionRenderer from '../SectionRenderer'\n\ninterface IssueLabsPageProps {\n  params: { issueSlug: string }\n}\n\nexport default async function IssueLabsPage({ params }: IssueLabsPageProps) {\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.id) {\n    redirect('/auth/signin')\n  }\n\n  const result = await getIssueSection(session.user.id, params.issueSlug, 'labs')\n  \n  // Handle case where user has no bloodwork data\n  if (!result) {\n    // Return a friendly message instead of 404\n    return (\n      <div className=\"space-y-8\">\n        <section className=\"bg-white border border-gray-200 rounded-2xl shadow-sm p-6\">\n          <h2 className=\"text-lg font-semibold text-gray-900 mb-2\">Labs & Bloodwork Insights</h2>\n          <p className=\"text-sm text-gray-700 leading-relaxed\">\n            There is no labs or bloodwork currently in your health information data. \n            Upload your blood test results in Health Setup to receive personalized lab insights and recommendations.\n          </p>\n        </section>\n      </div>\n    )\n  }\n\n  return <SectionRenderer issueSlug={params.issueSlug} section=\"labs\" initialResult={result} />\n}\n","truncated":false,"size":1367},{"path":"app/insights/issues/[issueSlug]/layout.tsx","content":"import { ReactNode } from 'react'\nimport { getServerSession } from 'next-auth'\nimport { redirect } from 'next/navigation'\nimport { authOptions } from '@/lib/auth'\nimport { getIssueSummaries, ISSUE_SECTION_ORDER, type IssueSummary } from '@/lib/insights/issue-engine'\nimport InsightsTopNav from '../../InsightsTopNav'\nimport InsightsBottomNav from '../../InsightsBottomNav'\nimport IssueSectionNav from './IssueSectionNav'\nimport IssueBackButton from './IssueBackButton'\n\ninterface IssueLayoutProps {\n  children: ReactNode\n  params: { issueSlug: string }\n}\n\nexport default async function IssueLayout({ children, params }: IssueLayoutProps) {\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.id) {\n    redirect('/auth/signin')\n  }\n\n  const summaries = await getIssueSummaries(session.user.id)\n  let issue = summaries.find((item) => item.slug === params.issueSlug)\n  if (!issue) {\n    const name = params.issueSlug\n      .replace(/[-_]+/g, ' ')\n      .split(' ')\n      .map((p) => (p ? p[0].toUpperCase() + p.slice(1) : p))\n      .join(' ')\n    issue = {\n      id: `temp:${params.issueSlug}`,\n      slug: params.issueSlug,\n      name,\n      polarity: 'negative',\n      severityLabel: 'Needs data',\n      severityScore: null,\n      currentRating: null,\n      ratingScaleMax: 6,\n      trend: 'inconclusive',\n      trendDelta: null,\n      lastUpdated: null,\n      highlight: 'Add logs to unlock personalised insights.',\n      blockers: [],\n      status: 'needs-data',\n    } as IssueSummary\n  }\n\n  return (\n    <div className=\"min-h-screen bg-gray-50\">\n      <InsightsTopNav sessionUser={{\n        name: session.user.name ?? null,\n        email: session.user.email ?? null,\n        image: session.user.image ?? null,\n      }} />\n\n      <header className=\"bg-white border-b border-gray-200 px-4 py-6\">\n        <div className=\"max-w-6xl mx-auto space-y-4\">\n          <div className=\"flex items-center gap-3 text-sm text-gray-500\">\n            <IssueBackButton issueSlug={issue.slug} />\n          </div>\n          <div className=\"flex flex-col md:flex-row md:items-center md:justify-between gap-4\">\n            <div>\n              <p className=\"text-xs uppercase tracking-[0.2em] text-helfi-green font-semibold mb-1\">Issue workspace</p>\n              <h1 className=\"text-3xl font-bold text-gray-900\">{issue.name}</h1>\n              <p className=\"text-sm text-gray-600 mt-2\">{issue.highlight}</p>\n            </div>\n            <div className=\"inline-flex flex-col md:items-end bg-gray-50 border border-gray-200 rounded-xl px-4 py-3\">\n              <span className=\"text-xs uppercase text-gray-500 tracking-wide\">Current rating</span>\n              <span className=\"text-2xl font-semibold text-gray-900 mt-1\">\n                {issue.currentRating !== null ? `${issue.currentRating}/${issue.ratingScaleMax ?? 6}` : 'Not logged'}\n              </span>\n              <span className=\"text-xs text-gray-500 mt-1\">\n                {issue.severityLabel} ‚Ä¢ {issue.trend.charAt(0).toUpperCase() + issue.trend.slice(1)}\n              </span>\n            </div>\n          </div>\n          <IssueSectionNav issueSlug={issue.slug} sections={ISSUE_SECTION_ORDER} />\n        </div>\n      </header>\n\n      <main className=\"max-w-6xl mx-auto px-4 py-8 pb-24 md:pb-12\">\n        {children}\n      </main>\n\n      <InsightsBottomNav />\n    </div>\n  )\n}\n","truncated":false,"size":3349},{"path":"app/insights/issues/[issueSlug]/lifestyle/page.tsx","content":"import { getServerSession } from 'next-auth'\nimport { redirect, notFound } from 'next/navigation'\nimport { authOptions } from '@/lib/auth'\nimport { getIssueSection } from '@/lib/insights/issue-engine'\nimport SectionRenderer from '../SectionRenderer'\n\ninterface IssueLifestylePageProps {\n  params: { issueSlug: string }\n}\n\nexport default async function IssueLifestylePage({ params }: IssueLifestylePageProps) {\n  // Lifestyle has been folded into Overview; redirect to Overview for this issue\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.id) {\n    redirect('/auth/signin')\n  }\n  redirect(`/insights/issues/${params.issueSlug}/overview`)\n}\n","truncated":false,"size":669},{"path":"app/insights/issues/[issueSlug]/loading.tsx","content":"export default function IssueWorkspaceLoading() {\n  return (\n    <div className=\"min-h-screen bg-gray-50\">\n      <header className=\"bg-white border-b border-gray-200 px-4 py-6 animate-pulse\">\n        <div className=\"max-w-6xl mx-auto space-y-4\">\n          <div className=\"h-4 w-24 rounded-full bg-gray-200\" />\n          <div className=\"h-8 w-2/5 rounded-full bg-gray-200\" />\n          <div className=\"h-4 w-1/3 rounded-full bg-gray-200\" />\n        </div>\n      </header>\n      <main className=\"max-w-6xl mx-auto px-4 py-10 space-y-6\">\n        <div className=\"space-y-4\">\n          {[0, 1, 2].map((row) => (\n            <div key={row} className=\"bg-white border border-gray-200 rounded-2xl p-6 space-y-3 animate-pulse\">\n              <div className=\"h-4 w-36 rounded-full bg-gray-200\" />\n              <div className=\"h-4 w-3/4 rounded-full bg-gray-200\" />\n              <div className=\"h-4 w-2/3 rounded-full bg-gray-200\" />\n            </div>\n          ))}\n        </div>\n      </main>\n    </div>\n  )\n}\n","truncated":false,"size":1004},{"path":"app/insights/issues/[issueSlug]/medications/avoid/page.tsx","content":"'use client'\n\nimport { useMedicationsContext } from '../MedicationsShell'\n\nexport default function MedicationsAvoidPage() {\n  const { extras } = useMedicationsContext()\n  const items = extras.avoidList ?? []\n\n  if (!items.length) {\n    return (\n      <div className=\"bg-white border border-gray-200 rounded-2xl shadow-sm p-6 text-sm text-gray-700\">\n        No medications in your current regimen are flagging as risky for this issue. Continue logging updates so we can keep monitoring interactions.\n      </div>\n    )\n  }\n\n  return (\n    <div className=\"space-y-3\">\n      {items.map((medication, index) => (\n        <div key={`${medication.name}-${index}`} className=\"border border-rose-200 bg-rose-50/70 rounded-2xl p-5\">\n          <h3 className=\"text-base font-semibold text-rose-700\">{medication.name}</h3>\n          <p className=\"text-sm text-rose-700 mt-1 leading-relaxed\">{medication.reason}</p>\n          <dl className=\"mt-4 grid grid-cols-1 sm:grid-cols-2 gap-3 text-sm text-rose-700\">\n            <div>\n              <dt className=\"text-xs uppercase tracking-wide\">Dose</dt>\n              <dd>{medication.dosage || 'Not logged'}</dd>\n            </div>\n            <div>\n              <dt className=\"text-xs uppercase tracking-wide\">Timing</dt>\n              <dd>\n                {Array.isArray(medication.timing) && medication.timing.length\n                  ? medication.timing.join(', ')\n                  : 'Timing not logged'}\n              </dd>\n            </div>\n          </dl>\n          <p className=\"text-xs text-rose-700 mt-3\">Review this with your clinician as soon as possible.</p>\n        </div>\n      ))}\n    </div>\n  )\n}\n","truncated":false,"size":1647},{"path":"app/insights/issues/[issueSlug]/medications/layout.tsx","content":"import { ReactNode } from 'react'\nimport { getServerSession } from 'next-auth'\nimport { redirect } from 'next/navigation'\nimport { authOptions } from '@/lib/auth'\nimport { getCachedIssueSection } from '@/lib/insights/issue-engine'\nimport MedicationsShell from './MedicationsShell'\n\ninterface MedicationsLayoutProps {\n  children: ReactNode\n  params: { issueSlug: string }\n}\n\nexport default async function MedicationsLayout({ children, params }: MedicationsLayoutProps) {\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.id) {\n    redirect('/auth/signin')\n  }\n\n  // Cache-only read - never blocks on LLM during SSR\n  const result = await getCachedIssueSection(session.user.id, params.issueSlug, 'medications', { mode: 'latest' })\n\n  return (\n    <MedicationsShell initialResult={result} issueSlug={params.issueSlug}>\n      {children}\n    </MedicationsShell>\n  )\n}\n","truncated":false,"size":889},{"path":"app/insights/issues/[issueSlug]/medications/MedicationsShell.tsx","content":"'use client'\n\nimport { createContext, ReactNode, useContext, useEffect, useMemo, useState } from 'react'\nimport Link from 'next/link'\nimport { useSelectedLayoutSegments } from 'next/navigation'\nimport SectionChat from '../SectionChat'\nimport type { IssueSectionResult } from '@/lib/insights/issue-engine'\n\n// Progress bar component: indeterminate shimmer to avoid misleading ‚Äústuck‚Äù states\nfunction ProgressBar() {\n  return (\n    <div className=\"w-full bg-gray-200 rounded-full h-2 overflow-hidden relative\">\n      <div className=\"absolute inset-0 bg-gradient-to-r from-helfi-green/30 via-helfi-green to-helfi-green/30 animate-pulse\" />\n    </div>\n  )\n}\n\ntype TabKey = 'working' | 'suggested' | 'avoid'\n\ntype MedicationsExtras = {\n  supportiveDetails?: Array<{ name: string; reason: string; dosage: string | null; timing: string[] }>\n  suggestedAdditions?: Array<{ title: string; reason: string; suggestion: string | null; alreadyCovered?: boolean }>\n  avoidList?: Array<{ name: string; reason: string; dosage: string | null; timing: string[] }>\n  missingDose?: string[]\n  missingTiming?: string[]\n  totalLogged?: number\n  source?: 'llm' | 'llm-error'\n}\n\ninterface MedicationsContextValue {\n  result: IssueSectionResult\n  loading: boolean\n  error: string | null\n  handleGenerate: (mode: 'daily' | 'weekly' | 'custom', range?: { from?: string; to?: string }) => Promise<void>\n  issueSlug: string\n  extras: MedicationsExtras\n}\n\nconst MedicationsContext = createContext<MedicationsContextValue | null>(null)\n\nexport function useMedicationsContext() {\n  const ctx = useContext(MedicationsContext)\n  if (!ctx) {\n    throw new Error('useMedicationsContext must be used within MedicationsShell')\n  }\n  return ctx\n}\n\ninterface MedicationsShellProps {\n  children: ReactNode\n  initialResult: IssueSectionResult | null\n  issueSlug: string\n}\n\nexport default function MedicationsShell({ children, initialResult, issueSlug }: MedicationsShellProps) {\n  const [result, setResult] = useState<IssueSectionResult | null>(initialResult)\n  const [loading, setLoading] = useState(!initialResult)\n  const [error, setError] = useState<string | null>(null)\n  const segments = useSelectedLayoutSegments()\n  const activeTab = (segments?.[0] as TabKey | undefined) ?? 'working'\n\n  // Fetch data client-side if SSR returned null (cache miss)\n  useEffect(() => {\n    if (!initialResult) {\n      setLoading(true)\n      const scrollPosition = window.scrollY || document.documentElement.scrollTop\n      // Save scroll position to prevent any scrolling\n      sessionStorage.setItem(`scroll-${issueSlug}-medications`, scrollPosition.toString())\n      \n      fetch(`/api/insights/issues/${issueSlug}/sections/medications`)\n        .then((res) => {\n          if (!res.ok) {\n            throw new Error('Failed to load section')\n          }\n          return res.json()\n        })\n        .then((data) => {\n          setResult(data)\n          setLoading(false)\n          // Prevent scroll - restore original position multiple times to ensure it sticks\n          const preventScroll = () => {\n            window.scrollTo(0, scrollPosition)\n            document.documentElement.scrollTop = scrollPosition\n            document.body.scrollTop = scrollPosition\n          }\n          preventScroll()\n          requestAnimationFrame(preventScroll)\n          setTimeout(preventScroll, 0)\n          setTimeout(preventScroll, 50)\n          setTimeout(preventScroll, 100)\n          setTimeout(preventScroll, 200)\n        })\n        .catch((err) => {\n          setError((err as Error).message)\n          setLoading(false)\n          const preventScroll = () => {\n            window.scrollTo(0, scrollPosition)\n            document.documentElement.scrollTop = scrollPosition\n            document.body.scrollTop = scrollPosition\n          }\n          preventScroll()\n          requestAnimationFrame(preventScroll)\n          setTimeout(preventScroll, 0)\n          setTimeout(preventScroll, 50)\n        })\n    }\n  }, [initialResult, issueSlug])\n  \n  // Additional scroll prevention when result loads\n  useEffect(() => {\n    if (result && !loading) {\n      // Prevent any auto-scrolling when result finishes loading\n      const preventScroll = () => {\n        const savedPosition = sessionStorage.getItem(`scroll-${issueSlug}-medications`)\n        if (savedPosition) {\n          const position = parseInt(savedPosition, 10)\n          window.scrollTo(0, position)\n          document.documentElement.scrollTop = position\n          document.body.scrollTop = position\n        }\n      }\n      preventScroll()\n      requestAnimationFrame(preventScroll)\n      setTimeout(preventScroll, 0)\n      setTimeout(preventScroll, 100)\n      setTimeout(preventScroll, 200)\n    }\n  }, [result, loading, issueSlug])\n\n  async function handleGenerate(mode: 'daily' | 'weekly' | 'custom', range?: { from?: string; to?: string }) {\n    // This function is kept for backward compatibility but is no longer used\n    // Insights are now updated via Update button on health data pages\n  }\n\n  const extras = useMemo<MedicationsExtras>(() => {\n    if (!result) {\n      return {\n        supportiveDetails: [],\n        suggestedAdditions: [],\n        avoidList: [],\n        missingDose: [],\n        missingTiming: [],\n        totalLogged: 0,\n      }\n    }\n    const raw = (result.extras ?? {}) as MedicationsExtras\n    return {\n      supportiveDetails: raw.supportiveDetails ?? [],\n      suggestedAdditions: raw.suggestedAdditions ?? [],\n      avoidList: raw.avoidList ?? [],\n      missingDose: raw.missingDose ?? [],\n      missingTiming: raw.missingTiming ?? [],\n      totalLogged: raw.totalLogged ?? 0,\n    }\n  }, [result])\n\n  const tabs: Array<{ key: TabKey; label: string; href: string }> = [\n    { key: 'working', label: 'Medications That Are Working', href: `/insights/issues/${issueSlug}/medications/working` },\n    { key: 'suggested', label: 'Suggested Medications', href: `/insights/issues/${issueSlug}/medications/suggested` },\n    { key: 'avoid', label: 'Medications to Avoid', href: `/insights/issues/${issueSlug}/medications/avoid` },\n  ]\n\n  const contextValue = useMemo<MedicationsContextValue>(() => {\n    // Create minimal dummy result when null to satisfy context type\n    const dummyResult: IssueSectionResult = result || {\n      issue: { id: '', slug: issueSlug, name: '', polarity: 'negative', severityLabel: '', severityScore: null, currentRating: null, ratingScaleMax: null, trend: 'stable', trendDelta: null, lastUpdated: null, highlight: '', blockers: [], status: 'monitor' },\n      section: 'medications',\n      generatedAt: new Date().toISOString(),\n      confidence: 0,\n      summary: '',\n      highlights: [],\n      dataPoints: [],\n      recommendations: [],\n      mode: 'latest',\n      extras: {},\n    }\n    return {\n      result: dummyResult,\n      loading,\n      error,\n      handleGenerate,\n      issueSlug,\n      extras,\n    }\n  }, [result, loading, error, issueSlug, extras])\n\n  if (!result && loading) {\n    return (\n      <MedicationsContext.Provider value={contextValue}>\n        <div className=\"space-y-6\">\n          <section className=\"bg-white border border-gray-200 rounded-2xl shadow-sm p-6\">\n            <div className=\"flex flex-col md:flex-row md:items-start md:justify-between gap-4\">\n              <div className=\"flex-1\">\n                <h2 className=\"text-lg font-semibold text-gray-900 mb-2\">Medications report</h2>\n                <p className=\"text-sm text-gray-700 leading-relaxed mb-3\">Preparing initial guidance...</p>\n                <ProgressBar />\n              </div>\n            </div>\n          </section>\n          <nav className=\"space-y-2\">\n            {tabs.map((tab) => (\n              <Link\n                key={tab.key}\n                href={tab.href}\n                className={`block rounded-xl border px-4 py-3 text-left text-sm font-semibold transition-colors ${\n                  tab.key === activeTab\n                    ? 'border-helfi-green bg-helfi-green text-white shadow-sm'\n                    : 'border-gray-200 bg-white text-gray-700 hover:border-helfi-green/70 hover:bg-gray-50'\n                }`}\n              >\n                {tab.label}\n              </Link>\n            ))}\n          </nav>\n          <div>{children}</div>\n        </div>\n      </MedicationsContext.Provider>\n    )\n  }\n\n  if (!result) {\n    return (\n      <MedicationsContext.Provider value={contextValue}>\n        <div className=\"space-y-6\">\n          <section className=\"bg-white border border-gray-200 rounded-2xl shadow-sm p-6\">\n            <div className=\"flex flex-col md:flex-row md:items-start md:justify-between gap-4\">\n              <div>\n                <h2 className=\"text-lg font-semibold text-gray-900 mb-2\">Medications report</h2>\n                <p className=\"text-sm text-red-600\">{error || 'Failed to load section data'}</p>\n              </div>\n            </div>\n          </section>\n          <nav className=\"space-y-2\">\n            {tabs.map((tab) => (\n              <Link\n                key={tab.key}\n                href={tab.href}\n                className={`block rounded-xl border px-4 py-3 text-left text-sm font-semibold transition-colors ${\n                  tab.key === activeTab\n                    ? 'border-helfi-green bg-helfi-green text-white shadow-sm'\n                    : 'border-gray-200 bg-white text-gray-700 hover:border-helfi-green/70 hover:bg-gray-50'\n                }`}\n              >\n                {tab.label}\n              </Link>\n            ))}\n          </nav>\n          <div>{children}</div>\n        </div>\n      </MedicationsContext.Provider>\n    )\n  }\n\n  return (\n    <MedicationsContext.Provider value={contextValue}>\n      <div className=\"space-y-6\">\n        <section className=\"bg-white border border-gray-200 rounded-2xl shadow-sm p-6\">\n          <div className=\"flex flex-col md:flex-row md:items-start md:justify-between gap-4\">\n            <div>\n              <h2 className=\"text-lg font-semibold text-gray-900 mb-2\">Medications report</h2>\n              <p className=\"text-sm text-gray-700 leading-relaxed\">{result.summary}</p>\n              <p className=\"text-xs text-gray-500 mt-3\">\n                Generated {new Date(result.generatedAt).toLocaleString()} ‚Ä¢ Confidence {(result.confidence * 100).toFixed(0)}%\n              </p>\n            </div>\n          </div>\n        </section>\n\n        <nav className=\"space-y-2\">\n          {tabs.map((tab) => (\n            <Link\n              key={tab.key}\n              href={tab.href}\n              className={`block rounded-xl border px-4 py-3 text-left text-sm font-semibold transition-colors ${\n                tab.key === activeTab\n                  ? 'border-helfi-green bg-helfi-green text-white shadow-sm'\n                  : 'border-gray-200 bg-white text-gray-700 hover:border-helfi-green/70 hover:bg-gray-50'\n              }`}\n            >\n              {tab.label}\n            </Link>\n          ))}\n        </nav>\n\n        <div>{children}</div>\n\n        <SectionChat issueSlug={issueSlug} section=\"medications\" issueName={result?.issue?.name ?? ''} />\n      </div>\n    </MedicationsContext.Provider>\n  )\n}\n","truncated":false,"size":11107},{"path":"app/insights/issues/[issueSlug]/medications/page.tsx","content":"import { redirect } from 'next/navigation'\n\ninterface MedicationsPageProps {\n  params: { issueSlug: string }\n}\n\nexport default function MedicationsPage({ params }: MedicationsPageProps) {\n  redirect(`/insights/issues/${params.issueSlug}/medications/working`)\n}\n","truncated":false,"size":261},{"path":"app/insights/issues/[issueSlug]/medications/suggested/page.tsx","content":"'use client'\n\nimport { useMedicationsContext } from '../MedicationsShell'\n\nexport default function MedicationsSuggestedPage() {\n  const { extras } = useMedicationsContext()\n  const suggestions = extras.suggestedAdditions ?? []\n\n  if (!suggestions.length) {\n    return (\n      <div className=\"bg-white border border-gray-200 rounded-2xl shadow-sm p-6 text-sm text-gray-700\">\n        No additional medications are commonly recommended based on your current log. Keep collaborating with your clinician and update Helfi after any prescription changes.\n      </div>\n    )\n  }\n\n  return (\n    <div className=\"space-y-3\">\n      {suggestions.map((item, index) => (\n        <div key={`${item.title}-${index}`} className=\"border border-gray-200 bg-white rounded-2xl p-5\">\n          <h3 className=\"text-base font-semibold text-gray-900\">{item.title}</h3>\n          <p className=\"text-sm text-gray-700 mt-1 leading-relaxed\">{item.reason}</p>\n          {item.suggestion && (\n            <p className=\"mt-3 text-sm text-helfi-green font-semibold\">\n              Suggested protocol: {item.suggestion}\n            </p>\n          )}\n        </div>\n      ))}\n      <p className=\"text-xs text-gray-500 mt-4\">\n        Discuss any new medication ideas with your clinician before starting, then update Helfi so the AI can monitor responses and interactions.\n      </p>\n    </div>\n  )\n}\n","truncated":false,"size":1364},{"path":"app/insights/issues/[issueSlug]/medications/working/page.tsx","content":"'use client'\n\nimport { useMedicationsContext } from '../MedicationsShell'\n\nexport default function MedicationsWorkingPage() {\n  const { extras } = useMedicationsContext()\n  const items = extras.supportiveDetails ?? []\n\n  if (!items.length) {\n    return (\n      <div className=\"bg-white border border-gray-200 rounded-2xl shadow-sm p-6 text-sm text-gray-700\">\n        You're currently not taking any medications that clearly support this issue. Please review the ‚ÄúSuggested Medications‚Äù tab with your clinician before making changes.\n      </div>\n    )\n  }\n\n  return (\n    <div className=\"space-y-3\">\n      {items.map((medication, index) => (\n        <div key={`${medication.name}-${index}`} className=\"border border-emerald-200 bg-emerald-50/70 rounded-2xl p-5\">\n          <h3 className=\"text-base font-semibold text-gray-900\">{medication.name}</h3>\n          <p className=\"text-sm text-emerald-800 mt-1 leading-relaxed\">{medication.reason}</p>\n          <dl className=\"mt-4 grid grid-cols-1 sm:grid-cols-2 gap-3 text-sm text-gray-700\">\n            <div>\n              <dt className=\"text-xs uppercase text-gray-500 tracking-wide\">Dose</dt>\n              <dd>{medication.dosage || 'Not logged yet'}</dd>\n            </div>\n            <div>\n              <dt className=\"text-xs uppercase text-gray-500 tracking-wide\">Timing</dt>\n              <dd>\n                {Array.isArray(medication.timing) && medication.timing.length\n                  ? medication.timing.join(', ')\n                  : 'Add timing so we can flag spacing tips.'}\n              </dd>\n            </div>\n          </dl>\n        </div>\n      ))}\n    </div>\n  )\n}\n","truncated":false,"size":1639},{"path":"app/insights/issues/[issueSlug]/nutrition/avoid/page.tsx","content":"'use client'\n\nimport { useNutritionContext } from '../NutritionShell'\n\nexport default function NutritionAvoidPage() {\n  const { extras } = useNutritionContext()\n  const runs = (extras.suggestionRuns ?? []).filter((r) => (r.avoidFoods ?? []).length > 0)\n  const fallbackItems = extras.avoidFoods ?? []\n\n  if (!runs.length && !fallbackItems.length) {\n    return (\n      <div className=\"bg-white border border-gray-200 rounded-2xl shadow-sm p-6 text-sm text-gray-700\">\n        None of your recent meals are raising red flags. Keep balancing plates with protein, fiber, and colour.\n      </div>\n    )\n  }\n\n  return (\n    <div className=\"space-y-4\">\n      {runs.length\n        ? runs.map((run, runIdx) => (\n            <div key={`run-${run.generatedAt}-${runIdx}`} className=\"space-y-3\">\n              <div className=\"text-xs font-semibold text-gray-600\">\n                Generated {new Date(run.generatedAt).toLocaleString()}\n              </div>\n              {run.avoidFoods.map((food, index) => (\n                <div key={`${food.name}-${index}`} className=\"border border-rose-200 bg-rose-50/70 rounded-2xl p-5\">\n                  <h3 className=\"text-base font-semibold text-rose-700\">{food.name}</h3>\n                  <p className=\"text-sm text-rose-700 mt-1 leading-relaxed\">{food.reason}</p>\n                  <p className=\"text-xs text-rose-700 mt-3\">Swap in a steadier option from the suggested tab and monitor how you feel.</p>\n                </div>\n              ))}\n            </div>\n          ))\n        : fallbackItems.map((food, index) => (\n            <div key={`${food.name}-${index}`} className=\"border border-rose-200 bg-rose-50/70 rounded-2xl p-5\">\n              <h3 className=\"text-base font-semibold text-rose-700\">{food.name}</h3>\n              <p className=\"text-sm text-rose-700 mt-1 leading-relaxed\">{food.reason}</p>\n              <p className=\"text-xs text-rose-700 mt-3\">Swap in a steadier option from the suggested tab and monitor how you feel.</p>\n            </div>\n          ))}\n    </div>\n  )\n}\n","truncated":false,"size":2028},{"path":"app/insights/issues/[issueSlug]/nutrition/layout.tsx","content":"import { ReactNode } from 'react'\nimport { getServerSession } from 'next-auth'\nimport { redirect } from 'next/navigation'\nimport { authOptions } from '@/lib/auth'\nimport { getCachedIssueSection } from '@/lib/insights/issue-engine'\nimport NutritionShell from './NutritionShell'\n\ninterface NutritionLayoutProps {\n  children: ReactNode\n  params: { issueSlug: string }\n}\n\nexport default async function NutritionLayout({ children, params }: NutritionLayoutProps) {\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.id) {\n    redirect('/auth/signin')\n  }\n\n  // Cache-only read - never blocks on LLM during SSR\n  const result = await getCachedIssueSection(session.user.id, params.issueSlug, 'nutrition', { mode: 'latest' })\n\n  return (\n    <NutritionShell initialResult={result} issueSlug={params.issueSlug}>\n      {children}\n    </NutritionShell>\n  )\n}\n","truncated":false,"size":873},{"path":"app/insights/issues/[issueSlug]/nutrition/NutritionShell.tsx","content":"'use client'\n\nimport { createContext, ReactNode, useContext, useEffect, useMemo, useState } from 'react'\nimport Link from 'next/link'\nimport { useSelectedLayoutSegments } from 'next/navigation'\nimport SectionChat from '../SectionChat'\nimport type { IssueSectionResult } from '@/lib/insights/issue-engine'\n\n// Progress bar component: indeterminate shimmer to avoid misleading ‚Äústuck‚Äù states\nfunction ProgressBar() {\n  return (\n    <div className=\"w-full bg-gray-200 rounded-full h-2 overflow-hidden relative\">\n      <div className=\"absolute inset-0 bg-gradient-to-r from-helfi-green/30 via-helfi-green to-helfi-green/30 animate-pulse\" />\n    </div>\n  )\n}\n\ntype TabKey = 'working' | 'suggested' | 'avoid'\n\ntype NutritionSuggestionRun = {\n  generatedAt: string\n  suggestedFocus: Array<{ title: string; reason: string }>\n  avoidFoods: Array<{ name: string; reason: string }>\n}\n\ntype NutritionExtras = {\n  workingFocus?: Array<{ title: string; reason: string; example: string }>\n  suggestedFocus?: Array<{ title: string; reason: string }>\n  avoidFoods?: Array<{ name: string; reason: string }>\n  suggestionRuns?: NutritionSuggestionRun[]\n  totalLogged?: number\n}\n\ninterface NutritionContextValue {\n  result: IssueSectionResult\n  loading: boolean\n  error: string | null\n  handleGenerate: () => Promise<void>\n  isRefreshing: boolean\n  issueSlug: string\n  extras: NutritionExtras\n}\n\nconst NutritionContext = createContext<NutritionContextValue | null>(null)\n\nexport function useNutritionContext() {\n  const ctx = useContext(NutritionContext)\n  if (!ctx) {\n    throw new Error('useNutritionContext must be used within NutritionShell')\n  }\n  return ctx\n}\n\ninterface NutritionShellProps {\n  children: ReactNode\n  initialResult: IssueSectionResult | null\n  issueSlug: string\n}\n\nexport default function NutritionShell({ children, initialResult, issueSlug }: NutritionShellProps) {\n  const [result, setResult] = useState<IssueSectionResult | null>(initialResult)\n  const [loading, setLoading] = useState(!initialResult)\n  const [error, setError] = useState<string | null>(null)\n  const [isRefreshing, setIsRefreshing] = useState(false)\n  const [chargeNotice, setChargeNotice] = useState<string | null>(null)\n  const segments = useSelectedLayoutSegments()\n  const activeTab = (segments?.[0] as TabKey | undefined) ?? 'working'\n\n  // Fetch data client-side if SSR returned null (cache miss)\n  useEffect(() => {\n    if (!initialResult) {\n      setLoading(true)\n      const scrollPosition = window.scrollY || document.documentElement.scrollTop\n      // Save scroll position to prevent any scrolling\n      sessionStorage.setItem(`scroll-${issueSlug}-nutrition`, scrollPosition.toString())\n      \n      fetch(`/api/insights/issues/${issueSlug}/sections/nutrition`)\n        .then((res) => {\n          if (!res.ok) {\n            throw new Error('Failed to load section')\n          }\n          return res.json()\n        })\n        .then((data) => {\n          setResult(data)\n          setLoading(false)\n          // Prevent scroll - restore original position multiple times to ensure it sticks\n          const preventScroll = () => {\n            window.scrollTo(0, scrollPosition)\n            document.documentElement.scrollTop = scrollPosition\n            document.body.scrollTop = scrollPosition\n          }\n          preventScroll()\n          requestAnimationFrame(preventScroll)\n          setTimeout(preventScroll, 0)\n          setTimeout(preventScroll, 50)\n          setTimeout(preventScroll, 100)\n          setTimeout(preventScroll, 200)\n        })\n        .catch((err) => {\n          setError((err as Error).message)\n          setLoading(false)\n          const preventScroll = () => {\n            window.scrollTo(0, scrollPosition)\n            document.documentElement.scrollTop = scrollPosition\n            document.body.scrollTop = scrollPosition\n          }\n          preventScroll()\n          requestAnimationFrame(preventScroll)\n          setTimeout(preventScroll, 0)\n          setTimeout(preventScroll, 50)\n        })\n    }\n  }, [initialResult, issueSlug])\n  \n  // Additional scroll prevention when result loads\n  useEffect(() => {\n    if (result && !loading) {\n      // Prevent any auto-scrolling when result finishes loading\n      const preventScroll = () => {\n        const savedPosition = sessionStorage.getItem(`scroll-${issueSlug}-nutrition`)\n        if (savedPosition) {\n          const position = parseInt(savedPosition, 10)\n          window.scrollTo(0, position)\n          document.documentElement.scrollTop = position\n          document.body.scrollTop = position\n        }\n      }\n      preventScroll()\n      requestAnimationFrame(preventScroll)\n      setTimeout(preventScroll, 0)\n      setTimeout(preventScroll, 100)\n      setTimeout(preventScroll, 200)\n    }\n  }, [result, loading, issueSlug])\n\n  async function handleGenerate() {\n    setIsRefreshing(true)\n    setError(null)\n    setChargeNotice(null)\n    try {\n      const runId =\n        typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function'\n          ? crypto.randomUUID()\n          : `run_${Math.random().toString(36).slice(2)}`\n\n      const regenResponse = await fetch('/api/insights/regenerate-targeted', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ changeTypes: ['food'], runId }),\n      })\n      const regenData = await regenResponse.json().catch(() => null)\n      if (!regenResponse.ok || !regenData?.success) {\n        throw new Error(regenData?.message || 'Failed to refresh nutrition insights')\n      }\n\n      const res = await fetch(`/api/insights/issues/${issueSlug}/sections/nutrition`)\n      if (!res.ok) throw new Error('Failed to load nutrition insights')\n      const data = await res.json()\n      setResult(data)\n\n      if (typeof regenData.chargedCredits === 'number') {\n        const costPart =\n          typeof regenData.costCents === 'number'\n            ? ` (AI cost ~$${(regenData.costCents / 100).toFixed(2)})`\n            : ''\n        setChargeNotice(\n          regenData.chargedCredits > 0\n            ? `Charged ${regenData.chargedCredits} credits${costPart}.`\n            : 'Insights updated without any AI charges.'\n        )\n      }\n      try {\n        window.dispatchEvent(new Event('credits:refresh'))\n      } catch {\n        // non-blocking\n      }\n    } catch (err) {\n      setError((err as Error).message || 'Failed to refresh nutrition insights')\n    } finally {\n      setIsRefreshing(false)\n      setLoading(false)\n    }\n  }\n\n  const extras = useMemo<NutritionExtras>(() => {\n    if (!result) {\n      return {\n        workingFocus: [],\n        suggestedFocus: [],\n        avoidFoods: [],\n        suggestionRuns: [],\n        totalLogged: 0,\n      }\n    }\n    const raw = (result.extras ?? {}) as NutritionExtras\n\n    // Build grouped runs; fall back to a single run if no history is present\n    const suggestionRuns: NutritionSuggestionRun[] =\n      (Array.isArray(raw.suggestionRuns) ? raw.suggestionRuns : []).length\n        ? (raw.suggestionRuns as NutritionSuggestionRun[])\n        : [\n            {\n              generatedAt: result.generatedAt,\n              suggestedFocus: raw.suggestedFocus ?? [],\n              avoidFoods: raw.avoidFoods ?? [],\n            },\n          ]\n\n    return {\n      workingFocus: raw.workingFocus ?? [],\n      suggestedFocus: raw.suggestedFocus ?? [],\n      avoidFoods: raw.avoidFoods ?? [],\n      suggestionRuns,\n      totalLogged: raw.totalLogged ?? 0,\n    }\n  }, [result])\n\n  const tabs: Array<{ key: TabKey; label: string; href: string }> = [\n    { key: 'working', label: 'Foods That Are Working', href: `/insights/issues/${issueSlug}/nutrition/working` },\n    { key: 'suggested', label: 'Suggested Foods', href: `/insights/issues/${issueSlug}/nutrition/suggested` },\n    { key: 'avoid', label: 'Foods to Avoid', href: `/insights/issues/${issueSlug}/nutrition/avoid` },\n  ]\n\n  const contextValue = useMemo<NutritionContextValue>(() => {\n    // Create minimal dummy result when null to satisfy context type\n    const dummyResult: IssueSectionResult = result || {\n      issue: { id: '', slug: issueSlug, name: '', polarity: 'negative', severityLabel: '', severityScore: null, currentRating: null, ratingScaleMax: null, trend: 'stable', trendDelta: null, lastUpdated: null, highlight: '', blockers: [], status: 'monitor' },\n      section: 'nutrition',\n      generatedAt: new Date().toISOString(),\n      confidence: 0,\n      summary: '',\n      highlights: [],\n      dataPoints: [],\n      recommendations: [],\n      mode: 'latest',\n      extras: {},\n    }\n    return {\n      result: dummyResult,\n      loading,\n      error,\n      handleGenerate,\n      isRefreshing,\n      issueSlug,\n      extras,\n    }\n  }, [result, loading, error, issueSlug, extras, isRefreshing])\n\n  if (!result && loading) {\n    return (\n      <NutritionContext.Provider value={contextValue}>\n        <div className=\"space-y-6\">\n          <section className=\"bg-white border border-gray-200 rounded-2xl shadow-sm p-6\">\n            <div className=\"flex flex-col md:flex-row md:items-start md:justify-between gap-4\">\n              <div className=\"flex-1\">\n                <h2 className=\"text-lg font-semibold text-gray-900 mb-2\">Nutrition report</h2>\n                <p className=\"text-sm text-gray-700 leading-relaxed mb-3\">Preparing initial guidance...</p>\n                <ProgressBar />\n              </div>\n            </div>\n          </section>\n          <nav className=\"space-y-2\">\n            {tabs.map((tab) => (\n              <Link\n                key={tab.key}\n                href={tab.href}\n                className={`block rounded-xl border px-4 py-3 text-left text-sm font-semibold transition-colors ${\n                  tab.key === activeTab\n                    ? 'border-helfi-green bg-helfi-green text-white shadow-sm'\n                    : 'border-gray-200 bg-white text-gray-700 hover:border-helfi-green/70 hover:bg-gray-50'\n                }`}\n              >\n                {tab.label}\n              </Link>\n            ))}\n          </nav>\n          <div>{children}</div>\n        </div>\n      </NutritionContext.Provider>\n    )\n  }\n\n  if (!result) {\n    return (\n      <NutritionContext.Provider value={contextValue}>\n        <div className=\"space-y-6\">\n          <section className=\"bg-white border border-gray-200 rounded-2xl shadow-sm p-6\">\n            <div className=\"flex flex-col md:flex-row md:items-start md:justify-between gap-4\">\n              <div>\n                <h2 className=\"text-lg font-semibold text-gray-900 mb-2\">Nutrition report</h2>\n                <p className=\"text-sm text-red-600\">{error || 'Failed to load section data'}</p>\n              </div>\n            </div>\n          </section>\n          <nav className=\"space-y-2\">\n            {tabs.map((tab) => (\n              <Link\n                key={tab.key}\n                href={tab.href}\n                className={`block rounded-xl border px-4 py-3 text-left text-sm font-semibold transition-colors ${\n                  tab.key === activeTab\n                    ? 'border-helfi-green bg-helfi-green text-white shadow-sm'\n                    : 'border-gray-200 bg-white text-gray-700 hover:border-helfi-green/70 hover:bg-gray-50'\n                }`}\n              >\n                {tab.label}\n              </Link>\n            ))}\n          </nav>\n          <div>{children}</div>\n        </div>\n      </NutritionContext.Provider>\n    )\n  }\n\n  return (\n    <NutritionContext.Provider value={contextValue}>\n      <div className=\"space-y-6\">\n        <section className=\"bg-white border border-gray-200 rounded-2xl shadow-sm p-6\">\n          <div className=\"flex flex-col md:flex-row md:items-start md:justify-between gap-4\">\n            <div>\n              <h2 className=\"text-lg font-semibold text-gray-900 mb-2\">Nutrition report</h2>\n              <p className=\"text-sm text-gray-700 leading-relaxed\">\n                {result.summary && !result.summary.toLowerCase().includes('couldn‚Äôt generate')\n                  ? result.summary\n                  : 'No nutrition insights yet. Click ‚ÄúGenerate Nutrition Insights‚Äù to create them using your latest food diary entries.'}\n              </p>\n              <p className=\"text-xs text-gray-500 mt-3\">\n                Generated {new Date(result.generatedAt).toLocaleString()} ‚Ä¢ Confidence {(result.confidence * 100).toFixed(0)}%\n              </p>\n            </div>\n            <div className=\"flex flex-col items-start gap-2\">\n              <button\n                onClick={handleGenerate}\n                disabled={isRefreshing}\n                className={`px-4 py-2 rounded-lg text-sm font-semibold transition-colors ${\n                  isRefreshing ? 'bg-gray-200 text-gray-500 cursor-not-allowed' : 'bg-helfi-green text-white hover:bg-helfi-green/90'\n                }`}\n              >\n                {isRefreshing ? 'Refreshing‚Ä¶' : 'Generate Nutrition Insights'}\n              </button>\n              <p className=\"text-xs text-gray-500\">Credits will be charged after generation based on actual AI usage.</p>\n              <p className=\"text-xs text-gray-500\">Runs only on new/changed food diary entries.</p>\n              {chargeNotice && (\n                <p className=\"text-sm text-gray-700 bg-gray-100 border border-gray-200 rounded-md px-3 py-2\">\n                  {chargeNotice}\n                </p>\n              )}\n            </div>\n          </div>\n          {(isRefreshing || loading) && (\n            <div className=\"mt-4\">\n              <ProgressBar />\n              <p className=\"text-sm text-gray-600 mt-2\">Updating nutrition insights...</p>\n            </div>\n          )}\n          {error && (\n            <div className=\"mt-4 text-sm text-red-600 bg-red-50 border border-red-200 rounded-lg p-3\">\n              {error}\n            </div>\n          )}\n        </section>\n\n        <nav className=\"space-y-2\">\n          {tabs.map((tab) => (\n            <Link\n              key={tab.key}\n              href={tab.href}\n              className={`block rounded-xl border px-4 py-3 text-left text-sm font-semibold transition-colors ${\n                tab.key === activeTab\n                  ? 'border-helfi-green bg-helfi-green text-white shadow-sm'\n                  : 'border-gray-200 bg-white text-gray-700 hover:border-helfi-green/70 hover:bg-gray-50'\n              }`}\n            >\n              {tab.label}\n            </Link>\n          ))}\n        </nav>\n\n        <div>{children}</div>\n\n        <SectionChat issueSlug={issueSlug} section=\"nutrition\" issueName={result?.issue?.name ?? ''} />\n      </div>\n    </NutritionContext.Provider>\n  )\n}\n","truncated":false,"size":14614},{"path":"app/insights/issues/[issueSlug]/nutrition/page.tsx","content":"import { redirect } from 'next/navigation'\n\ninterface NutritionPageProps {\n  params: { issueSlug: string }\n}\n\nexport default function NutritionPage({ params }: NutritionPageProps) {\n  redirect(`/insights/issues/${params.issueSlug}/nutrition/working`)\n}\n","truncated":false,"size":253},{"path":"app/insights/issues/[issueSlug]/nutrition/suggested/page.tsx","content":"'use client'\n\nimport { useNutritionContext } from '../NutritionShell'\n\nexport default function NutritionSuggestedPage() {\n  const { extras } = useNutritionContext()\n  const runs = (extras.suggestionRuns ?? []).filter((r) => (r.suggestedFocus ?? []).length > 0)\n  const fallbackItems = extras.suggestedFocus ?? []\n\n  if (!runs.length && !fallbackItems.length) {\n    return (\n      <div className=\"bg-white border border-gray-200 rounded-2xl shadow-sm p-6 text-sm text-gray-700\">\n        Your logged meals already cover the core nutrition moves for this issue. Keep noting portions and energy shifts so we can refine guidance.\n      </div>\n    )\n  }\n\n  return (\n    <div className=\"space-y-4\">\n      {runs.length\n        ? runs.map((run, runIdx) => (\n            <div key={`run-${run.generatedAt}-${runIdx}`} className=\"space-y-3\">\n              <div className=\"text-xs font-semibold text-gray-600\">\n                Generated {new Date(run.generatedAt).toLocaleString()}\n              </div>\n              {run.suggestedFocus.map((focus, index) => (\n                <div key={`${focus.title}-${index}`} className=\"border border-gray-200 bg-white rounded-2xl p-5\">\n                  <h3 className=\"text-base font-semibold text-gray-900\">{focus.title}</h3>\n                  <p className=\"text-sm text-gray-700 mt-1 leading-relaxed\">{focus.reason}</p>\n                  <p className=\"mt-3 text-xs text-gray-500\">Plan a meal this week that highlights this focus and log how you feel afterwards.</p>\n                </div>\n              ))}\n            </div>\n          ))\n        : fallbackItems.map((focus, index) => (\n            <div key={`${focus.title}-${index}`} className=\"border border-gray-200 bg-white rounded-2xl p-5\">\n              <h3 className=\"text-base font-semibold text-gray-900\">{focus.title}</h3>\n              <p className=\"text-sm text-gray-700 mt-1 leading-relaxed\">{focus.reason}</p>\n              <p className=\"mt-3 text-xs text-gray-500\">Plan a meal this week that highlights this focus and log how you feel afterwards.</p>\n            </div>\n          ))}\n    </div>\n  )\n}\n","truncated":false,"size":2095},{"path":"app/insights/issues/[issueSlug]/nutrition/working/page.tsx","content":"'use client'\n\nimport { useNutritionContext } from '../NutritionShell'\n\nexport default function NutritionWorkingPage() {\n  const { extras } = useNutritionContext()\n  const items = extras.workingFocus ?? []\n\n  if (!items.length) {\n    return (\n      <div className=\"bg-white border border-gray-200 rounded-2xl shadow-sm p-6 text-sm text-gray-700\">\n        We don‚Äôt yet see foods in your log that directly support this issue. Check the ‚ÄúSuggested Foods‚Äù tab for ideas and log meals so we can track wins.\n      </div>\n    )\n  }\n\n  return (\n    <div className=\"space-y-3\">\n      {items.map((focus, index) => (\n        <div key={`${focus.title}-${index}`} className=\"border border-emerald-200 bg-emerald-50/70 rounded-2xl p-5\">\n          <h3 className=\"text-base font-semibold text-gray-900\">{focus.title}</h3>\n          <p className=\"text-sm text-emerald-800 mt-1 leading-relaxed\">{focus.reason}</p>\n          <dl className=\"mt-4 text-sm text-gray-700\">\n            <dt className=\"text-xs uppercase text-gray-500 tracking-wide\">Example from your log</dt>\n            <dd>{focus.example}</dd>\n          </dl>\n        </div>\n      ))}\n    </div>\n  )\n}\n","truncated":false,"size":1151},{"path":"app/insights/issues/[issueSlug]/overview/page.tsx","content":"import { getServerSession } from 'next-auth'\nimport { redirect, notFound } from 'next/navigation'\nimport { authOptions } from '@/lib/auth'\nimport { getIssueSection } from '@/lib/insights/issue-engine'\nimport SectionRenderer from '../SectionRenderer'\n\ninterface IssueOverviewReportPageProps {\n  params: { issueSlug: string }\n}\n\nexport default async function IssueOverviewReportPage({ params }: IssueOverviewReportPageProps) {\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.id) {\n    redirect('/auth/signin')\n  }\n\n  const result = await getIssueSection(session.user.id, params.issueSlug, 'overview')\n  if (!result) {\n    notFound()\n  }\n\n  return <SectionRenderer issueSlug={params.issueSlug} section=\"overview\" initialResult={result} />\n}\n","truncated":false,"size":766},{"path":"app/insights/issues/[issueSlug]/page.tsx","content":"import { getServerSession } from 'next-auth'\nimport { redirect } from 'next/navigation'\nimport { authOptions } from '@/lib/auth'\nimport { getIssueSummaries, ISSUE_SECTION_ORDER } from '@/lib/insights/issue-engine'\nimport type { IssueSummary } from '@/lib/insights/issue-engine'\nimport dynamic from 'next/dynamic'\nconst SectionPrefetcher = dynamic(() => import('./SectionPrefetcher'), { ssr: false })\nconst IssueOverviewClient = dynamic(() => import('./IssueOverviewClient'), { ssr: false })\n\ninterface IssueOverviewPageProps {\n  params: { issueSlug: string }\n}\n\nfunction fallbackIssue(slug: string): IssueSummary {\n  const readable = slug\n    .replace(/[-_]+/g, ' ')\n    .trim()\n    .split(' ')\n    .filter(Boolean)\n    .map(part => part.charAt(0).toUpperCase() + part.slice(1))\n    .join(' ')\n  return {\n    id: `temp:${slug}`,\n    slug,\n    name: readable || 'Insight',\n    polarity: 'negative',\n    severityLabel: 'Needs data',\n    severityScore: null,\n    currentRating: null,\n    ratingScaleMax: 6,\n    trend: 'inconclusive',\n    trendDelta: null,\n    lastUpdated: null,\n    highlight: 'Needs more data before we can generate trends.',\n    blockers: ['Log more recent data so we can generate this report.'],\n    status: 'needs-data',\n  }\n}\n\nexport default async function IssueOverviewPage({ params }: IssueOverviewPageProps) {\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.id) {\n    redirect('/auth/signin')\n  }\n\n  const summaries = await getIssueSummaries(session.user.id)\n  const issue = summaries.find((item) => item.slug === params.issueSlug) ?? fallbackIssue(params.issueSlug)\n\n  const sectionDescriptions: Record<string, string> = {\n    supplements: 'Review current regimen, identify gaps, and spot potential additions.',\n    medications: 'Track prescriptions, capture timing, and see what is actually helping.',\n    labs: 'Track bloodwork targets and know when to upload or re-test.',\n    nutrition: 'See how logged meals support this issue and what to tweak next.',\n  }\n\n  const sectionsToPrefetch = ISSUE_SECTION_ORDER\n\n  return (\n    <div className=\"space-y-6\">\n      {/* Prefetch all sections in the background so opening is instant */}\n      <SectionPrefetcher issueSlug={issue.slug} sections={sectionsToPrefetch} />\n      <IssueOverviewClient issue={issue} issueSlug={issue.slug} />\n    </div>\n  )\n}\n","truncated":false,"size":2348},{"path":"app/insights/issues/[issueSlug]/SectionChat.tsx","content":"'use client'\n\nimport { FormEvent, KeyboardEvent, useEffect, useLayoutEffect, useMemo, useRef, useState, useCallback } from 'react'\nimport { createPortal } from 'react-dom'\nimport { ArrowsPointingOutIcon, ArrowsPointingInIcon } from '@heroicons/react/24/outline'\nimport { formatChatContent } from '@/lib/chatFormatting'\n\ninterface SectionChatProps {\n  issueSlug: string\n  section: string\n  issueName: string\n}\n\ntype ChatMessage = { role: 'user' | 'assistant'; content: string }\ntype ChatThread = { id: string; title: string | null; createdAt: string; updatedAt: string }\n\nexport default function SectionChat({ issueSlug, section, issueName }: SectionChatProps) {\n  const storageKey = useMemo(() => `helfi:insights:thread:${issueSlug}:${section}`, [issueSlug, section])\n  const [messages, setMessages] = useState<ChatMessage[]>([])\n  const [input, setInput] = useState('')\n  const [loading, setLoading] = useState(false)\n  const [error, setError] = useState<string | null>(null)\n  const [isListening, setIsListening] = useState(false)\n  const [threads, setThreads] = useState<ChatThread[]>([])\n  const [threadId, setThreadId] = useState<string | null>(null)\n  const [showThreadMenu, setShowThreadMenu] = useState(false)\n  const [hasSpeechRecognition, setHasSpeechRecognition] = useState(false)\n  const [expanded, setExpanded] = useState(false)\n  const [showExpandControl, setShowExpandControl] = useState(false)\n  const scrollPositionRef = useRef<number>(0)\n  const endRef = useRef<HTMLDivElement | null>(null)\n  const containerRef = useRef<HTMLDivElement | null>(null)\n  const textareaRef = useRef<HTMLTextAreaElement | null>(null)\n  const enabled = (process.env.NEXT_PUBLIC_INSIGHTS_CHAT || 'true').toLowerCase() === 'true' || (process.env.NEXT_PUBLIC_INSIGHTS_CHAT || '') === '1'\n  const recognitionRef = useRef<any>(null)\n  const resizeRafRef = useRef<number | null>(null)\n  const [isClient, setIsClient] = useState(false)\n\n  // Smooth single-frame resize to prevent jitter when text grows/shrinks quickly\n  const resizeTextarea = useCallback(() => {\n    if (resizeRafRef.current) cancelAnimationFrame(resizeRafRef.current)\n    resizeRafRef.current = requestAnimationFrame(() => {\n      const textarea = textareaRef.current\n      if (!textarea) return\n      const minHeight = 52\n      const maxHeight = 200\n      textarea.style.height = 'auto'\n      const desired = Math.min(Math.max(textarea.scrollHeight, minHeight), maxHeight)\n      if (textarea.style.height !== `${desired}px`) {\n        textarea.style.height = `${desired}px`\n      }\n      textarea.style.overflowY = textarea.scrollHeight > maxHeight ? 'auto' : 'hidden'\n\n      // Show expand control when textarea height exceeds ~3-4 lines (around 156px for 3 lines)\n      // Using scrollHeight which reflects actual content height\n      const shouldShow = textarea.scrollHeight > 140 || (textarea.value.match(/\\n/g) || []).length >= 2\n      setShowExpandControl(shouldShow)\n    })\n  }, [])\n\n  // Initialize speech recognition\n  useEffect(() => {\n    if (typeof window === 'undefined' || !enabled) return\n    \n    // Check for speech recognition support immediately\n    const SpeechRecognition = (window as any).SpeechRecognition || (window as any).webkitSpeechRecognition\n    if (SpeechRecognition) {\n      setHasSpeechRecognition(true)\n    } else {\n      return\n    }\n\n    const recognition = new SpeechRecognition()\n    recognition.continuous = true\n    recognition.interimResults = true\n    recognition.lang = 'en-US'\n\n    let finalTranscript = ''\n\n    recognition.onstart = () => {\n      setIsListening(true)\n      finalTranscript = ''\n    }\n\n    recognition.onresult = (event: any) => {\n      let interimTranscript = ''\n      \n      for (let i = event.resultIndex; i < event.results.length; i++) {\n        const transcript = event.results[i][0].transcript\n        if (event.results[i].isFinal) {\n          finalTranscript += transcript + ' '\n        } else {\n          interimTranscript += transcript\n        }\n      }\n      \n      setInput(finalTranscript + interimTranscript)\n    }\n\n    recognition.onerror = (event: any) => {\n      setIsListening(false)\n      if (event.error !== 'no-speech') {\n        setError('Speech recognition error. Please try again.')\n      }\n    }\n\n    recognition.onend = () => {\n      setIsListening(false)\n      if (finalTranscript.trim()) {\n        setInput(finalTranscript.trim())\n      }\n    }\n\n    recognitionRef.current = recognition\n    return () => {\n      if (recognitionRef.current) recognitionRef.current.stop()\n    }\n  }, [enabled])\n\n  // Track client-side mount so we can safely use portals\n  useEffect(() => {\n    setIsClient(true)\n  }, [])\n\n  function startListening() {\n    if (!recognitionRef.current || isListening) return\n    try {\n      recognitionRef.current.start()\n    } catch (err) {\n      setError('Failed to start voice recognition')\n    }\n  }\n\n  function stopListening() {\n    if (recognitionRef.current && isListening) {\n      recognitionRef.current.stop()\n      setIsListening(false)\n    }\n  }\n\n  // Load threads and current thread on mount\n  useEffect(() => {\n    if (!enabled) return\n    let cancelled = false\n    ;(async () => {\n      try {\n        let hasThreads = false\n        // Load threads\n        const threadsRes = await fetch(`/api/insights/issues/${issueSlug}/sections/${section}/threads`, { cache: 'no-store' })\n        if (threadsRes.ok) {\n          const threadsData = await threadsRes.json()\n          if (!cancelled && threadsData.threads && Array.isArray(threadsData.threads)) {\n            setThreads(threadsData.threads)\n            hasThreads = threadsData.threads.length > 0\n            if (threadsData.threads.length > 0 && !threadId) {\n              // Load most recent thread\n              const latestThreadId = threadsData.threads[0].id\n              setThreadId(latestThreadId)\n              loadThreadMessages(latestThreadId)\n            }\n          }\n        }\n        // Only try backward compatibility if we have NO threads (to avoid creating duplicates)\n        if (!cancelled && !hasThreads && !threadId) {\n          const res = await fetch(`/api/insights/issues/${issueSlug}/sections/${section}/chat`, { cache: 'no-store' })\n          if (res.ok) {\n            const data = await res.json()\n            if (!cancelled && typeof data?.threadId === 'string') {\n              setThreadId(data.threadId)\n              const serverMessages = Array.isArray(data?.messages)\n                ? data.messages.map((m: any) => ({ role: m.role, content: m.content })).filter((m: any) => m?.content)\n                : []\n              if (!cancelled && serverMessages.length) setMessages(serverMessages)\n            }\n          }\n        }\n      } catch {}\n      // Also hydrate from localStorage if server has nothing yet\n      if (!cancelled && messages.length === 0) {\n        try {\n          const saved = localStorage.getItem(storageKey)\n          if (saved) {\n            const parsed = JSON.parse(saved)\n            if (Array.isArray(parsed)) {\n              setMessages(parsed.filter((m) => m && typeof m.content === 'string' && (m.role === 'user' || m.role === 'assistant')).slice(-24))\n            }\n          }\n        } catch {}\n      }\n    })()\n    return () => { cancelled = true }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [enabled, issueSlug, section])\n\n  async function loadThreadMessages(threadIdToLoad: string) {\n    try {\n      const res = await fetch(`/api/insights/issues/${issueSlug}/sections/${section}/chat?threadId=${threadIdToLoad}`, { cache: 'no-store' })\n      if (res.ok) {\n        const data = await res.json()\n        const serverMessages = Array.isArray(data?.messages)\n          ? data.messages.map((m: any) => ({ role: m.role, content: m.content })).filter((m: any) => m?.content)\n          : []\n        setMessages(serverMessages)\n      }\n    } catch (err) {\n      console.error('Failed to load thread messages:', err)\n    }\n  }\n\n  async function handleNewChat() {\n    try {\n      const res = await fetch(`/api/insights/issues/${issueSlug}/sections/${section}/threads`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({}),\n      })\n      if (res.ok) {\n        const data = await res.json()\n        const newThreadId = data.threadId\n        setThreadId(newThreadId)\n        setMessages([])\n        // Reload threads\n        const threadsRes = await fetch(`/api/insights/issues/${issueSlug}/sections/${section}/threads`, { cache: 'no-store' })\n        if (threadsRes.ok) {\n          const threadsData = await threadsRes.json()\n          if (threadsData.threads) setThreads(threadsData.threads)\n        }\n      }\n    } catch (err) {\n      console.error('Failed to create new thread:', err)\n    }\n  }\n\n  async function handleDeleteThread(threadIdToDelete: string) {\n    if (!confirm('Delete this chat?')) return\n    try {\n      const res = await fetch(`/api/insights/issues/${issueSlug}/sections/${section}/threads`, {\n        method: 'DELETE',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ threadId: threadIdToDelete }),\n      })\n      if (res.ok) {\n        // Reload threads\n        const threadsRes = await fetch(`/api/insights/issues/${issueSlug}/sections/${section}/threads`, { cache: 'no-store' })\n        if (threadsRes.ok) {\n          const threadsData = await threadsRes.json()\n          if (threadsData.threads) {\n            setThreads(threadsData.threads)\n            if (threadsData.threads.length > 0) {\n              const newThreadId = threadsData.threads[0].id\n              setThreadId(newThreadId)\n              loadThreadMessages(newThreadId)\n            } else {\n              setThreadId(null)\n              setMessages([])\n            }\n          }\n        }\n      }\n    } catch (err) {\n      console.error('Failed to delete thread:', err)\n    }\n  }\n\n  // Persist a lightweight copy locally for UX continuity\n  useEffect(() => {\n    try {\n      localStorage.setItem(storageKey, JSON.stringify(messages))\n    } catch {}\n  }, [messages, storageKey])\n\n  // Only auto-scroll when user sends a message, not on initial load\n  const [hasUserInteracted, setHasUserInteracted] = useState(false)\n  \n  useEffect(() => {\n    // Only scroll if user has interacted (sent a message)\n    if (hasUserInteracted && messages.length > 0) {\n      // Use setTimeout to ensure scroll happens after render\n      setTimeout(() => {\n        endRef.current?.scrollIntoView({ behavior: 'smooth' })\n      }, 100)\n    }\n  }, [messages, loading, hasUserInteracted])\n\n  // NOTE: We intentionally do NOT manipulate page scroll when expanding.\n  // The expanded chat is rendered in a fullscreen portal overlay,\n  // so closing it simply removes the overlay and leaves page scroll\n  // exactly where it was.\n\n  useEffect(() => {\n    return () => {\n      if (resizeRafRef.current) cancelAnimationFrame(resizeRafRef.current)\n    }\n  }, [])\n\n  function onComposerKeyDown(event: KeyboardEvent<HTMLTextAreaElement>) {\n    if (event.key === 'Enter' && !event.shiftKey) {\n      event.preventDefault()\n      const form = (event.target as HTMLTextAreaElement).closest('form') as HTMLFormElement | null\n      form?.requestSubmit()\n    }\n  }\n\n  async function handleClear() {\n    try {\n      if (!enabled) return\n      setLoading(true)\n      setError(null)\n      await fetch(`/api/insights/issues/${issueSlug}/sections/${section}/chat`, { method: 'DELETE' })\n      setMessages([])\n      setThreadId(null)\n      try { localStorage.removeItem(storageKey) } catch {}\n    } catch (err) {\n      setError((err as Error).message)\n    } finally {\n      setLoading(false)\n    }\n  }\n\n  async function handleSubmit(event: FormEvent<HTMLFormElement>) {\n    event.preventDefault()\n    const text = input.trim()\n    if (!text) {\n      setError('Enter a question to ask the AI.')\n      return\n    }\n    try {\n      setLoading(true)\n      setError(null)\n      stopListening()\n      const nextMessages: ChatMessage[] = [...messages, { role: 'user', content: text }]\n      setMessages(nextMessages)\n      setInput('')\n\n      // Attempt streaming via SSE to new chat endpoint\n      const url = `/api/insights/issues/${issueSlug}/sections/${section}/chat`\n      const res = await fetch(url, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json', Accept: 'text/event-stream' },\n        body: JSON.stringify({ \n          message: text,\n          threadId: threadId || undefined,\n          newThread: false, // Never create a new thread automatically - user must click \"+ New\"\n        }),\n      })\n      if (res.ok && (res.headers.get('content-type') || '').includes('text/event-stream') && res.body) {\n        const reader = res.body.getReader()\n        const decoder = new TextDecoder()\n        let buffer = ''\n        let hasAssistant = false\n        while (true) {\n          const { value, done } = await reader.read()\n          if (done) break\n          buffer += decoder.decode(value, { stream: true })\n          const parts = buffer.split('\\n\\n')\n          buffer = parts.pop() || ''\n          for (const chunk of parts) {\n            if (chunk.startsWith('data: ')) {\n              const raw = chunk.slice(6).trim()\n              let token = ''\n              // Prefer JSON payloads to preserve newlines; fall back to raw\n              try {\n                const parsed = JSON.parse(raw)\n                if (typeof parsed === 'string') {\n                  token = parsed\n                } else if (parsed && typeof parsed.token === 'string') {\n                  token = parsed.token\n                } else {\n                  token = raw\n                }\n              } catch {\n                token = raw\n              }\n              if (!hasAssistant) {\n                setMessages((prev) => [...prev, { role: 'assistant', content: token }])\n                hasAssistant = true\n              } else {\n                setMessages((prev) => {\n                  const copy = prev.slice()\n                  copy[copy.length - 1] = { role: 'assistant', content: (copy[copy.length - 1] as any).content + token }\n                  return copy\n                })\n              }\n            } else if (chunk.startsWith('event: end')) {\n              // Response complete - reload threads to get updated title\n              const threadsRes = await fetch(`/api/insights/issues/${issueSlug}/sections/${section}/threads`, { cache: 'no-store' })\n              if (threadsRes.ok) {\n                const threadsData = await threadsRes.json()\n                if (threadsData.threads) {\n                  setThreads(threadsData.threads)\n                  // Update threadId if we created a new thread\n                  if (!threadId && threadsData.threads.length > 0) {\n                    setThreadId(threadsData.threads[0].id)\n                  }\n                }\n              }\n            }\n          }\n        }\n      } else {\n        // Fallback to non-streaming JSON\n        const data = await res.json().catch(() => null)\n        const textOut = data?.assistant as string | undefined\n        if (textOut) {\n          setMessages((prev) => [...prev, { role: 'assistant', content: textOut }])\n        }\n        // Update threadId if returned\n        if (data?.threadId) {\n          setThreadId(data.threadId)\n          // Reload threads to get updated titles\n          const threadsRes = await fetch(`/api/insights/issues/${issueSlug}/sections/${section}/threads`, { cache: 'no-store' })\n          if (threadsRes.ok) {\n            const threadsData = await threadsRes.json()\n            if (threadsData.threads) setThreads(threadsData.threads)\n          }\n        }\n      }\n    } catch (err) {\n      setError((err as Error).message)\n    } finally {\n      setLoading(false)\n    }\n  }\n\n  if (!enabled) return null\n  const sectionClass = expanded\n    ? 'fixed inset-0 z-[9999] bg-white flex flex-col h-[100dvh]'\n    : 'flex flex-col h-[calc(100vh-140px)] md:h-full bg-white md:rounded-2xl md:border md:shadow-sm relative'\n\n  const chatUI = (\n    <div\n      className={sectionClass}\n      style={\n        expanded\n          ? {\n              paddingTop: 'calc(env(safe-area-inset-top, 16px))',\n              paddingBottom: 'env(safe-area-inset-bottom, 0px)',\n            }\n          : undefined\n      }\n    >\n      {/* Thread Selector Header */}\n      <div className=\"border-b border-gray-200 bg-white px-4 py-2 flex items-center justify-between relative\">\n        <div className=\"flex items-center gap-2 flex-1 min-w-0\">\n          <button\n            type=\"button\"\n            onClick={() => setShowThreadMenu(!showThreadMenu)}\n            className=\"flex items-center gap-2 px-3 py-1.5 rounded-lg hover:bg-gray-100 transition-colors min-w-0 flex-1\"\n          >\n            <span className=\"truncate text-sm font-medium text-gray-700\">\n              {threadId ? threads.find(t => t.id === threadId)?.title || 'New Chat' : 'New Chat'}\n            </span>\n            <svg className=\"w-4 h-4 text-gray-500 flex-shrink-0\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M19 9l-7 7-7-7\" />\n            </svg>\n          </button>\n          {showThreadMenu && (\n            <div className=\"absolute left-4 top-12 bg-white border border-gray-200 rounded-lg shadow-lg z-50 max-h-96 overflow-y-auto min-w-[200px]\">\n              <button\n                type=\"button\"\n                onClick={() => {\n                  handleNewChat()\n                  setShowThreadMenu(false)\n                }}\n                className=\"w-full px-4 py-2 text-left text-sm hover:bg-gray-100 border-b border-gray-100\"\n              >\n                + New Chat\n              </button>\n              {threads.map((thread) => (\n                <div key={thread.id} className=\"flex items-center group\">\n                  <button\n                    type=\"button\"\n                    onClick={() => {\n                      setThreadId(thread.id)\n                      loadThreadMessages(thread.id)\n                      setShowThreadMenu(false)\n                    }}\n                    className={`flex-1 px-4 py-2 text-left text-sm hover:bg-gray-100 truncate ${\n                      threadId === thread.id ? 'bg-gray-50' : ''\n                    }`}\n                  >\n                    {thread.title || 'New Chat'}\n                  </button>\n                  <button\n                    type=\"button\"\n                    onClick={() => handleDeleteThread(thread.id)}\n                    className=\"px-2 py-2 text-gray-400 hover:text-red-600 opacity-0 group-hover:opacity-100 transition-opacity\"\n                  >\n                    <svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                      <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16\" />\n                    </svg>\n                  </button>\n                </div>\n              ))}\n            </div>\n          )}\n        </div>\n        <button\n          type=\"button\"\n          onClick={handleNewChat}\n          className=\"px-3 py-1.5 text-sm text-gray-700 hover:bg-gray-100 rounded-lg transition-colors\"\n        >\n          + New\n        </button>\n      </div>\n      {/* Messages Area - ChatGPT style */}\n      <div className=\"px-4 pb-2 text-sm text-gray-500\">\n        AI replies use credits (billed at 2√ó OpenAI cost). Typical: 2‚Äì4 credits per reply, depending on length.\n      </div>\n      <div\n        ref={containerRef}\n        className={`overflow-y-auto overflow-x-hidden px-4 py-6 space-y-6 min-w-0 w-full max-w-3xl mx-auto ${expanded ? 'flex-1 min-h-0' : 'min-h-[220px]'}`}\n        aria-live=\"polite\"\n        style={{\n          maxWidth: '100%',\n          wordWrap: 'break-word',\n          paddingBottom: 'calc(env(safe-area-inset-bottom, 0px) + 96px)',\n        }}\n      >\n        {messages.length === 0 && !loading && (\n          <div className=\"w-full md:max-w-3xl mx-auto\">\n            <div className=\"text-center mb-8\">\n              <h2 className=\"text-2xl font-semibold text-gray-900 mb-2\">How can I help you today?</h2>\n            </div>\n            <div className=\"grid grid-cols-1 md:grid-cols-2 gap-3\">\n              {[\n                `How do these recommendations help ${issueName}?`,\n                'Are there safety interactions to watch?',\n                'What should I try first this week?',\n                `Tell me more about ${issueName}`,\n              ].map((q) => (\n                <button\n                  key={q}\n                  onClick={() => setInput(q)}\n                  className=\"text-left px-4 py-3 bg-gray-50 hover:bg-gray-100 rounded-xl text-sm text-gray-700 transition-colors\"\n                  type=\"button\"\n                >\n                  {q}\n                </button>\n              ))}\n            </div>\n          </div>\n        )}\n        {messages.map((m, idx) => (\n          <div key={idx} className={`flex gap-4 w-full md:max-w-3xl mx-auto ${m.role === 'user' ? 'flex-row-reverse' : ''}`}>\n            <div className=\"flex-shrink-0 w-8 h-8 rounded-full bg-gray-200 flex items-center justify-center\">\n              {m.role === 'user' ? (\n                <svg className=\"w-5 h-5 text-gray-600\" fill=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path d=\"M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z\"/>\n                </svg>\n              ) : (\n                <svg className=\"w-5 h-5 text-gray-600\" fill=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path d=\"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z\"/>\n                </svg>\n              )}\n            </div>\n            <div className={`flex-1 min-w-0 ${m.role === 'user' ? 'text-right' : ''}`}>\n              <div className={`inline-block max-w-full px-4 py-2.5 rounded-2xl ${\n                m.role === 'user' \n                  ? 'bg-gray-900 text-white' \n                  : 'bg-gray-100 text-gray-900'\n              }`} style={{ wordWrap: 'break-word', overflowWrap: 'break-word' }}>\n                <div className=\"text-lg leading-relaxed break-words\">\n                  {(() => {\n                    const formatted = formatChatContent(m.content)\n                    // Split by double newlines first to get paragraphs\n                    const paragraphs = formatted.split(/\\n\\n+/)\n                    return paragraphs.map((para, paraIdx) => {\n                      const trimmed = para.trim()\n                      if (!trimmed) return null\n                      \n                      // Split paragraph into lines\n                      const lines = trimmed.split('\\n')\n                      \n                      return (\n                        <div key={paraIdx} className={paraIdx > 0 ? 'mt-4' : ''}>\n                          {lines.map((line, lineIdx) => {\n                            const lineTrimmed = line.trim()\n                            if (!lineTrimmed) return <div key={lineIdx} className=\"h-2\" />\n                            \n                            // Check for bold heading (entire line is bold)\n                            if (lineTrimmed.startsWith('**') && lineTrimmed.endsWith('**') && lineTrimmed.length > 4) {\n                              return (\n                                <div key={lineIdx} className=\"font-bold text-gray-900 mb-2 mt-3 first:mt-0\">\n                                  {lineTrimmed.slice(2, -2)}\n                                </div>\n                              )\n                            }\n                            \n                            // Check for numbered list\n                            const numberedMatch = lineTrimmed.match(/^(\\d+)\\.\\s+(.+)$/)\n                            if (numberedMatch) {\n                              const parts = numberedMatch[2].split(/(\\*\\*.*?\\*\\*)/g)\n                              return (\n                                <div key={lineIdx} className=\"ml-4 mb-1.5\">\n                                  <span className=\"font-medium\">{numberedMatch[1]}.</span>{' '}\n                                  {parts.map((part, j) => {\n                                    if (part.startsWith('**') && part.endsWith('**')) {\n                                      return <strong key={j} className=\"font-semibold\">{part.slice(2, -2)}</strong>\n                                    }\n                                    return <span key={j}>{part}</span>\n                                  })}\n                                </div>\n                              )\n                            }\n                            \n                            // Check for bullet point\n                            const bulletMatch = lineTrimmed.match(/^[-‚Ä¢*]\\s+(.+)$/)\n                            if (bulletMatch) {\n                              const parts = bulletMatch[1].split(/(\\*\\*.*?\\*\\*)/g)\n                              return (\n                                <div key={lineIdx} className=\"ml-4 mb-1.5\">\n                                  <span className=\"mr-2\">‚Ä¢</span>\n                                  {parts.map((part, j) => {\n                                    if (part.startsWith('**') && part.endsWith('**')) {\n                                      return <strong key={j} className=\"font-semibold\">{part.slice(2, -2)}</strong>\n                                    }\n                                    return <span key={j}>{part}</span>\n                                  })}\n                                </div>\n                              )\n                            }\n                            \n                            // Regular paragraph line - parse inline bold\n                            const parts = lineTrimmed.split(/(\\*\\*.*?\\*\\*)/g)\n                            return (\n                              <div key={lineIdx} className={lineIdx > 0 ? 'mt-2' : ''}>\n                                {parts.map((part, j) => {\n                                  if (part.startsWith('**') && part.endsWith('**')) {\n                                    return <strong key={j} className=\"font-semibold\">{part.slice(2, -2)}</strong>\n                                  }\n                                  return <span key={j}>{part}</span>\n                                })}\n                              </div>\n                            )\n                          })}\n                        </div>\n                      )\n                    })\n                  })()}\n                </div>\n              </div>\n            </div>\n          </div>\n        ))}\n        {loading && (\n          <div className=\"flex gap-4 w-full md:max-w-3xl mx-auto\">\n            <div className=\"flex-shrink-0 w-8 h-8 rounded-full bg-gray-200 flex items-center justify-center\">\n              <svg className=\"w-5 h-5 text-gray-600\" fill=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path d=\"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z\"/>\n              </svg>\n            </div>\n            <div className=\"flex-1\">\n              <div className=\"inline-block px-4 py-2.5 rounded-2xl bg-gray-100\">\n                <div className=\"flex gap-1\">\n                  <span className=\"w-2 h-2 bg-gray-400 rounded-full animate-bounce\" style={{ animationDelay: '0ms' }}></span>\n                  <span className=\"w-2 h-2 bg-gray-400 rounded-full animate-bounce\" style={{ animationDelay: '150ms' }}></span>\n                  <span className=\"w-2 h-2 bg-gray-400 rounded-full animate-bounce\" style={{ animationDelay: '300ms' }}></span>\n                </div>\n              </div>\n            </div>\n          </div>\n        )}\n        <div ref={endRef} />\n      </div>\n\n      {/* Input Area - ChatGPT style */}\n      <div className=\"border-t border-gray-200 bg-white\">\n        {error && (\n          <div className=\"px-4 py-2 text-sm text-red-600 bg-red-50\">{error}</div>\n        )}\n        <form\n          className=\"px-4 py-3 sticky bottom-0 left-0 right-0 bg-white border-t border-gray-200 z-40 shadow-[0_-6px_18px_rgba(0,0,0,0.08)] flex-shrink-0\"\n          onSubmit={handleSubmit}\n          style={{ paddingBottom: 'calc(env(safe-area-inset-bottom, 0px) + 12px)' }}\n        >\n          <div className=\"w-full md:max-w-3xl mx-auto flex items-center gap-2\">\n            {messages.length > 0 && (\n              <button\n                type=\"button\"\n                onClick={handleClear}\n                disabled={loading}\n                className=\"px-3 h-10 rounded-full text-sm text-gray-600 bg-gray-100 hover:bg-gray-200 transition-colors\"\n                aria-label=\"Clear chat\"\n              >\n                Reset\n              </button>\n            )}\n            {hasSpeechRecognition && (\n              <button\n                type=\"button\"\n                onClick={isListening ? stopListening : startListening}\n                disabled={loading}\n                className={`flex-shrink-0 w-10 h-10 rounded-full flex items-center justify-center transition-colors ${\n                  isListening\n                    ? 'bg-red-500 text-white'\n                    : 'bg-gray-100 text-gray-600 hover:bg-gray-200'\n                } disabled:opacity-50 disabled:cursor-not-allowed`}\n                aria-label={isListening ? 'Stop listening' : 'Start voice input'}\n              >\n                {isListening ? (\n                  <svg className=\"w-5 h-5\" fill=\"currentColor\" viewBox=\"0 0 24 24\">\n                    <path d=\"M12 14c1.66 0 2.99-1.34 2.99-3L15 5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.3-3c0 3-2.54 5.1-5.3 5.1S6.7 14 6.7 11H5c0 3.41 2.72 6.23 6 6.72V21h2v-3.28c3.28-.48 6-3.3 6-6.72h-1.7z\"/>\n                  </svg>\n                ) : (\n                  <svg className=\"w-5 h-5\" fill=\"currentColor\" viewBox=\"0 0 24 24\">\n                    <path d=\"M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z\"/>\n                    <path d=\"M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z\"/>\n                  </svg>\n                )}\n              </button>\n            )}\n            <div className=\"flex-1 relative flex items-center min-w-0\">\n              <textarea\n                ref={textareaRef}\n                value={input}\n                onChange={(event) => {\n                  setInput(event.target.value)\n                  resizeTextarea()\n                }}\n                onKeyDown={onComposerKeyDown}\n                placeholder=\"Ask anything\"\n                rows={1}\n                className=\"w-full rounded-2xl border-0 bg-gray-100 px-4 py-3 pr-14 text-[16px] leading-6 text-gray-900 placeholder-gray-500 focus:outline-none focus:ring-0 resize-none transition-all duration-200 min-h-[52px] max-h-[200px]\"\n              />\n              {false && (\n                <button\n                  type=\"button\"\n                  onClick={(e) => {\n                    e.preventDefault()\n                    e.stopPropagation()\n                    setExpanded((v) => !v)\n                  }}\n                  className=\"absolute right-14 top-2.5 w-5 h-5 flex items-center justify-center text-gray-500 hover:text-gray-700 transition-colors z-10\"\n                  aria-label={expanded ? 'Exit expanded chat view' : 'Expand chat area'}\n                >\n                  {expanded ? (\n                    <ArrowsPointingInIcon className=\"w-4 h-4\" />\n                  ) : (\n                    <ArrowsPointingOutIcon className=\"w-4 h-4\" />\n                  )}\n                </button>\n              )}\n              <button\n                type=\"submit\"\n                disabled={loading || !input.trim() || isListening}\n                className=\"absolute right-2 bottom-2 w-9 h-9 rounded-full bg-gray-900 text-white flex items-center justify-center hover:bg-gray-800 disabled:opacity-50 disabled:cursor-not-allowed transition-colors\"\n                aria-label=\"Send message\"\n              >\n                <svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M12 19l9 2-9-18-9 18 9-2zm0 0v-8\" />\n                </svg>\n              </button>\n            </div>\n          </div>\n        </form>\n      </div>\n    </div>\n  )\n\n  if (expanded && isClient && typeof document !== 'undefined') {\n    return createPortal(chatUI, document.body)\n  }\n\n  return chatUI\n}\n","truncated":false,"size":32660},{"path":"app/insights/issues/[issueSlug]/SectionPrefetcher.tsx","content":"'use client'\n\nimport { useEffect } from 'react'\nimport type { IssueSectionKey } from '@/lib/insights/issue-engine'\n\nexport default function SectionPrefetcher({ issueSlug, sections }: { issueSlug: string; sections: IssueSectionKey[] }) {\n  useEffect(() => {\n    let cancelled = false\n    const controller = new AbortController()\n    const signal = controller.signal\n\n    async function prefetch() {\n      try {\n        const response = await fetch(`/api/insights/issues/${issueSlug}/sections/prefetch`, {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({ sections, mode: 'latest', concurrency: 4 }),\n          signal,\n        })\n        if (!response.ok && !cancelled) {\n          throw new Error('Prefetch batch failed')\n        }\n      } catch {\n        // Fallback: serialize individual POSTs if batch prefetch fails (network or legacy environments).\n        for (const section of sections) {\n          if (cancelled) break\n          try {\n            await fetch(`/api/insights/issues/${issueSlug}/sections/${section}`, {\n              method: 'POST',\n              headers: { 'Content-Type': 'application/json' },\n              body: JSON.stringify({ mode: 'latest' }),\n              signal,\n            }).catch(() => {})\n          } catch {}\n          await new Promise((resolve) => setTimeout(resolve, 200))\n        }\n      }\n      return () => {\n        cancelled = true\n      }\n    }\n\n    prefetch()\n    return () => {\n      cancelled = true\n      controller.abort()\n    }\n  }, [issueSlug, sections])\n\n  return null\n}\n\n","truncated":false,"size":1596},{"path":"app/insights/issues/[issueSlug]/SectionRenderer.tsx","content":"'use client'\n\nimport { useState } from 'react'\nimport Link from 'next/link'\nimport type { IssueSectionKey, IssueSectionResult } from '@/lib/insights/issue-engine'\nimport SectionChat from './SectionChat'\n\ninterface SectionRendererProps {\n  issueSlug: string\n  section: IssueSectionKey\n  initialResult: IssueSectionResult\n}\n\nexport default function SectionRenderer({ issueSlug, section, initialResult }: SectionRendererProps) {\n  const [result, setResult] = useState<IssueSectionResult>(initialResult)\n  // Daily/Weekly/Custom report functionality removed - no longer needed\n\n  return (\n    <div className=\"space-y-8\">\n      <section className=\"bg-white border border-gray-200 rounded-2xl shadow-sm p-6\">\n        <div className=\"flex flex-col md:flex-row md:items-start md:justify-between gap-4\">\n          <div>\n            <h2 className=\"text-lg font-semibold text-gray-900 mb-2 capitalize\">\n              {section === 'overview' ? 'Section summary' : `${section} insights`}\n            </h2>\n            <p className=\"text-sm text-gray-700 leading-relaxed\">{result.summary}</p>\n            <p className=\"text-xs text-gray-500 mt-3\">\n              Mode: {formatReportMode(result.mode)}\n              {result.range?.from || result.range?.to ? ` ‚Ä¢ ${formatRange(result.range)}` : ''}\n            </p>\n            <p className=\"text-xs text-gray-500 mt-1\">\n              Generated {new Date(result.generatedAt).toLocaleString()} ‚Ä¢ Confidence {(result.confidence * 100).toFixed(0)}%\n            </p>\n          </div>\n          {/* Daily/Weekly/Custom report buttons removed per user request - no longer needed */}\n        </div>\n      </section>\n\n      {result.highlights.length > 0 && (\n        <section>\n          <h3 className=\"text-sm font-semibold text-gray-900 uppercase tracking-wide mb-3\">Key signals</h3>\n          <div className=\"grid gap-3 md:grid-cols-2\">\n            {result.highlights.map((highlight, idx) => (\n              <div\n                key={`${highlight.title}-${idx}`}\n                className={`rounded-xl border p-4 ${\n                  highlight.tone === 'warning'\n                    ? 'border-rose-200 bg-rose-50/60 text-rose-700'\n                    : highlight.tone === 'positive'\n                    ? 'border-emerald-200 bg-emerald-50/60 text-emerald-700'\n                    : 'border-gray-200 bg-white text-gray-700'\n                }`}\n              >\n                <h4 className=\"text-sm font-semibold mb-1\">{highlight.title}</h4>\n                <p className=\"text-sm leading-relaxed\">{highlight.detail}</p>\n              </div>\n            ))}\n          </div>\n        </section>\n      )}\n\n      {result.dataPoints.length > 0 && (\n        <section className=\"bg-white border border-gray-200 rounded-2xl shadow-sm p-6\">\n          <h3 className=\"text-sm font-semibold text-gray-900 uppercase tracking-wide mb-3\">Data points</h3>\n          <dl className=\"grid gap-4 md:grid-cols-2\">\n            {result.dataPoints.map((datum, idx) => (\n              <div key={`${datum.label}-${idx}`} className=\"bg-gray-50/70 rounded-lg p-4\">\n                <dt className=\"text-xs uppercase text-gray-500 tracking-wide\">{datum.label}</dt>\n                <dd className=\"text-base font-semibold text-gray-900\">{datum.value}</dd>\n                {datum.context && <p className=\"text-xs text-gray-500 mt-1\">{datum.context}</p>}\n              </div>\n            ))}\n          </dl>\n        </section>\n      )}\n\n      {result.recommendations.length > 0 && (\n        <section className=\"bg-white border border-gray-200 rounded-2xl shadow-sm p-6\">\n          <div className=\"flex items-center justify-between mb-3\">\n            <h3 className=\"text-sm font-semibold text-gray-900 uppercase tracking-wide\">Recommendations</h3>\n            {section === 'labs' && (\n              <Link\n                href=\"/onboarding?step=9\"\n                className=\"px-4 py-2 bg-helfi-green hover:bg-helfi-green/90 text-white rounded-lg text-sm font-medium transition-colors\"\n              >\n                Upload Blood Results\n              </Link>\n            )}\n          </div>\n          <div className=\"space-y-4\">\n            {result.recommendations.map((recommendation, idx) => (\n              <div key={`${recommendation.title}-${idx}`} className=\"border border-gray-200 rounded-xl p-4\">\n                <div className=\"flex items-start justify-between gap-3\">\n                  <div>\n                    <h4 className=\"text-base font-semibold text-gray-900\">{recommendation.title}</h4>\n                    <p className=\"text-sm text-gray-700 mt-1 leading-relaxed\">{recommendation.description}</p>\n                  </div>\n                  <span className={`text-xs font-semibold uppercase tracking-wide ${priorityBadgeColor(recommendation.priority)}`}>\n                    {recommendation.priority === 'now' ? 'High Priority' : recommendation.priority === 'soon' ? 'Next Focus' : 'Monitor'}\n                  </span>\n                </div>\n                <ul className=\"mt-3 space-y-2 text-sm text-gray-700 list-disc list-inside\">\n                  {recommendation.actions.map((action, actionIdx) => (\n                    <li key={actionIdx}>{action}</li>\n                  ))}\n                </ul>\n              </div>\n            ))}\n          </div>\n        </section>\n      )}\n\n      <SectionChat issueSlug={issueSlug} section={section} issueName={result.issue.name} />\n    </div>\n  )\n}\n\nfunction priorityBadgeColor(priority: 'now' | 'soon' | 'monitor') {\n  switch (priority) {\n    case 'now':\n      return 'text-rose-600'\n    case 'soon':\n      return 'text-amber-600'\n    default:\n      return 'text-emerald-600'\n  }\n}\n\nfunction formatReportMode(mode?: IssueSectionResult['mode']) {\n  switch (mode) {\n    case 'daily':\n      return 'Daily snapshot'\n    case 'weekly':\n      return 'Weekly roll-up'\n    case 'custom':\n      return 'Custom range'\n    default:\n      return 'Latest available data'\n  }\n}\n\nfunction formatRange(range?: { from?: string; to?: string }) {\n  if (!range) return ''\n  const fromLabel = range.from ? new Date(range.from).toLocaleDateString() : null\n  const toLabel = range.to ? new Date(range.to).toLocaleDateString() : null\n  if (fromLabel && toLabel) return `${fromLabel} ‚Üí ${toLabel}`\n  if (fromLabel) return `since ${fromLabel}`\n  if (toLabel) return `through ${toLabel}`\n  return ''\n}\n","truncated":false,"size":6335},{"path":"app/insights/issues/[issueSlug]/supplements/avoid/page.tsx","content":"'use client'\n\nimport { useSupplementsContext } from '../SupplementsShell'\n\nexport default function SupplementsAvoidPage() {\n  const { extras } = useSupplementsContext()\n  const items = extras.avoidList ?? []\n\n  if (!items.length) {\n    return (\n      <div className=\"bg-white border border-gray-200 rounded-2xl shadow-sm p-6 text-sm text-gray-700\">\n        No supplements in your current stack are flagging as risky for this issue. Keep logging any changes so we can continue monitoring.\n      </div>\n    )\n  }\n\n  return (\n    <div className=\"space-y-3\">\n      {items.map((supplement, index) => (\n        <div key={`${supplement.name}-${index}`} className=\"border border-rose-200 bg-rose-50/70 rounded-2xl p-5\">\n          <h3 className=\"text-base font-semibold text-rose-700\">{supplement.name}</h3>\n          <p className=\"text-sm text-rose-700 mt-1 leading-relaxed\">{supplement.reason}</p>\n          <dl className=\"mt-4 grid grid-cols-1 sm:grid-cols-2 gap-3 text-sm text-rose-700\">\n            <div>\n              <dt className=\"text-xs uppercase tracking-wide\">Dose</dt>\n              <dd>{supplement.dosage || 'Not logged'}</dd>\n            </div>\n            <div>\n              <dt className=\"text-xs uppercase tracking-wide\">Timing</dt>\n              <dd>\n                {Array.isArray(supplement.timing) && supplement.timing.length\n                  ? supplement.timing.join(', ')\n                  : 'Timing not logged'}\n              </dd>\n            </div>\n          </dl>\n          <p className=\"text-xs text-rose-700 mt-3\">Discuss this with your practitioner before continuing.</p>\n        </div>\n      ))}\n    </div>\n  )\n}\n","truncated":false,"size":1638},{"path":"app/insights/issues/[issueSlug]/supplements/layout.tsx","content":"import { ReactNode } from 'react'\nimport { getServerSession } from 'next-auth'\nimport { redirect } from 'next/navigation'\nimport { authOptions } from '@/lib/auth'\nimport { getCachedIssueSection } from '@/lib/insights/issue-engine'\nimport SupplementsShell from './SupplementsShell'\n\ninterface SupplementsLayoutProps {\n  children: ReactNode\n  params: { issueSlug: string }\n}\n\nexport default async function SupplementsLayout({ children, params }: SupplementsLayoutProps) {\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.id) {\n    redirect('/auth/signin')\n  }\n\n  // Cache-only read - never blocks on LLM during SSR\n  const result = await getCachedIssueSection(session.user.id, params.issueSlug, 'supplements', { mode: 'latest' })\n\n  return (\n    <SupplementsShell initialResult={result} issueSlug={params.issueSlug}>\n      {children}\n    </SupplementsShell>\n  )\n}\n","truncated":false,"size":889},{"path":"app/insights/issues/[issueSlug]/supplements/page.tsx","content":"import { redirect } from 'next/navigation'\n\ninterface SupplementsPageProps {\n  params: { issueSlug: string }\n}\n\nexport default function SupplementsPage({ params }: SupplementsPageProps) {\n  redirect(`/insights/issues/${params.issueSlug}/supplements/working`)\n}\n","truncated":false,"size":261},{"path":"app/insights/issues/[issueSlug]/supplements/suggested/page.tsx","content":"'use client'\n\nimport { useSupplementsContext } from '../SupplementsShell'\n\nexport default function SupplementsSuggestedPage() {\n  const { extras } = useSupplementsContext()\n  const suggestions = extras.suggestedAdditions ?? []\n\n  if (!suggestions.length) {\n    return (\n      <div className=\"bg-white border border-gray-200 rounded-2xl shadow-sm p-6 text-sm text-gray-700\">\n        Great work‚Äîeverything commonly recommended for this issue is already covered. Keep logging dose and timing so Helfi can keep tracking your response.\n      </div>\n    )\n  }\n\n  return (\n    <div className=\"space-y-3\">\n      {suggestions.map((item, index) => (\n        <div key={`${item.title}-${index}`} className=\"border border-gray-200 bg-white rounded-2xl p-5\">\n          <h3 className=\"text-base font-semibold text-gray-900\">{item.title}</h3>\n          <p className=\"text-sm text-gray-700 mt-1 leading-relaxed\">{item.reason}</p>\n          {item.suggestion && (\n            <p className=\"mt-3 text-sm text-helfi-green font-semibold\">\n              Suggested protocol: {item.suggestion}\n            </p>\n          )}\n        </div>\n      ))}\n      <p className=\"text-xs text-gray-500 mt-4\">\n        Always review new supplements with your practitioner before adding them to your routine, then update your Helfi log so the AI can monitor changes.\n      </p>\n    </div>\n  )\n}\n","truncated":false,"size":1358},{"path":"app/insights/issues/[issueSlug]/supplements/SupplementsShell.tsx","content":"'use client'\n\nimport { createContext, ReactNode, useContext, useEffect, useMemo, useState } from 'react'\nimport Link from 'next/link'\nimport { useSelectedLayoutSegments } from 'next/navigation'\nimport SectionChat from '../SectionChat'\nimport type { IssueSectionResult } from '@/lib/insights/issue-engine'\n\n// Accurate progress bar that polls status endpoint\nfunction RegenerationProgressBar({ issueSlug, onComplete }: { issueSlug: string; onComplete: () => void }) {\n  const [progress, setProgress] = useState(0)\n  const [status, setStatus] = useState<'starting' | 'generating' | 'complete'>('starting')\n  const [startTime] = useState(Date.now())\n  \n  useEffect(() => {\n    let pollInterval: NodeJS.Timeout | null = null\n    let timeoutId: NodeJS.Timeout | null = null\n    let isComplete = false\n    \n    const pollStatus = async () => {\n      try {\n        const response = await fetch(`/api/insights/issues/${issueSlug}/sections/supplements`)\n        if (!response.ok) return\n        \n        const data = await response.json()\n        const meta = data._meta || {}\n        const currentStatus = meta.status || 'missing'\n        \n        // Calculate progress based on elapsed time\n        const elapsed = Date.now() - startTime\n        const elapsedSeconds = elapsed / 1000\n        \n        // Realistic estimate: 60-120 seconds for full generation\n        // Progress calculation:\n        // - 0-10s: 0-20% (initialization)\n        // - 10-60s: 20-85% (main generation phase)\n        // - 60-120s: 85-95% (finalization)\n        // - Only reach 100% when status is 'fresh'\n        \n        let timeBasedProgress = 0\n        if (elapsedSeconds < 10) {\n          timeBasedProgress = (elapsedSeconds / 10) * 20 // 0-20%\n        } else if (elapsedSeconds < 60) {\n          timeBasedProgress = 20 + ((elapsedSeconds - 10) / 50) * 65 // 20-85%\n        } else if (elapsedSeconds < 120) {\n          timeBasedProgress = 85 + ((elapsedSeconds - 60) / 60) * 10 // 85-95%\n        } else {\n          timeBasedProgress = 95 // Cap at 95% until actually complete\n        }\n        \n        // Update status\n        if (currentStatus === 'fresh' || currentStatus === 'complete') {\n          setStatus('complete')\n          setProgress(100)\n          isComplete = true\n          if (pollInterval) clearInterval(pollInterval)\n          if (timeoutId) clearTimeout(timeoutId)\n          // Wait a moment for UI to show 100%, then call onComplete\n          setTimeout(() => {\n            onComplete()\n          }, 500)\n          return\n        } else if (currentStatus === 'generating' || currentStatus === 'stale') {\n          setStatus('generating')\n          setProgress(Math.min(timeBasedProgress, 95)) // Cap at 95% until complete\n        } else {\n          setStatus('generating')\n          setProgress(Math.min(timeBasedProgress, 95))\n        }\n      } catch (error) {\n        console.error('Error polling status:', error)\n        // Continue polling even on error\n      }\n    }\n    \n    // Start polling immediately, then every 2 seconds\n    pollStatus()\n    pollInterval = setInterval(pollStatus, 2000)\n    \n    // Safety timeout: if still not complete after 3 minutes, assume complete\n    timeoutId = setTimeout(() => {\n      if (!isComplete) {\n        console.warn('Regeneration timeout - assuming complete')\n        setStatus('complete')\n        setProgress(100)\n        if (pollInterval) clearInterval(pollInterval)\n        setTimeout(() => {\n          onComplete()\n        }, 500)\n      }\n    }, 180000) // 3 minutes max\n    \n    return () => {\n      if (pollInterval) clearInterval(pollInterval)\n      if (timeoutId) clearTimeout(timeoutId)\n    }\n  }, [issueSlug, startTime, onComplete])\n  \n  return (\n    <div className=\"w-full\">\n      <div className=\"w-full bg-gray-200 rounded-full h-2 overflow-hidden mb-2\">\n        <div \n          className=\"bg-helfi-green h-2 rounded-full transition-all duration-500 ease-out\"\n          style={{ width: `${Math.min(progress, 100)}%` }}\n        ></div>\n      </div>\n      <p className=\"text-xs text-gray-600\">\n        {status === 'complete' \n          ? '‚úì Regeneration complete!' \n          : `Regenerating insights... This may take 1-2 minutes.`}\n      </p>\n    </div>\n  )\n}\n\ntype TabKey = 'working' | 'suggested' | 'avoid'\n\ntype SupplementsExtras = {\n  supportiveDetails?: Array<{ name: string; reason: string; dosage: string | null; timing: string[] }>\n  suggestedAdditions?: Array<{ title: string; reason: string; suggestion: string | null; alreadyCovered?: boolean }>\n  avoidList?: Array<{ name: string; reason: string; dosage: string | null; timing: string[] }>\n  missingDose?: string[]\n  missingTiming?: string[]\n  totalLogged?: number\n  source?: 'llm' | 'llm-error'\n}\n\ninterface SupplementsContextValue {\n  result: IssueSectionResult\n  loading: boolean\n  error: string | null\n  handleGenerate: (mode: 'daily' | 'weekly' | 'custom', range?: { from?: string; to?: string }) => Promise<void>\n  issueSlug: string\n  extras: SupplementsExtras\n}\n\nconst SupplementsContext = createContext<SupplementsContextValue | null>(null)\n\nexport function useSupplementsContext() {\n  const ctx = useContext(SupplementsContext)\n  if (!ctx) {\n    throw new Error('useSupplementsContext must be used within SupplementsShell')\n  }\n  return ctx\n}\n\ninterface SupplementsShellProps {\n  children: ReactNode\n  initialResult: IssueSectionResult | null\n  issueSlug: string\n}\n\nexport default function SupplementsShell({ children, initialResult, issueSlug }: SupplementsShellProps) {\n  const [result, setResult] = useState<IssueSectionResult | null>(initialResult)\n  const [loading, setLoading] = useState(!initialResult)\n  const [error, setError] = useState<string | null>(null)\n  const [isRegenerating, setIsRegenerating] = useState(false)\n  const segments = useSelectedLayoutSegments()\n  const activeTab = (segments?.[0] as TabKey | undefined) ?? 'working'\n\n  // Fetch data client-side if SSR returned null (cache miss)\n  useEffect(() => {\n    if (!initialResult) {\n      setLoading(true)\n      const scrollPosition = window.scrollY || document.documentElement.scrollTop\n      // Save scroll position to prevent any scrolling\n      sessionStorage.setItem(`scroll-${issueSlug}-supplements`, scrollPosition.toString())\n      \n      fetch(`/api/insights/issues/${issueSlug}/sections/supplements`)\n        .then((res) => {\n          if (!res.ok) {\n            throw new Error('Failed to load section')\n          }\n          return res.json()\n        })\n        .then((data) => {\n          setResult(data)\n          setLoading(false)\n          // Prevent scroll - restore original position multiple times to ensure it sticks\n          const preventScroll = () => {\n            window.scrollTo(0, scrollPosition)\n            document.documentElement.scrollTop = scrollPosition\n            document.body.scrollTop = scrollPosition\n          }\n          preventScroll()\n          requestAnimationFrame(preventScroll)\n          setTimeout(preventScroll, 0)\n          setTimeout(preventScroll, 50)\n          setTimeout(preventScroll, 100)\n          setTimeout(preventScroll, 200)\n        })\n        .catch((err) => {\n          setError((err as Error).message)\n          setLoading(false)\n          const preventScroll = () => {\n            window.scrollTo(0, scrollPosition)\n            document.documentElement.scrollTop = scrollPosition\n            document.body.scrollTop = scrollPosition\n          }\n          preventScroll()\n          requestAnimationFrame(preventScroll)\n          setTimeout(preventScroll, 0)\n          setTimeout(preventScroll, 50)\n        })\n    }\n  }, [initialResult, issueSlug])\n  \n  // Additional scroll prevention when result loads\n  useEffect(() => {\n    if (result && !loading) {\n      // Prevent any auto-scrolling when result finishes loading\n      const preventScroll = () => {\n        const savedPosition = sessionStorage.getItem(`scroll-${issueSlug}-supplements`)\n        if (savedPosition) {\n          const position = parseInt(savedPosition, 10)\n          window.scrollTo(0, position)\n          document.documentElement.scrollTop = position\n          document.body.scrollTop = position\n        }\n      }\n      preventScroll()\n      requestAnimationFrame(preventScroll)\n      setTimeout(preventScroll, 0)\n      setTimeout(preventScroll, 100)\n      setTimeout(preventScroll, 200)\n    }\n  }, [result, loading, issueSlug])\n\n  async function handleGenerate(mode: 'daily' | 'weekly' | 'custom', range?: { from?: string; to?: string }) {\n    try {\n      setIsRegenerating(true)\n      setError(null)\n      \n      // Start regeneration (non-blocking - returns immediately)\n      const response = await fetch(`/api/insights/issues/${issueSlug}/sections/supplements`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({ mode, range, force: true }),\n      })\n      \n      if (!response.ok) {\n        throw new Error('Unable to start regeneration right now.')\n      }\n      \n      // Note: We don't wait for completion here - the progress bar will poll for status\n      // and call handleRegenerationComplete when done\n    } catch (err) {\n      setError((err as Error).message)\n      setIsRegenerating(false)\n    }\n  }\n  \n  async function handleRegenerationComplete() {\n    try {\n      // Fetch the updated result\n      const response = await fetch(`/api/insights/issues/${issueSlug}/sections/supplements`, {\n        cache: 'no-cache',\n      })\n      if (response.ok) {\n        const data = await response.json()\n        setResult(data)\n      }\n    } catch (err) {\n      console.error('Error fetching regenerated result:', err)\n    } finally {\n      setIsRegenerating(false)\n    }\n  }\n\n  const extras = useMemo<SupplementsExtras>(() => {\n    if (!result) {\n      return {\n        supportiveDetails: [],\n        suggestedAdditions: [],\n        avoidList: [],\n        missingDose: [],\n        missingTiming: [],\n        totalLogged: 0,\n      }\n    }\n    const raw = (result.extras ?? {}) as SupplementsExtras\n    return {\n      supportiveDetails: raw.supportiveDetails ?? [],\n      suggestedAdditions: raw.suggestedAdditions ?? [],\n      avoidList: raw.avoidList ?? [],\n      missingDose: raw.missingDose ?? [],\n      missingTiming: raw.missingTiming ?? [],\n      totalLogged: raw.totalLogged ?? 0,\n    }\n  }, [result])\n\n  const tabs: Array<{ key: TabKey; label: string; href: string }>\n    = [\n      { key: 'working', label: \"What's Working\", href: `/insights/issues/${issueSlug}/supplements/working` },\n      { key: 'suggested', label: 'Suggested Supplements', href: `/insights/issues/${issueSlug}/supplements/suggested` },\n      { key: 'avoid', label: 'Supplements to Avoid', href: `/insights/issues/${issueSlug}/supplements/avoid` },\n    ]\n\n  const contextValue = useMemo<SupplementsContextValue>(() => {\n    // Create minimal dummy result when null to satisfy context type\n    const dummyResult: IssueSectionResult = result || {\n      issue: { id: '', slug: issueSlug, name: '', polarity: 'negative', severityLabel: '', severityScore: null, currentRating: null, ratingScaleMax: null, trend: 'stable', trendDelta: null, lastUpdated: null, highlight: '', blockers: [], status: 'monitor' },\n      section: 'supplements',\n      generatedAt: new Date().toISOString(),\n      confidence: 0,\n      summary: '',\n      highlights: [],\n      dataPoints: [],\n      recommendations: [],\n      mode: 'latest',\n      extras: {},\n    }\n    return {\n      result: dummyResult,\n      loading,\n      error,\n      handleGenerate,\n      issueSlug,\n      extras,\n    }\n  }, [result, loading, error, issueSlug, extras])\n\n  if (!result && loading) {\n    return (\n      <SupplementsContext.Provider value={contextValue}>\n        <div className=\"space-y-6\">\n          <section className=\"bg-white border border-gray-200 rounded-2xl shadow-sm p-6\">\n            <div className=\"flex flex-col md:flex-row md:items-start md:justify-between gap-4\">\n              <div className=\"flex-1\">\n                <h2 className=\"text-lg font-semibold text-gray-900 mb-2\">Supplements report</h2>\n                <p className=\"text-sm text-gray-700 leading-relaxed mb-3\">Preparing initial guidance...</p>\n                <div className=\"w-full bg-gray-200 rounded-full h-2 overflow-hidden\">\n                  <div className=\"bg-helfi-green h-2 rounded-full animate-pulse\" style={{ width: '60%' }}></div>\n                </div>\n              </div>\n            </div>\n          </section>\n          <nav className=\"space-y-2\">\n            {tabs.map((tab) => (\n              <Link\n                key={tab.key}\n                href={tab.href}\n                className={`block rounded-xl border px-4 py-3 text-left text-sm font-semibold transition-colors ${\n                  tab.key === activeTab\n                    ? 'border-helfi-green bg-helfi-green text-white shadow-sm'\n                    : 'border-gray-200 bg-white text-gray-700 hover:border-helfi-green/70 hover:bg-gray-50'\n                }`}\n              >\n                {tab.label}\n              </Link>\n            ))}\n          </nav>\n          <div>{children}</div>\n        </div>\n      </SupplementsContext.Provider>\n    )\n  }\n\n  if (!result) {\n    return (\n      <SupplementsContext.Provider value={contextValue}>\n        <div className=\"space-y-6\">\n          <section className=\"bg-white border border-gray-200 rounded-2xl shadow-sm p-6\">\n            <div className=\"flex flex-col md:flex-row md:items-start md:justify-between gap-4\">\n              <div>\n                <h2 className=\"text-lg font-semibold text-gray-900 mb-2\">Supplements report</h2>\n                <p className=\"text-sm text-red-600\">{error || 'Failed to load section data'}</p>\n              </div>\n            </div>\n          </section>\n          <nav className=\"space-y-2\">\n            {tabs.map((tab) => (\n              <Link\n                key={tab.key}\n                href={tab.href}\n                className={`block rounded-xl border px-4 py-3 text-left text-sm font-semibold transition-colors ${\n                  tab.key === activeTab\n                    ? 'border-helfi-green bg-helfi-green text-white shadow-sm'\n                    : 'border-gray-200 bg-white text-gray-700 hover:border-helfi-green/70 hover:bg-gray-50'\n                }`}\n              >\n                {tab.label}\n              </Link>\n            ))}\n          </nav>\n          <div>{children}</div>\n        </div>\n      </SupplementsContext.Provider>\n    )\n  }\n\n  return (\n    <SupplementsContext.Provider value={contextValue}>\n      <div className=\"space-y-6\">\n        <section className=\"bg-white border border-gray-200 rounded-2xl shadow-sm p-6\">\n          <div className=\"flex flex-col md:flex-row md:items-start md:justify-between gap-4\">\n            <div className=\"flex-1\">\n              <h2 className=\"text-lg font-semibold text-gray-900 mb-2\">Supplements report</h2>\n              <p className=\"text-sm text-gray-700 leading-relaxed\">{result.summary}</p>\n              <p className=\"text-xs text-gray-500 mt-3\">\n                Generated {new Date(result.generatedAt).toLocaleString()} ‚Ä¢ Confidence {(result.confidence * 100).toFixed(0)}%\n              </p>\n            </div>\n          </div>\n        </section>\n\n        <nav className=\"space-y-2\">\n          {tabs.map((tab) => (\n            <Link\n              key={tab.key}\n              href={tab.href}\n              className={`block rounded-xl border px-4 py-3 text-left text-sm font-semibold transition-colors ${\n                tab.key === activeTab\n                  ? 'border-helfi-green bg-helfi-green text-white shadow-sm'\n                  : 'border-gray-200 bg-white text-gray-700 hover:border-helfi-green/70 hover:bg-gray-50'\n              }`}\n            >\n              {tab.label}\n            </Link>\n          ))}\n        </nav>\n\n        <div>{children}</div>\n\n        <SectionChat issueSlug={issueSlug} section=\"supplements\" issueName={result?.issue?.name ?? ''} />\n      </div>\n    </SupplementsContext.Provider>\n  )\n}\n","truncated":false,"size":16002},{"path":"app/insights/issues/[issueSlug]/supplements/working/page.tsx","content":"'use client'\n\nimport { useSupplementsContext } from '../SupplementsShell'\n\nexport default function SupplementsWorkingPage() {\n  const { extras } = useSupplementsContext()\n  const items = extras.supportiveDetails ?? []\n\n  if (!items.length) {\n    return (\n      <div className=\"bg-white border border-gray-200 rounded-2xl shadow-sm p-6 text-sm text-gray-700\">\n        You're currently not taking any supplements that could help with this health issue. Please go back and click on the ‚ÄúSuggested Supplements‚Äù tab on the previous page.\n      </div>\n    )\n  }\n\n  return (\n    <div className=\"space-y-3\">\n      {items.map((supplement, index) => (\n        <div key={`${supplement.name}-${index}`} className=\"border border-emerald-200 bg-emerald-50/70 rounded-2xl p-5\">\n          <h3 className=\"text-base font-semibold text-gray-900\">{supplement.name}</h3>\n          <p className=\"text-sm text-emerald-800 mt-1 leading-relaxed\">{supplement.reason}</p>\n          <dl className=\"mt-4 grid grid-cols-1 sm:grid-cols-2 gap-3 text-sm text-gray-700\">\n            <div>\n              <dt className=\"text-xs uppercase text-gray-500 tracking-wide\">Dose</dt>\n              <dd>{supplement.dosage || 'Not logged yet'}</dd>\n            </div>\n            <div>\n              <dt className=\"text-xs uppercase text-gray-500 tracking-wide\">Timing</dt>\n              <dd>\n                {Array.isArray(supplement.timing) && supplement.timing.length\n                  ? supplement.timing.join(', ')\n                  : 'Add timing so we can flag spacing tips.'}\n              </dd>\n            </div>\n          </dl>\n        </div>\n      ))}\n    </div>\n  )\n}\n","truncated":false,"size":1639},{"path":"app/insights/loading.tsx","content":"export default function InsightsLoading() {\n  return (\n    <div className=\"min-h-screen bg-gray-50\">\n      <header className=\"bg-white border-b border-gray-200 px-4 py-6 animate-pulse\">\n        <div className=\"max-w-7xl mx-auto space-y-4\">\n          <div className=\"h-3 w-24 rounded-full bg-gray-200\" />\n          <div className=\"flex flex-col gap-3 md:flex-row md:items-center md:justify-between\">\n            <div className=\"space-y-3\">\n              <div className=\"h-7 w-52 rounded-full bg-gray-200\" />\n              <div className=\"h-4 w-72 rounded-full bg-gray-200\" />\n            </div>\n            <div className=\"h-3 w-40 rounded-full bg-gray-200\" />\n          </div>\n        </div>\n      </header>\n      <main className=\"max-w-6xl mx-auto px-4 py-10 space-y-6\">\n        {[0, 1, 2].map((row) => (\n          <section key={row} className=\"space-y-3\">\n            <div className=\"h-4 w-40 rounded-full bg-gray-200\" />\n            <div className=\"bg-white border border-gray-200 rounded-2xl p-5 space-y-4 animate-pulse\">\n              <div className=\"h-4 w-full rounded-full bg-gray-200\" />\n              <div className=\"h-4 w-5/6 rounded-full bg-gray-200\" />\n              <div className=\"h-4 w-2/3 rounded-full bg-gray-200\" />\n            </div>\n          </section>\n        ))}\n      </main>\n    </div>\n  )\n}\n","truncated":false,"size":1317},{"path":"app/insights/nutrition/page.tsx","content":"'use client'\n\nimport React, { useEffect, useState } from 'react'\nimport Link from 'next/link'\n\nexport default function NutritionInsights() {\n  const [items, setItems] = useState<any[]>([])\n  const [loading, setLoading] = useState<boolean>(true)\n\n  async function load() {\n    try {\n      setLoading(true)\n      const issuesRes = await fetch('/api/checkins/issues', { cache: 'no-cache' })\n      const issuesData = await issuesRes.json().catch(()=>({}))\n      const issueNames: string[] = Array.isArray(issuesData?.issues) ? issuesData.issues.map((i:any)=>i.name).filter(Boolean) : []\n      if (issueNames.length) {\n        setItems(issueNames.map((g) => ({ id: `nutrition:${g}`, title: g, summary: 'Open nutrition details', tags: ['nutrition'] })))\n      } else {\n        const ud = await fetch('/api/user-data', { cache: 'no-cache' }).then(r=>r.json())\n        const goals: string[] = Array.isArray(ud?.data?.goals) ? ud.data.goals : []\n        setItems(goals.map((g) => ({ id: `nutrition:${g}`, title: g, summary: 'Open nutrition details', tags: ['nutrition'] })))\n      }\n    } catch { setItems([]) }\n    finally { setLoading(false) }\n  }\n  useEffect(() => { load() }, [])\n\n  return (\n    <div className=\"min-h-screen bg-gray-50\">\n      <div className=\"bg-white border-b border-gray-200 px-4 py-4\">\n        <div className=\"max-w-4xl mx-auto flex items-center gap-3\">\n          <Link href=\"/insights\" className=\"text-helfi-green\">‚Äπ Back</Link>\n          <h1 className=\"text-lg font-semibold\">Nutrition</h1>\n        </div>\n      </div>\n      <div className=\"max-w-4xl mx-auto px-4 py-6 space-y-4\">\n        <div className=\"flex items-center justify-between mb-2\">\n          <Link href=\"/insights\" className=\"text-helfi-green text-lg\">‚Üê Back</Link>\n          <button onClick={async()=>{ fetch('/api/insights/generate?preview=1', { method: 'POST' }).catch(()=>{}); await load() }} className=\"px-3 py-2 bg-helfi-green text-white rounded-md text-sm\">Refresh</button>\n        </div>\n        {loading && (\n          <div className=\"flex items-center gap-2 text-gray-500 text-sm\">\n            <span className=\"h-4 w-4 border-2 border-gray-300 border-t-transparent rounded-full animate-spin\"></span>\n            Loading‚Ä¶\n          </div>\n        )}\n        {!loading && items.map((it) => (\n          <Link href={String(it.id).startsWith('nutrition:') ? `/insights/issue/${encodeURIComponent(it.title)}?tab=nutrition` : `/insights/${encodeURIComponent(it.id)}`} key={it.id} className=\"bg-white border border-gray-200 rounded-lg p-4 block\">\n            <div className=\"font-semibold text-gray-900 mb-1\">{it.title}</div>\n            <div className=\"text-sm text-gray-700\">{it.summary}</div>\n          </Link>\n        ))}\n        {!loading && items.length === 0 && (\n          <div className=\"text-sm text-gray-600\">No goals found in your profile yet.</div>\n        )}\n      </div>\n    </div>\n  )\n}\n\n\n","truncated":false,"size":2894},{"path":"app/insights/page.tsx","content":"import { getServerSession } from 'next-auth'\nimport Link from 'next/link'\nimport { redirect } from 'next/navigation'\nimport { authOptions } from '@/lib/auth'\nimport { getIssueLandingPayload } from '@/lib/insights/issue-engine'\nimport InsightsLandingClient from './InsightLandingClient'\n\nexport default async function InsightsPage() {\n  const session = await getServerSession(authOptions)\n  if (!session?.user?.id) {\n    redirect('/auth/signin')\n  }\n\n  const payload = await getIssueLandingPayload(session.user.id)\n\n  // ‚ö†Ô∏è HEALTH SETUP GUARD RAIL\n  // If Health Setup is not complete, Insights MUST remain fully locked.\n  // This gate is the single source of truth for /insights access and must\n  // mirror the onboardingComplete definition in HEALTH_SETUP_PROTECTION.md.\n  // Do NOT bypass this check or show \"fake\" personalised insights to users\n  // with incomplete Health Setup.\n  // If Health Setup is not complete, completely gate the Insights section and\n  // guide the user back to onboarding instead of showing empty insights.\n  if (!payload.onboardingComplete) {\n    return (\n      <div className=\"min-h-screen flex items-center justify-center bg-gradient-to-b from-white to-helfi-green-light/10 dark:from-gray-900 dark:to-gray-900 px-4\">\n        <div className=\"max-w-md w-full bg-white dark:bg-gray-800 rounded-2xl shadow-xl p-6 text-center\">\n          <div className=\"mx-auto mb-4 w-14 h-14 rounded-full bg-amber-100 flex items-center justify-center\">\n            <span className=\"text-2xl\">üìù</span>\n          </div>\n          <h1 className=\"text-xl font-semibold text-gray-900 mb-2\">\n            Finish your Health Setup to unlock Insights\n          </h1>\n          <p className=\"text-sm text-gray-600 mb-5\">\n            Helfi needs your core health information to generate accurate insights. Complete your\n            Health Setup and we&apos;ll unlock this section for you.\n          </p>\n          <div className=\"space-y-3\">\n            <Link\n              href=\"/onboarding?step=1\"\n              className=\"block w-full bg-helfi-green text-white text-sm font-medium py-2.5 rounded-lg hover:bg-helfi-green-dark transition-colors\"\n            >\n              Complete Health Setup\n            </Link>\n            <Link\n              href=\"/dashboard\"\n              className=\"block w-full bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-100 text-sm font-medium py-2.5 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors\"\n            >\n              Back to Dashboard\n            </Link>\n          </div>\n        </div>\n      </div>\n    )\n  }\n\n  return (\n    <InsightsLandingClient\n      sessionUser={{\n        name: session.user.name ?? null,\n        email: session.user.email ?? null,\n        image: session.user.image ?? null,\n      }}\n      issues={payload.issues}\n      generatedAt={payload.generatedAt}\n      onboardingComplete={payload.onboardingComplete}\n      dataNeeds={payload.dataNeeds}\n    />\n  )\n}\n","truncated":false,"size":2963},{"path":"app/insights/safety/page.tsx","content":"'use client'\n\nimport React, { useEffect, useState } from 'react'\nimport Link from 'next/link'\n\nexport default function SafetyInsights() {\n  const [items, setItems] = useState<any[]>([])\n  const [question, setQuestion] = useState('')\n  const [answer, setAnswer] = useState<string>('')\n  const [asking, setAsking] = useState(false)\n\n  async function load() {\n    // Prefer real analyzer results; fall back to preview list\n    try {\n      const res = await fetch('/api/insights/safety/analyze', { cache: 'no-cache' })\n      const data = await res.json().catch(() => ({}))\n      if (Array.isArray(data?.items) && data.items.length) {\n        setItems(data.items)\n        return\n      }\n    } catch {}\n    const res = await fetch('/api/insights/list?preview=1', { cache: 'no-cache' })\n    const data = await res.json().catch(() => ({}))\n    const all: any[] = data?.items || []\n    const by = all.filter((it: any) => (it.tags || []).includes('safety') || (it.tags || []).includes('medication'))\n    setItems(by.length ? by : all)\n  }\n  useEffect(() => { load() }, [])\n\n  return (\n    <div className=\"min-h-screen bg-gray-50\">\n      <div className=\"bg-white border-b border-gray-200 px-4 py-4\">\n        <div className=\"max-w-4xl mx-auto flex items-center gap-3\">\n          <Link href=\"/insights\" className=\"text-helfi-green\">‚Äπ Back</Link>\n          <h1 className=\"text-lg font-semibold\">Safety</h1>\n        </div>\n      </div>\n      <div className=\"max-w-4xl mx-auto px-4 py-6 space-y-4\">\n        <div className=\"flex justify-end mb-2\">\n          <button onClick={async()=>{ await load() }} className=\"px-3 py-2 bg-helfi-green text-white rounded-md text-sm\">Refresh</button>\n        </div>\n        {items.map((it) => (\n          <div key={it.id} className=\"bg-white border border-gray-200 rounded-lg p-4\">\n            <div className=\"font-semibold text-gray-900 mb-1\">{it.title}</div>\n            <div className=\"text-sm text-gray-700 mb-2\">{it.summary}</div>\n            {it.reason && (<div className=\"text-xs text-gray-500 mb-2\">Why: {it.reason}</div>)}\n            {Array.isArray(it.actions) && it.actions.length > 0 && (\n              <ul className=\"list-disc pl-5 text-sm text-gray-800 space-y-1\">\n                {it.actions.map((a: string, idx: number) => (<li key={idx}>{a}</li>))}\n              </ul>\n            )}\n          </div>\n        ))}\n        {items.length === 0 && (\n          <div className=\"text-sm text-gray-600\">No safety insights yet.</div>\n        )}\n\n        {/* Ask AI about Safety */}\n        <div className=\"bg-white border border-gray-200 rounded-lg p-4\">\n          <div className=\"font-semibold text-gray-900 mb-2\">Ask AI about Safety</div>\n          <div className=\"text-xs text-gray-500 mb-3\">We‚Äôll use only your relevant recent data (medications, supplements, recent ratings) to answer.</div>\n          <div className=\"flex gap-2\">\n            <input\n              value={question}\n              onChange={(e)=>setQuestion(e.target.value)}\n              placeholder=\"e.g., How should I time my supplements for best absorption?\"\n              className=\"flex-1 border border-gray-300 rounded-md px-3 py-2 text-sm\"\n            />\n            <button\n              onClick={async()=>{\n                if (!question.trim()) return\n                setAsking(true)\n                try {\n                  const res = await fetch('/api/insights/ask', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ section: 'safety', question }) })\n                  const data = await res.json().catch(()=>({}))\n                  setAnswer(data?.answer || 'No answer available right now.')\n                } finally { setAsking(false) }\n              }}\n              disabled={asking || !question.trim()}\n              className=\"px-3 py-2 bg-blue-600 text-white rounded-md text-sm disabled:opacity-50\"\n            >{asking ? 'Thinking‚Ä¶' : 'Ask'}</button>\n          </div>\n          {answer && (\n            <div className=\"mt-3 text-sm text-gray-800 whitespace-pre-wrap\">{answer}</div>\n          )}\n        </div>\n      </div>\n    </div>\n  )\n}\n\n\n","truncated":false,"size":4103},{"path":"app/insights/sleep/page.tsx","content":"'use client'\n\nimport React, { useEffect, useState } from 'react'\nimport Link from 'next/link'\n\nexport default function SleepInsights() {\n  const [items, setItems] = useState<any[]>([])\n\n  async function load() {\n    const res = await fetch('/api/insights/list?preview=1', { cache: 'no-cache' })\n    const data = await res.json().catch(() => ({}))\n    const all: any[] = data?.items || []\n    const by = all.filter((it: any) => (it.tags || []).includes('sleep'))\n    setItems(by.length ? by : all)\n  }\n  useEffect(() => { load() }, [])\n\n  return (\n    <div className=\"min-h-screen bg-gray-50\">\n      <div className=\"bg-white border-b border-gray-200 px-4 py-4\">\n        <div className=\"max-w-4xl mx-auto flex items-center gap-3\">\n          <Link href=\"/insights\" className=\"text-helfi-green\">‚Äπ Back</Link>\n          <h1 className=\"text-lg font-semibold\">Sleep</h1>\n        </div>\n      </div>\n      <div className=\"max-w-4xl mx-auto px-4 py-6 space-y-4\">\n        <div className=\"flex justify-end mb-2\">\n          <button onClick={async()=>{ fetch('/api/insights/generate?preview=1', { method: 'POST' }).catch(()=>{}); await load() }} className=\"px-3 py-2 bg-helfi-green text-white rounded-md text-sm\">Refresh</button>\n        </div>\n        {items.map((it) => (\n          <Link href={`/insights/${encodeURIComponent(it.id)}`} key={it.id} className=\"bg-white border border-gray-200 rounded-lg p-4 block\">\n            <div className=\"font-semibold text-gray-900 mb-1\">{it.title}</div>\n            <div className=\"text-sm text-gray-700\">{it.summary}</div>\n          </Link>\n        ))}\n        {items.length === 0 && (\n          <div className=\"text-sm text-gray-600\">No sleep insights yet.</div>\n        )}\n      </div>\n    </div>\n  )\n}\n\n\n","truncated":false,"size":1738},{"path":"app/insights/supplements/[name]/page.tsx","content":"'use client'\n\nimport React, { useEffect, useState } from 'react'\nimport Link from 'next/link'\nimport { useParams } from 'next/navigation'\n\nexport default function SupplementDetail() {\n  const { name } = useParams() as { name?: string }\n  const [data, setData] = useState<any | null>(null)\n  const [loading, setLoading] = useState<boolean>(true)\n\n  useEffect(() => {\n    async function load() {\n      try {\n        setLoading(true)\n        const ud = await fetch('/api/user-data', { cache: 'no-cache' }).then(r=>r.json()).catch(()=>({}))\n        const list = Array.isArray(ud?.data?.supplements) ? ud.data.supplements : []\n        const found = list.find((s: any) => (s.name || '').toLowerCase() === String(name||'').toLowerCase())\n        const detail = await fetch(`/api/insights/detail?supplement=${encodeURIComponent(String(name||''))}`, { cache: 'no-cache' }).then(r=>r.json()).catch(()=>({}))\n        const d = detail?.data || {}\n        setData({ ...found, name: found?.name || decodeURIComponent(String(name||'')), what: d.what, reason: d.reason, actions: d.actions, timing: d.timing, safety: d.safety })\n      } finally { setLoading(false) }\n    }\n    load()\n  }, [name])\n\n  if (!data) return null\n\n  return (\n    <div className=\"min-h-screen bg-gray-50\">\n      <div className=\"bg-white border-b border-gray-200 px-4 py-4\">\n        <div className=\"max-w-4xl mx-auto flex items-center gap-3\">\n          <Link href=\"/insights/supplements\" className=\"text-helfi-green\">‚Üê Back</Link>\n          <h1 className=\"text-lg font-semibold\">{data.name}</h1>\n        </div>\n      </div>\n      <div className=\"max-w-4xl mx-auto px-4 py-6 space-y-4\">\n        {loading && (\n          <div className=\"flex items-center gap-2 text-gray-500 text-sm\">\n            <span className=\"h-4 w-4 border-2 border-gray-300 border-t-transparent rounded-full animate-spin\"></span>\n            Loading‚Ä¶\n          </div>\n        )}\n        {!loading && (\n          <>\n            <div className=\"bg-white border border-gray-200 rounded-lg p-4\">\n              <div className=\"text-sm text-gray-700\">{data.what || 'Recommendations for this supplement.'}</div>\n              {data.reason && <div className=\"text-xs text-gray-500 mt-2\">Why: {data.reason}</div>}\n            </div>\n            <div className=\"bg-white border border-gray-200 rounded-lg p-4\">\n              <div className=\"text-sm text-gray-700\">Timing: {Array.isArray(data.timing) ? data.timing.join(', ') : (data.timing || 'not set')}</div>\n            </div>\n            <div className=\"bg-white border border-gray-200 rounded-lg p-4\">\n              <div className=\"font-semibold mb-2\">Actions</div>\n              <ul className=\"list-disc pl-5 space-y-2 text-sm text-gray-800\">\n                {Array.isArray(data.actions) && data.actions.length ? data.actions.map((a:string,i:number)=>(<li key={i}>{a}</li>)) : <li>No actions yet.</li>}\n              </ul>\n              {data.safety && <div className=\"text-xs text-gray-500 mt-2\">Safety: {data.safety}</div>}\n            </div>\n          </>\n        )}\n      </div>\n    </div>\n  )\n}\n\n\n","truncated":false,"size":3079},{"path":"app/insights/supplements/page.tsx","content":"'use client'\n\nimport React, { useEffect, useState } from 'react'\nimport Link from 'next/link'\n\nexport default function SupplementsInsights() {\n  const [supps, setSupps] = useState<any[]>([])\n  const [loading, setLoading] = useState<boolean>(true)\n\n  useEffect(() => {\n    async function load() {\n      try {\n        setLoading(true)\n        const res = await fetch('/api/user-data', { cache: 'no-cache' })\n        const data = await res.json().catch(() => ({}))\n        const s = Array.isArray(data?.data?.supplements) ? data.data.supplements : []\n        setSupps(s)\n      } finally { setLoading(false) }\n    }\n    load()\n  }, [])\n\n  return (\n    <div className=\"min-h-screen bg-gray-50\">\n      <div className=\"bg-white border-b border-gray-200 px-4 py-4\">\n        <div className=\"max-w-4xl mx-auto flex items-center gap-3\">\n          <Link href=\"/insights\" className=\"text-helfi-green\">‚Äπ Back</Link>\n          <h1 className=\"text-lg font-semibold\">Supplements</h1>\n        </div>\n      </div>\n      <div className=\"max-w-4xl mx-auto px-4 py-6 space-y-4\">\n        <div className=\"flex items-center justify-between mb-2\">\n          <Link href=\"/insights\" className=\"text-helfi-green text-lg\">‚Üê Back</Link>\n        </div>\n        {loading && (\n          <div className=\"flex items-center gap-2 text-gray-500 text-sm\">\n            <span className=\"h-4 w-4 border-2 border-gray-300 border-t-transparent rounded-full animate-spin\"></span>\n            Loading‚Ä¶\n          </div>\n        )}\n        {!loading && supps.map((s, idx) => (\n          <Link href={`/insights/supplements/${encodeURIComponent(s.name || 'supp_'+idx)}`} key={idx} className=\"bg-white border border-gray-200 rounded-lg p-4 block\">\n            <div className=\"font-semibold text-gray-900 mb-1\">{s.name || 'Supplement'}</div>\n            <div className=\"text-sm text-gray-700\">{Array.isArray(s.timing) ? s.timing.join(', ') : (s.timing || 'timing not set')}</div>\n          </Link>\n        ))}\n        {!loading && supps.length === 0 && (\n          <div className=\"text-sm text-gray-600\">No supplements saved yet.</div>\n        )}\n      </div>\n    </div>\n  )\n}\n\n\n","truncated":false,"size":2133},{"path":"app/lab-reports/page.tsx","content":"'use client';\n\nimport React from 'react';\nimport LabReportUpload from '@/components/reports/LabReportUpload';\n\nexport default function LabReportsPage() {\n  const handleUploadComplete = (reportId: string) => {\n    console.log('Report uploaded:', reportId);\n    // Could redirect to report details page or show success message\n  };\n\n  return (\n    <div className=\"min-h-screen bg-gray-50 py-8\">\n      <div className=\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8\">\n        <LabReportUpload onUploadComplete={handleUploadComplete} />\n      </div>\n    </div>\n  );\n}\n\n","truncated":false,"size":556},{"path":"app/layout.tsx","content":"import './globals.css'\nimport { Inter } from 'next/font/google'\nimport { AuthProvider } from '@/components/providers/AuthProvider'\nimport { UserDataProvider } from '@/components/providers/UserDataProvider'\nimport LayoutWrapper from '@/components/LayoutWrapper'\nimport type { Metadata } from 'next'\n\nconst inter = Inter({ \n  subsets: ['latin'],\n  weight: ['400', '500', '600', '700'],\n  variable: '--font-inter',\n})\n\nexport const metadata: Metadata = {\n  title: 'Helfi - Your AI Health Intelligence Platform',\n  description: 'Transform your health with personalized AI insights, comprehensive tracking, and intelligent recommendations.',\n  viewport: 'width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no',\n  manifest: '/manifest.json',\n  icons: {\n    icon: [\n      {\n        url: '/favicon.ico',\n        sizes: '32x32',\n        type: 'image/x-icon',\n      },\n      {\n        url: '/icons/app-192.png',\n        sizes: '192x192',\n        type: 'image/png',\n      },\n      {\n        url: '/icons/app-512.png',\n        sizes: '512x512',\n        type: 'image/png',\n      },\n    ],\n    apple: [\n      { url: '/apple-touch-icon.png', sizes: '180x180' },\n    ],\n  },\n}\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <head>\n        <meta name=\"apple-mobile-web-app-capable\" content=\"yes\" />\n        <meta name=\"apple-mobile-web-app-status-bar-style\" content=\"default\" />\n        <meta name=\"apple-mobile-web-app-title\" content=\"Helfi\" />\n        <meta name=\"mobile-web-app-capable\" content=\"yes\" />\n        <link\n          rel=\"stylesheet\"\n          href=\"https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:wght,FILL,GRAD@500,0,0\"\n        />\n        <script\n          dangerouslySetInnerHTML={{\n            __html: `\n              // Dark mode initialization - runs before React hydration to prevent flash.\n              // IMPORTANT: Dark mode is only allowed inside the signed-in app.\n              // Public pages (like / and /auth/*) should always render in light mode.\n              (function() {\n                try {\n                  var path = (window && window.location && window.location.pathname) ? window.location.pathname : '';\n                  var isPublic =\n                    path === '/' ||\n                    path === '/healthapp' ||\n                    path === '/privacy' ||\n                    path === '/terms' ||\n                    path === '/help' ||\n                    path === '/faq' ||\n                    path.indexOf('/auth/') === 0 ||\n                    path.indexOf('/staging-signin') === 0;\n\n                  if (isPublic) {\n                    document.documentElement.classList.remove('dark');\n                    return;\n                  }\n\n                  var darkMode = localStorage.getItem('darkMode') === 'true';\n                  document.documentElement.classList.toggle('dark', darkMode);\n                } catch (e) {\n                  // Ignore localStorage/cookie errors\n                }\n              })();\n            `,\n          }}\n        />\n      </head>\n      <body className={`${inter.variable} ${inter.className}`}>\n        <AuthProvider>\n          <UserDataProvider>\n            <LayoutWrapper>\n              {children}\n            </LayoutWrapper>\n          </UserDataProvider>\n        </AuthProvider>\n        <script\n          dangerouslySetInnerHTML={{\n            __html: `\n              // Register service worker for push notifications\n              (function(){\n                try {\n                  if ('serviceWorker' in navigator) {\n                    navigator.serviceWorker.register('/sw.js').catch(function(err) {\n                      console.log('Service worker registration failed:', err);\n                    });\n                  }\n                } catch (e) {\n                  console.log('Service worker not supported:', e);\n                }\n              })();\n\n              // Global dark mode toggle function\n              window.toggleDarkMode = function(enabled) {\n                try {\n                  localStorage.setItem('darkMode', enabled.toString());\n                  document.documentElement.classList.toggle('dark', enabled);\n                  \n                  // Dispatch custom event to sync all pages\n                  window.dispatchEvent(new CustomEvent('darkModeChanged', { detail: enabled }));\n                } catch (e) {\n                  console.error('Dark mode error:', e);\n                }\n              };\n              \n              // Listen for dark mode changes\n              window.addEventListener('darkModeChanged', function(e) {\n                document.documentElement.classList.toggle('dark', e.detail);\n              });\n            `,\n          }}\n        />\n      </body>\n    </html>\n  )\n} \n","truncated":false,"size":4836},{"path":"app/main-admin/head.tsx","content":"export default function MainAdminHead() {\n  return (\n    <>\n      <link rel=\"manifest\" href=\"/main-admin/manifest.json\" />\n      <link rel=\"apple-touch-icon\" href=\"/icons/admin-192.png\" />\n    </>\n  )\n}\n\n","truncated":false,"size":204},{"path":"app/main-admin/layout.tsx","content":"import type { Metadata } from 'next'\nimport type { ReactNode } from 'react'\n\nexport const metadata: Metadata = {\n  title: 'Helfi Admin Panel',\n  manifest: '/main-admin/manifest.json',\n}\n\nexport default function MainAdminLayout({\n  children,\n}: {\n  children: ReactNode\n}) {\n  return <>{children}</>\n}\n\n","truncated":false,"size":301},{"path":"app/main-admin/page.tsx","content":"export { default } from '../admin-panel/page'\n\n","truncated":false,"size":47},{"path":"app/main-admin/qr-login/page.tsx","content":"export { default } from '../../admin-panel/qr-login/page'\n\n","truncated":false,"size":59},{"path":"app/main-admin/tickets/[id]/page.tsx","content":"export { default } from '../../../admin-panel/tickets/[id]/page'\n\n","truncated":false,"size":66},{"path":"app/medical-images/history/page.tsx","content":"'use client'\n\nimport { useCallback, useEffect, useState } from 'react'\nimport Link from 'next/link'\nimport Image from 'next/image'\nimport { usePathname } from 'next/navigation'\nimport PageHeader from '@/components/PageHeader'\n\ntype MedicalAnalysisResult = {\n  summary?: string | null\n  possibleCauses?: Array<{ name: string; whyLikely?: string; confidence?: string }>\n  redFlags?: string[]\n  nextSteps?: string[]\n  analysisText?: string | null\n}\n\ntype MedicalHistoryItem = {\n  id: string\n  summary?: string | null\n  analysisText?: string | null\n  analysisData?: MedicalAnalysisResult | null\n  createdAt: string\n  imageUrl?: string | null\n}\n\nexport default function MedicalImagesHistoryPage() {\n  const pathname = usePathname()\n  const [historyItems, setHistoryItems] = useState<MedicalHistoryItem[]>([])\n  const [historyLoading, setHistoryLoading] = useState<boolean>(false)\n  const [historyError, setHistoryError] = useState<string | null>(null)\n  const [historyDeletingId, setHistoryDeletingId] = useState<string | null>(null)\n  const [historyClearing, setHistoryClearing] = useState<boolean>(false)\n  const [expandedHistoryId, setExpandedHistoryId] = useState<string | null>(null)\n\n  const loadHistory = useCallback(async () => {\n    try {\n      setHistoryLoading(true)\n      setHistoryError(null)\n      const res = await fetch('/api/medical-images/history', { cache: 'no-store' as any })\n      if (!res.ok) {\n        throw new Error('Failed to load history')\n      }\n      const data = await res.json()\n      const nextHistory = Array.isArray(data?.history)\n        ? data.history.map((item: any) => ({\n            ...item,\n            analysisData: item?.analysisData && typeof item.analysisData === 'object' ? item.analysisData : null,\n          }))\n        : []\n      setHistoryItems(nextHistory)\n    } catch (err) {\n      setHistoryError((err as Error).message || 'Failed to load history')\n    } finally {\n      setHistoryLoading(false)\n    }\n  }, [])\n\n  useEffect(() => {\n    loadHistory()\n  }, [loadHistory])\n\n  const handleDeleteHistoryItem = async (id: string) => {\n    if (!window.confirm('Delete this saved scan? This cannot be undone.')) return\n    try {\n      setHistoryDeletingId(id)\n      setHistoryError(null)\n      const res = await fetch(`/api/medical-images/history/${id}`, { method: 'DELETE' })\n      if (!res.ok) {\n        throw new Error('Failed to delete saved scan')\n      }\n      setHistoryItems((prev) => prev.filter((item) => item.id !== id))\n      setExpandedHistoryId((prev) => (prev === id ? null : prev))\n    } catch (err) {\n      setHistoryError((err as Error).message || 'Failed to delete saved scan')\n    } finally {\n      setHistoryDeletingId(null)\n    }\n  }\n\n  const handleClearHistory = async () => {\n    if (!window.confirm('Clear all saved scans? This cannot be undone.')) return\n    try {\n      setHistoryClearing(true)\n      setHistoryError(null)\n      const res = await fetch('/api/medical-images/history', { method: 'DELETE' })\n      if (!res.ok) {\n        throw new Error('Failed to clear history')\n      }\n      setHistoryItems([])\n      setExpandedHistoryId(null)\n    } catch (err) {\n      setHistoryError((err as Error).message || 'Failed to clear history')\n    } finally {\n      setHistoryClearing(false)\n    }\n  }\n\n  return (\n    <div className=\"min-h-screen bg-gray-50 flex flex-col\">\n      <PageHeader title=\"Medical Image Analyzer\" />\n\n      {/* Tabs */}\n      <div className=\"max-w-7xl mx-auto w-full px-4 pt-4\">\n        <div className=\"bg-white rounded-t-xl border-b border-gray-200\">\n          <div className=\"flex\">\n            <Link\n              href=\"/medical-images\"\n              style={{ width: '100%' }}\n              className={`flex-1 px-4 py-3 text-center font-medium transition-colors ${\n                pathname !== '/medical-images/history'\n                  ? 'text-helfi-green border-b-2 border-helfi-green'\n                  : 'text-gray-600 hover:text-gray-900'\n              }`}\n            >\n              Medical Image Analyzer\n            </Link>\n            <Link\n              href=\"/medical-images/history\"\n              style={{ width: '100%' }}\n              className={`flex-1 px-4 py-3 text-center font-medium transition-colors ${\n                pathname === '/medical-images/history'\n                  ? 'text-helfi-green border-b-2 border-helfi-green'\n                  : 'text-gray-600 hover:text-gray-900'\n              }`}\n            >\n              History\n            </Link>\n          </div>\n        </div>\n      </div>\n\n      <main className=\"flex-1\">\n        <div className=\"max-w-7xl mx-auto px-4 py-6\">\n          <div className=\"bg-white rounded-b-2xl shadow-sm border border-gray-200 p-6\">\n            <div className=\"flex items-center justify-between gap-2 mb-4\">\n              <div>\n                <h1 className=\"text-2xl font-bold text-gray-900\">Medical Image History</h1>\n                <p className=\"text-xs text-gray-500 mt-1\">Only scans you chose to save appear here.</p>\n              </div>\n              <div className=\"flex items-center gap-3 text-xs\">\n                {historyItems.length > 0 && (\n                  <button\n                    onClick={handleClearHistory}\n                    className=\"text-red-600 hover:text-red-700 disabled:opacity-60\"\n                    type=\"button\"\n                    disabled={historyClearing}\n                  >\n                    {historyClearing ? 'Clearing...' : 'Clear all'}\n                  </button>\n                )}\n                <button\n                  onClick={loadHistory}\n                  className=\"text-gray-600 hover:text-gray-900 disabled:opacity-60\"\n                  type=\"button\"\n                  disabled={historyLoading}\n                >\n                  Refresh\n                </button>\n              </div>\n            </div>\n\n            {historyLoading && <div className=\"text-sm text-gray-500\">Loading history...</div>}\n            {historyError && <div className=\"text-sm text-red-700\">{historyError}</div>}\n            {!historyLoading && !historyError && historyItems.length === 0 && (\n              <div className=\"text-sm text-gray-500\">No saved scans yet.</div>\n            )}\n\n            <div className=\"mt-4 space-y-4\">\n              {historyItems.map((item) => {\n                const analysisData = item.analysisData || null\n                const possibleCauses = Array.isArray(analysisData?.possibleCauses)\n                  ? analysisData?.possibleCauses\n                  : []\n                const redFlags = Array.isArray(analysisData?.redFlags) ? analysisData?.redFlags : []\n                const nextSteps = Array.isArray(analysisData?.nextSteps) ? analysisData?.nextSteps : []\n                const isExpanded = expandedHistoryId === item.id\n                const createdAtLabel = item.createdAt\n                  ? new Date(item.createdAt).toLocaleString()\n                  : 'Unknown date'\n\n                return (\n                  <div key={item.id} className=\"border border-gray-200 rounded-lg p-4 bg-white\">\n                    <div className=\"flex flex-col gap-4 md:flex-row\">\n                      <div className=\"w-full md:w-36 flex-shrink-0\">\n                        {item.imageUrl ? (\n                          <Image\n                            src={item.imageUrl}\n                            alt=\"Saved medical scan\"\n                            width={144}\n                            height={144}\n                            className=\"h-36 w-full rounded-lg object-cover border border-gray-100\"\n                          />\n                        ) : (\n                          <div className=\"h-36 w-full rounded-lg border border-dashed border-gray-200 bg-gray-50 flex items-center justify-center text-xs text-gray-400\">\n                            No image\n                          </div>\n                        )}\n                      </div>\n                      <div className=\"flex-1 space-y-2\">\n                        <div className=\"flex items-center justify-between gap-2\">\n                          <div className=\"text-xs text-gray-500\">{createdAtLabel}</div>\n                          <div className=\"flex items-center gap-3 text-xs\">\n                            <button\n                              type=\"button\"\n                              onClick={() => setExpandedHistoryId(isExpanded ? null : item.id)}\n                              className=\"text-helfi-green hover:text-helfi-green/80\"\n                            >\n                              {isExpanded ? 'Hide details' : 'View details'}\n                            </button>\n                            <button\n                              type=\"button\"\n                              onClick={() => handleDeleteHistoryItem(item.id)}\n                              className=\"text-red-600 hover:text-red-700 disabled:opacity-60\"\n                              disabled={historyDeletingId === item.id || historyClearing}\n                            >\n                              {historyDeletingId === item.id ? 'Deleting...' : 'Delete'}\n                            </button>\n                          </div>\n                        </div>\n                        {item.summary && <p className=\"text-sm text-gray-800\">{item.summary}</p>}\n                        {!item.summary && item.analysisText && (\n                          <p className=\"text-sm text-gray-800 whitespace-pre-line\">{item.analysisText}</p>\n                        )}\n\n                        {isExpanded && (\n                          <div className=\"pt-2 space-y-3 text-sm text-gray-700\">\n                            {possibleCauses.length > 0 && (\n                              <div>\n                                <div className=\"font-medium text-gray-900 mb-1\">Likely conditions</div>\n                                <ul className=\"space-y-1\">\n                                  {possibleCauses.map((cause: any, idx: number) => (\n                                    <li key={`${cause.name}-${idx}`} className=\"flex items-center gap-2\">\n                                      <span className=\"text-gray-900\">{cause.name}</span>\n                                      {cause.confidence && (\n                                        <span className=\"text-xs text-gray-500\">({cause.confidence})</span>\n                                      )}\n                                    </li>\n                                  ))}\n                                </ul>\n                              </div>\n                            )}\n                            {redFlags.length > 0 && (\n                              <div>\n                                <div className=\"font-medium text-red-700 mb-1\">Red-flag signs</div>\n                                <ul className=\"list-disc list-inside space-y-1 text-red-800\">\n                                  {redFlags.map((flag: string, idx: number) => (\n                                    <li key={idx}>{flag}</li>\n                                  ))}\n                                </ul>\n                              </div>\n                            )}\n                            {nextSteps.length > 0 && (\n                              <div>\n                                <div className=\"font-medium text-gray-900 mb-1\">Next steps</div>\n                                <ul className=\"list-disc list-inside space-y-1\">\n                                  {nextSteps.map((step: string, idx: number) => (\n                                    <li key={idx}>{step}</li>\n                                  ))}\n                                </ul>\n                              </div>\n                            )}\n                            {item.analysisText && item.summary && (\n                              <div>\n                                <div className=\"font-medium text-gray-900 mb-1\">Full notes</div>\n                                <p className=\"whitespace-pre-line\">{item.analysisText}</p>\n                              </div>\n                            )}\n                          </div>\n                        )}\n                      </div>\n                    </div>\n                  </div>\n                )\n              })}\n            </div>\n          </div>\n        </div>\n      </main>\n    </div>\n  )\n}\n","truncated":false,"size":12262},{"path":"app/medical-images/MedicalImageChat.tsx","content":"'use client'\n\nimport { FormEvent, KeyboardEvent, useCallback, useEffect, useLayoutEffect, useRef, useState } from 'react'\nimport { createPortal } from 'react-dom'\nimport { ArrowsPointingOutIcon, ArrowsPointingInIcon } from '@heroicons/react/24/outline'\nimport { formatChatContent } from '@/lib/chatFormatting'\n\ntype ChatMessage = { role: 'user' | 'assistant'; content: string }\n\ntype MedicalAnalysisResult = {\n  summary?: string | null\n  possibleCauses?: Array<{ name: string; whyLikely: string; confidence: string }>\n  redFlags?: string[]\n  nextSteps?: string[]\n  analysisText?: string\n}\n\ninterface MedicalImageChatProps {\n  analysisResult: MedicalAnalysisResult\n}\n\nconst SECTION_HEADINGS = [\n  // Current chat structure\n  '**Short answer**',\n  '**Why this matters**',\n  '**When to see a doctor**',\n  '**What you can do at home**',\n  // Legacy headings kept for backwards compatibility\n  '**Summary of what the analysis found**',\n  '**Most likely condition (high confidence)**',\n  '**Other possible explanations (medium / low)**',\n  '**Red-flag signs to watch for**',\n  '**What you can do next**',\n]\n\nfunction normaliseMedicalChatContent(raw: string): string {\n  return formatChatContent(raw, { headings: SECTION_HEADINGS })\n}\n\nexport default function MedicalImageChat({ analysisResult }: MedicalImageChatProps) {\n  const [messages, setMessages] = useState<ChatMessage[]>([])\n  const [input, setInput] = useState('')\n  const [loading, setLoading] = useState(false)\n  const [error, setError] = useState<string | null>(null)\n  const [expanded, setExpanded] = useState(false)\n  const [showExpandControl, setShowExpandControl] = useState(false)\n  const scrollPositionRef = useRef<number>(0)\n  const endRef = useRef<HTMLDivElement | null>(null)\n  const containerRef = useRef<HTMLDivElement | null>(null)\n  const textareaRef = useRef<HTMLTextAreaElement | null>(null)\n  const resizeRafRef = useRef<number | null>(null)\n  const [isClient, setIsClient] = useState(false)\n\n  // Smooth, single-frame resize to keep composer steady during rapid updates (typing/voice)\n  const resizeTextarea = useCallback(() => {\n    if (resizeRafRef.current) cancelAnimationFrame(resizeRafRef.current)\n    resizeRafRef.current = requestAnimationFrame(() => {\n      const textarea = textareaRef.current\n      if (!textarea) return\n      const minHeight = 52\n      const maxHeight = 200\n      textarea.style.height = 'auto'\n      const desired = Math.min(Math.max(textarea.scrollHeight, minHeight), maxHeight)\n      if (textarea.style.height !== `${desired}px`) {\n        textarea.style.height = `${desired}px`\n      }\n      textarea.style.overflowY = textarea.scrollHeight > maxHeight ? 'auto' : 'hidden'\n\n      // Show expand control when textarea height exceeds ~3-4 lines (around 156px for 3 lines)\n      // Using scrollHeight which reflects actual content height\n      const shouldShow = textarea.scrollHeight > 140 || (textarea.value.match(/\\n/g) || []).length >= 2\n      setShowExpandControl(shouldShow)\n    })\n  }, [])\n\n  // Scroll to bottom inside chat container\n  useEffect(() => {\n    const container = containerRef.current\n    if (!container) return\n    container.scrollTop = container.scrollHeight\n\n    return () => {\n      if (resizeRafRef.current) cancelAnimationFrame(resizeRafRef.current)\n    }\n  }, [messages, loading])\n\n  useEffect(() => {\n    return () => {\n      if (resizeRafRef.current) cancelAnimationFrame(resizeRafRef.current)\n    }\n  }, [])\n\n  // Auto-resize textarea pre-paint to reduce flicker\n  useLayoutEffect(() => {\n    resizeTextarea()\n  }, [input, resizeTextarea])\n\n  // Track client-side mount so we can safely use portals\n  useEffect(() => {\n    setIsClient(true)\n  }, [])\n\n  function onComposerKeyDown(event: KeyboardEvent<HTMLTextAreaElement>) {\n    if (event.key === 'Enter' && !event.shiftKey) {\n      event.preventDefault()\n      const form = (event.target as HTMLTextAreaElement).closest('form') as HTMLFormElement | null\n      form?.requestSubmit()\n    }\n  }\n\n  async function handleClear() {\n    try {\n      setLoading(true)\n      setError(null)\n      setMessages([])\n    } catch (err) {\n      setError((err as Error).message)\n    } finally {\n      setLoading(false)\n    }\n  }\n\n  async function handleSubmit(event: FormEvent<HTMLFormElement>) {\n    event.preventDefault()\n    const text = input.trim()\n    if (!text) {\n      setError('Enter a question to ask the AI.')\n      return\n    }\n\n    try {\n      setLoading(true)\n      setError(null)\n\n      const nextMessages: ChatMessage[] = [...messages, { role: 'user', content: text }]\n      setMessages(nextMessages)\n      setInput('')\n\n      const res = await fetch('/api/medical-images/chat', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json', Accept: 'text/event-stream' },\n        body: JSON.stringify({\n          message: text,\n          analysisResult,\n        }),\n      })\n\n      if (res.ok && (res.headers.get('content-type') || '').includes('text/event-stream') && res.body) {\n        const reader = res.body.getReader()\n        const decoder = new TextDecoder()\n        let buffer = ''\n        let hasAssistant = false\n        while (true) {\n          const { value, done } = await reader.read()\n          if (done) break\n          buffer += decoder.decode(value, { stream: true })\n          const parts = buffer.split('\\n\\n')\n          buffer = parts.pop() || ''\n          for (const chunk of parts) {\n            if (chunk.startsWith('data: ')) {\n              const token = chunk.slice(6)\n              if (!hasAssistant) {\n                setMessages((prev) => [...prev, { role: 'assistant', content: token }])\n                hasAssistant = true\n              } else {\n                setMessages((prev) => {\n                  const copy = prev.slice()\n                  copy[copy.length - 1] = {\n                    role: 'assistant',\n                    content: (copy[copy.length - 1] as any).content + token,\n                  }\n                  return copy\n                })\n              }\n            }\n          }\n        }\n      } else {\n        const data = await res.json().catch(() => null)\n        const textOut = data?.assistant as string | undefined\n        if (textOut) setMessages((prev) => [...prev, { role: 'assistant', content: textOut }])\n      }\n    } catch (err) {\n      setError((err as Error).message)\n    } finally {\n      setLoading(false)\n    }\n  }\n\n  const sectionClass = expanded\n    ? 'fixed inset-0 z-[9999] bg-white flex flex-col h-[100dvh]'\n    : 'bg-white overflow-hidden md:rounded-2xl md:border md:shadow-sm relative flex flex-col h-[calc(100vh-140px)] md:h-auto'\n\n  const chatUI = (\n    <section\n      className={sectionClass}\n      style={\n        expanded\n          ? {\n              paddingTop: 'calc(env(safe-area-inset-top, 16px))',\n              paddingBottom: 'env(safe-area-inset-bottom, 0px)',\n            }\n          : undefined\n      }\n    >\n      <header className=\"flex items-center justify-between px-4 py-3 border-b border-gray-200 w-full max-w-3xl mx-auto\">\n        <div>\n          <h3 className=\"text-sm font-semibold text-gray-900\">Chat about your medical image</h3>\n          <p className=\"text-xs text-gray-500\">\n            Ask follow-up questions ‚Äì chat resets when you leave this page or run a new analysis\n          </p>\n        </div>\n        <div className=\"flex items-center gap-2\">\n          <button\n            onClick={handleClear}\n            disabled={loading}\n            className=\"text-xs rounded-md border border-gray-300 px-2 py-1 text-gray-600 hover:bg-gray-50 disabled:opacity-60\"\n          >\n            Reset\n          </button>\n        </div>\n      </header>\n\n      <div\n        ref={containerRef}\n        className={`px-4 py-6 overflow-y-auto overflow-x-hidden space-y-6 min-w-0 w-full max-w-3xl mx-auto ${expanded ? 'flex-1 min-h-0' : 'min-h-[220px]'}`}\n        aria-live=\"polite\"\n        style={{\n          maxWidth: '100%',\n          wordWrap: 'break-word',\n          paddingBottom: 'calc(env(safe-area-inset-bottom, 0px) + 96px)',\n        }}\n      >\n        {messages.length === 0 && !loading && (\n          <div className=\"text-sm text-gray-400\">\n            Ask follow‚Äëups like:\n            <div className=\"mt-3 flex flex-wrap gap-2\">\n              {[\n                'What should I do about these red flags?',\n                'Can you explain the most likely condition in more detail?',\n                'When should I see a doctor about this image?',\n                'What everyday things can make this better or worse?',\n              ].map((q) => (\n                <button\n                  key={q}\n                  onClick={() => setInput(q)}\n                  className=\"text-left px-4 py-3 bg-gray-50 hover:bg-gray-100 rounded-xl text-sm text-gray-700 transition-colors\"\n                  type=\"button\"\n                >\n                  {q}\n                </button>\n              ))}\n            </div>\n          </div>\n        )}\n\n        {messages.map((m, idx) => (\n          <div key={idx} className={`flex gap-4 ${m.role === 'user' ? 'flex-row-reverse' : ''}`}>\n            <div className=\"flex-shrink-0 w-8 h-8 rounded-full bg-gray-200 flex items-center justify-center\">\n              {m.role === 'user' ? (\n                <svg className=\"w-5 h-5 text-gray-600\" fill=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path d=\"M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z\" />\n                </svg>\n              ) : (\n                <svg className=\"w-5 h-5 text-gray-600\" fill=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path d=\"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z\" />\n                </svg>\n              )}\n            </div>\n            <div className={`flex-1 min-w-0 ${m.role === 'user' ? 'text-right' : ''}`}>\n              <div\n                className={`inline-block max-w-full px-4 py-2.5 rounded-2xl ${\n                  m.role === 'user'\n                    ? 'bg-gray-900 text-white'\n                    : 'bg-gray-100 text-gray-900'\n                }`}\n                style={{ wordWrap: 'break-word', overflowWrap: 'break-word' }}\n              >\n                <div\n                  className=\"text-sm leading-relaxed break-words\"\n                  style={{ whiteSpace: 'pre-wrap' }}\n                >\n                  {normaliseMedicalChatContent(m.content).split('\\n').map((line, i) => {\n                    const trimmed = line.trim()\n                    if (!trimmed) {\n                      return <div key={i} className=\"h-3\" />\n                    }\n\n                    // Section headings in **bold** ‚Äì allow for cases where the model\n                    // keeps the heading and the first sentence on the same line.\n                    if (trimmed.startsWith('**')) {\n                      const endIndex = trimmed.indexOf('**', 2)\n                      if (endIndex > 2) {\n                        const headingText = trimmed.slice(2, endIndex)\n                        const rest = trimmed.slice(endIndex + 2).trim()\n\n                        if (!rest) {\n                          return (\n                            <div\n                              key={i}\n                              className=\"font-bold text-gray-900 mb-2 mt-3 first:mt-0\"\n                            >\n                              {headingText}\n                            </div>\n                          )\n                        }\n\n                        return (\n                          <div key={i}>\n                            <div className=\"font-bold text-gray-900 mb-1 mt-3 first:mt-0\">\n                              {headingText}\n                            </div>\n                            <div className=\"mb-2\">{rest}</div>\n                          </div>\n                        )\n                      }\n                    }\n\n                    // Numbered list\n                    const numberedMatch = trimmed.match(/^(\\d+)\\.\\s+(.+)$/)\n                    if (numberedMatch) {\n                      return (\n                        <div key={i} className=\"ml-4 mb-1.5\">\n                          <span className=\"font-medium\">{numberedMatch[1]}.</span>{' '}\n                          {numberedMatch[2]}\n                        </div>\n                      )\n                    }\n\n                    // Bullet list\n                    const bulletMatch = trimmed.match(/^[-‚Ä¢*]\\s+(.+)$/)\n                    if (bulletMatch) {\n                      return (\n                        <div key={i} className=\"ml-4 mb-1.5\">\n                          <span className=\"mr-2\">‚Ä¢</span> {bulletMatch[1]}\n                        </div>\n                      )\n                    }\n\n                    // Inline bold handling for **text**\n                    const parts = trimmed.split(/(\\*\\*.*?\\*\\*)/g)\n                    return (\n                      <div key={i} className=\"mb-2\">\n                        {parts.map((part, j) => {\n                          if (part.startsWith('**') && part.endsWith('**')) {\n                            return (\n                              <strong key={j} className=\"font-semibold\">\n                                {part.slice(2, -2)}\n                              </strong>\n                            )\n                          }\n                          return <span key={j}>{part}</span>\n                        })}\n                      </div>\n                    )\n                  })}\n                </div>\n              </div>\n            </div>\n          </div>\n        ))}\n\n        {loading && (\n          <div className=\"flex gap-4\">\n            <div className=\"flex-shrink-0 w-8 h-8 rounded-full bg-gray-200 flex items-center justify-center\">\n              <svg className=\"w-5 h-5 text-gray-600\" fill=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path d=\"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z\" />\n              </svg>\n            </div>\n            <div className=\"flex-1\">\n              <div className=\"inline-block px-4 py-2.5 rounded-2xl bg-gray-100\">\n                <div className=\"flex gap-1\">\n                  <span\n                    className=\"w-2 h-2 bg-gray-400 rounded-full animate-bounce\"\n                    style={{ animationDelay: '0ms' }}\n                  ></span>\n                  <span\n                    className=\"w-2 h-2 bg-gray-400 rounded-full animate-bounce\"\n                    style={{ animationDelay: '150ms' }}\n                  ></span>\n                  <span\n                    className=\"w-2 h-2 bg-gray-400 rounded-full animate-bounce\"\n                    style={{ animationDelay: '300ms' }}\n                  ></span>\n                </div>\n              </div>\n            </div>\n          </div>\n        )}\n        <div ref={endRef} />\n      </div>\n\n      <form\n        className=\"sticky bottom-0 left-0 right-0 border-t border-gray-200 px-4 py-3 bg-white z-40 shadow-[0_-6px_18px_rgba(0,0,0,0.08)] flex-shrink-0\"\n        onSubmit={handleSubmit}\n        style={{ paddingBottom: 'calc(env(safe-area-inset-bottom, 0px) + 12px)' }}\n      >\n        <div className=\"flex items-center gap-2 w-full max-w-3xl mx-auto\">\n          <div className=\"flex-1 relative flex items-center\">\n            <textarea\n              ref={textareaRef}\n              value={input}\n              onChange={(event) => {\n                setInput(event.target.value)\n                resizeTextarea()\n              }}\n              onKeyDown={onComposerKeyDown}\n              placeholder=\"Message AI about your medical image analysis\"\n              rows={1}\n              className=\"w-full rounded-2xl border-0 bg-gray-100 px-4 py-3 pr-14 text-[16px] leading-6 text-gray-900 placeholder-gray-500 focus:outline-none focus:ring-0 resize-none transition-all duration-200 min-h-[52px] max-h-[200px]\"\n            />\n            {false && (\n              <button\n                type=\"button\"\n                onClick={(e) => {\n                  e.preventDefault()\n                  e.stopPropagation()\n                  setExpanded((v) => !v)\n                }}\n                className=\"absolute right-14 top-2.5 w-5 h-5 flex items-center justify-center text-gray-500 hover:text-gray-700 transition-colors z-10\"\n                aria-label={expanded ? 'Exit expanded chat view' : 'Expand chat area'}\n              >\n                {expanded ? (\n                  <ArrowsPointingInIcon className=\"w-4 h-4\" />\n                ) : (\n                  <ArrowsPointingOutIcon className=\"w-4 h-4\" />\n                )}\n              </button>\n            )}\n            <button\n              type=\"submit\"\n              disabled={loading || !input.trim()}\n              className=\"absolute right-2 bottom-2 w-9 h-9 rounded-full bg-gray-900 text-white flex items-center justify-center hover:bg-gray-800 disabled:opacity-50 disabled:cursor-not-allowed transition-colors\"\n              aria-label=\"Send message\"\n            >\n              <svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M12 19l9 2-9-18-9 18 9-2zm0 0v-8\" />\n              </svg>\n            </button>\n          </div>\n        </div>\n        {error && <div className=\"mt-2 text-xs text-red-600\">{error}</div>}\n      </form>\n    </section>\n  )\n\n  if (expanded && isClient && typeof document !== 'undefined') {\n    return createPortal(chatUI, document.body)\n  }\n\n  return chatUI\n}\n","truncated":false,"size":17617},{"path":"app/medical-images/page.tsx","content":"'use client'\nimport { Cog6ToothIcon } from '@heroicons/react/24/outline'\n\nimport { useCallback, useEffect, useRef, useState } from 'react'\nimport Link from 'next/link'\nimport { usePathname } from 'next/navigation'\nimport CreditPurchaseModal from '@/components/CreditPurchaseModal'\nimport MobileMoreMenu from '@/components/MobileMoreMenu'\nimport UsageMeter from '@/components/UsageMeter'\nimport FeatureUsageDisplay from '@/components/FeatureUsageDisplay'\nimport PageHeader from '@/components/PageHeader'\nimport MedicalImageChat from './MedicalImageChat'\n\ntype ConfidenceLevel = 'low' | 'medium' | 'high'\n\ntype MedicalPossibleCause = {\n  name: string\n  whyLikely: string\n  confidence: ConfidenceLevel | string\n}\n\ntype MedicalAnalysisResult = {\n  summary?: string | null\n  possibleCauses?: MedicalPossibleCause[]\n  redFlags?: string[]\n  nextSteps?: string[]\n  disclaimer?: string\n  analysisText?: string\n}\n\nexport default function MedicalImagesPage() {\n  const pathname = usePathname()\n  const [imageFile, setImageFile] = useState<File | null>(null)\n  const [imagePreview, setImagePreview] = useState<string | null>(null)\n  const [isAnalyzing, setIsAnalyzing] = useState<boolean>(false)\n  const [analysis, setAnalysis] = useState<string | null>(null)\n  const [analysisResult, setAnalysisResult] = useState<MedicalAnalysisResult | null>(null)\n  const [error, setError] = useState<string>('')\n  const [saveToHistory, setSaveToHistory] = useState<boolean>(false)\n  const [historySaveError, setHistorySaveError] = useState<string | null>(null)\n  const [currentHistorySaving, setCurrentHistorySaving] = useState<boolean>(false)\n  const [currentHistorySaved, setCurrentHistorySaved] = useState<boolean>(false)\n  const [showCreditsModal, setShowCreditsModal] = useState<boolean>(false)\n  const [creditInfo, setCreditInfo] = useState<any>({\n    dailyUsed: 0,\n    dailyLimit: 0,\n    additionalCredits: 0,\n    plan: 'FREE',\n    creditCost: 2, // Medical image analysis costs 2 credits\n    featureUsageToday: { foodAnalysis: 0, interactionAnalysis: 0 }\n  })\n  const [usageMeterRefresh, setUsageMeterRefresh] = useState<number>(0) // Trigger for UsageMeter refresh\n  const [hasPaidAccess, setHasPaidAccess] = useState<boolean>(false)\n  const [hasAnalyzedCurrentImage, setHasAnalyzedCurrentImage] = useState<boolean>(false)\n  const [analysisSessionId, setAnalysisSessionId] = useState<number>(0)\n  const resultRef = useRef<HTMLDivElement | null>(null)\n  const [creditRefreshTick, setCreditRefreshTick] = useState<number>(0)\n\n  const handleImageSelect = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const file = e.target.files?.[0]\n    if (file) {\n      setImageFile(file)\n      setAnalysis(null)\n      setAnalysisResult(null)\n      setError('')\n      setHistorySaveError(null)\n      setHasAnalyzedCurrentImage(false)\n      setCurrentHistorySaved(false)\n      setCurrentHistorySaving(false)\n      // Create preview\n      const reader = new FileReader()\n      reader.onloadend = () => {\n        setImagePreview(reader.result as string)\n      }\n      reader.readAsDataURL(file)\n    }\n  }\n\n  useEffect(() => {\n    const handler = () => setCreditRefreshTick((v) => v + 1)\n    try {\n      window.addEventListener('credits:refresh', handler)\n      return () => window.removeEventListener('credits:refresh', handler)\n    } catch {\n      return () => {}\n    }\n  }, [])\n\n  useEffect(() => {\n    const fetchCreditStatus = async () => {\n      try {\n        const res = await fetch(`/api/credit/status`, { cache: 'no-store' })\n        if (!res.ok) return\n        const data = await res.json()\n        const isPremium = data?.plan === 'PREMIUM'\n        const hasWalletCredits =\n          typeof data?.totalAvailableCents === 'number' && data.totalAvailableCents > 0\n        const hasLegacyCredits =\n          typeof data?.credits?.total === 'number' && data.credits.total > 0\n\n        setHasPaidAccess(Boolean(isPremium || hasWalletCredits || hasLegacyCredits))\n      } catch {\n        // ignore failures ‚Äì fall back to showing free banner\n      }\n    }\n    fetchCreditStatus()\n  }, [creditRefreshTick])\n\n  const saveCurrentToHistory = useCallback(async () => {\n    if (!imageFile) {\n      setHistorySaveError('Please upload an image before saving.')\n      return\n    }\n    if (!analysis && !analysisResult) {\n      setHistorySaveError('Please run an analysis before saving.')\n      return\n    }\n    if (currentHistorySaved || currentHistorySaving) return\n\n    try {\n      setCurrentHistorySaving(true)\n      setHistorySaveError(null)\n\n      const payload = {\n        summary: analysisResult?.summary ?? null,\n        possibleCauses: Array.isArray(analysisResult?.possibleCauses)\n          ? analysisResult?.possibleCauses\n          : [],\n        redFlags: Array.isArray(analysisResult?.redFlags) ? analysisResult?.redFlags : [],\n        nextSteps: Array.isArray(analysisResult?.nextSteps) ? analysisResult?.nextSteps : [],\n        disclaimer: analysisResult?.disclaimer ?? null,\n        analysisText: analysis ?? analysisResult?.analysisText ?? null,\n      }\n\n      const formData = new FormData()\n      formData.append('image', imageFile)\n      formData.append('analysis', JSON.stringify(payload))\n\n      const res = await fetch('/api/medical-images/history', {\n        method: 'POST',\n        body: formData,\n      })\n      if (!res.ok) {\n        const data = await res.json().catch(() => ({}))\n        throw new Error(data?.error || 'Failed to save scan to history')\n      }\n      const data = await res.json()\n      setCurrentHistorySaved(true)\n    } catch (err) {\n      setHistorySaveError((err as Error).message || 'Failed to save scan to history')\n    } finally {\n      setCurrentHistorySaving(false)\n    }\n  }, [analysis, analysisResult, currentHistorySaved, currentHistorySaving, imageFile])\n\n  const handleSaveToggle = async (checked: boolean) => {\n    setSaveToHistory(checked)\n    if (checked && (analysisResult || analysis) && !currentHistorySaved && !currentHistorySaving) {\n      await saveCurrentToHistory()\n    }\n  }\n\n  const handleAnalyze = async () => {\n    if (!imageFile) {\n      setError('Please select an image first')\n      return\n    }\n    if (hasAnalyzedCurrentImage) {\n      setError('This image has already been analyzed. Reset to analyze a new image.')\n      return\n    }\n\n    setError('')\n    setAnalysis(null)\n    setAnalysisResult(null)\n    setIsAnalyzing(true)\n    setHasAnalyzedCurrentImage(false)\n    setHistorySaveError(null)\n    setCurrentHistorySaved(false)\n    setCurrentHistorySaving(false)\n\n    try {\n      const formData = new FormData()\n      formData.append('image', imageFile)\n      formData.append('saveToHistory', saveToHistory ? 'true' : 'false')\n\n      const response = await fetch('/api/test-vision', {\n        method: 'POST',\n        body: formData,\n      })\n\n      if (response.status === 402) {\n        const data = await response.json()\n        setCreditInfo({\n          dailyUsed: 0,\n          dailyLimit: 0,\n          additionalCredits: data.additionalCredits ?? 0,\n          plan: data.plan ?? 'FREE',\n          creditCost: 2,\n          featureUsageToday: { foodAnalysis: 0, interactionAnalysis: 0 }\n        })\n        setShowCreditsModal(true)\n        setIsAnalyzing(false)\n        return\n      }\n\n      if (!response.ok) {\n        const data = await response.json().catch(() => ({}))\n        throw new Error(data?.error || data?.message || 'Failed to analyze image')\n      }\n\n      const result = await response.json()\n      if (result.success) {\n        const analysisText = typeof result.analysis === 'string' ? result.analysis : null\n        const possibleCauses = Array.isArray(result.possibleCauses) ? result.possibleCauses : []\n        const redFlags = Array.isArray(result.redFlags) ? result.redFlags : []\n        const nextSteps = Array.isArray(result.nextSteps) ? result.nextSteps : []\n        const hasStructured =\n          Boolean(result.summary) ||\n          possibleCauses.length > 0 ||\n          redFlags.length > 0 ||\n          nextSteps.length > 0\n\n        if (!analysisText && !hasStructured) {\n          throw new Error('Invalid response from server')\n        }\n\n        if (analysisText) {\n          setAnalysis(analysisText)\n        }\n\n        const structured: MedicalAnalysisResult = {\n          summary: result.summary ?? null,\n          possibleCauses,\n          redFlags,\n          nextSteps,\n          disclaimer:\n            result.disclaimer ||\n            'This analysis is for information only and is not a substitute for professional medical advice, diagnosis, or treatment. Always seek the advice of a qualified healthcare provider with any questions you may have regarding a medical condition.',\n          analysisText: analysisText ?? undefined,\n        }\n        if (analysisText || hasStructured) {\n          setAnalysisResult(structured)\n        }\n        setAnalysisSessionId(prev => prev + 1)\n        setHasAnalyzedCurrentImage(true)\n        // Trigger usage meter refresh after successful analysis\n        try { window.dispatchEvent(new Event('credits:refresh')); } catch {}\n\n        if (saveToHistory) {\n          if (result.historySaved && result.historyItem) {\n            setCurrentHistorySaved(true)\n          } else if (result.historyError) {\n            setHistorySaveError(result.historyError)\n          } else if (!result.historySaved) {\n            setHistorySaveError('We could not save this scan to your history.')\n          }\n        }\n      } else {\n        throw new Error('Invalid response from server')\n      }\n    } catch (e: any) {\n      setError(e?.message || 'Something went wrong')\n    } finally {\n      setIsAnalyzing(false)\n    }\n  }\n\n  const handleReset = () => {\n    setImageFile(null)\n    setImagePreview(null)\n    setAnalysis(null)\n    setAnalysisResult(null)\n    setError('')\n    setHasAnalyzedCurrentImage(false)\n    setCurrentHistorySaved(false)\n    setCurrentHistorySaving(false)\n  }\n\n  useEffect(() => {\n    if (!analysisResult) return\n    const el = resultRef.current\n    if (!el) return\n    requestAnimationFrame(() => {\n      el.scrollIntoView({ behavior: 'smooth', block: 'start' })\n    })\n  }, [analysisResult])\n\n  return (\n    <div className=\"min-h-screen bg-gray-50 flex flex-col\">\n      <PageHeader title=\"Medical Image Analyzer\" />\n\n      {/* Tabs */}\n      <div className=\"max-w-7xl mx-auto w-full px-4 pt-4\">\n        <div className=\"bg-white rounded-t-xl border-b border-gray-200\">\n          <div className=\"flex\">\n            <Link\n              href=\"/medical-images\"\n              style={{ width: '100%' }}\n              className={`flex-1 px-4 py-3 text-center font-medium transition-colors ${\n                pathname !== '/medical-images/history'\n                  ? 'text-helfi-green border-b-2 border-helfi-green'\n                  : 'text-gray-600 hover:text-gray-900'\n              }`}\n            >\n              Medical Image Analyzer\n            </Link>\n            <Link\n              href=\"/medical-images/history\"\n              style={{ width: '100%' }}\n              className={`flex-1 px-4 py-3 text-center font-medium transition-colors ${\n                pathname === '/medical-images/history'\n                  ? 'text-helfi-green border-b-2 border-helfi-green'\n                  : 'text-gray-600 hover:text-gray-900'\n              }`}\n            >\n              History\n            </Link>\n          </div>\n        </div>\n      </div>\n\n      {/* Content */}\n      <main className=\"flex-1\">\n        <div className=\"mx-auto w-full px-0 sm:px-4 md:max-w-3xl md:px-4 py-6\">\n          <div className=\"bg-white rounded-lg shadow-sm border border-gray-200 p-4 md:p-6\">\n            <h1 className=\"text-xl font-semibold text-gray-900 mb-1\">Medical Image Analyzer</h1>\n            <div className=\"bg-blue-50 border border-blue-200 rounded-lg p-4 mb-4\">\n              <h2 className=\"text-sm font-semibold text-blue-900 mb-2\">What is this feature?</h2>\n              <p className=\"text-sm text-blue-800 mb-2\">\n                Our AI-powered Medical Image Analyzer helps you understand medical images by providing detailed analysis and insights. \n                Upload photos of various medical conditions and receive AI-generated descriptions and observations.\n              </p>\n              <p className=\"text-sm text-blue-800 font-medium mb-1\">Perfect for analyzing:</p>\n              <ul className=\"text-sm text-blue-800 list-disc list-inside space-y-1 ml-2\">\n                <li>Skin conditions (rashes, hives, eczema, psoriasis)</li>\n                <li>Skin anomalies (moles, lesions, growths)</li>\n                <li>X-rays and medical scans</li>\n                <li>Wounds and injuries</li>\n                <li>Eye conditions</li>\n                <li>Nail abnormalities</li>\n                <li>Other visible medical concerns</li>\n              </ul>\n              <p className=\"text-xs text-blue-700 mt-3 italic\">\n                ‚ö†Ô∏è This tool provides informational analysis only and is not a substitute for professional medical advice, diagnosis, or treatment.\n              </p>\n            </div>\n\n            {/* Image Upload */}\n            <div className=\"mb-4\">\n              {!imagePreview ? (\n                <label className=\"flex flex-col items-center justify-center w-full h-64 border-2 border-gray-300 border-dashed rounded-lg cursor-pointer bg-gray-50 hover:bg-gray-100 transition-colors\">\n                  <div className=\"flex flex-col items-center justify-center pt-5 pb-6\">\n                    <svg className=\"w-10 h-10 mb-3 text-gray-400\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                      <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12\" />\n                    </svg>\n                    <p className=\"mb-2 text-sm text-gray-500\">\n                      <span className=\"font-semibold\">Click to upload</span> or drag and drop\n                    </p>\n                    <p className=\"text-xs text-gray-500\">PNG, JPG, GIF up to 10MB</p>\n                  </div>\n                  <input\n                    type=\"file\"\n                    accept=\"image/*\"\n                    onChange={handleImageSelect}\n                    className=\"hidden\"\n                  />\n                </label>\n              ) : (\n                <div className=\"relative\">\n                  <img\n                    src={imagePreview}\n                    alt=\"Preview\"\n                    className=\"w-full h-auto rounded-lg border border-gray-200 max-h-96 object-contain bg-gray-50\"\n                  />\n                  <button\n                    onClick={handleReset}\n                    className=\"absolute top-2 right-2 bg-red-500 text-white rounded-full p-2 hover:bg-red-600 transition-colors\"\n                    aria-label=\"Remove image\"\n                  >\n                    <svg className=\"w-5 h-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                      <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M6 18L18 6M6 6l12 12\" />\n                    </svg>\n                  </button>\n                </div>\n              )}\n            </div>\n\n            {error && (\n              <div className=\"bg-red-50 border border-red-200 text-red-800 rounded-lg p-3 mb-4 text-sm\">{error}</div>\n            )}\n\n            <div className=\"mb-4 flex flex-col gap-2 rounded-lg border border-gray-200 bg-gray-50 px-4 py-3\">\n              <label className=\"flex items-center gap-2 text-sm text-gray-800\">\n                <input\n                  type=\"checkbox\"\n                  checked={saveToHistory}\n                  onChange={(e) => handleSaveToggle(e.target.checked)}\n                  className=\"h-4 w-4 rounded border-gray-300 text-helfi-green focus:ring-helfi-green\"\n                />\n                Save this scan to my history\n              </label>\n              <p className=\"text-xs text-gray-500\">\n                Saved scans include the image and analysis. Stored in Vercel Blob (AES-256 at rest, HTTPS in transit) and tied to your account.\n                You can delete them anytime. Leave this off to keep this scan private.\n              </p>\n              {historySaveError && (\n                <p className=\"text-xs text-amber-700\">{historySaveError}</p>\n              )}\n              {analysisResult && saveToHistory && !currentHistorySaved && !historySaveError && (\n                <p className=\"text-xs text-gray-500\">\n                  {currentHistorySaving ? 'Saving this scan to history...' : 'This scan will be saved to your history.'}\n                </p>\n              )}\n              {analysisResult && saveToHistory && currentHistorySaved && (\n                <p className=\"text-xs text-emerald-700\">Saved to history.</p>\n              )}\n            </div>\n\n            <div className=\"flex gap-3\">\n              <button\n                onClick={handleAnalyze}\n                disabled={!imageFile || isAnalyzing || hasAnalyzedCurrentImage}\n                className={`flex-1 inline-flex items-center justify-center px-4 py-2 rounded-lg font-medium text-white transition-colors ${\n                  !imageFile || isAnalyzing || hasAnalyzedCurrentImage\n                    ? 'bg-gray-400 cursor-not-allowed'\n                    : 'bg-helfi-green hover:bg-helfi-green/90'\n                }`}\n              >\n                {isAnalyzing ? (\n                  <>\n                    <svg className=\"animate-spin -ml-1 mr-3 h-5 w-5 text-white\" xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\">\n                      <circle className=\"opacity-25\" cx=\"12\" cy=\"12\" r=\"10\" stroke=\"currentColor\" strokeWidth=\"4\"></circle>\n                      <path className=\"opacity-75\" fill=\"currentColor\" d=\"M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z\"></path>\n                    </svg>\n                    Analyzing...\n                  </>\n                ) : (\n                  'Analyze Image'\n                )}\n              </button>\n              {imagePreview && (\n                <button\n                  onClick={handleReset}\n                  className=\"px-4 py-2 border border-gray-300 text-gray-700 rounded-lg hover:bg-gray-50 transition-colors\"\n                >\n                  Reset\n                </button>\n              )}\n            </div>\n            <div className=\"mt-2\">\n              <p className=\"text-xs text-gray-500 mb-2\">Cost: 8 credits per analysis</p>\n              {!hasPaidAccess && (\n                <div className=\"text-[11px] text-blue-800 bg-blue-50 border border-blue-200 rounded px-2 py-1 mb-2\">\n                  Free accounts can try this AI feature once. After your free analysis, upgrade or buy credits to continue.\n                </div>\n              )}\n              <UsageMeter inline={true} refreshTrigger={usageMeterRefresh} feature=\"medicalImageAnalysis\" />\n              <FeatureUsageDisplay featureName=\"medicalImageAnalysis\" featureLabel=\"Medical Image Analysis\" refreshTrigger={usageMeterRefresh} />\n            </div>\n\n            {/* Analysis Results */}\n            {(analysisResult || analysis) && (\n              <div\n                ref={resultRef}\n                className=\"mt-6 bg-gray-50 border border-gray-200 rounded-lg p-4 md:p-6 space-y-4\"\n              >\n                <h2 className=\"text-lg font-semibold text-gray-900\">Analysis Results</h2>\n\n                {/* Summary */}\n                {analysisResult?.summary && (\n                  <section>\n                    <h3 className=\"font-medium text-gray-900 mb-1\">Summary</h3>\n                    <p className=\"text-sm text-gray-700 whitespace-pre-line\">\n                      {analysisResult.summary}\n                    </p>\n                  </section>\n                )}\n\n                {/* Likely conditions (visually ranked: high ‚Üí medium ‚Üí low) */}\n                {Array.isArray(analysisResult?.possibleCauses) &&\n                  analysisResult.possibleCauses.length > 0 && (\n                    <section>\n                      <h3 className=\"font-medium text-gray-900 mb-2\">Likely conditions</h3>\n                      <ul className=\"space-y-2\">\n                        {(() => {\n                          const sorted = [...analysisResult.possibleCauses].sort((a, b) => {\n                            const weight: Record<string, number> = { high: 3, medium: 2, low: 1 }\n                            const wa = weight[(a.confidence || 'medium').toLowerCase()] ?? 2\n                            const wb = weight[(b.confidence || 'medium').toLowerCase()] ?? 2\n                            return wb - wa\n                          })\n\n                          const hasExplicitHigh = sorted.some(\n                            (c) => String(c.confidence || '').toLowerCase() === 'high'\n                          )\n\n                          return sorted.map((c, idx) => {\n                            const raw = String(c.confidence || '').toLowerCase()\n\n                            // Normalise so there is always a clear \"high\" at the top\n                            // and a \"low\" at the bottom if we have more than one item.\n                            let level: ConfidenceLevel\n                            if (hasExplicitHigh) {\n                              // Respect the model's explicit labelling when a high is present.\n                              level =\n                                raw === 'high' || raw === 'medium' || raw === 'low'\n                                  ? (raw as ConfidenceLevel)\n                                  : 'medium'\n                            } else if (sorted.length === 1) {\n                              level = 'high'\n                            } else if (idx === 0) {\n                              level = 'high'\n                            } else if (idx === sorted.length - 1) {\n                              level = 'low'\n                            } else {\n                              level = 'medium'\n                            }\n\n                            const badgeClasses =\n                              level === 'high'\n                                ? 'bg-red-100 text-red-800 border-red-200'\n                                : level === 'low'\n                                ? 'bg-gray-100 text-gray-700 border-gray-200'\n                                : 'bg-amber-100 text-amber-800 border-amber-200'\n\n                            return (\n                              <li\n                                key={`${c.name}-${idx}`}\n                                className=\"p-3 border border-gray-200 rounded-lg bg-white\"\n                              >\n                                <div className=\"flex items-center justify-between gap-3\">\n                                  <div className=\"font-medium text-gray-900\">{c.name}</div>\n                                  <span\n                                    className={`text-xs px-2 py-0.5 rounded-full border ${badgeClasses}`}\n                                  >\n                                    {level}\n                                  </span>\n                                </div>\n                                {c.whyLikely && (\n                                  <div className=\"mt-1 text-sm text-gray-700\">\n                                    {c.whyLikely}\n                                  </div>\n                                )}\n                              </li>\n                            )\n                          })\n                        })()}\n                      </ul>\n                    </section>\n                  )}\n\n                {/* Red flags */}\n                {Array.isArray(analysisResult?.redFlags) && analysisResult.redFlags.length > 0 && (\n                  <section>\n                    <h3 className=\"font-medium text-red-700 mb-2\">Red‚Äëflag signs to watch for</h3>\n                    <ul className=\"list-disc list-inside text-sm text-red-800 space-y-1\">\n                      {analysisResult.redFlags.map((rf, idx) => (\n                        <li key={idx}>{rf}</li>\n                      ))}\n                    </ul>\n                  </section>\n                )}\n\n                {/* Next steps */}\n                {Array.isArray(analysisResult?.nextSteps) && analysisResult.nextSteps.length > 0 && (\n                  <section>\n                    <h3 className=\"font-medium text-gray-900 mb-2\">What to do next</h3>\n                    <ul className=\"list-disc list-inside text-sm text-gray-700 space-y-1\">\n                      {analysisResult.nextSteps.map((step, idx) => (\n                        <li key={idx}>{step}</li>\n                      ))}\n                    </ul>\n                  </section>\n                )}\n\n                {/* Fallback detailed explanation if we have raw text but no structure */}\n                {!analysisResult?.summary &&\n                  (!analysisResult?.possibleCauses ||\n                    analysisResult.possibleCauses.length === 0) &&\n                  analysis && (\n                    <section>\n                      <p className=\"text-sm text-gray-700 whitespace-pre-line\">{analysis}</p>\n                    </section>\n                  )}\n\n                {/* Disclaimer */}\n                <div className=\"mt-2 text-xs text-gray-500 bg-yellow-50 border border-yellow-200 rounded-lg p-3\">\n                  <strong>‚ö†Ô∏è Important:</strong>{' '}\n                  {analysisResult?.disclaimer ||\n                    'This analysis is for informational purposes only and is not a substitute for professional medical advice, diagnosis, or treatment. Always seek the advice of a qualified healthcare provider with any questions you may have regarding a medical condition.'}\n                </div>\n              </div>\n            )}\n\n            {/* Medical image chat ‚Äì follows the analysis and is pre‚Äëaware of it.\n                We key it by a simple incrementing session so the chat fully resets\n                whenever a new analysis is completed. */}\n            {analysisResult && (\n              <div className=\"mt-6 bg-white rounded-lg shadow-sm border border-gray-200\">\n                <MedicalImageChat key={analysisSessionId} analysisResult={analysisResult} />\n              </div>\n            )}\n\n          </div>\n        </div>\n      </main>\n\n      {/* Mobile Bottom Spacing */}\n      <div className=\"h-20 md:h-0\" />\n\n      {/* Credit Modal */}\n      <CreditPurchaseModal\n        isOpen={showCreditsModal}\n        onClose={() => setShowCreditsModal(false)}\n        creditInfo={creditInfo}\n      />\n\n      {/* Mobile Bottom Navigation */}\n      <nav className=\"md:hidden fixed bottom-0 left-0 right-0 bg-white border-t border-gray-200 px-4 py-2 z-40\">\n        <div className=\"flex items-center justify-around\">\n          <Link href=\"/dashboard\" className=\"pressable ripple flex flex-col items-center py-2 px-1 min-w-0 flex-1\">\n            <div className=\"icon text-gray-400\">\n              <svg className=\"w-6 h-6\" fill=\"currentColor\" viewBox=\"0 0 24 24\"><path d=\"M3 13h8V3H3v10zm0 8h8v-6H3v6zm10 0h8V11h-8v10zm0-18v6h8V3h-8z\"/></svg>\n            </div>\n            <span className=\"label text-xs mt-1 truncate text-gray-400 font-medium\">Dashboard</span>\n          </Link>\n          <Link href=\"/insights\" className=\"pressable ripple flex flex-col items-center py-2 px-1 min-w-0 flex-1\">\n            <div className=\"icon text-gray-400\">\n              <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\"><path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z\"/></svg>\n            </div>\n            <span className=\"label text-xs mt-1 truncate text-gray-400 font-medium\">Insights</span>\n          </Link>\n          <Link href=\"/food\" className=\"pressable ripple flex flex-col items-center py-2 px-1 min-w-0 flex-1\">\n            <div className=\"icon text-gray-400\">\n              <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\"><path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10\"/></svg>\n            </div>\n            <span className=\"label text-xs mt-1 truncate text-gray-400 font-medium\">Food</span>\n          </Link>\n          <MobileMoreMenu />\n          <Link href=\"/settings\" className=\"pressable ripple flex flex-col items-center py-2 px-1 min-w-0 flex-1\">\n            <div className=\"icon text-gray-400\">\n              <Cog6ToothIcon className=\"w-6 h-6 flex-shrink-0\" style={{ minWidth: '24px', minHeight: '24px' }} />\n            </div>\n            <span className=\"label text-xs mt-1 truncate text-gray-400 font-medium\">Settings</span>\n          </Link>\n        </div>\n      </nav>\n    </div>\n  )\n}\n","truncated":false,"size":29076},{"path":"app/mood/activity/page.tsx","content":"'use client'\n\nimport { useEffect } from 'react'\nimport { useRouter } from 'next/navigation'\n\nexport default function MoodActivityRedirectPage() {\n  const router = useRouter()\n\n  useEffect(() => {\n    try {\n      sessionStorage.setItem('moodInfluencesExpanded', '1')\n    } catch {}\n    router.replace('/mood')\n  }, [router])\n\n  return (\n    <div className=\"min-h-screen bg-[#f8f9fa] dark:bg-gray-900 flex items-center justify-center px-6\">\n      <div className=\"max-w-md w-full bg-white dark:bg-gray-800 border border-slate-100 dark:border-gray-700 rounded-2xl p-6 text-center\">\n        <div className=\"text-lg font-bold text-slate-800 dark:text-white\">One moment‚Ä¶</div>\n        <div className=\"mt-2 text-sm text-slate-500 dark:text-gray-300\">\n          Taking you back to your mood check‚Äëin.\n        </div>\n      </div>\n    </div>\n  )\n}\n\n","truncated":false,"size":842},{"path":"app/mood/history/page.tsx","content":"'use client'\n\nimport React, { useEffect, useMemo, useRef, useState } from 'react'\nimport PageHeader from '@/components/PageHeader'\nimport MoodTabs from '@/components/mood/MoodTabs'\nimport MoodTrendGraph from '@/components/mood/MoodTrendGraph'\nimport { emojiForMoodValue } from '@/components/mood/moodScale'\nimport MoodPieChart from '@/components/mood/MoodPieChart'\nimport InsightsBottomNav from '@/app/insights/InsightsBottomNav'\n\nexport const dynamic = 'force-dynamic'\n\ntype MoodEntry = {\n  id: string\n  localDate: string\n  timestamp: string\n  mood: number\n  tags: any\n  note: string\n  context: any\n}\n\ntype EntriesResponse = {\n  range: { start: string; end: string }\n  entries: MoodEntry[]\n}\n\ntype InsightsResponse = { insights: any }\n\nfunction safeTags(tags: any): string[] {\n  if (Array.isArray(tags)) return tags.map((t) => String(t)).filter(Boolean)\n  if (typeof tags === 'string') {\n    try {\n      const parsed = JSON.parse(tags)\n      if (Array.isArray(parsed)) return parsed.map((t) => String(t)).filter(Boolean)\n    } catch {}\n  }\n  return []\n}\n\nfunction safeContext(ctx: any): Record<string, any> {\n  if (!ctx) return {}\n  if (typeof ctx === 'object') return ctx\n  if (typeof ctx === 'string') {\n    try {\n      const parsed = JSON.parse(ctx)\n      if (parsed && typeof parsed === 'object') return parsed\n    } catch {}\n  }\n  return {}\n}\n\nfunction asDateString(d: Date) {\n  const yyyy = d.getFullYear()\n  const mm = String(d.getMonth() + 1).padStart(2, '0')\n  const dd = String(d.getDate()).padStart(2, '0')\n  return `${yyyy}-${mm}-${dd}`\n}\n\nfunction parseLocalDate(localDate: string) {\n  return new Date(`${localDate}T00:00:00.000Z`)\n}\n\nfunction shiftDays(localDate: string, deltaDays: number) {\n  const d = parseLocalDate(localDate)\n  d.setUTCDate(d.getUTCDate() + deltaDays)\n  return asDateString(d)\n}\n\nfunction daysBetweenInclusive(start: string, end: string) {\n  const a = parseLocalDate(start)\n  const b = parseLocalDate(end)\n  const diff = Math.round((b.getTime() - a.getTime()) / (24 * 60 * 60 * 1000))\n  return Math.max(1, diff + 1)\n}\n\nfunction moodSummaryFromAverage(avg: number) {\n  if (avg >= 6.3) return 'Mostly Amazing'\n  if (avg >= 5.5) return 'Mostly Great'\n  if (avg >= 4.7) return 'Mostly Good'\n  if (avg >= 3.8) return 'Mostly Okay'\n  if (avg >= 2.8) return 'Mostly Meh'\n  if (avg >= 1.8) return 'Mostly Bad'\n  return 'Mostly Terrible'\n}\n\nfunction dotColorForAvg(avg: number | null) {\n  if (avg == null) return 'bg-gray-300 dark:bg-gray-600'\n  if (avg >= 5) return 'bg-green-400'\n  if (avg >= 3.5) return 'bg-yellow-400'\n  return 'bg-red-400'\n}\n\nfunction firstDayOfMonth(localDate: string) {\n  const d = parseLocalDate(localDate)\n  d.setUTCDate(1)\n  return asDateString(d)\n}\n\nfunction lastDayOfMonth(localDate: string) {\n  const d = parseLocalDate(localDate)\n  d.setUTCMonth(d.getUTCMonth() + 1)\n  d.setUTCDate(0)\n  return asDateString(d)\n}\n\nfunction mondayIndexFromUtcDate(localDate: string) {\n  // 0..6 where 0 is Monday\n  const d = parseLocalDate(localDate)\n  const dow = d.getUTCDay() // 0 Sun ... 6 Sat\n  return (dow + 6) % 7\n}\n\nfunction formatDayLabel(localDate: string) {\n  const today = asDateString(new Date())\n  const yesterday = shiftDays(today, -1)\n  if (localDate === today) return 'Today'\n  if (localDate === yesterday) return 'Yesterday'\n  const d = new Date(`${localDate}T00:00:00`)\n  return d.toLocaleDateString(undefined, { month: 'short', day: 'numeric' })\n}\n\nfunction entryDayKey(entry: MoodEntry) {\n  const localDate = String(entry.localDate || '').slice(0, 10)\n  if (localDate) return localDate\n  const ts = new Date(entry.timestamp)\n  if (!Number.isNaN(ts.getTime())) return asDateString(ts)\n  return ''\n}\n\nexport default function MoodHistoryPage() {\n  const [timeframe, setTimeframe] = useState<'day' | 'week' | 'month' | 'year'>('week')\n  const [chartMode, setChartMode] = useState<'pie' | 'wave'>('pie')\n  const [selectedDay, setSelectedDay] = useState<string | null>(null)\n  const [entries, setEntries] = useState<MoodEntry[]>([])\n  const [loading, setLoading] = useState(false)\n  const [error, setError] = useState<string | null>(null)\n  const [trendPct, setTrendPct] = useState<number | null>(null)\n  const [monthMap, setMonthMap] = useState(() => new Map())\n  const [insights, setInsights] = useState<InsightsResponse | null>(null)\n  const [streakDays, setStreakDays] = useState<number>(0)\n  const [expandedDays, setExpandedDays] = useState<Record<string, boolean>>({})\n  const [recentEntries, setRecentEntries] = useState<MoodEntry[]>([])\n  const weekScrollRef = useRef<HTMLDivElement | null>(null)\n\n  const [banner, setBanner] = useState<string | null>(null)\n  useEffect(() => {\n    try {\n      const params = new URLSearchParams(window.location.search || '')\n      if (params.get('saved') === '1') {\n        setBanner('Saved mood check‚Äëin.')\n        const t = setTimeout(() => setBanner(null), 2500)\n        return () => clearTimeout(t)\n      }\n    } catch {}\n  }, [])\n\n  useEffect(() => {\n    try {\n      const storedTimeframe = localStorage.getItem('moodHistoryTimeframe') as any\n      const storedChartMode = localStorage.getItem('moodHistoryChartMode') as any\n      if (storedTimeframe === 'day' || storedTimeframe === 'week' || storedTimeframe === 'month' || storedTimeframe === 'year') {\n        setTimeframe(storedTimeframe)\n      }\n      if (storedChartMode === 'pie' || storedChartMode === 'wave') {\n        setChartMode(storedChartMode)\n      }\n    } catch {}\n  }, [])\n\n  useEffect(() => {\n    try {\n      localStorage.setItem('moodHistoryTimeframe', timeframe)\n    } catch {}\n  }, [timeframe])\n\n  useEffect(() => {\n    try {\n      localStorage.setItem('moodHistoryChartMode', chartMode)\n    } catch {}\n  }, [chartMode])\n\n  useEffect(() => {\n    let ignore = false\n    const today = asDateString(new Date())\n\n    const range = (() => {\n      if (timeframe === 'day') {\n        const base = selectedDay || today\n        return { start: shiftDays(base, -6), end: base }\n      }\n      if (timeframe === 'week') return { start: shiftDays(today, -6), end: today }\n      if (timeframe === 'month') return { start: shiftDays(today, -29), end: today }\n      return { start: shiftDays(today, -364), end: today }\n    })()\n\n    const load = async () => {\n      let hasCache = false\n      try {\n        const cacheKey = `moodHistoryCache:${range.start}:${range.end}`\n        const cachedRaw = sessionStorage.getItem(cacheKey)\n        if (cachedRaw) {\n          const cached = JSON.parse(cachedRaw)\n          if (Array.isArray(cached?.entries)) {\n            setEntries(cached.entries)\n            hasCache = true\n          }\n        }\n      } catch {}\n\n      setLoading(!hasCache)\n      setError(null)\n      try {\n        const curRes = await fetch(`/api/mood/entries?start=${range.start}&end=${range.end}`, { cache: 'no-store' as any })\n        if (!curRes.ok) throw new Error('Failed to load')\n        const cur = (await curRes.json()) as EntriesResponse\n        if (ignore) return\n        setEntries(Array.isArray(cur.entries) ? cur.entries : [])\n        try {\n          const cacheKey = `moodHistoryCache:${range.start}:${range.end}`\n          sessionStorage.setItem(cacheKey, JSON.stringify({ entries: cur.entries, cachedAt: Date.now() }))\n        } catch {}\n        if (!ignore) setLoading(false)\n\n        const days = daysBetweenInclusive(range.start, range.end)\n        const prev = {\n          start: shiftDays(range.start, -days),\n          end: shiftDays(range.start, -1),\n        }\n\n        void (async () => {\n          try {\n            const prevRes = await fetch(`/api/mood/entries?start=${prev.start}&end=${prev.end}`, { cache: 'no-store' as any })\n            if (!prevRes.ok) throw new Error('Failed to load previous')\n            const prevData = (await prevRes.json()) as EntriesResponse\n            if (ignore) return\n            const avgMood = (list: MoodEntry[]) => {\n              const nums = list.map((e) => Number(e.mood)).filter((n) => Number.isFinite(n))\n              if (nums.length === 0) return null\n              return nums.reduce((a, b) => a + b, 0) / nums.length\n            }\n            const curAvg = avgMood(cur.entries || [])\n            const prevAvg = avgMood(prevData.entries || [])\n            if (curAvg != null && prevAvg != null && prevAvg > 0) {\n              setTrendPct(((curAvg - prevAvg) / prevAvg) * 100)\n            } else {\n              setTrendPct(null)\n            }\n          } catch {\n            if (!ignore) setTrendPct(null)\n          }\n        })()\n\n        void (async () => {\n          try {\n            const insightPeriod = timeframe === 'week' || timeframe === 'day' ? 'week' : 'month'\n            const insRes = await fetch(`/api/mood/insights?period=${insightPeriod}`, { cache: 'no-store' as any }).catch(() => null)\n            if (insRes && insRes.ok) {\n              const ins = (await insRes.json()) as InsightsResponse\n              if (!ignore) setInsights(ins)\n            }\n          } catch {}\n        })()\n      } catch (e: any) {\n        if (!ignore) setError(e?.message || 'Failed to load history')\n      } finally {\n        if (!ignore && !hasCache) setLoading(false)\n      }\n    }\n    load()\n    return () => { ignore = true }\n  }, [timeframe, selectedDay])\n\n  useEffect(() => {\n    let ignore = false\n    const today = asDateString(new Date())\n    const start = shiftDays(today, -6)\n    const end = today\n    const loadRecent = async () => {\n      try {\n        const res = await fetch(`/api/mood/entries?start=${start}&end=${end}`, { cache: 'no-store' as any })\n        if (!res.ok) return\n        const j = (await res.json()) as EntriesResponse\n        if (!ignore) setRecentEntries(Array.isArray(j.entries) ? j.entries : [])\n      } catch {}\n    }\n    loadRecent()\n    return () => { ignore = true }\n  }, [entries])\n\n  useEffect(() => {\n    let ignore = false\n    const today = asDateString(new Date())\n    const start = firstDayOfMonth(today)\n    const end = lastDayOfMonth(today)\n    const loadMonth = async () => {\n      try {\n        const res = await fetch(`/api/mood/entries?start=${start}&end=${end}`, { cache: 'no-store' as any })\n        if (!res.ok) return\n        const j = (await res.json()) as EntriesResponse\n        if (ignore) return\n        const m = new Map()\n        for (const e of j.entries || []) {\n          const d = String(e.localDate || '').slice(0, 10)\n          const v = Number(e.mood)\n          if (!d || !Number.isFinite(v)) continue\n          if (!m.has(d)) m.set(d, 0)\n          // store sum in temp map and count separately\n        }\n        // build averages\n        const sums = new Map()\n        for (const e of j.entries || []) {\n          const d = String(e.localDate || '').slice(0, 10)\n          const v = Number(e.mood)\n          if (!d || !Number.isFinite(v)) continue\n          const cur = sums.get(d) || { sum: 0, n: 0 }\n          cur.sum += v\n          cur.n += 1\n          sums.set(d, cur)\n        }\n        const avgs = new Map()\n        sums.forEach((v, d) => avgs.set(d, v.sum / v.n))\n        setMonthMap(avgs)\n      } catch {}\n    }\n    loadMonth()\n    return () => { ignore = true }\n  }, [])\n\n  useEffect(() => {\n    let ignore = false\n    const today = asDateString(new Date())\n    const start = shiftDays(today, -364)\n    const end = today\n    const loadStreak = async () => {\n      try {\n        const res = await fetch(`/api/mood/entries?start=${start}&end=${end}`, { cache: 'no-store' as any })\n        if (!res.ok) return\n        const j = (await res.json()) as EntriesResponse\n        if (ignore) return\n        const daysWithEntries = new Set<string>()\n        for (const e of j.entries || []) {\n          const d = String(e.localDate || '').slice(0, 10)\n          if (d) daysWithEntries.add(d)\n        }\n        let streak = 0\n        let cursor = today\n        while (daysWithEntries.has(cursor)) {\n          streak += 1\n          cursor = shiftDays(cursor, -1)\n          if (streak > 365) break\n        }\n        setStreakDays(streak)\n      } catch {}\n    }\n    loadStreak()\n    return () => { ignore = true }\n  }, [])\n\n  const chartEntries = useMemo(() => {\n    if (timeframe !== 'day' && timeframe !== 'week') return entries\n    if (timeframe === 'day' && selectedDay) return entries\n    if (recentEntries.length === 0) return entries\n    const merged = new Map<string, MoodEntry>()\n    for (const entry of entries) merged.set(entry.id, entry)\n    for (const entry of recentEntries) merged.set(entry.id, entry)\n    return Array.from(merged.values())\n  }, [entries, recentEntries, timeframe, selectedDay])\n\n  const points = useMemo(() => {\n    const xs = chartEntries\n      .slice()\n      .sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime())\n      .map((e) => ({ timestamp: e.timestamp, mood: Number(e.mood) }))\n    return xs\n  }, [chartEntries])\n\n  const daySeries = useMemo(() => {\n    const map = new Map<string, MoodEntry[]>()\n    for (const entry of chartEntries) {\n      const day = entryDayKey(entry)\n      if (!day) continue\n      if (!map.has(day)) map.set(day, [])\n      map.get(day)!.push(entry)\n    }\n\n    const today = asDateString(new Date())\n    const base = timeframe === 'day' ? (selectedDay || today) : today\n    const days = (timeframe === 'week' || timeframe === 'day')\n      ? Array.from({ length: 7 }, (_, i) => shiftDays(base, i - 6))\n      : Array.from(map.keys()).sort((a, b) => parseLocalDate(a).getTime() - parseLocalDate(b).getTime())\n\n    return days.map((day) => {\n      const items = (map.get(day) || []).slice().sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime())\n      return {\n        day,\n        label: formatDayLabel(day),\n        points: items.map((e) => ({ timestamp: e.timestamp, mood: Number(e.mood) })),\n      }\n    })\n  }, [chartEntries, timeframe, selectedDay])\n\n  const weekSummaryPoints = useMemo(() => {\n    if (timeframe !== 'week') return []\n    return daySeries.map((day) => {\n      const counts = new Map<number, number>()\n      for (const point of day.points) {\n        const value = Number(point.mood)\n        if (!Number.isFinite(value)) continue\n        counts.set(value, (counts.get(value) || 0) + 1)\n      }\n      let topMood: number | null = null\n      let topCount = -1\n      counts.forEach((count, mood) => {\n        if (count > topCount) {\n          topCount = count\n          topMood = mood\n        } else if (count === topCount && topMood != null && mood > topMood) {\n          topMood = mood\n        }\n      })\n      const stamp = new Date(`${day.day}T12:00:00`)\n      return {\n        timestamp: Number.isNaN(stamp.getTime()) ? `${day.day}T12:00:00` : stamp.toISOString(),\n        mood: topMood,\n        label: day.label,\n      }\n    })\n  }, [daySeries, timeframe])\n\n  useEffect(() => {\n    if (timeframe !== 'week' && timeframe !== 'day') return\n    if (loading) return\n    const el = weekScrollRef.current\n    if (!el) return\n    const scrollToEnd = () => {\n      const target = Math.max(0, el.scrollWidth - el.clientWidth)\n      el.scrollLeft = target\n    }\n    requestAnimationFrame(() => {\n      scrollToEnd()\n      setTimeout(scrollToEnd, 160)\n      setTimeout(scrollToEnd, 320)\n    })\n  }, [timeframe, daySeries.length, loading])\n\n  const recentGroups = useMemo(() => {\n    const source = timeframe === 'day'\n      ? (recentEntries.length ? recentEntries : chartEntries)\n      : chartEntries\n    const sorted = source\n      .slice()\n      .sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime())\n    const map = new Map<string, MoodEntry[]>()\n    const order: string[] = []\n    for (const entry of sorted) {\n      const day = entryDayKey(entry)\n      if (!day) continue\n      if (!map.has(day)) {\n        map.set(day, [])\n        order.push(day)\n      }\n      map.get(day)!.push(entry)\n    }\n    return order.slice(0, 3).map((day) => ({\n      day,\n      entries: (map.get(day) || []).slice().sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()),\n    }))\n  }, [chartEntries, recentEntries, timeframe])\n\n  const formatTime = (ts: any) => {\n    try {\n      const d = new Date(ts)\n      if (Number.isNaN(d.getTime())) return ''\n      return d.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' })\n    } catch {\n      return ''\n    }\n  }\n\n  const dailyAverages = useMemo(() => {\n    const sums = new Map()\n    for (const e of chartEntries) {\n      const d = String(e.localDate || '').slice(0, 10)\n      const v = Number(e.mood)\n      if (!d || !Number.isFinite(v)) continue\n      const cur = sums.get(d) || { sum: 0, n: 0 }\n      cur.sum += v\n      cur.n += 1\n      sums.set(d, cur)\n    }\n    const avg = new Map()\n    sums.forEach((v, d) => avg.set(d, v.sum / v.n))\n    return avg\n  }, [chartEntries])\n\n  const overallAverage = useMemo(() => {\n    const nums = chartEntries.map((e) => Number(e.mood)).filter((n) => Number.isFinite(n))\n    if (nums.length === 0) return null\n    return nums.reduce((a, b) => a + b, 0) / nums.length\n  }, [chartEntries])\n\n  const hasEntries = useMemo(() => {\n    if (timeframe === 'week') return weekSummaryPoints.some((p) => Number.isFinite(p.mood))\n    return points.length > 0\n  }, [timeframe, weekSummaryPoints, points.length])\n\n  const topMood = useMemo(() => {\n    const counts = new Map()\n    for (const e of chartEntries) {\n      const v = Number(e.mood)\n      if (!Number.isFinite(v)) continue\n      counts.set(v, (counts.get(v) || 0) + 1)\n    }\n    let best: { mood: number; n: number } | null = null\n    counts.forEach((n, mood) => {\n      if (!best || n > best.n) best = { mood, n }\n    })\n    return best\n  }, [chartEntries])\n\n  const topMoodValue = (topMood as any)?.mood as number | null\n  const topMoodCount = (topMood as any)?.n as number | null\n\n  const monthGrid = useMemo(() => {\n    const today = asDateString(new Date())\n    const start = firstDayOfMonth(today)\n    const end = lastDayOfMonth(today)\n    const daysInMonth = Number(end.slice(8, 10))\n    const pad = mondayIndexFromUtcDate(start)\n    const cells: any[] = []\n    for (let i = 0; i < pad; i++) cells.push({ type: 'pad' })\n    for (let day = 1; day <= daysInMonth; day++) {\n      const d = start.slice(0, 8) + String(day).padStart(2, '0')\n      cells.push({ type: 'day', date: d, day, avg: monthMap.get(d) ?? null })\n    }\n    return { cells, today }\n  }, [monthMap])\n\n  const insightCards = useMemo(() => {\n    const list: any[] = []\n    const by = insights?.insights || {}\n    const pushFirst = (key: string, icon: string, color: string) => {\n      const arr = (by as any)?.[key]\n      if (!Array.isArray(arr) || arr.length === 0) return\n      list.push({ title: arr[0].title, detail: arr[0].detail, icon, color })\n    }\n    pushFirst('sleep', 'bedtime', 'bg-purple-100 text-purple-600')\n    pushFirst('nutrition', 'restaurant', 'bg-green-100 text-green-600')\n    pushFirst('activity', 'directions_walk', 'bg-emerald-100 text-emerald-700')\n    pushFirst('stress', 'schedule', 'bg-blue-100 text-blue-600')\n    return list.slice(0, 6)\n  }, [insights])\n\n  return (\n    <div className=\"min-h-screen bg-gray-50 dark:bg-gray-900 pb-24\">\n      <PageHeader title=\"Mood\" backHref=\"/mood\" />\n      <MoodTabs />\n\n      <main className=\"max-w-3xl mx-auto px-4 py-6\">\n        {banner && (\n          <div className=\"mb-4 rounded-xl border border-green-200 bg-green-50 text-green-800 px-4 py-3 text-sm\">\n            {banner}\n          </div>\n        )}\n\n        <div className=\"bg-white dark:bg-gray-800 rounded-2xl shadow-sm border border-gray-100 dark:border-gray-700 p-5\">\n          <div className=\"flex h-12 w-full items-center justify-between rounded-full bg-white dark:bg-gray-800 p-1.5 shadow-sm border border-gray-100 dark:border-gray-700\">\n            {(['day', 'week', 'month', 'year'] as const).map((t) => {\n              const active = timeframe === t\n              const label = t === 'day' ? 'Day' : t[0].toUpperCase() + t.slice(1)\n              return (\n                <button\n                  key={t}\n                  type=\"button\"\n                  onClick={() => {\n                    setTimeframe(t)\n                    if (t !== 'day') setSelectedDay(null)\n                  }}\n                  className=\"relative flex flex-1 h-full items-center justify-center rounded-full transition-all\"\n                >\n                  <span className={`z-10 text-sm font-semibold ${active ? 'text-white' : 'text-gray-600 dark:text-gray-300'}`}>\n                    {label}\n                  </span>\n                  <span className={`absolute inset-0 rounded-full bg-helfi-green transition-all duration-300 ${active ? 'opacity-100 scale-100' : 'opacity-0 scale-95'}`} />\n                </button>\n              )\n            })}\n          </div>\n\n          <div className=\"mt-6\">\n            <div className=\"flex items-center justify-between mb-4\">\n              <div className=\"flex flex-col gap-1\">\n                <h3 className=\"text-gray-500 dark:text-gray-300 text-sm font-bold uppercase tracking-wider\">\n                  {chartMode === 'pie' ? 'Mood Breakdown' : 'Mood Wave'}\n                </h3>\n                <div className=\"flex items-baseline gap-2 flex-wrap\">\n                  <p className=\"text-3xl font-bold tracking-tight text-gray-900 dark:text-white\">\n                    {overallAverage == null ? 'No data yet' : moodSummaryFromAverage(overallAverage)}\n                  </p>\n                  {trendPct != null && (\n                    <span className=\"inline-flex items-center gap-1 text-helfi-green text-sm font-bold bg-helfi-green/10 px-2 py-0.5 rounded-full\">\n                      <span className=\"material-symbols-outlined text-sm leading-none\">trending_up</span>\n                      {Math.abs(trendPct).toFixed(0)}%\n                    </span>\n                  )}\n                </div>\n              </div>\n              <div className=\"flex items-center rounded-full border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 p-1\">\n                {(['pie', 'wave'] as const).map((mode) => {\n                  const active = chartMode === mode\n                  return (\n                    <button\n                      key={mode}\n                      type=\"button\"\n                      onClick={() => setChartMode(mode)}\n                      className={[\n                        'px-3 py-1 rounded-full text-xs font-semibold transition-colors',\n                        active ? 'bg-helfi-green text-white' : 'text-gray-600 dark:text-gray-300',\n                      ].join(' ')}\n                    >\n                      {mode === 'pie' ? 'Pie' : 'Wave'}\n                    </button>\n                  )\n                })}\n              </div>\n            </div>\n\n\t            {loading ? (\n\t              <div className=\"flex items-center justify-center py-12\">\n\t                <div className=\"animate-spin rounded-full h-8 w-8 border-b-2 border-helfi-green\"></div>\n\t              </div>\n\t            ) : error ? (\n\t              <div className=\"rounded-xl border border-red-200 bg-red-50 text-red-700 px-4 py-3 text-sm\">\n\t                {error}\n\t              </div>\n            ) : !hasEntries ? (\n\t              <div className=\"rounded-xl border border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-gray-800/60 text-gray-600 dark:text-gray-300 px-4 py-6 text-sm\">\n\t                No mood entries yet. Add your first check‚Äëin from the Mood tab.\n\t              </div>\n\t            ) : (\n                <div className=\"space-y-4\">\n                  {timeframe === 'day' ? (\n                    <div className=\"space-y-2\">\n                      <div className=\"text-xs text-gray-500 dark:text-gray-400\">\n                        Swipe left or right to view each day.\n                      </div>\n                      <div\n                        ref={weekScrollRef}\n                        className=\"flex gap-4 overflow-x-auto snap-x snap-mandatory pb-2 -mx-4 px-4 touch-pan-x\"\n                      >\n                        {daySeries.map((day) => (\n                          <div key={day.day} className=\"min-w-full snap-center\">\n                            <div className=\"text-sm font-semibold text-gray-800 dark:text-gray-100 mb-2\">\n                              {day.label}\n                            </div>\n                            <div className=\"relative h-[220px] w-full rounded-2xl bg-white dark:bg-gray-900 shadow-sm border border-gray-100 dark:border-gray-700 p-4 overflow-visible\">\n                              {chartMode === 'pie' ? (\n                                <MoodPieChart entries={day.points} />\n                              ) : (\n                                <MoodTrendGraph points={day.points} showTimeAxis />\n                              )}\n                            </div>\n                          </div>\n                        ))}\n                      </div>\n                    </div>\n                  ) : timeframe === 'week' ? (\n                    <div className=\"space-y-2\">\n                      <div className=\"text-xs text-gray-500 dark:text-gray-400\">\n                        Weekly summary of your most common mood each day.\n                      </div>\n                      <div className=\"relative h-[220px] w-full rounded-2xl bg-white dark:bg-gray-900 shadow-sm border border-gray-100 dark:border-gray-700 p-4 overflow-visible\">\n                        {chartMode === 'pie' ? (\n                          <MoodPieChart entries={chartEntries} />\n                        ) : (\n                          <MoodTrendGraph points={weekSummaryPoints} fillArea={false} spanGaps />\n                        )}\n                      </div>\n                    </div>\n                  ) : (\n                    <div className=\"relative h-[220px] w-full rounded-2xl bg-white dark:bg-gray-900 shadow-sm border border-gray-100 dark:border-gray-700 p-4 overflow-visible\">\n                      {chartMode === 'pie' ? (\n                        <MoodPieChart entries={entries} />\n                      ) : (\n                        <MoodTrendGraph points={points} />\n                      )}\n                    </div>\n                  )}\n                  <div className=\"rounded-2xl bg-white dark:bg-gray-900 border border-gray-100 dark:border-gray-700 p-4\">\n                    <div className=\"text-xs font-bold uppercase tracking-wider text-gray-500 dark:text-gray-300 mb-3\">\n                      Recent check‚Äëins\n                    </div>\n                    {recentGroups.length === 0 ? (\n                      <div className=\"text-sm text-gray-500 dark:text-gray-400\">\n                        No check‚Äëins yet.\n                      </div>\n                    ) : (\n                      <div className=\"space-y-2\">\n                        {recentGroups.map((group) => {\n                          const expanded = !!expandedDays[group.day]\n                          return (\n                            <div\n                              key={group.day}\n                              className=\"rounded-xl border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800/60 overflow-hidden\"\n                            >\n                              <button\n                                type=\"button\"\n                                onClick={() =>\n                                  setExpandedDays((prev) => ({\n                                    ...prev,\n                                    [group.day]: !prev[group.day],\n                                  }))\n                                }\n                                className=\"w-full flex items-center justify-between px-3 py-2\"\n                              >\n                                <div className=\"flex items-center gap-2\">\n                                  <span className=\"text-sm font-semibold text-gray-800 dark:text-gray-100\">\n                                    {formatDayLabel(group.day)}\n                                  </span>\n                                  <span className=\"text-xs text-gray-500 dark:text-gray-400\">\n                                    {group.entries.length} check‚Äëin{group.entries.length === 1 ? '' : 's'}\n                                  </span>\n                                </div>\n                                <span\n                                  className={[\n                                    'material-symbols-outlined text-base text-gray-500 transition-transform',\n                                    expanded ? 'rotate-180' : '',\n                                  ].join(' ')}\n                                >\n                                  expand_more\n                                </span>\n                              </button>\n                              {expanded && (\n                                <div className=\"flex flex-wrap gap-2 px-3 pb-3\">\n                                  {group.entries.map((e) => (\n                                    <div\n                                      key={e.id}\n                                      className=\"inline-flex items-center gap-2 rounded-full border border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-gray-800 px-3 py-2\"\n                                    >\n                                      <span className=\"text-lg leading-none\">{emojiForMoodValue(Number(e.mood))}</span>\n                                      <span className=\"text-sm font-semibold text-gray-800 dark:text-gray-200\">\n                                        {formatTime(e.timestamp)}\n                                      </span>\n                                    </div>\n                                  ))}\n                                </div>\n                              )}\n                            </div>\n                          )\n                        })}\n                      </div>\n                    )}\n                  </div>\n                </div>\n\t            )}\n\t          </div>\n\t        </div>\n\n        <div className=\"px-1 mt-6\">\n          <h3 className=\"text-gray-900 dark:text-white text-xl font-bold mb-4\">Highlights</h3>\n          <div className=\"grid grid-cols-2 gap-4\">\n            <div className=\"bg-white dark:bg-gray-800 rounded-2xl p-5 flex flex-col justify-between aspect-[4/3] relative overflow-hidden shadow-sm border border-gray-100 dark:border-gray-700\">\n              <div className=\"absolute top-0 right-0 p-4 opacity-10\">\n                <span className=\"text-6xl grayscale opacity-50\">{topMoodValue ? emojiForMoodValue(topMoodValue) : 'üôÇ'}</span>\n              </div>\n              <div>\n                <p className=\"text-gray-500 dark:text-gray-300 text-xs font-bold uppercase tracking-wider mb-1\">Top Mood</p>\n                <p className=\"text-gray-900 dark:text-white text-lg font-bold leading-tight\">\n                  {topMoodValue ? `‚Äú${emojiForMoodValue(topMoodValue)}‚Äù` : '‚Äî'}\n                </p>\n              </div>\n              <div className=\"flex items-end justify-between relative z-10\">\n                <span className=\"text-4xl\">{topMoodValue ? emojiForMoodValue(topMoodValue) : 'üôÇ'}</span>\n                <span className=\"text-xs font-medium text-helfi-green bg-helfi-green/10 px-2 py-1 rounded-lg\">\n                  {topMoodCount ? `${topMoodCount}x` : '0x'}\n                </span>\n              </div>\n            </div>\n\n            <div className=\"bg-white dark:bg-gray-800 rounded-2xl p-5 flex flex-col justify-between aspect-[4/3] relative overflow-hidden shadow-sm border border-gray-100 dark:border-gray-700\">\n              <div className=\"absolute -right-4 -bottom-4 bg-helfi-green/10 w-24 h-24 rounded-full blur-2xl\"></div>\n              <div>\n                <p className=\"text-gray-500 dark:text-gray-300 text-xs font-bold uppercase tracking-wider mb-1\">Streak</p>\n                <p className=\"text-gray-900 dark:text-white text-lg font-bold leading-tight\">On fire</p>\n              </div>\n              <div className=\"flex items-end gap-2 relative z-10\">\n                <span className=\"text-4xl\">üî•</span>\n                <span className=\"text-2xl font-bold text-helfi-green\">\n                  {streakDays} <span className=\"text-sm text-gray-500 dark:text-gray-300 font-normal\">days</span>\n                </span>\n              </div>\n            </div>\n          </div>\n        </div>\n\n        <div className=\"mt-8\">\n          <div className=\"flex items-center justify-between px-1 mb-3\">\n            <h3 className=\"text-gray-900 dark:text-white text-xl font-bold\">Insights</h3>\n            <a className=\"text-helfi-green text-xs font-bold uppercase tracking-wide hover:underline\" href=\"/mood/insights\">\n              View All\n            </a>\n          </div>\n          <div className=\"px-1 mb-3 text-sm text-gray-600 dark:text-gray-300\">\n            A quick look at possible patterns between your mood and things like sleep, meals, and activity.\n          </div>\n          <div className=\"flex overflow-x-auto no-scrollbar gap-4 px-1 pb-2\">\n            {insightCards.length === 0 ? (\n              <div className=\"min-w-[260px] bg-white dark:bg-gray-800 rounded-2xl p-5 border border-gray-100 dark:border-gray-700 shadow-sm text-sm text-gray-600 dark:text-gray-300\">\n                Add a few mood check‚Äëins to unlock insights.\n              </div>\n            ) : (\n              insightCards.map((c, idx) => (\n                <div key={idx} className=\"min-w-[260px] bg-white dark:bg-gray-800 rounded-2xl p-5 flex flex-col gap-3 border border-gray-100 dark:border-gray-700 shadow-sm\">\n                  <div className=\"flex items-center gap-2\">\n                    <div className={`w-8 h-8 rounded-full flex items-center justify-center ${c.color}`}>\n                      <span className=\"material-symbols-outlined text-lg\">{c.icon}</span>\n                    </div>\n                    <span className=\"text-gray-900 dark:text-white font-bold text-sm\">Pattern</span>\n                  </div>\n                  <p className=\"text-gray-600 dark:text-gray-300 text-sm leading-relaxed\">\n                    {c.detail}\n                  </p>\n                </div>\n              ))\n            )}\n          </div>\n        </div>\n\n        <div className=\"px-1 mt-8\">\n          <h3 className=\"text-gray-900 dark:text-white text-xl font-bold mb-4\">This Month</h3>\n          <div className=\"bg-white dark:bg-gray-800 rounded-2xl p-5 shadow-sm border border-gray-100 dark:border-gray-700\">\n            <div className=\"grid grid-cols-7 gap-y-4 gap-x-2 text-center mb-2\">\n              {['M', 'T', 'W', 'T', 'F', 'S', 'S'].map((d) => (\n                <span key={d} className=\"text-[10px] font-bold text-gray-500 dark:text-gray-300 uppercase\">{d}</span>\n              ))}\n              {monthGrid.cells.map((cell, idx) => {\n                if (cell.type === 'pad') {\n                  return <div key={`pad-${idx}`} className=\"aspect-square rounded-full flex items-center justify-center text-xs text-gray-300\" />\n                }\n                const isToday = cell.date === monthGrid.today\n                const avg = cell.avg\n                return (\n                  <button\n                    key={cell.date}\n                    type=\"button\"\n                    onClick={() => {\n                      setTimeframe('day')\n                      setSelectedDay(cell.date)\n                    }}\n                    className={[\n                      'aspect-square rounded-full flex items-center justify-center border transition-colors cursor-pointer',\n                      isToday ? 'bg-white dark:bg-gray-800 border-helfi-green ring-2 ring-helfi-green/20' : 'bg-gray-50 dark:bg-gray-900/40 border-gray-100 dark:border-gray-700 hover:border-helfi-green',\n                    ].join(' ')}\n                    aria-label={`Select ${cell.date}`}\n                  >\n                    {avg == null ? (\n                      <span className=\"text-xs text-gray-400 dark:text-gray-500\">{cell.day}</span>\n                    ) : (\n                      <div className={`w-2 h-2 rounded-full ${dotColorForAvg(avg)}`} />\n                    )}\n                  </button>\n                )\n              })}\n            </div>\n            <div className=\"flex items-center justify-center gap-4 mt-4\">\n              <div className=\"flex items-center gap-1.5\">\n                <div className=\"w-2 h-2 rounded-full bg-green-400\" />\n                <span className=\"text-[10px] text-gray-500 dark:text-gray-300\">Good</span>\n              </div>\n              <div className=\"flex items-center gap-1.5\">\n                <div className=\"w-2 h-2 rounded-full bg-yellow-400\" />\n                <span className=\"text-[10px] text-gray-500 dark:text-gray-300\">Okay</span>\n              </div>\n              <div className=\"flex items-center gap-1.5\">\n                <div className=\"w-2 h-2 rounded-full bg-red-400\" />\n                <span className=\"text-[10px] text-gray-500 dark:text-gray-300\">Bad</span>\n              </div>\n            </div>\n          </div>\n        </div>\n\n        <div className=\"mt-8\">\n          <h3 className=\"text-gray-900 dark:text-white text-xl font-bold mb-3 px-1\">Recent entries</h3>\n          <div className=\"space-y-3\">\n            {entries.slice(0, 12).map((e) => {\n              const tags = safeTags(e.tags)\n              const ctx = safeContext(e.context)\n              const when = new Date(e.timestamp)\n              const time = when.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })\n              const quick = [\n                ctx.intensityPercent != null ? `Intensity ${ctx.intensityPercent}%` : null,\n                ctx.sleepMinutes ? `Sleep ${Math.round(ctx.sleepMinutes / 6) / 10}h` : null,\n                ctx.stepsToday != null ? `${Number(ctx.stepsToday).toLocaleString()} steps` : null,\n              ].filter(Boolean) as string[]\n              return (\n                <details key={e.id} className=\"group bg-white dark:bg-gray-800 rounded-2xl p-4 shadow-sm border border-gray-100 dark:border-gray-700\">\n                  <summary className=\"list-none cursor-pointer select-none\">\n                    <div className=\"flex items-center gap-3\">\n                      <div className=\"w-12 h-12 rounded-full bg-helfi-green/10 flex items-center justify-center\">\n                        <span className=\"text-2xl\">{emojiForMoodValue(Number(e.mood))}</span>\n                      </div>\n                      <div className=\"flex-1 min-w-0\">\n                        <div className=\"flex items-center justify-between gap-2\">\n                          <div className=\"text-sm font-bold text-gray-900 dark:text-white truncate\">\n                            {e.localDate}\n                          </div>\n                          <div className=\"text-xs text-gray-500 dark:text-gray-300\">\n                            {time}\n                          </div>\n                        </div>\n                        {tags.length > 0 && (\n                          <div className=\"mt-2 flex flex-wrap gap-2\">\n                            {tags.slice(0, 4).map((t) => (\n                              <span key={t} className=\"px-3 py-1 rounded-full bg-gray-50 dark:bg-gray-900/40 border border-gray-100 dark:border-gray-700 text-xs text-gray-600 dark:text-gray-200\">\n                                {t}\n                              </span>\n                            ))}\n                          </div>\n                        )}\n                        {quick.length > 0 && (\n                          <div className=\"mt-2 text-xs text-gray-500 dark:text-gray-300\">\n                            {quick.join(' ¬∑ ')}\n                          </div>\n                        )}\n                      </div>\n                      <span className=\"material-symbols-outlined text-gray-400 transition-transform group-open:rotate-180\">expand_more</span>\n                    </div>\n                  </summary>\n\n                  <div className=\"mt-3 pt-3 border-t border-gray-100 dark:border-gray-700 space-y-2\">\n                    {e.note && (\n                      <div className=\"text-sm text-gray-700 dark:text-gray-200 whitespace-pre-line\">\n                        {e.note}\n                      </div>\n                    )}\n                    <div className=\"grid grid-cols-1 sm:grid-cols-2 gap-2 text-xs text-gray-600 dark:text-gray-300\">\n                      {ctx.sleepMinutes != null && <div>Sleep: {minutesToHours(ctx.sleepMinutes)}</div>}\n                      {ctx.stepsToday != null && <div>Steps: {Number(ctx.stepsToday).toLocaleString()}</div>}\n                      {ctx.mealsTodayCount != null && <div>Meals logged: {ctx.mealsTodayCount}</div>}\n                      {ctx.exerciseMinutesToday != null && <div>Exercise: {ctx.exerciseMinutesToday} min</div>}\n                      {ctx.intensityPercent != null && <div>Intensity: {ctx.intensityPercent}%</div>}\n                    </div>\n                  </div>\n                </details>\n              )\n            })}\n          </div>\n        </div>\n      </main>\n\n      <InsightsBottomNav />\n    </div>\n  )\n}\n\nfunction minutesToHours(minutes: number | null) {\n  if (!minutes) return '‚Äî'\n  const hrs = minutes / 60\n  return `${hrs.toFixed(1)} h`\n}\n","truncated":false,"size":41086},{"path":"app/mood/insights/page.tsx","content":"'use client'\n\nimport React, { useEffect, useMemo, useState } from 'react'\nimport PageHeader from '@/components/PageHeader'\nimport MoodTabs from '@/components/mood/MoodTabs'\nimport InsightsBottomNav from '@/app/insights/InsightsBottomNav'\n\nexport const dynamic = 'force-dynamic'\n\ntype Insight = {\n  id: string\n  title: string\n  detail: string\n  confidence: 'low' | 'medium' | 'high'\n  sampleSize: number\n}\n\ntype InsightsResponse = {\n  range: { start: string; end: string }\n  insights: {\n    sleep: Insight[]\n    nutrition: Insight[]\n    supplements: Insight[]\n    activity: Insight[]\n    stress: Insight[]\n  }\n  meta: { sampleSize: number }\n}\n\ntype Card = { id: string; title: string; detail: string; icon: string; color: string }\n\nfunction pickFirst(map: InsightsResponse['insights']) {\n  const cards: Card[] = []\n  const add = (key: keyof InsightsResponse['insights'], icon: string, color: string) => {\n    const arr = map[key]\n    if (!Array.isArray(arr) || arr.length === 0) return\n    cards.push({ id: `${key}-${arr[0].id}`, title: arr[0].title, detail: arr[0].detail, icon, color })\n  }\n  add('sleep', 'bedtime', 'bg-purple-100 text-purple-600')\n  add('nutrition', 'restaurant', 'bg-green-100 text-green-600')\n  add('activity', 'directions_walk', 'bg-emerald-100 text-emerald-700')\n  add('stress', 'schedule', 'bg-blue-100 text-blue-600')\n  return cards\n}\n\nexport default function MoodInsightsPage() {\n  const [period, setPeriod] = useState<'week' | 'month'>('month')\n  const [data, setData] = useState<InsightsResponse | null>(null)\n  const [loading, setLoading] = useState(false)\n  const [error, setError] = useState<string | null>(null)\n  const [showAll, setShowAll] = useState(false)\n\n  useEffect(() => {\n    let ignore = false\n    const load = async () => {\n      setLoading(true)\n      setError(null)\n      try {\n        const res = await fetch(`/api/mood/insights?period=${period}`, { cache: 'no-store' as any })\n        if (!res.ok) throw new Error('Failed to load insights')\n        const j = (await res.json()) as InsightsResponse\n        if (!ignore) setData(j)\n      } catch (e: any) {\n        if (!ignore) setError(e?.message || 'Failed to load insights')\n      } finally {\n        if (!ignore) setLoading(false)\n      }\n    }\n    load()\n    return () => { ignore = true }\n  }, [period])\n\n  const carousel = useMemo(() => {\n    if (!data) return []\n    return pickFirst(data.insights)\n  }, [data])\n\n  const allGroups = useMemo(() => {\n    if (!data) return [] as Array<{ label: string; items: Insight[] }>\n    return [\n      { label: 'Sleep', items: data.insights.sleep || [] },\n      { label: 'Meals', items: data.insights.nutrition || [] },\n      { label: 'Activity', items: data.insights.activity || [] },\n      { label: 'Timing', items: data.insights.stress || [] },\n    ]\n  }, [data])\n\n  return (\n    <div className=\"min-h-screen bg-gray-50 dark:bg-gray-900 pb-24\">\n      <PageHeader title=\"Mood Insights\" backHref=\"/mood\" />\n      <MoodTabs />\n\n      <main className=\"max-w-3xl mx-auto px-4 py-6\">\n        <div className=\"bg-white dark:bg-gray-800 rounded-2xl shadow-sm p-6 border border-gray-100 dark:border-gray-700\">\n          <div className=\"flex items-center justify-between gap-3\">\n            <div className=\"text-lg font-semibold text-gray-900 dark:text-white\">Insights</div>\n            <div className=\"flex items-center gap-2 shrink-0\">\n              <button\n                type=\"button\"\n                onClick={() => setPeriod('week')}\n                className={`px-4 py-2 rounded-full text-sm font-bold border transition-colors ${\n                  period === 'week'\n                    ? 'bg-helfi-green text-white border-helfi-green'\n                    : 'bg-white dark:bg-gray-800 text-gray-600 dark:text-gray-200 border-gray-200 dark:border-gray-700 hover:bg-gray-50 dark:hover:bg-gray-700/50'\n                }`}\n              >\n                Week\n              </button>\n              <button\n                type=\"button\"\n                onClick={() => setPeriod('month')}\n                className={`px-4 py-2 rounded-full text-sm font-bold border transition-colors ${\n                  period === 'month'\n                    ? 'bg-helfi-green text-white border-helfi-green'\n                    : 'bg-white dark:bg-gray-800 text-gray-600 dark:text-gray-200 border-gray-200 dark:border-gray-700 hover:bg-gray-50 dark:hover:bg-gray-700/50'\n                }`}\n              >\n                Month\n              </button>\n            </div>\n          </div>\n          <div className=\"mt-2 text-sm text-gray-500 dark:text-gray-300\">\n            This is a simple ‚Äúpattern finder‚Äù using your mood check‚Äëins alongside things like sleep, meals, and activity. It‚Äôs not medical advice.\n          </div>\n          <div className=\"mt-1 text-xs text-gray-500 dark:text-gray-400\">\n            The more you check in, the clearer this becomes.\n          </div>\n\n          {loading ? (\n            <div className=\"flex items-center justify-center py-12\">\n              <div className=\"animate-spin rounded-full h-8 w-8 border-b-2 border-helfi-green\"></div>\n            </div>\n          ) : error ? (\n            <div className=\"mt-4 rounded-xl border border-red-200 bg-red-50 text-red-700 px-4 py-3 text-sm\">\n              {error}\n            </div>\n          ) : !data || carousel.length === 0 ? (\n            <div className=\"mt-4 rounded-xl border border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-gray-800/60 text-gray-600 dark:text-gray-300 px-4 py-6 text-sm\">\n              No insights yet. Add a few mood check‚Äëins first.\n            </div>\n          ) : (\n            <div className=\"mt-6\">\n              <div className=\"flex items-center justify-between mb-3\">\n                <h3 className=\"text-gray-900 dark:text-white text-xl font-bold\">Highlights</h3>\n                <button\n                  type=\"button\"\n                  onClick={() => setShowAll((v) => !v)}\n                  className=\"text-helfi-green text-xs font-bold uppercase tracking-wide hover:underline\"\n                >\n                  {showAll ? 'Hide details' : 'View all'}\n                </button>\n              </div>\n              <div className=\"mb-3 text-xs text-gray-500 dark:text-gray-400\">\n                Based on {data.meta?.sampleSize ?? 0} day(s) of mood history in this view.\n              </div>\n              <div className=\"flex overflow-x-auto no-scrollbar gap-4 pb-2\">\n                {carousel.map((c) => (\n                  <div key={c.id} className=\"min-w-[260px] bg-white dark:bg-gray-800 rounded-2xl p-5 flex flex-col gap-3 border border-gray-100 dark:border-gray-700 shadow-sm\">\n                    <div className=\"flex items-center gap-2\">\n                      <div className={`w-8 h-8 rounded-full flex items-center justify-center ${c.color}`}>\n                        <span className=\"material-symbols-outlined text-lg\">{c.icon}</span>\n                      </div>\n                      <span className=\"text-gray-900 dark:text-white font-bold text-sm\">Insight</span>\n                    </div>\n                    <div className=\"text-gray-900 dark:text-white font-bold text-sm\">\n                      {c.title}\n                    </div>\n                    <p className=\"text-gray-600 dark:text-gray-300 text-sm leading-relaxed\">\n                      {c.detail}\n                    </p>\n                  </div>\n                ))}\n              </div>\n\n              {showAll && (\n                <div className=\"mt-6 space-y-4\">\n                  {allGroups.map((g) => (\n                    <div key={g.label}>\n                      <div className=\"text-xs font-bold uppercase tracking-wider text-gray-500 dark:text-gray-300 mb-2\">\n                        {g.label}\n                      </div>\n                      <div className=\"space-y-3\">\n                        {g.items.map((it) => (\n                          <div key={it.id} className=\"rounded-2xl border border-gray-100 dark:border-gray-700 bg-white dark:bg-gray-900 p-4 shadow-sm\">\n                            <div className=\"text-sm font-bold text-gray-900 dark:text-white\">{it.title}</div>\n                            <div className=\"mt-2 text-sm text-gray-600 dark:text-gray-300 leading-relaxed\">{it.detail}</div>\n                          </div>\n                        ))}\n                      </div>\n                    </div>\n                  ))}\n                </div>\n              )}\n            </div>\n          )}\n        </div>\n      </main>\n\n      <a\n        href=\"/mood\"\n        className=\"md:hidden fixed bottom-28 left-1/2 -translate-x-1/2 w-16 h-16 rounded-full bg-helfi-green text-white shadow-[0_0_15px_rgba(77,175,80,0.4)] flex items-center justify-center\"\n        aria-label=\"Add mood\"\n      >\n        <span className=\"material-symbols-outlined text-[32px]\">add</span>\n      </a>\n\n      <InsightsBottomNav />\n    </div>\n  )\n}\n","truncated":false,"size":8881},{"path":"app/mood/journal/page.tsx","content":"'use client'\n\nimport React, { useEffect, useMemo, useRef, useState } from 'react'\nimport PageHeader from '@/components/PageHeader'\nimport MoodTabs from '@/components/mood/MoodTabs'\nimport InsightsBottomNav from '@/app/insights/InsightsBottomNav'\n\nexport const dynamic = 'force-dynamic'\n\ntype JournalEntry = {\n  id: string\n  localDate: string\n  title: string\n  content: string\n  images: any\n  tags?: any\n  audio?: any\n  prompt?: string\n  template?: string\n  createdAt: string\n}\n\nconst PROMPTS = [\n  'What went well today?',\n  'What felt hard today?',\n  'What am I grateful for?',\n  'What do I need tomorrow?',\n  'What surprised me today?',\n]\n\nconst TEMPLATES = [\n  {\n    name: 'Daily reflection',\n    body: '<p><strong>Wins</strong></p><p><br></p><p><strong>Challenges</strong></p><p><br></p><p><strong>What I learned</strong></p><p><br></p>',\n  },\n  {\n    name: 'Gratitude',\n    body: '<p><strong>Today I am grateful for...</strong></p><p><br></p><p><strong>Someone I appreciate</strong></p><p><br></p><p><strong>One small win</strong></p><p><br></p>',\n  },\n  {\n    name: 'Stress check',\n    body: '<p><strong>What caused stress?</strong></p><p><br></p><p><strong>How I responded</strong></p><p><br></p><p><strong>What could help next time</strong></p><p><br></p>',\n  },\n]\n\nfunction asDateString(d: Date) {\n  const yyyy = d.getFullYear()\n  const mm = String(d.getMonth() + 1).padStart(2, '0')\n  const dd = String(d.getDate()).padStart(2, '0')\n  return `${yyyy}-${mm}-${dd}`\n}\n\nfunction formatDateLabel(localDate: string) {\n  const today = asDateString(new Date())\n  const yesterday = asDateString(new Date(Date.now() - 24 * 60 * 60 * 1000))\n  if (localDate === today) return 'Today'\n  if (localDate === yesterday) return 'Yesterday'\n  const d = new Date(`${localDate}T00:00:00`)\n  return d.toLocaleDateString(undefined, { month: 'short', day: 'numeric' })\n}\n\nfunction formatDateLong(localDate: string) {\n  const d = new Date(`${localDate}T00:00:00`)\n  if (Number.isNaN(d.getTime())) return localDate\n  return d.toLocaleDateString(undefined, { month: 'short', day: 'numeric', year: 'numeric' })\n}\n\nfunction stripHtml(html: string) {\n  return html.replace(/<[^>]*>/g, ' ').replace(/\\s+/g, ' ').trim()\n}\n\nfunction normalizeImages(raw: any): string[] {\n  if (Array.isArray(raw)) return raw.filter((item) => typeof item === 'string' && item.trim())\n  if (typeof raw === 'string') {\n    try {\n      const parsed = JSON.parse(raw)\n      if (Array.isArray(parsed)) {\n        return parsed.filter((item) => typeof item === 'string' && item.trim())\n      }\n    } catch {}\n  }\n  return []\n}\n\nfunction normalizeTags(raw: any): string[] {\n  if (Array.isArray(raw)) return raw.filter((item) => typeof item === 'string' && item.trim())\n  if (typeof raw === 'string') {\n    try {\n      const parsed = JSON.parse(raw)\n      if (Array.isArray(parsed)) {\n        return parsed.filter((item) => typeof item === 'string' && item.trim())\n      }\n    } catch {}\n  }\n  return []\n}\n\nfunction formatSeconds(total: number) {\n  const mins = Math.floor(total / 60)\n  const secs = total % 60\n  return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`\n}\n\nexport default function MoodJournalPage() {\n  const [entries, setEntries] = useState<JournalEntry[]>([])\n  const [loading, setLoading] = useState(false)\n  const [saving, setSaving] = useState(false)\n  const [uploading, setUploading] = useState(false)\n  const [uploadingAudio, setUploadingAudio] = useState(false)\n  const [recording, setRecording] = useState(false)\n  const [recordSeconds, setRecordSeconds] = useState(0)\n  const [error, setError] = useState<string | null>(null)\n  const [notice, setNotice] = useState<string | null>(null)\n\n  const [title, setTitle] = useState('')\n  const [localDate, setLocalDate] = useState(asDateString(new Date()))\n  const [contentHtml, setContentHtml] = useState('')\n  const [images, setImages] = useState<string[]>([])\n  const [audioClips, setAudioClips] = useState<string[]>([])\n  const [tags, setTags] = useState<string[]>([])\n  const [tagInput, setTagInput] = useState('')\n  const [selectedPrompt, setSelectedPrompt] = useState('')\n  const [selectedTemplate, setSelectedTemplate] = useState('')\n  const [editingId, setEditingId] = useState<string | null>(null)\n  const [searchTerm, setSearchTerm] = useState('')\n\n  const editorRef = useRef<HTMLDivElement | null>(null)\n  const selectionRef = useRef<Range | null>(null)\n  const fileInputRef = useRef<HTMLInputElement | null>(null)\n  const dateInputRef = useRef<HTMLInputElement | null>(null)\n  const mediaRecorderRef = useRef<MediaRecorder | null>(null)\n  const recordTimerRef = useRef<ReturnType<typeof setInterval> | null>(null)\n\n  const loadEntries = async (query?: string) => {\n    setLoading(true)\n    setError(null)\n    try {\n      const q = query?.trim()\n      const url = q\n        ? `/api/mood/journal/entries?limit=50&q=${encodeURIComponent(q)}`\n        : '/api/mood/journal/entries?limit=50'\n      const res = await fetch(url, { cache: 'no-store' as any })\n      if (!res.ok) throw new Error('Failed to load journal')\n      const data = await res.json()\n      setEntries(Array.isArray(data?.entries) ? data.entries : [])\n    } catch (e: any) {\n      setError(e?.message || 'Failed to load journal')\n    } finally {\n      setLoading(false)\n    }\n  }\n\n  useEffect(() => {\n    loadEntries()\n  }, [])\n\n  useEffect(() => {\n    const handle = setTimeout(() => {\n      loadEntries(searchTerm)\n    }, 300)\n    return () => clearTimeout(handle)\n  }, [searchTerm])\n\n  useEffect(() => {\n    return () => {\n      if (recordTimerRef.current) clearInterval(recordTimerRef.current)\n      if (mediaRecorderRef.current && mediaRecorderRef.current.state !== 'inactive') {\n        mediaRecorderRef.current.stop()\n      }\n    }\n  }, [])\n\n  useEffect(() => {\n    const handleSelectionChange = () => {\n      const el = editorRef.current\n      const sel = window.getSelection()\n      if (!el || !sel || sel.rangeCount === 0) return\n      const range = sel.getRangeAt(0)\n      if (!el.contains(range.startContainer)) return\n      selectionRef.current = range.cloneRange()\n    }\n    document.addEventListener('selectionchange', handleSelectionChange)\n    return () => document.removeEventListener('selectionchange', handleSelectionChange)\n  }, [])\n\n  const syncSelectionRef = () => {\n    const el = editorRef.current\n    const sel = window.getSelection()\n    if (!el || !sel || sel.rangeCount === 0) return\n    const range = sel.getRangeAt(0)\n    if (!el.contains(range.startContainer)) return\n    selectionRef.current = range.cloneRange()\n  }\n\n  const restoreEditorSelection = () => {\n    const el = editorRef.current\n    const range = selectionRef.current\n    const sel = window.getSelection()\n    if (!el || !range || !sel) return false\n    if (!el.contains(range.startContainer)) return false\n    sel.removeAllRanges()\n    sel.addRange(range)\n    return true\n  }\n\n  const ensureEditorSelection = () => {\n    const el = editorRef.current\n    if (!el) return\n    el.focus()\n    if (!el.innerHTML || el.innerHTML === '<br>') {\n      el.innerHTML = '<p><br></p>'\n    }\n    if (restoreEditorSelection()) return\n    const sel = window.getSelection()\n    if (!sel) return\n    if (sel.rangeCount === 0 || !el.contains(sel.anchorNode)) {\n      const range = document.createRange()\n      range.selectNodeContents(el)\n      range.collapse(false)\n      sel.removeAllRanges()\n      sel.addRange(range)\n    }\n    syncSelectionRef()\n  }\n\n  const insertHtmlAtSelection = (html: string) => {\n    const el = editorRef.current\n    if (!el) return false\n    const sel = window.getSelection()\n    if (!sel || sel.rangeCount === 0) return false\n    const range = sel.getRangeAt(0)\n    if (!el.contains(range.startContainer)) return false\n    range.deleteContents()\n    const temp = document.createElement('div')\n    temp.innerHTML = html\n    const frag = document.createDocumentFragment()\n    let node: ChildNode | null = null\n    let lastNode: ChildNode | null = null\n    while ((node = temp.firstChild)) {\n      lastNode = frag.appendChild(node)\n    }\n    range.insertNode(frag)\n    if (lastNode) {\n      range.setStartAfter(lastNode)\n      range.collapse(true)\n      sel.removeAllRanges()\n      sel.addRange(range)\n    }\n    selectionRef.current = range.cloneRange()\n    return true\n  }\n\n  const wrapSelection = (tag: 'strong' | 'em' | 'u') => {\n    const el = editorRef.current\n    if (!el) return false\n    const sel = window.getSelection()\n    if (!sel || sel.rangeCount === 0) return false\n    const range = sel.getRangeAt(0)\n    if (!el.contains(range.startContainer)) return false\n    const wrapper = document.createElement(tag)\n    const selectedText = range.toString()\n    range.deleteContents()\n    if (selectedText) {\n      wrapper.textContent = selectedText\n      range.insertNode(wrapper)\n      range.setStartAfter(wrapper)\n      range.collapse(true)\n    } else {\n      const zwsp = document.createTextNode('\\u200B')\n      wrapper.appendChild(zwsp)\n      range.insertNode(wrapper)\n      range.setStart(zwsp, 1)\n      range.collapse(true)\n    }\n    sel.removeAllRanges()\n    sel.addRange(range)\n    selectionRef.current = range.cloneRange()\n    return true\n  }\n\n  const insertListElement = (ordered: boolean) => {\n    const el = editorRef.current\n    if (!el) return false\n    const sel = window.getSelection()\n    if (!sel || sel.rangeCount === 0) return false\n    const range = sel.getRangeAt(0)\n    if (!el.contains(range.startContainer)) return false\n    range.deleteContents()\n    const list = document.createElement(ordered ? 'ol' : 'ul')\n    const li = document.createElement('li')\n    li.appendChild(document.createElement('br'))\n    list.appendChild(li)\n    range.insertNode(list)\n    range.setStart(li, 0)\n    range.collapse(true)\n    sel.removeAllRanges()\n    sel.addRange(range)\n    selectionRef.current = range.cloneRange()\n    return true\n  }\n\n  const insertLineBreak = () => {\n    const el = editorRef.current\n    if (!el) return false\n    const sel = window.getSelection()\n    if (!sel || sel.rangeCount === 0) return false\n    const range = sel.getRangeAt(0)\n    if (!el.contains(range.startContainer)) return false\n    range.deleteContents()\n    const br = document.createElement('br')\n    range.insertNode(br)\n    range.setStartAfter(br)\n    range.collapse(true)\n    sel.removeAllRanges()\n    sel.addRange(range)\n    selectionRef.current = range.cloneRange()\n    return true\n  }\n\n  const handleCommand = (command: string) => {\n    const el = editorRef.current\n    if (!el) return\n    ensureEditorSelection()\n    const before = el.innerHTML\n    let ok = document.execCommand(command)\n    const isListCommand = command === 'insertUnorderedList' || command === 'insertOrderedList'\n    if (isListCommand && before === el.innerHTML) ok = false\n    if (!ok) {\n      if (command === 'bold') ok = wrapSelection('strong')\n      if (command === 'italic') ok = wrapSelection('em')\n      if (command === 'underline') ok = wrapSelection('u')\n      if (command === 'insertUnorderedList') ok = insertListElement(false)\n      if (command === 'insertOrderedList') ok = insertListElement(true)\n    }\n    if (!ok) {\n      if (command === 'insertUnorderedList') {\n        insertHtmlAtSelection('<ul><li><br></li></ul>')\n      } else if (command === 'insertOrderedList') {\n        insertHtmlAtSelection('<ol><li><br></li></ol>')\n      }\n    }\n    setContentHtml(el.innerHTML)\n    syncSelectionRef()\n  }\n\n  const handleEditorKeyDown = (event: React.KeyboardEvent<HTMLDivElement>) => {\n    if (event.key !== 'Enter') return\n    const el = editorRef.current\n    if (!el) return\n    const sel = window.getSelection()\n    if (!sel || sel.rangeCount === 0 || !el.contains(sel.anchorNode)) return\n    const before = el.innerHTML\n    const execOk = document.execCommand('insertParagraph') || document.execCommand('insertLineBreak')\n    if (execOk && el.innerHTML !== before) {\n      setContentHtml(el.innerHTML)\n      syncSelectionRef()\n      event.preventDefault()\n      return\n    }\n    let node: Node | null = sel.anchorNode\n    while (node && node !== el) {\n      if (node.nodeName === 'LI') return\n      node = node.parentNode\n    }\n    if (insertLineBreak()) {\n      setContentHtml(el.innerHTML)\n      event.preventDefault()\n    }\n  }\n\n  const insertHtml = (html: string) => {\n    const el = editorRef.current\n    if (!el) return\n    ensureEditorSelection()\n    const ok = document.execCommand('insertHTML', false, html)\n    if (!ok && !insertHtmlAtSelection(html)) {\n      el.innerHTML = `${el.innerHTML}${html}`\n    }\n    setContentHtml(el.innerHTML)\n    syncSelectionRef()\n  }\n\n  const removePromptBlock = (prompt?: string) => {\n    const el = editorRef.current\n    if (!el) return\n    const marked = Array.from(el.querySelectorAll('[data-journal-prompt=\"true\"]'))\n    if (marked.length > 0) {\n      marked.forEach((node) => node.remove())\n    } else if (prompt) {\n      const candidates = Array.from(el.querySelectorAll('p'))\n      const match = candidates.find((node) => node.textContent?.trim() === prompt)\n      if (match) match.remove()\n    }\n    setContentHtml(el.innerHTML)\n    syncSelectionRef()\n  }\n\n  const applyPrompt = (prompt: string) => {\n    removePromptBlock(selectedPrompt)\n    setSelectedPrompt(prompt)\n    insertHtml(`<p data-journal-prompt=\"true\"><strong>${prompt}</strong></p><p><br></p>`)\n  }\n\n  const clearPrompt = () => {\n    removePromptBlock(selectedPrompt)\n    setSelectedPrompt('')\n  }\n\n  const clearEditor = () => {\n    setContentHtml('')\n    if (editorRef.current) editorRef.current.innerHTML = ''\n    ensureEditorSelection()\n  }\n\n  const applyTemplate = (template: typeof TEMPLATES[number]) => {\n    setSelectedTemplate(template.name)\n    insertHtml(template.body)\n  }\n\n  const clearTemplate = () => {\n    setSelectedTemplate('')\n    clearEditor()\n  }\n\n  const handleImagePick = () => {\n    fileInputRef.current?.click()\n  }\n\n  const handleImages = async (files: FileList | null) => {\n    if (!files?.length) return\n    setUploading(true)\n    setError(null)\n    try {\n      const uploads = Array.from(files).slice(0, 6)\n      for (const file of uploads) {\n        const formData = new FormData()\n        formData.append('image', file)\n        const res = await fetch('/api/mood/journal/upload', {\n          method: 'POST',\n          body: formData,\n        })\n        if (!res.ok) {\n          const msg = await res.json().catch(() => null)\n          throw new Error(msg?.error || 'Upload failed')\n        }\n        const data = await res.json()\n        if (data?.url) {\n          setImages((prev) => [...prev, data.url])\n        }\n      }\n    } catch (e: any) {\n      setError(e?.message || 'Failed to upload image')\n    } finally {\n      setUploading(false)\n      if (fileInputRef.current) fileInputRef.current.value = ''\n    }\n  }\n\n  const uploadAudioBlob = async (blob: Blob) => {\n    setUploadingAudio(true)\n    setError(null)\n    try {\n      const file = new File([blob], `voice-note-${Date.now()}.webm`, { type: blob.type || 'audio/webm' })\n      const formData = new FormData()\n      formData.append('audio', file)\n      const res = await fetch('/api/mood/journal/upload-audio', {\n        method: 'POST',\n        body: formData,\n      })\n      if (!res.ok) {\n        const msg = await res.json().catch(() => null)\n        throw new Error(msg?.error || 'Audio upload failed')\n      }\n      const data = await res.json()\n      if (data?.url) {\n        setAudioClips((prev) => [...prev, data.url])\n      }\n    } catch (e: any) {\n      setError(e?.message || 'Failed to upload audio')\n    } finally {\n      setUploadingAudio(false)\n    }\n  }\n\n  const startRecording = async () => {\n    if (recording) return\n    setError(null)\n    try {\n      if (typeof MediaRecorder === 'undefined' || !navigator.mediaDevices?.getUserMedia) {\n        setError('Voice notes are not supported on this device.')\n        return\n      }\n      const stream = await navigator.mediaDevices.getUserMedia({ audio: true })\n      const recorder = new MediaRecorder(stream)\n      const chunks: BlobPart[] = []\n      recorder.ondataavailable = (event) => {\n        if (event.data.size > 0) chunks.push(event.data)\n      }\n      recorder.onstop = async () => {\n        stream.getTracks().forEach((track) => track.stop())\n        const blob = new Blob(chunks, { type: recorder.mimeType || 'audio/webm' })\n        if (blob.size > 0) {\n          await uploadAudioBlob(blob)\n        }\n      }\n      recorder.start()\n      mediaRecorderRef.current = recorder\n      setRecording(true)\n      setRecordSeconds(0)\n      if (recordTimerRef.current) clearInterval(recordTimerRef.current)\n      recordTimerRef.current = setInterval(() => setRecordSeconds((prev) => prev + 1), 1000)\n    } catch (e) {\n      setError('Microphone permission was not granted.')\n    }\n  }\n\n  const stopRecording = () => {\n    const recorder = mediaRecorderRef.current\n    if (recorder && recorder.state !== 'inactive') recorder.stop()\n    mediaRecorderRef.current = null\n    setRecording(false)\n    if (recordTimerRef.current) {\n      clearInterval(recordTimerRef.current)\n      recordTimerRef.current = null\n    }\n  }\n\n  const handleAddTag = () => {\n    const value = tagInput.trim()\n    if (!value) return\n    if (tags.includes(value)) {\n      setTagInput('')\n      return\n    }\n    setTags((prev) => [...prev, value])\n    setTagInput('')\n  }\n\n  const handleSave = async () => {\n    const content = editorRef.current?.innerHTML?.trim() || ''\n    if (!title.trim() && !content && images.length === 0 && audioClips.length === 0) {\n      setError('Add a title, some text, a photo, or a voice note first.')\n      return\n    }\n    setSaving(true)\n    setError(null)\n    try {\n      const payload = {\n        title,\n        content,\n        images,\n        audio: audioClips,\n        tags,\n        prompt: selectedPrompt,\n        template: selectedTemplate,\n        localDate,\n      }\n      const url = editingId ? `/api/mood/journal/entries/${editingId}` : '/api/mood/journal/entries'\n      const res = await fetch(url, {\n        method: editingId ? 'PUT' : 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(payload),\n      })\n      if (!res.ok) {\n        const msg = await res.json().catch(() => null)\n        throw new Error(msg?.error || 'Failed to save entry')\n      }\n      setTitle('')\n      setContentHtml('')\n      setImages([])\n      setAudioClips([])\n      setTags([])\n      setSelectedPrompt('')\n      setSelectedTemplate('')\n      setEditingId(null)\n      if (editorRef.current) editorRef.current.innerHTML = ''\n      setNotice(editingId ? 'Journal entry updated.' : 'Journal entry saved.')\n      setTimeout(() => setNotice(null), 2000)\n      loadEntries(searchTerm)\n    } catch (e: any) {\n      setError(e?.message || 'Failed to save entry')\n    } finally {\n      setSaving(false)\n    }\n  }\n\n  const handleEdit = (entry: JournalEntry) => {\n    setEditingId(entry.id)\n    setTitle(entry.title || '')\n    setLocalDate(entry.localDate || asDateString(new Date()))\n    setImages(normalizeImages(entry.images))\n    setAudioClips(normalizeImages(entry.audio))\n    setTags(normalizeTags(entry.tags))\n    setSelectedPrompt(entry.prompt || '')\n    setSelectedTemplate(entry.template || '')\n    const html = entry.content || ''\n    setContentHtml(html)\n    if (editorRef.current) editorRef.current.innerHTML = html\n  }\n\n  const handleCancelEdit = () => {\n    setEditingId(null)\n    setTitle('')\n    setContentHtml('')\n    setImages([])\n    setAudioClips([])\n    setTags([])\n    setSelectedPrompt('')\n    setSelectedTemplate('')\n    setLocalDate(asDateString(new Date()))\n    if (editorRef.current) editorRef.current.innerHTML = ''\n  }\n\n  const handleDelete = async (entryId: string) => {\n    if (!window.confirm('Delete this journal entry?')) return\n    setError(null)\n    try {\n      const res = await fetch(`/api/mood/journal/entries/${entryId}`, { method: 'DELETE' })\n      if (!res.ok) {\n        const msg = await res.json().catch(() => null)\n        throw new Error(msg?.error || 'Failed to delete entry')\n      }\n      if (editingId === entryId) handleCancelEdit()\n      loadEntries(searchTerm)\n    } catch (e: any) {\n      setError(e?.message || 'Failed to delete entry')\n    }\n  }\n\n  const visibleEntries = useMemo(() => entries, [entries])\n  const dateLabel = useMemo(() => formatDateLong(localDate), [localDate])\n\n  return (\n    <div className=\"min-h-screen bg-gray-50 dark:bg-gray-900 pb-24 overflow-x-hidden\">\n      <PageHeader title=\"Mood\" backHref=\"/mood\" />\n      <MoodTabs />\n\n      <main className=\"max-w-3xl mx-auto px-4 py-6 space-y-6 touch-pan-y overscroll-x-none\">\n        {notice && (\n          <div className=\"rounded-xl border border-green-200 bg-green-50 text-green-800 px-4 py-3 text-sm\">\n            {notice}\n          </div>\n        )}\n        {error && (\n          <div className=\"rounded-xl border border-red-200 bg-red-50 text-red-700 px-4 py-3 text-sm\">\n            {error}\n          </div>\n        )}\n\n        <div className=\"bg-white dark:bg-gray-800 rounded-2xl shadow-sm border border-gray-100 dark:border-gray-700 p-5 space-y-4\">\n          <div className=\"flex items-start justify-between gap-3\">\n            <div>\n              <h2 className=\"text-lg font-bold text-gray-900 dark:text-white\">Journal</h2>\n              <p className=\"text-xs text-gray-500 dark:text-gray-400\">Write it out, add photos, and keep the story of your day.</p>\n            </div>\n            <div className=\"relative\">\n              <button\n                type=\"button\"\n                onClick={() => {\n                  const el = dateInputRef.current\n                  if (!el) return\n                  if (typeof (el as any).showPicker === 'function') {\n                    ;(el as any).showPicker()\n                  } else {\n                    el.click()\n                  }\n                }}\n                className=\"rounded-xl border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-900 px-3 py-2 text-xs font-semibold text-gray-700 dark:text-gray-200 whitespace-nowrap\"\n              >\n                {dateLabel}\n              </button>\n              <input\n                ref={dateInputRef}\n                type=\"date\"\n                value={localDate}\n                onChange={(e) => setLocalDate(e.target.value)}\n                className=\"absolute inset-0 opacity-0 pointer-events-none\"\n                aria-label=\"Journal date\"\n              />\n            </div>\n          </div>\n\n          <input\n            type=\"text\"\n            placeholder=\"Entry title\"\n            value={title}\n            onChange={(e) => setTitle(e.target.value)}\n            className=\"w-full rounded-xl border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-900 px-4 py-3 text-sm text-gray-900 dark:text-white focus:outline-none focus:ring-4 focus:ring-helfi-green/10\"\n          />\n\n          <div className=\"space-y-2\">\n            <div className=\"text-xs font-bold uppercase tracking-wider text-gray-500 dark:text-gray-300\">Prompts</div>\n            <div className=\"flex flex-wrap gap-2\">\n              {PROMPTS.map((prompt) => (\n                <button\n                  key={prompt}\n                  type=\"button\"\n                  onClick={() => applyPrompt(prompt)}\n                  className={`rounded-full border px-3 py-1 text-xs font-semibold transition-colors ${\n                    selectedPrompt === prompt\n                      ? 'border-helfi-green text-helfi-green'\n                      : 'border-gray-200 dark:border-gray-700 text-gray-600 dark:text-gray-200'\n                  }`}\n                >\n                  {prompt}\n                </button>\n              ))}\n              {selectedPrompt && (\n                <button\n                  type=\"button\"\n                  onClick={clearPrompt}\n                  className=\"rounded-full border border-red-200 bg-red-50 px-3 py-1 text-xs font-semibold text-red-600\"\n                >\n                  Clear prompt\n                </button>\n              )}\n            </div>\n          </div>\n\n          <div className=\"space-y-2\">\n            <div className=\"text-xs font-bold uppercase tracking-wider text-gray-500 dark:text-gray-300\">Templates</div>\n            <div className=\"flex flex-wrap gap-2\">\n              {TEMPLATES.map((template) => (\n                <button\n                  key={template.name}\n                  type=\"button\"\n                  onClick={() => applyTemplate(template)}\n                  className={`rounded-full border px-3 py-1 text-xs font-semibold transition-colors ${\n                    selectedTemplate === template.name\n                      ? 'border-helfi-green text-helfi-green'\n                      : 'border-gray-200 dark:border-gray-700 text-gray-600 dark:text-gray-200'\n                  }`}\n                >\n                  {template.name}\n                </button>\n              ))}\n              {selectedTemplate && (\n                <button\n                  type=\"button\"\n                  onClick={clearTemplate}\n                  className=\"rounded-full border border-red-200 bg-red-50 px-3 py-1 text-xs font-semibold text-red-600\"\n                >\n                  Clear template\n                </button>\n              )}\n            </div>\n          </div>\n\n          <div className=\"space-y-2\">\n            <div className=\"text-xs font-bold uppercase tracking-wider text-gray-500 dark:text-gray-300\">Tags</div>\n            <div className=\"flex flex-wrap gap-2\">\n              {tags.map((tag) => (\n                <span key={tag} className=\"inline-flex items-center gap-2 rounded-full border border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-gray-900 px-3 py-1 text-xs text-gray-600 dark:text-gray-200\">\n                  {tag}\n                  <button\n                    type=\"button\"\n                    onClick={() => setTags((prev) => prev.filter((t) => t !== tag))}\n                    className=\"text-xs text-gray-400\"\n                    aria-label=\"Remove tag\"\n                  >\n                    x\n                  </button>\n                </span>\n              ))}\n              <div className=\"flex items-center gap-2\">\n                <input\n                  type=\"text\"\n                  value={tagInput}\n                  onChange={(e) => setTagInput(e.target.value)}\n                  onKeyDown={(e) => {\n                    if (e.key === 'Enter') {\n                      e.preventDefault()\n                      handleAddTag()\n                    }\n                  }}\n                  placeholder=\"Add tag\"\n                  className=\"rounded-full border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-900 px-3 py-1 text-xs text-gray-700 dark:text-gray-200\"\n                />\n                <button\n                  type=\"button\"\n                  onClick={handleAddTag}\n                  className=\"rounded-full border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-900 px-3 py-1 text-xs font-semibold text-gray-600 dark:text-gray-200\"\n                >\n                  Add\n                </button>\n              </div>\n            </div>\n          </div>\n\n          <div className=\"flex flex-wrap gap-2\">\n            {([\n              { cmd: 'bold', label: 'B' },\n              { cmd: 'italic', label: 'I' },\n              { cmd: 'underline', label: 'U' },\n              { cmd: 'insertUnorderedList', label: 'Bullet list' },\n              { cmd: 'insertOrderedList', label: '1. List' },\n            ] as const).map((btn) => (\n              <button\n                key={btn.cmd}\n                type=\"button\"\n                onClick={() => handleCommand(btn.cmd)}\n                className=\"rounded-full border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-900 px-3 py-1 text-xs font-semibold text-gray-600 dark:text-gray-200\"\n              >\n                {btn.label}\n              </button>\n            ))}\n            <button\n              type=\"button\"\n              onClick={handleImagePick}\n              className=\"rounded-full border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-900 px-3 py-1 text-xs font-semibold text-helfi-green\"\n            >\n              {uploading ? 'Uploading...' : 'Add photo'}\n            </button>\n            <button\n              type=\"button\"\n              onClick={recording ? stopRecording : startRecording}\n              className=\"rounded-full border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-900 px-3 py-1 text-xs font-semibold text-gray-600 dark:text-gray-200\"\n            >\n              {recording ? `Stop ${formatSeconds(recordSeconds)}` : 'Record voice note'}\n            </button>\n            {uploadingAudio && (\n              <span className=\"text-xs text-gray-500 dark:text-gray-400 self-center\">Uploading audio...</span>\n            )}\n            <input\n              ref={fileInputRef}\n              type=\"file\"\n              accept=\"image/*\"\n              capture=\"environment\"\n              multiple\n              onChange={(e) => handleImages(e.target.files)}\n              className=\"hidden\"\n            />\n          </div>\n\n          <div className=\"relative rounded-2xl border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-900 px-4 py-3 min-h-[180px] overflow-x-hidden\">\n            {!contentHtml && (\n              <div className=\"pointer-events-none absolute left-4 top-3 text-sm text-gray-400\">Start writing...</div>\n            )}\n            <div\n              ref={editorRef}\n              contentEditable\n              suppressContentEditableWarning\n              onInput={() => {\n                setContentHtml(editorRef.current?.innerHTML || '')\n                syncSelectionRef()\n              }}\n              onKeyDown={handleEditorKeyDown}\n              onKeyUp={syncSelectionRef}\n              onMouseUp={syncSelectionRef}\n              onTouchEnd={syncSelectionRef}\n              onFocus={syncSelectionRef}\n              role=\"textbox\"\n              aria-multiline=\"true\"\n              tabIndex={0}\n              className=\"journal-editor min-h-[140px] text-sm text-gray-900 dark:text-gray-100 focus:outline-none break-words whitespace-pre-wrap max-w-full\"\n            />\n          </div>\n\n          {images.length > 0 && (\n            <div className=\"flex flex-wrap gap-3\">\n              {images.map((url) => (\n                <div key={url} className=\"relative\">\n                  <img src={url} alt=\"Journal\" className=\"h-20 w-20 rounded-xl object-cover\" />\n                  <button\n                    type=\"button\"\n                    onClick={() => setImages((prev) => prev.filter((item) => item !== url))}\n                    className=\"absolute -top-2 -right-2 bg-white dark:bg-gray-900 border border-gray-200 dark:border-gray-700 rounded-full p-1 text-xs\"\n                    aria-label=\"Remove\"\n                  >\n                    x\n                  </button>\n                </div>\n              ))}\n            </div>\n          )}\n\n          {audioClips.length > 0 && (\n            <div className=\"space-y-2\">\n              {audioClips.map((url) => (\n                <div key={url} className=\"flex items-center gap-3 rounded-xl border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-900 px-3 py-2\">\n                  <audio controls src={url} className=\"w-full\" />\n                  <button\n                    type=\"button\"\n                    onClick={() => setAudioClips((prev) => prev.filter((item) => item !== url))}\n                    className=\"text-xs text-gray-500\"\n                  >\n                    Remove\n                  </button>\n                </div>\n              ))}\n            </div>\n          )}\n\n          <div className=\"flex flex-col gap-3\">\n            <button\n              type=\"button\"\n              onClick={handleSave}\n              disabled={saving}\n              className=\"w-full rounded-xl bg-helfi-green text-white text-sm font-semibold py-3 disabled:opacity-60\"\n            >\n              {saving ? 'Saving...' : editingId ? 'Update entry' : 'Save entry'}\n            </button>\n            {editingId && (\n              <button\n                type=\"button\"\n                onClick={handleCancelEdit}\n                className=\"w-full rounded-xl border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-900 text-sm font-semibold py-3 text-gray-600 dark:text-gray-200\"\n              >\n                Cancel edit\n              </button>\n            )}\n          </div>\n        </div>\n\n        <div className=\"space-y-3\">\n          <div className=\"flex items-center justify-between gap-2\">\n            <h3 className=\"text-base font-bold text-gray-900 dark:text-white\">Recent journal entries</h3>\n            <input\n              type=\"text\"\n              value={searchTerm}\n              onChange={(e) => setSearchTerm(e.target.value)}\n              placeholder=\"Search journal\"\n              className=\"rounded-full border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-900 px-3 py-1 text-xs text-gray-700 dark:text-gray-200\"\n            />\n          </div>\n\n          {loading ? (\n            <div className=\"rounded-xl border border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-gray-800/60 text-gray-600 dark:text-gray-300 px-4 py-6 text-sm\">\n              Loading journal entries...\n            </div>\n          ) : visibleEntries.length === 0 ? (\n            <div className=\"rounded-xl border border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-gray-800/60 text-gray-600 dark:text-gray-300 px-4 py-6 text-sm\">\n              No journal entries yet.\n            </div>\n          ) : (\n            visibleEntries.map((entry) => {\n              const entryImages = normalizeImages(entry.images)\n              const entryAudio = normalizeImages(entry.audio)\n              const entryTags = normalizeTags(entry.tags)\n              const preview = stripHtml(entry.content || '').slice(0, 140)\n              const createdAt = entry.createdAt ? new Date(entry.createdAt) : null\n              const time = createdAt ? createdAt.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' }) : ''\n              return (\n                <div key={entry.id} className=\"bg-white dark:bg-gray-800 rounded-2xl p-4 shadow-sm border border-gray-100 dark:border-gray-700\">\n                  <div className=\"flex items-center justify-between text-xs text-gray-500 dark:text-gray-400\">\n                    <span className=\"font-semibold text-gray-700 dark:text-gray-200\">{formatDateLabel(entry.localDate)}</span>\n                    <span>{time}</span>\n                  </div>\n                  <div className=\"mt-2 text-sm font-semibold text-gray-900 dark:text-white\">\n                    {entry.title || 'Untitled entry'}\n                  </div>\n                  {(entry.prompt || entry.template) && (\n                    <div className=\"mt-2 flex flex-wrap gap-2 text-[11px] text-gray-500 dark:text-gray-300\">\n                      {entry.prompt && <span className=\"px-2 py-1 rounded-full border border-gray-200 dark:border-gray-700\">{entry.prompt}</span>}\n                      {entry.template && <span className=\"px-2 py-1 rounded-full border border-gray-200 dark:border-gray-700\">{entry.template}</span>}\n                    </div>\n                  )}\n                  {entryTags.length > 0 && (\n                    <div className=\"mt-2 flex flex-wrap gap-2\">\n                      {entryTags.map((tag) => (\n                        <span key={tag} className=\"px-2 py-1 rounded-full bg-gray-50 dark:bg-gray-900 border border-gray-200 dark:border-gray-700 text-[11px] text-gray-600 dark:text-gray-200\">\n                          {tag}\n                        </span>\n                      ))}\n                    </div>\n                  )}\n                  {preview && (\n                    <div className=\"mt-2 text-sm text-gray-600 dark:text-gray-300\">\n                      {preview}\n                    </div>\n                  )}\n                  {entryImages.length > 0 && (\n                    <div className=\"mt-3 flex flex-wrap gap-2\">\n                      {entryImages.slice(0, 4).map((url: string) => (\n                        <img key={url} src={url} alt=\"Journal\" className=\"h-16 w-16 rounded-xl object-cover\" />\n                      ))}\n                    </div>\n                  )}\n                  {entryAudio.length > 0 && (\n                    <div className=\"mt-3 space-y-2\">\n                      {entryAudio.map((url: string) => (\n                        <audio key={url} controls src={url} className=\"w-full\" />\n                      ))}\n                    </div>\n                  )}\n                  <div className=\"mt-3 flex items-center justify-end gap-2\">\n                    <button\n                      type=\"button\"\n                      onClick={() => handleEdit(entry)}\n                      className=\"rounded-full border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-900 px-3 py-1 text-xs font-semibold text-gray-600 dark:text-gray-200\"\n                    >\n                      Edit\n                    </button>\n                    <button\n                      type=\"button\"\n                      onClick={() => handleDelete(entry.id)}\n                      className=\"rounded-full border border-red-200 bg-red-50 px-3 py-1 text-xs font-semibold text-red-600\"\n                    >\n                      Delete\n                    </button>\n                  </div>\n                </div>\n              )\n            })\n          )}\n        </div>\n      </main>\n\n      <InsightsBottomNav />\n    </div>\n  )\n}\n","truncated":false,"size":37570},{"path":"app/mood/page.tsx","content":"'use client'\n\nimport React, { useEffect, useMemo, useState } from 'react'\nimport PageHeader from '@/components/PageHeader'\nimport MoodPicker from '@/components/mood/MoodPicker'\nimport IntensitySlider from '@/components/mood/IntensitySlider'\nimport InfluenceChips from '@/components/mood/InfluenceChips'\nimport ExpandableContextRow from '@/components/mood/ExpandableContextRow'\nimport FivePointScale from '@/components/mood/FivePointScale'\nimport MoodTabs from '@/components/mood/MoodTabs'\nimport MoodTagChips from '@/components/mood/MoodTagChips'\nimport InsightsBottomNav from '@/app/insights/InsightsBottomNav'\nimport { ArrowTrendingUpIcon, BeakerIcon, BoltIcon, MoonIcon, SparklesIcon } from '@heroicons/react/24/outline'\nimport { useSession } from 'next-auth/react'\n\ntype ContextResponse = {\n  localDate: string\n  meals: { todayCount: number; last: { name: string; meal: string | null; at: string } | null }\n  supplements: { count: number }\n  activity: { stepsToday: number | null; exerciseMinutesToday: number | null; exerciseCaloriesToday: number | null }\n  sleep: { minutes: number | null; date: string | null }\n}\n\nfunction localDateToday() {\n  const d = new Date()\n  const yyyy = d.getFullYear()\n  const mm = String(d.getMonth() + 1).padStart(2, '0')\n  const dd = String(d.getDate()).padStart(2, '0')\n  return `${yyyy}-${mm}-${dd}`\n}\n\nfunction minutesToHours(minutes: number | null) {\n  if (!minutes) return null\n  const hrs = minutes / 60\n  return `${hrs.toFixed(1)} h`\n}\n\nexport default function MoodCheckInPage() {\n  const { data: session } = useSession()\n  const [mood, setMood] = useState<number | null>(null)\n  const [tags, setTags] = useState<string[]>([])\n  const [feelings, setFeelings] = useState<string[]>([])\n  const [note, setNote] = useState('')\n  const [saving, setSaving] = useState(false)\n  const [banner, setBanner] = useState<{ type: 'success' | 'error'; message: string } | null>(null)\n  const [intensityPercent, setIntensityPercent] = useState<number>(35)\n\n  const [context, setContext] = useState<ContextResponse | null>(null)\n  const [energyLevel, setEnergyLevel] = useState<number | null>(null)\n  const [sleepQuality, setSleepQuality] = useState<number | null>(null)\n  const [nutrition, setNutrition] = useState<number | null>(null)\n  const [supplements, setSupplements] = useState<number | null>(null)\n  const [physicalActivity, setPhysicalActivity] = useState<number | null>(null)\n\n  const localDate = useMemo(() => localDateToday(), [])\n\n  useEffect(() => {\n    try {\n      const raw = sessionStorage.getItem('moodActivitySelections')\n      if (!raw) return\n      const parsed = JSON.parse(raw)\n      if (!Array.isArray(parsed)) return\n      setTags((prev) => {\n        const next = new Set<string>(prev || [])\n        for (const t of parsed) {\n          const s = String(t ?? '').trim()\n          if (!s) continue\n          next.add(s)\n        }\n        return Array.from(next).slice(0, 12)\n      })\n      sessionStorage.removeItem('moodActivitySelections')\n    } catch {}\n  }, [])\n\n  useEffect(() => {\n    let ignore = false\n    const load = async () => {\n      try {\n        const res = await fetch(`/api/mood/context?localDate=${encodeURIComponent(localDate)}`, { cache: 'no-store' as any })\n        if (!res.ok) return\n        const j = (await res.json()) as ContextResponse\n        if (!ignore) setContext(j)\n      } catch {}\n    }\n    load()\n    return () => { ignore = true }\n  }, [localDate])\n\n  const save = async () => {\n    if (mood == null) return\n    setSaving(true)\n    setBanner(null)\n    try {\n      const res = await fetch('/api/mood/entries', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          mood,\n          tags,\n          note,\n          localDate,\n          context: {\n            localHour: new Date().getHours(),\n            intensityPercent,\n            ...(feelings.length ? { feelings } : {}),\n            ...(energyLevel == null ? {} : { energyLevel }),\n            ...(sleepQuality == null ? {} : { sleepQuality }),\n            ...(nutrition == null ? {} : { nutrition }),\n            ...(supplements == null ? {} : { supplements }),\n            ...(physicalActivity == null ? {} : { physicalActivity }),\n          },\n        }),\n      })\n      if (!res.ok) throw new Error('save failed')\n      setBanner({ type: 'success', message: 'Saved.' })\n      setMood(null)\n      setTags([])\n      setFeelings([])\n      setNote('')\n      setIntensityPercent(35)\n      setEnergyLevel(null)\n      setSleepQuality(null)\n      setNutrition(null)\n      setSupplements(null)\n      setPhysicalActivity(null)\n      setTimeout(() => { window.location.assign('/mood/history?saved=1') }, 400)\n    } catch {\n      setBanner({ type: 'error', message: 'Could not save. Please try again.' })\n    } finally {\n      setSaving(false)\n    }\n  }\n\n  const sleepValue = context?.sleep?.minutes ? minutesToHours(context.sleep.minutes) : null\n  const activityValue =\n    context?.activity?.stepsToday != null ? `${context.activity.stepsToday.toLocaleString()} steps` :\n    context?.activity?.exerciseMinutesToday != null ? `${context.activity.exerciseMinutesToday} min` :\n    null\n  const nutritionValue =\n    context ? `${context.meals.todayCount} meal${context.meals.todayCount === 1 ? '' : 's'} logged` : null\n  const supplementsValue = context ? (context.supplements.count > 0 ? 'Saved in Helfi' : 'None saved') : null\n\n  const firstName = (() => {\n    const raw = String(session?.user?.name || '').trim()\n    if (!raw) return ''\n    return raw.split(' ')[0] || raw\n  })()\n\n  return (\n    <div className=\"min-h-screen bg-[#f8f9fa] dark:bg-gray-900 pb-28\">\n      <PageHeader title=\"Daily Check‚ÄëIn\" backHref=\"/more\" />\n      <MoodTabs />\n\n      <main className=\"max-w-3xl mx-auto px-4 py-6\">\n        {banner && (\n          <div\n            className={[\n              'mb-4 rounded-xl border px-4 py-3 text-sm',\n              banner.type === 'success'\n                ? 'bg-green-50 border-green-200 text-green-800'\n                : 'bg-red-50 border-red-200 text-red-700',\n            ].join(' ')}\n          >\n            {banner.message}\n          </div>\n        )}\n\n        <div className=\"bg-white dark:bg-gray-800 rounded-3xl shadow-sm p-6 border border-slate-100 dark:border-gray-700\">\n          <div className=\"mb-6 text-center px-2\">\n            <h1 className=\"tracking-tight text-[30px] sm:text-[32px] font-bold leading-tight text-slate-800 dark:text-white\">\n              How are you feeling{firstName ? `, ${firstName}` : ''}?\n            </h1>\n            <p className=\"text-slate-500 dark:text-gray-300 text-base font-medium leading-normal mt-2\">\n              Pick the face that matches your vibe.\n            </p>\n          </div>\n\n          <MoodPicker value={mood} onChange={setMood} />\n\n          <div className=\"mt-6\">\n            <IntensitySlider value={intensityPercent} onChange={setIntensityPercent} />\n          </div>\n\n          <div className=\"mt-6\">\n            <MoodTagChips value={feelings} onChange={setFeelings} title=\"Emotions (optional)\" />\n          </div>\n\n          <div className=\"mt-8\">\n            <InfluenceChips value={tags} onChange={setTags} />\n          </div>\n\n          <div className=\"mt-8\">\n            <details className=\"mt-2\">\n              <summary className=\"cursor-pointer select-none text-base font-bold text-slate-800 dark:text-white px-1\">\n                Optional details\n              </summary>\n              <div className=\"mt-4 space-y-3\">\n                <ExpandableContextRow\n                  label=\"Energy\"\n                  value={energyLevel ? `Level ${energyLevel}/5` : 'Optional'}\n                  icon={<BoltIcon className=\"w-5 h-5\" aria-hidden=\"true\" />}\n                >\n                  <FivePointScale label=\"Energy\" value={energyLevel} onChange={setEnergyLevel} />\n                </ExpandableContextRow>\n\n                <ExpandableContextRow\n                  label=\"Sleep\"\n                  value={sleepQuality ? `Level ${sleepQuality}/5` : (sleepValue ? `Recent: ${sleepValue}` : 'Optional')}\n                  icon={<MoonIcon className=\"w-5 h-5\" aria-hidden=\"true\" />}\n                >\n                  <div className=\"mb-3 text-xs text-gray-500 dark:text-gray-400\">\n                    {sleepValue ? `Recent sleep: ${sleepValue}.` : 'If you connect a device, sleep can fill in automatically.'}\n                  </div>\n                  <FivePointScale label=\"Sleep quality\" value={sleepQuality} onChange={setSleepQuality} />\n                </ExpandableContextRow>\n\n                <ExpandableContextRow\n                  label=\"Nutrition\"\n                  value={nutrition ? `Level ${nutrition}/5` : (nutritionValue || 'Optional')}\n                  icon={<SparklesIcon className=\"w-5 h-5\" aria-hidden=\"true\" />}\n                >\n                  {context?.meals?.last && (\n                    <div className=\"mb-3 text-xs text-gray-500 dark:text-gray-400\">\n                      Last meal: {context.meals.last.name}\n                    </div>\n                  )}\n                  <FivePointScale label=\"Nutrition quality\" value={nutrition} onChange={setNutrition} />\n                </ExpandableContextRow>\n\n                <ExpandableContextRow\n                  label=\"Supplements\"\n                  value={supplements ? `Level ${supplements}/5` : (supplementsValue || 'Optional')}\n                  icon={<BeakerIcon className=\"w-5 h-5\" aria-hidden=\"true\" />}\n                >\n                  <FivePointScale label=\"Supplements impact\" value={supplements} onChange={setSupplements} />\n                </ExpandableContextRow>\n\n                <ExpandableContextRow\n                  label=\"Activity\"\n                  value={physicalActivity ? `Level ${physicalActivity}/5` : (activityValue || 'Optional')}\n                  icon={<ArrowTrendingUpIcon className=\"w-5 h-5\" aria-hidden=\"true\" />}\n                >\n                  <div className=\"mb-3 text-xs text-gray-500 dark:text-gray-400\">\n                    {activityValue ? `Today: ${activityValue}.` : 'If you log activity, it can show up here automatically.'}\n                  </div>\n                  <FivePointScale label=\"Activity level\" value={physicalActivity} onChange={setPhysicalActivity} />\n                </ExpandableContextRow>\n\n                <div className=\"px-1\">\n                  <div className=\"text-sm font-bold text-slate-800 dark:text-white\">Note (optional)</div>\n                  <textarea\n                    value={note}\n                    onChange={(e) => setNote(e.target.value)}\n                    rows={3}\n                    maxLength={600}\n                    placeholder=\"Write a quick note‚Ä¶\"\n                    className=\"mt-3 w-full rounded-2xl border border-slate-200 dark:border-gray-700 bg-white dark:bg-gray-900 px-4 py-3 text-sm text-slate-900 dark:text-white focus:outline-none focus:ring-4 focus:ring-helfi-green/10\"\n                  />\n                  <div className=\"mt-1 text-xs text-slate-400 dark:text-gray-400\">\n                    {note.length}/600\n                  </div>\n                </div>\n              </div>\n            </details>\n\n            <div className=\"mt-4 text-xs text-slate-500 dark:text-gray-400 px-1\">\n              Mood is required. Everything else is optional.\n            </div>\n\n            <div className=\"hidden md:block mt-6\">\n              <button\n                type=\"button\"\n                onClick={save}\n                disabled={mood == null || saving}\n                className=\"w-full bg-helfi-green hover:bg-helfi-green-dark active:scale-[0.98] text-white text-lg font-bold py-4 rounded-2xl shadow-lg shadow-green-200/60 transition-all flex items-center justify-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed\"\n              >\n                {saving ? 'Saving‚Ä¶' : 'Log Mood'}\n                <span className=\"material-symbols-outlined text-[24px]\">arrow_forward</span>\n              </button>\n            </div>\n          </div>\n        </div>\n      </main>\n\n      <div className=\"md:hidden fixed bottom-20 left-0 right-0 p-4 bg-gradient-to-t from-white via-white/90 to-transparent dark:from-gray-900 dark:via-gray-900/90 pt-10 z-40\">\n        <div className=\"max-w-3xl mx-auto px-4\">\n          <button\n            type=\"button\"\n            onClick={save}\n            disabled={mood == null || saving}\n            className=\"w-full bg-helfi-green hover:bg-helfi-green-dark active:scale-[0.98] text-white text-lg font-bold py-4 rounded-2xl shadow-lg shadow-green-200/60 transition-all flex items-center justify-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed\"\n          >\n            {saving ? 'Saving‚Ä¶' : 'Log Mood'}\n            <span className=\"material-symbols-outlined text-[24px]\">arrow_forward</span>\n          </button>\n        </div>\n      </div>\n\n      <InsightsBottomNav />\n    </div>\n  )\n}\n","truncated":false,"size":12896},{"path":"app/mood/preferences/page.tsx","content":"'use client'\n\nimport React, { useEffect, useMemo, useState } from 'react'\nimport { useRouter } from 'next/navigation'\nimport MoodTabs from '@/components/mood/MoodTabs'\n\nfunction urlBase64ToUint8Array(base64String: string) {\n  const padding = '='.repeat((4 - (base64String.length % 4)) % 4)\n  const base64 = (base64String + padding).replace(/-/g, '+').replace(/_/g, '/')\n  const rawData = window.atob(base64)\n  const outputArray = new Uint8Array(rawData.length)\n  for (let i = 0; i < rawData.length; ++i) {\n    outputArray[i] = rawData.charCodeAt(i)\n  }\n  return outputArray\n}\n\nfunction normalizeTime(input: string, fallback: string) {\n  const s = (input || '').trim()\n  const m24 = s.match(/^([01]\\d|2[0-3]):([0-5]\\d)$/)\n  if (m24) return `${m24[1]}:${m24[2]}`\n  return fallback\n}\n\nexport default function MoodPreferencesPage() {\n  const router = useRouter()\n  const [loading, setLoading] = useState(true)\n  const [saving, setSaving] = useState(false)\n  const [banner, setBanner] = useState<{ type: 'success' | 'error'; message: string } | null>(null)\n\n  const [enabled, setEnabled] = useState(false)\n  const [frequency, setFrequency] = useState(1)\n  const [time1, setTime1] = useState('20:00')\n  const [time2, setTime2] = useState('12:00')\n  const [time3, setTime3] = useState('18:00')\n\n  const deviceTimezone = useMemo(() => {\n    try {\n      return Intl.DateTimeFormat().resolvedOptions().timeZone || 'UTC'\n    } catch {\n      return 'UTC'\n    }\n  }, [])\n  const [timezone, setTimezone] = useState(deviceTimezone)\n  const [timezoneOptions, setTimezoneOptions] = useState<string[]>([])\n  const [timezoneQuery, setTimezoneQuery] = useState(deviceTimezone)\n  const [showTimezoneDropdown, setShowTimezoneDropdown] = useState(false)\n\n  const [notificationsReady, setNotificationsReady] = useState(false)\n  const [notificationsBusy, setNotificationsBusy] = useState(false)\n  const [sendingNow, setSendingNow] = useState(false)\n\n  useEffect(() => {\n    ;(async () => {\n      try {\n        const res = await fetch('/api/mood/reminders', { cache: 'no-store' as any })\n        if (res.ok) {\n          const data = await res.json()\n          setEnabled(!!data.enabled)\n          setFrequency(Number(data.frequency) || 1)\n          setTime1(normalizeTime(data.time1 || '', '20:00'))\n          setTime2(normalizeTime(data.time2 || '', '12:00'))\n          setTime3(normalizeTime(data.time3 || '', '18:00'))\n          const savedTimezone = (data.timezone && String(data.timezone).trim()) || deviceTimezone\n          setTimezone(savedTimezone)\n          setTimezoneQuery(savedTimezone)\n        }\n      } catch {}\n      setLoading(false)\n    })()\n  }, [deviceTimezone])\n\n  useEffect(() => {\n    ;(async () => {\n      try {\n        if (!('serviceWorker' in navigator) || !('Notification' in window)) return\n        const reg = await navigator.serviceWorker.getRegistration()\n        const sub = reg ? await reg.pushManager.getSubscription() : null\n        if (sub && Notification.permission === 'granted') setNotificationsReady(true)\n      } catch {}\n    })()\n  }, [])\n\n  useEffect(() => {\n    try {\n      const anyIntl = Intl as any\n      if (anyIntl && typeof anyIntl.supportedValuesOf === 'function') {\n        const supported = anyIntl.supportedValuesOf('timeZone') as string[]\n        if (Array.isArray(supported) && supported.length > 0) {\n          const sorted = [...supported].sort((a, b) => a.localeCompare(b))\n          setTimezoneOptions(sorted)\n          if (!timezone) {\n            const guessed = deviceTimezone || sorted[0] || 'UTC'\n            setTimezone(guessed)\n            setTimezoneQuery(guessed)\n          }\n          return\n        }\n      }\n    } catch {}\n\n    const fallback = [\n      'UTC',\n      'Europe/London',\n      'Europe/Paris',\n      'Europe/Berlin',\n      'Europe/Madrid',\n      'Europe/Rome',\n      'Europe/Amsterdam',\n      'Europe/Zurich',\n      'Europe/Stockholm',\n      'Europe/Athens',\n      'Africa/Johannesburg',\n      'Asia/Dubai',\n      'Asia/Kolkata',\n      'Asia/Bangkok',\n      'Asia/Singapore',\n      'Asia/Kuala_Lumpur',\n      'Asia/Hong_Kong',\n      'Asia/Tokyo',\n      'Asia/Seoul',\n      'Asia/Shanghai',\n      'Australia/Perth',\n      'Australia/Adelaide',\n      'Australia/Melbourne',\n      'Australia/Sydney',\n      'Pacific/Auckland',\n      'America/New_York',\n      'America/Chicago',\n      'America/Denver',\n      'America/Los_Angeles',\n      'America/Toronto',\n      'America/Vancouver',\n      'America/Mexico_City',\n      'America/Bogota',\n      'America/Sao_Paulo',\n    ]\n    setTimezoneOptions(fallback)\n    if (!timezone) {\n      const guessed = deviceTimezone || fallback[0] || 'UTC'\n      setTimezone(guessed)\n      setTimezoneQuery(guessed)\n    }\n  }, [deviceTimezone, timezone])\n\n  const filteredTimezones = useMemo(() => {\n    if (!timezoneOptions.length) return []\n    const query = (timezoneQuery || '').trim().toLowerCase()\n    if (!query) return timezoneOptions.slice(0, 50)\n    return timezoneOptions.filter((tz) => tz.toLowerCase().includes(query)).slice(0, 50)\n  }, [timezoneOptions, timezoneQuery])\n\n  const ensureNotifications = async (): Promise<boolean> => {\n    if (!('Notification' in window) || !('serviceWorker' in navigator)) return false\n    setNotificationsBusy(true)\n    try {\n      const permission = await Notification.requestPermission()\n      if (permission !== 'granted') return false\n      const reg = (await navigator.serviceWorker.getRegistration()) || (await navigator.serviceWorker.register('/sw.js'))\n      const vapid = await fetch('/api/push/vapid').then((r) => r.json()).catch(() => ({ publicKey: '' }))\n      if (!vapid.publicKey) return false\n      let sub = await reg.pushManager.getSubscription()\n      if (!sub) {\n        sub = await reg.pushManager.subscribe({\n          userVisibleOnly: true,\n          applicationServerKey: urlBase64ToUint8Array(vapid.publicKey),\n        })\n      }\n      const res = await fetch('/api/push/subscribe', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ subscription: sub }),\n      })\n      if (!res.ok) return false\n      setNotificationsReady(true)\n      return true\n    } catch {\n      return false\n    } finally {\n      setNotificationsBusy(false)\n    }\n  }\n\n  const save = async (nextEnabled: boolean) => {\n    setSaving(true)\n    setBanner(null)\n    try {\n      const res = await fetch('/api/mood/reminders', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          enabled: nextEnabled,\n          frequency,\n          time1: normalizeTime(time1, '20:00'),\n          time2: normalizeTime(time2, '12:00'),\n          time3: normalizeTime(time3, '18:00'),\n          timezone,\n        }),\n      })\n      const data = await res.json().catch(() => ({}))\n      if (!res.ok) throw new Error('save failed')\n      setEnabled(nextEnabled)\n      const failed = Array.isArray(data?.scheduleResults)\n        ? data.scheduleResults.filter((result: any) => result && result.scheduled === false)\n        : []\n      if (failed.length > 0) {\n        setBanner({ type: 'error', message: 'Saved, but scheduling failed. Tap ‚ÄúSend‚Äù to verify.' })\n      } else {\n        setBanner({ type: 'success', message: 'Saved.' })\n      }\n    } catch {\n      setBanner({ type: 'error', message: 'Could not save. Please try again.' })\n    } finally {\n      setSaving(false)\n    }\n  }\n\n  const toggleEnabled = async () => {\n    const next = !enabled\n    if (next) {\n      const ok = await ensureNotifications()\n      if (!ok) {\n        setBanner({ type: 'error', message: 'Notifications are not enabled on this device.' })\n        return\n      }\n    }\n    await save(next)\n  }\n\n  return (\n    <div className=\"min-h-screen bg-[#f8f9fa] dark:bg-gray-900 pb-28\">\n      <div className=\"sticky top-0 z-40 bg-[#f8f9fa]/95 dark:bg-gray-900/95 backdrop-blur-md px-4 py-3 flex items-center justify-between border-b border-slate-200/60 dark:border-gray-800\">\n        <button\n          type=\"button\"\n          onClick={() => router.back()}\n          className=\"flex size-12 shrink-0 items-center justify-start rounded-full hover:bg-black/5 dark:hover:bg-white/5 transition-colors\"\n          aria-label=\"Back\"\n        >\n          <span className=\"material-symbols-outlined text-[28px] text-slate-800 dark:text-white\">arrow_back</span>\n        </button>\n        <h1 className=\"text-lg font-bold leading-tight tracking-[-0.015em] flex-1 text-center text-slate-800 dark:text-white\">\n          Mood Preferences\n        </h1>\n        <div className=\"w-12\" />\n      </div>\n\n      <MoodTabs />\n\n      <main className=\"max-w-md mx-auto px-6 pt-6\">\n        {banner && (\n          <div\n            className={[\n              'mb-4 rounded-2xl px-4 py-3 text-sm font-medium border',\n              banner.type === 'success'\n                ? 'bg-green-50 text-green-800 border-green-200 dark:bg-green-900/20 dark:text-green-200 dark:border-green-800/40'\n                : 'bg-red-50 text-red-800 border-red-200 dark:bg-red-900/20 dark:text-red-200 dark:border-red-800/40',\n            ].join(' ')}\n          >\n            {banner.message}\n          </div>\n        )}\n\n        <div className=\"bg-white dark:bg-gray-800 rounded-2xl p-5 shadow-sm border border-slate-100 dark:border-gray-700\">\n          <div className=\"flex items-center justify-between\">\n            <div className=\"flex items-center gap-4\">\n              <div className=\"flex h-12 w-12 items-center justify-center rounded-full bg-sky-100 dark:bg-sky-900/30 text-sky-600 dark:text-sky-300\">\n                <span className=\"material-symbols-outlined\">notifications</span>\n              </div>\n              <div className=\"flex flex-col\">\n                <span className=\"font-bold text-base text-slate-800 dark:text-white\">Reminders</span>\n                <span className=\"text-xs text-slate-500 dark:text-gray-400 font-medium\">\n                  Get up to 3 reminders per day.\n                </span>\n              </div>\n            </div>\n\n            <button\n              type=\"button\"\n              onClick={toggleEnabled}\n              disabled={saving || loading || notificationsBusy}\n              className={[\n                'relative inline-flex h-7 w-12 items-center rounded-full transition-colors duration-300',\n                enabled ? 'bg-helfi-green' : 'bg-slate-200 dark:bg-gray-700',\n                (saving || loading || notificationsBusy) ? 'opacity-60 cursor-not-allowed' : '',\n              ].join(' ')}\n              aria-pressed={enabled}\n              aria-label=\"Toggle reminders\"\n            >\n              <span\n                className={[\n                  'inline-block h-5 w-5 transform rounded-full bg-white shadow-sm transition-transform duration-300',\n                  enabled ? 'translate-x-6' : 'translate-x-1',\n                ].join(' ')}\n              />\n            </button>\n          </div>\n\n          {!notificationsReady && (\n            <div className=\"mt-4 rounded-xl border border-slate-200 dark:border-gray-700 bg-slate-50 dark:bg-gray-900/40 p-4\">\n              <div className=\"text-sm font-bold text-slate-800 dark:text-white\">Notifications are off on this device</div>\n              <div className=\"mt-1 text-xs text-slate-500 dark:text-gray-400\">\n                Turn them on once to receive reminders here.\n              </div>\n              <button\n                type=\"button\"\n                onClick={async () => {\n                  const ok = await ensureNotifications()\n                  if (!ok) setBanner({ type: 'error', message: 'Notifications could not be enabled on this device.' })\n                  else setBanner({ type: 'success', message: 'Notifications are enabled.' })\n                }}\n                disabled={notificationsBusy}\n                className=\"mt-3 w-full rounded-xl bg-helfi-green hover:bg-helfi-green-dark text-white font-bold py-3 transition-colors disabled:opacity-50\"\n              >\n                Turn on notifications\n              </button>\n            </div>\n          )}\n\n          <div className=\"mt-5\">\n            <div className=\"text-sm font-bold text-slate-800 dark:text-white mb-3\">How many reminders per day?</div>\n            <div className=\"flex gap-2\">\n              {[1, 2, 3].map((n) => {\n                const active = frequency === n\n                return (\n                  <button\n                    key={n}\n                    type=\"button\"\n                    onClick={() => setFrequency(n)}\n                    disabled={!enabled}\n                    className={[\n                      'flex-1 rounded-full px-4 py-2 text-sm font-bold transition-all border',\n                      active\n                        ? 'bg-white dark:bg-gray-900 text-helfi-green border-helfi-green shadow-sm'\n                        : 'bg-white dark:bg-gray-900 text-slate-700 dark:text-gray-200 border-slate-200 dark:border-gray-700',\n                      !enabled ? 'opacity-50 cursor-not-allowed' : 'hover:bg-slate-50 dark:hover:bg-gray-800/60',\n                    ].join(' ')}\n                  >\n                    {n}\n                  </button>\n                )\n              })}\n            </div>\n            <div className=\"mt-2 text-xs text-slate-500 dark:text-gray-400\">\n              Defaults to your device time zone.\n            </div>\n          </div>\n\n          <div className=\"mt-5 space-y-3\">\n            <div className=\"flex items-center justify-between\">\n              <span className=\"text-sm font-bold text-slate-800 dark:text-white\">Reminder 1</span>\n              <input\n                type=\"time\"\n                value={time1}\n                onChange={(e) => setTime1(e.target.value)}\n                disabled={!enabled}\n                className=\"rounded-xl border border-slate-200 dark:border-gray-700 bg-white dark:bg-gray-900 px-3 py-2 text-sm text-slate-800 dark:text-white disabled:opacity-50\"\n              />\n            </div>\n            {frequency >= 2 && (\n              <div className=\"flex items-center justify-between\">\n                <span className=\"text-sm font-bold text-slate-800 dark:text-white\">Reminder 2</span>\n                <input\n                  type=\"time\"\n                  value={time2}\n                  onChange={(e) => setTime2(e.target.value)}\n                  disabled={!enabled}\n                  className=\"rounded-xl border border-slate-200 dark:border-gray-700 bg-white dark:bg-gray-900 px-3 py-2 text-sm text-slate-800 dark:text-white disabled:opacity-50\"\n                />\n              </div>\n            )}\n            {frequency >= 3 && (\n              <div className=\"flex items-center justify-between\">\n                <span className=\"text-sm font-bold text-slate-800 dark:text-white\">Reminder 3</span>\n                <input\n                  type=\"time\"\n                  value={time3}\n                  onChange={(e) => setTime3(e.target.value)}\n                  disabled={!enabled}\n                  className=\"rounded-xl border border-slate-200 dark:border-gray-700 bg-white dark:bg-gray-900 px-3 py-2 text-sm text-slate-800 dark:text-white disabled:opacity-50\"\n                />\n              </div>\n            )}\n          </div>\n\n          <div className=\"mt-5\">\n            <div className=\"text-sm font-bold text-slate-800 dark:text-white mb-2\">Timezone</div>\n            <div className=\"relative\">\n              <input\n                type=\"text\"\n                value={timezoneQuery}\n                onChange={(e) => {\n                  setTimezoneQuery(e.target.value)\n                  setShowTimezoneDropdown(true)\n                }}\n                onFocus={() => {\n                  if (enabled && timezoneOptions.length > 0) setShowTimezoneDropdown(true)\n                }}\n                placeholder=\"Start typing e.g. Australia/Melbourne\"\n                disabled={!enabled}\n                className=\"w-full rounded-xl border border-slate-200 dark:border-gray-700 bg-white dark:bg-gray-900 px-3 py-2 text-sm text-slate-800 dark:text-white disabled:opacity-50\"\n              />\n              {enabled && showTimezoneDropdown && filteredTimezones.length > 0 && (\n                <div className=\"absolute z-20 mt-1 w-full max-h-56 overflow-y-auto rounded-xl border border-slate-200 dark:border-gray-700 bg-white dark:bg-gray-900 shadow-lg\">\n                  {filteredTimezones.map((tzValue) => (\n                    <button\n                      key={tzValue}\n                      type=\"button\"\n                      onClick={() => {\n                        setTimezone(tzValue)\n                        setTimezoneQuery(tzValue)\n                        setShowTimezoneDropdown(false)\n                      }}\n                      className=\"w-full text-left px-3 py-2 text-xs text-slate-800 dark:text-white hover:bg-slate-50 dark:hover:bg-gray-800\"\n                    >\n                      {tzValue}\n                    </button>\n                  ))}\n                </div>\n              )}\n            </div>\n            <div className=\"mt-2 text-xs text-slate-500 dark:text-gray-400\">\n              Detected on this device: {deviceTimezone}\n            </div>\n          </div>\n\n          <div className=\"mt-6\">\n            <button\n              type=\"button\"\n              onClick={() => save(enabled)}\n              disabled={saving || loading}\n              className=\"w-full rounded-2xl bg-helfi-green hover:bg-helfi-green-dark text-white text-base font-bold py-4 transition-colors disabled:opacity-50\"\n            >\n              {saving ? 'Saving‚Ä¶' : 'Save'}\n            </button>\n          </div>\n        </div>\n\n        <div className=\"mt-4 bg-white dark:bg-gray-800 rounded-2xl p-5 shadow-sm border border-slate-100 dark:border-gray-700\">\n          <div className=\"flex items-center justify-between\">\n            <div>\n              <div className=\"text-sm font-bold text-slate-800 dark:text-white\">Send reminder now</div>\n              <div className=\"text-xs text-slate-500 dark:text-gray-400\">\n                Triggers a quick mood notification to this device.\n              </div>\n            </div>\n            <button\n              type=\"button\"\n              onClick={async () => {\n                setSendingNow(true)\n                setBanner(null)\n                try {\n                  const ok = await ensureNotifications()\n                  if (!ok) {\n                    setBanner({ type: 'error', message: 'Notifications are not enabled on this device.' })\n                    return\n                  }\n                  const res = await fetch('/api/mood/send-reminder-now', { method: 'POST' })\n                  const data = await res.json().catch(() => ({}))\n                  if (!res.ok) {\n                    const msg = data?.error || 'Failed to send reminder'\n                    setBanner({ type: 'error', message: msg })\n                    return\n                  }\n                  setBanner({ type: 'success', message: 'Reminder sent. Check your notifications.' })\n                } catch (e: any) {\n                  setBanner({ type: 'error', message: e?.message || 'Could not send reminder.' })\n                } finally {\n                  setSendingNow(false)\n                }\n              }}\n              disabled={sendingNow}\n              className=\"px-3 py-2 rounded-xl bg-helfi-green text-white text-sm font-bold hover:bg-helfi-green-dark disabled:opacity-60\"\n            >\n              {sendingNow ? 'Sending‚Ä¶' : 'Send'}\n            </button>\n          </div>\n        </div>\n\n        {loading && (\n          <div className=\"mt-4 text-sm text-slate-500 dark:text-gray-400\">\n            Loading‚Ä¶\n          </div>\n        )}\n      </main>\n    </div>\n  )\n}\n","truncated":false,"size":19711},{"path":"app/mood/quick/page.tsx","content":"'use client'\n\nimport React, { useMemo, useState } from 'react'\nimport PageHeader from '@/components/PageHeader'\nimport MoodPicker from '@/components/mood/MoodPicker'\nimport InfluenceChips from '@/components/mood/InfluenceChips'\nimport MoodTagChips from '@/components/mood/MoodTagChips'\nimport InsightsBottomNav from '@/app/insights/InsightsBottomNav'\n\nfunction localDateToday() {\n  const d = new Date()\n  const yyyy = d.getFullYear()\n  const mm = String(d.getMonth() + 1).padStart(2, '0')\n  const dd = String(d.getDate()).padStart(2, '0')\n  return `${yyyy}-${mm}-${dd}`\n}\n\nexport default function QuickMoodCheckInPage() {\n  const [mood, setMood] = useState<number | null>(null)\n  const [tags, setTags] = useState<string[]>([])\n  const [feelings, setFeelings] = useState<string[]>([])\n  const [saving, setSaving] = useState(false)\n  const [banner, setBanner] = useState<{ type: 'success' | 'error'; message: string } | null>(null)\n\n  const localDate = useMemo(() => localDateToday(), [])\n\n  const save = async () => {\n    if (mood == null) return\n    setSaving(true)\n    setBanner(null)\n    try {\n      const res = await fetch('/api/mood/entries', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          mood,\n          tags,\n          localDate,\n          context: {\n            localHour: new Date().getHours(),\n            ...(feelings.length ? { feelings } : {}),\n          },\n        }),\n      })\n      if (!res.ok) throw new Error('save failed')\n      setBanner({ type: 'success', message: 'Saved.' })\n      setTimeout(() => window.location.assign('/dashboard'), 400)\n    } catch {\n      setBanner({ type: 'error', message: 'Could not save. Please try again.' })\n    } finally {\n      setSaving(false)\n    }\n  }\n\n  return (\n    <div className=\"min-h-screen bg-[#f8f9fa] dark:bg-gray-900 pb-28\">\n      <PageHeader title=\"Quick Check‚ÄëIn\" backHref=\"/dashboard\" />\n\n      <main className=\"max-w-3xl mx-auto px-4 py-6\">\n        {banner && (\n          <div\n            className={[\n              'mb-4 rounded-xl border px-4 py-3 text-sm',\n              banner.type === 'success'\n                ? 'bg-green-50 border-green-200 text-green-800'\n                : 'bg-red-50 border-red-200 text-red-700',\n            ].join(' ')}\n          >\n            {banner.message}\n          </div>\n        )}\n\n        <div className=\"bg-white dark:bg-gray-800 rounded-3xl shadow-sm p-6 border border-slate-100 dark:border-gray-700\">\n          <div className=\"mb-6 text-center px-2\">\n            <h1 className=\"tracking-tight text-[30px] sm:text-[32px] font-bold leading-tight text-slate-800 dark:text-white\">\n              How are you feeling right now?\n            </h1>\n            <p className=\"text-slate-500 dark:text-gray-300 text-base font-medium leading-normal mt-2\">\n              Tap a face, pick what‚Äôs affecting you, done.\n            </p>\n          </div>\n\n          <MoodPicker value={mood} onChange={setMood} />\n\n          <div className=\"mt-6\">\n            <MoodTagChips value={feelings} onChange={setFeelings} title=\"Emotions (optional)\" />\n          </div>\n\n          <div className=\"mt-8\">\n            <InfluenceChips value={tags} onChange={setTags} />\n          </div>\n\n          <div className=\"hidden md:grid grid-cols-2 gap-3 mt-6\">\n            <button\n              type=\"button\"\n              onClick={() => window.history.back()}\n              className=\"w-full rounded-2xl border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 px-4 py-4 font-bold text-gray-800 dark:text-gray-200 active:scale-[0.98] transition-transform\"\n            >\n              Remind me later\n            </button>\n            <button\n              type=\"button\"\n              onClick={save}\n              disabled={mood == null || saving}\n              className=\"w-full bg-helfi-green hover:bg-helfi-green-dark active:scale-[0.98] text-white text-lg font-bold py-4 rounded-2xl shadow-lg shadow-green-200/60 transition-all flex items-center justify-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed\"\n            >\n              {saving ? 'Saving‚Ä¶' : 'Save'}\n              <span className=\"material-symbols-outlined text-[24px]\">check</span>\n            </button>\n          </div>\n        </div>\n      </main>\n\n      <div className=\"md:hidden fixed bottom-20 left-0 right-0 p-4 bg-gradient-to-t from-white via-white/90 to-transparent dark:from-gray-900 dark:via-gray-900/90 pt-10 z-40\">\n        <div className=\"max-w-3xl mx-auto px-4 grid grid-cols-2 gap-3\">\n          <button\n            type=\"button\"\n            onClick={() => window.history.back()}\n            className=\"w-full rounded-2xl border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 px-4 py-4 font-bold text-gray-800 dark:text-gray-200 active:scale-[0.98] transition-transform\"\n          >\n            Remind me later\n          </button>\n          <button\n            type=\"button\"\n            onClick={save}\n            disabled={mood == null || saving}\n            className=\"w-full bg-helfi-green hover:bg-helfi-green-dark active:scale-[0.98] text-white text-lg font-bold py-4 rounded-2xl shadow-lg shadow-green-200/60 transition-all flex items-center justify-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed\"\n          >\n            {saving ? 'Saving‚Ä¶' : 'Save'}\n            <span className=\"material-symbols-outlined text-[24px]\">check</span>\n          </button>\n        </div>\n      </div>\n\n      <InsightsBottomNav />\n    </div>\n  )\n}\n","truncated":false,"size":5526},{"path":"app/more/page.tsx","content":"'use client'\n\nimport Link from 'next/link'\nimport { usePathname } from 'next/navigation'\nimport MobileMoreMenu from '@/components/MobileMoreMenu'\nimport PageHeader from '@/components/PageHeader'\n\ninterface MenuItem {\n  icon: React.ReactNode\n  label: string\n  href: string\n  badge?: number\n}\n\nexport default function MorePage() {\n  const pathname = usePathname()\n\n  // Health & Analysis section\n  const healthItems: MenuItem[] = [\n    {\n      icon: (\n        <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n          <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z\" />\n        </svg>\n      ),\n      label: 'Talk to AI',\n      href: '/chat',\n    },\n    {\n      icon: (\n        <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n          <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M9 12h6m-6 4h6M7 20h10a2 2 0 002-2v-5a2 2 0 00-2-2h-3.586a1 1 0 01-.707-.293l-1.414-1.414A2 2 0 0010.586 8H7a2 2 0 00-2 2v8a2 2 0 002 2z\" />\n        </svg>\n      ),\n      label: 'Health Tips',\n      href: '/health-tips',\n    },\n    {\n      icon: (\n        <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n          <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z\" />\n        </svg>\n      ),\n      label: \"Today's Check-in\",\n      href: '/check-in',\n    },\n    {\n      icon: (\n        <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n          <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M8 7V3m8 4V3M5 11h14M5 19h14M7 11v8m10-8v8\" />\n        </svg>\n      ),\n      label: 'Rating History',\n      href: '/check-in/history',\n    },\n    {\n      icon: (\n        <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n          <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.26a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z\" />\n          <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M21 12a9 9 0 11-18 0 9 9 0 0118 0z\" />\n        </svg>\n      ),\n      label: 'Mood Tracker',\n      href: '/mood',\n    },\n    {\n      icon: (\n        <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n          <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M12 6v6l4 2\" />\n          <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M21 12a9 9 0 11-18 0 9 9 0 0118 0z\" />\n        </svg>\n      ),\n      label: 'Quick Mood Check‚ÄëIn',\n      href: '/mood/quick',\n    },\n    {\n      icon: (\n        <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n          <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z\" />\n        </svg>\n      ),\n      label: 'Symptom Analysis',\n      href: '/symptoms',\n    },\n    {\n      icon: (\n        <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n          <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z\" />\n        </svg>\n      ),\n      label: 'Medical Image Analyzer',\n      href: '/medical-images',\n    },\n    {\n      icon: (\n        <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n          <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-3 7h3m-3 4h3m-6-4h.01M9 16h.01\" />\n        </svg>\n      ),\n      label: 'Intake',\n      href: '/onboarding?step=1',\n    },\n  ]\n\n  // Account & Settings section\n  const accountItems: MenuItem[] = [\n    {\n      icon: (\n        <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n          <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M9 3v2m6-2v2M9 19v2m6-2v2M5 9H3m2 6H3m18-6h-2m2 6h-2M7 19h10a2 2 0 002-2V7a2 2 0 00-2-2H7a2 2 0 00-2 2v10a2 2 0 002 2zM9 9h6v6H9V9z\" />\n        </svg>\n      ),\n      label: 'Devices',\n      href: '/devices',\n    },\n    {\n      icon: (\n        <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n          <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z\" />\n        </svg>\n      ),\n      label: 'Profile',\n      href: '/profile',\n    },\n    {\n      icon: (\n        <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n          <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z\" />\n          <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M15 12a3 3 0 11-6 0 3 3 0 016 0z\" />\n        </svg>\n      ),\n      label: 'Settings',\n      href: '/settings',\n    },\n    {\n      icon: (\n        <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n          <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M3 10h18M7 15h1m4 0h1m-7 4h12a3 3 0 003-3V8a3 3 0 00-3-3H6a3 3 0 00-3 3v8a3 3 0 003 3z\" />\n        </svg>\n      ),\n      label: 'Billing',\n      href: '/billing',\n    },\n    {\n      icon: (\n        <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n          <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z\" />\n        </svg>\n      ),\n      label: 'Reports',\n      href: '/reports',\n    },\n    {\n      icon: (\n        <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n          <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z\" />\n        </svg>\n      ),\n      label: 'Help & Support',\n      href: '/help',\n    },\n  ]\n\n  const MenuSection = ({ title, items }: { title: string; items: MenuItem[] }) => (\n    <div className=\"mb-6\">\n      <h2 className=\"text-sm font-semibold text-gray-500 uppercase tracking-wide mb-3 px-4\">\n        {title}\n      </h2>\n      <div className=\"bg-white rounded-lg overflow-hidden\">\n        {items.map((item, index) => (\n          <Link\n            key={item.href}\n            href={item.href}\n            className={`flex items-center px-4 py-4 ${\n              index !== items.length - 1 ? 'border-b border-gray-100' : ''\n            } hover:bg-gray-50 active:bg-gray-100 transition-colors touch-manipulation`}\n          >\n            <div className=\"flex-shrink-0 w-10 h-10 flex items-center justify-center text-gray-600\">\n              {item.icon}\n            </div>\n            <span className=\"flex-1 ml-3 text-base font-medium text-gray-900\">\n              {item.label}\n            </span>\n            {item.badge && (\n              <span className=\"mr-2 w-2 h-2 bg-red-500 rounded-full\"></span>\n            )}\n            <svg\n              className=\"w-5 h-5 text-gray-400\"\n              fill=\"none\"\n              stroke=\"currentColor\"\n              viewBox=\"0 0 24 24\"\n            >\n              <path\n                strokeLinecap=\"round\"\n                strokeLinejoin=\"round\"\n                strokeWidth={2}\n                d=\"M9 5l7 7-7 7\"\n              />\n            </svg>\n          </Link>\n        ))}\n      </div>\n    </div>\n  )\n\n  return (\n    <div className=\"min-h-screen bg-gray-50 dark:bg-gray-900 pb-24\">\n      <PageHeader title=\"More\" />\n\n      {/* Content */}\n      <main className=\"max-w-7xl mx-auto px-4 py-6\">\n        <MenuSection title=\"Health & Analysis\" items={healthItems} />\n        <MenuSection title=\"Account & Settings\" items={accountItems} />\n      </main>\n\n      {/* Mobile Bottom Navigation */}\n      <nav className=\"md:hidden fixed bottom-0 left-0 right-0 bg-white dark:bg-gray-800 border-t border-gray-200 dark:border-gray-700 px-4 py-2 z-40\">\n        <div className=\"flex items-center justify-around\">\n          <Link href=\"/dashboard\" className=\"flex flex-col items-center py-2 px-1 min-w-0 flex-1\">\n            <div className=\"text-gray-400\">\n              <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6\" />\n              </svg>\n            </div>\n            <span className=\"text-xs text-gray-400 mt-1 font-medium truncate\">Dashboard</span>\n          </Link>\n\n          <Link href=\"/insights\" className=\"flex flex-col items-center py-2 px-1 min-w-0 flex-1\">\n            <div className=\"text-gray-400\">\n              <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z\" />\n              </svg>\n            </div>\n            <span className=\"text-xs text-gray-400 mt-1 font-medium truncate\">Insights</span>\n          </Link>\n\n          <Link href=\"/food\" className=\"flex flex-col items-center py-2 px-1 min-w-0 flex-1\">\n            <div className=\"text-gray-400\">\n              <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10\" />\n              </svg>\n            </div>\n            <span className=\"text-xs text-gray-400 mt-1 font-medium truncate\">Food</span>\n          </Link>\n\n          <MobileMoreMenu />\n\n          <Link href=\"/settings\" className=\"flex flex-col items-center py-2 px-1 min-w-0 flex-1\">\n            <div className=\"text-gray-400\">\n              <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z\" />\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M15 12a3 3 0 11-6 0 3 3 0 016 0z\" />\n              </svg>\n            </div>\n            <span className=\"text-xs text-gray-400 mt-1 font-medium truncate\">Settings</span>\n          </Link>\n        </div>\n      </nav>\n    </div>\n  )\n}\n","truncated":false,"size":12161},{"path":"app/notifications/page.tsx","content":"'use client'\n\nimport React from 'react'\nimport { useSession } from 'next-auth/react'\nimport Link from 'next/link'\nimport Image from 'next/image'\n\nexport default function Notifications() {\n  const { data: session } = useSession()\n\n  return (\n    <div className=\"min-h-screen bg-gray-50\">\n      {/* Navigation Header */}\n      <nav className=\"bg-white border-b border-gray-200 px-4 py-3\">\n        <div className=\"max-w-7xl mx-auto flex justify-between items-center\">\n          <div className=\"flex items-center\">\n            <Link href=\"/dashboard\" className=\"bg-helfi-green text-white px-4 py-2 rounded-lg hover:bg-helfi-green/90 transition-colors mr-4\">\n              Back to Dashboard\n            </Link>\n            <Link href=\"/\" className=\"w-16 h-16 md:w-20 md:h-20 cursor-pointer hover:opacity-80 transition-opacity\">\n              <Image\n                src=\"/mobile-assets/LOGOS/helfi-01-01.png\"\n                alt=\"Helfi Logo\"\n                width={80}\n                height={80}\n                className=\"w-full h-full object-contain dark:hidden\"\n                priority\n              />\n              <Image\n                src=\"/mobile-assets/LOGOS/helfi-01-06.png\"\n                alt=\"Helfi Logo\"\n                width={80}\n                height={80}\n                className=\"w-full h-full object-contain hidden dark:block\"\n                priority\n              />\n            </Link>\n            <div className=\"ml-4\">\n              <h1 className=\"text-lg md:text-xl font-semibold text-gray-900\">Notifications</h1>\n              <p className=\"text-sm text-gray-500 hidden sm:block\">Manage your notification preferences</p>\n            </div>\n          </div>\n          \n          {/* Desktop Navigation */}\n          <div className=\"hidden md:flex items-center space-x-6\">\n            <Link href=\"/dashboard\" className=\"text-gray-700 hover:text-helfi-green transition-colors font-medium\">\n              Dashboard\n            </Link>\n            <Link href=\"/health-tracking\" className=\"text-gray-700 hover:text-helfi-green transition-colors font-medium\">\n              Health Tracking\n            </Link>\n            <Link href=\"/insights\" className=\"text-gray-700 hover:text-helfi-green transition-colors font-medium\">\n              AI Insights\n            </Link>\n            <Link href=\"/reports\" className=\"text-gray-700 hover:text-helfi-green transition-colors font-medium\">\n              Reports\n            </Link>\n            <Link href=\"/onboarding?step=1\" className=\"text-gray-700 hover:text-helfi-green transition-colors font-medium\">\n              Health Info\n            </Link>\n          </div>\n        </div>\n      </nav>\n\n      {/* Main Content */}\n      <div className=\"max-w-3xl mx-auto px-4 py-8 pb-24 md:pb-8\">\n        <div className=\"bg-white rounded-lg shadow-sm p-6\">\n          <h2 className=\"text-2xl font-bold text-gray-900 mb-6\">Notification Settings</h2>\n          \n          {/* Notification Categories */}\n          <div className=\"space-y-6\">\n            <div className=\"border border-gray-200 rounded-lg p-4\">\n              <h3 className=\"font-semibold text-gray-900 mb-3\">Health Reminders</h3>\n              <div className=\"space-y-3\">\n                <div className=\"flex items-center justify-between\">\n                  <span className=\"text-gray-700\">Supplement reminders</span>\n                  <input type=\"checkbox\" className=\"rounded\" defaultChecked />\n                </div>\n                <div className=\"flex items-center justify-between\">\n                  <span className=\"text-gray-700\">Medication reminders</span>\n                  <input type=\"checkbox\" className=\"rounded\" defaultChecked />\n                </div>\n                <div className=\"flex items-center justify-between\">\n                  <span className=\"text-gray-700\">Exercise reminders</span>\n                  <input type=\"checkbox\" className=\"rounded\" />\n                </div>\n              </div>\n            </div>\n\n            <div className=\"border border-gray-200 rounded-lg p-4\">\n              <h3 className=\"font-semibold text-gray-900 mb-3\">AI Insights</h3>\n              <div className=\"space-y-3\">\n                <div className=\"flex items-center justify-between\">\n                  <span className=\"text-gray-700\">Daily insights</span>\n                  <input type=\"checkbox\" className=\"rounded\" defaultChecked />\n                </div>\n                <div className=\"flex items-center justify-between\">\n                  <span className=\"text-gray-700\">Weekly health reports</span>\n                  <input type=\"checkbox\" className=\"rounded\" defaultChecked />\n                </div>\n                <div className=\"flex items-center justify-between\">\n                  <span className=\"text-gray-700\">Health goal progress</span>\n                  <input type=\"checkbox\" className=\"rounded\" />\n                </div>\n              </div>\n            </div>\n\n            <div className=\"border border-gray-200 rounded-lg p-4\">\n              <h3 className=\"font-semibold text-gray-900 mb-3\">Account & Security</h3>\n              <div className=\"space-y-3\">\n                <div className=\"flex items-center justify-between\">\n                  <span className=\"text-gray-700\">Login alerts</span>\n                  <input type=\"checkbox\" className=\"rounded\" defaultChecked />\n                </div>\n                <div className=\"flex items-center justify-between\">\n                  <span className=\"text-gray-700\">Password changes</span>\n                  <input type=\"checkbox\" className=\"rounded\" defaultChecked />\n                </div>\n                <div className=\"flex items-center justify-between\">\n                  <span className=\"text-gray-700\">Account updates</span>\n                  <input type=\"checkbox\" className=\"rounded\" />\n                </div>\n              </div>\n            </div>\n          </div>\n\n          {/* Save Button */}\n          <div className=\"mt-8\">\n            <button className=\"bg-helfi-green text-white px-6 py-2 rounded-lg hover:bg-helfi-green/90 transition-colors\">\n              Save Preferences\n            </button>\n          </div>\n        </div>\n      </div>\n    </div>\n  )\n} ","truncated":false,"size":6181},{"path":"app/onboarding/HealthGoals.tsx","content":" ","truncated":false,"size":1},{"path":"app/onboarding/Medications.tsx","content":" ","truncated":false,"size":1},{"path":"app/onboarding/page-old.tsx","content":"import React, { useState } from 'react';\n\nconst steps = [\n  'gender',\n  'physical',\n  'healthGoals',\n  'supplements',\n  'medications',\n  'aiInsights',\n  'review',\n];\n\nfunction GenderStep({ onNext, initial }: { onNext: (data: any) => void, initial?: string }) {\n  const [gender, setGender] = useState(initial || '');\n  const [agreed, setAgreed] = useState(false);\n  return (\n    <div className=\"max-w-md mx-auto mt-12 p-6 bg-white rounded shadow\">\n      <h2 className=\"text-2xl font-bold mb-4\">Let's get started. What's your gender?</h2>\n      <p className=\"mb-4 text-gray-600\">This helps tailor your health guidance.</p>\n      <div className=\"flex gap-4 mb-6\">\n        <button\n          className={`flex-1 p-4 rounded border ${gender === 'male' ? 'bg-helfi-green text-white' : 'border-helfi-green'}`}\n          onClick={() => setGender('male')}\n        >\n          Male\n        </button>\n        <button\n          className={`flex-1 p-4 rounded border ${gender === 'female' ? 'bg-helfi-green text-white' : 'border-helfi-green'}`}\n          onClick={() => setGender('female')}\n        >\n          Female\n        </button>\n      </div>\n      <div className=\"flex items-center mb-4\">\n        <input\n          type=\"checkbox\"\n          id=\"agree-terms\"\n          checked={agreed}\n          onChange={e => setAgreed(e.target.checked)}\n          className=\"mr-2\"\n        />\n        <label htmlFor=\"agree-terms\" className=\"text-sm text-gray-700\">\n          I agree to the <a href=\"/terms\" target=\"_blank\" className=\"text-helfi-green underline\">Terms and Conditions</a> and <a href=\"/privacy\" target=\"_blank\" className=\"text-helfi-green underline\">Privacy Policy</a>\n        </label>\n      </div>\n      <button\n        className=\"btn-primary w-full\"\n        disabled={!gender || !agreed}\n        onClick={() => gender && agreed && onNext({ gender })}\n      >\n        Continue\n      </button>\n    </div>\n  );\n}\n\nfunction PhysicalStep({ onNext, onBack, initial }: { onNext: (data: any) => void, onBack: () => void, initial?: any }) {\n  const [weight, setWeight] = useState(initial?.weight || '');\n  const [height, setHeight] = useState(initial?.height || '');\n  const [bodyType, setBodyType] = useState(initial?.bodyType || '');\n  const [unit, setUnit] = useState<'metric' | 'imperial'>('metric');\n  return (\n    <div className=\"max-w-md mx-auto mt-12 p-6 bg-white rounded shadow\">\n      <h2 className=\"text-2xl font-bold mb-4\">Enter your current weight</h2>\n      <p className=\"mb-4 text-gray-600\">Used to personalize health and supplement recommendations.</p>\n      <div className=\"flex justify-end mb-2\">\n        <button className={`px-3 py-1 rounded-l ${unit === 'metric' ? 'bg-helfi-green text-white' : 'bg-gray-100'}`} onClick={() => setUnit('metric')}>kg/cm</button>\n        <button className={`px-3 py-1 rounded-r ${unit === 'imperial' ? 'bg-helfi-green text-white' : 'bg-gray-100'}`} onClick={() => setUnit('imperial')}>lbs/in</button>\n      </div>\n      <input\n        className=\"input-primary mb-4\"\n        type=\"number\"\n        inputMode=\"numeric\"\n        placeholder={`Weight (${unit === 'metric' ? 'kg' : 'lbs'})`}\n        value={weight}\n        onChange={e => setWeight(e.target.value)}\n        onFocus={() => setWeight('')}\n      />\n      <h2 className=\"text-2xl font-bold mb-4\">How tall are you?</h2>\n      <p className=\"mb-4 text-gray-600\">Height helps us calculate key health metrics.</p>\n      <input\n        className=\"input-primary mb-4\"\n        type=\"number\"\n        inputMode=\"numeric\"\n        placeholder={`Height (${unit === 'metric' ? 'cm' : 'inches'})`}\n        value={height}\n        onChange={e => setHeight(e.target.value)}\n        onFocus={() => setHeight('')}\n      />\n      <h2 className=\"text-2xl font-bold mb-4\">Choose your body type (optional)</h2>\n      <p className=\"mb-4 text-gray-600\">Helps tailor insights to your body composition.</p>\n      <div className=\"flex gap-2 mb-6\">\n        {['ectomorph', 'mesomorph', 'endomorph'].map(type => (\n          <button\n            key={type}\n            className={`flex-1 p-2 rounded border ${bodyType === type ? 'bg-helfi-green text-white' : 'border-helfi-green'}`}\n            onClick={() => setBodyType(type)}\n          >\n            {type.charAt(0).toUpperCase() + type.slice(1)}\n          </button>\n        ))}\n        <button className=\"flex-1 p-2 rounded border border-gray-300\" onClick={() => setBodyType('')}>Skip</button>\n      </div>\n      <div className=\"flex justify-between\">\n        <button className=\"btn-secondary\" onClick={onBack}>Back</button>\n        <button className=\"btn-primary\" disabled={!weight || !height} onClick={() => onNext({ weight, height, bodyType })}>Next</button>\n      </div>\n    </div>\n  );\n}\n\nfunction HealthGoalsStep({ onNext, onBack, initial }: { onNext: (data: any) => void, onBack: () => void, initial?: any }) {\n  const defaultGoals = [\n    'Energy', 'Libido', 'Sleep Quality', 'Stress', 'Digestion', 'Skin Conditions', 'Mood', 'Bloating', 'Headaches', 'Bowel Movements', 'Erection Quality'\n  ];\n  const [goals, setGoals] = useState(initial?.goals || []);\n  const [customGoal, setCustomGoal] = useState('');\n  const toggleGoal = (goal: string) => {\n    setGoals((prev: string[]) => prev.includes(goal) ? prev.filter(g => g !== goal) : [...prev, goal]);\n  };\n  return (\n    <div className=\"max-w-md mx-auto mt-12 p-6 bg-white rounded shadow\">\n      <h2 className=\"text-2xl font-bold mb-4\">Which health concerns are you most interested in improving?</h2>\n      <p className=\"mb-4 text-gray-600\">You can choose from our list or add your own.</p>\n      <div className=\"grid grid-cols-2 gap-2 mb-4\">\n        {defaultGoals.map(goal => (\n          <button\n            key={goal}\n            className={`p-2 rounded border text-left ${goals.includes(goal) ? 'bg-helfi-green text-white' : 'border-helfi-green'}`}\n            onClick={() => toggleGoal(goal)}\n          >\n            {goal}\n          </button>\n        ))}\n      </div>\n      <div className=\"flex mb-4\">\n        <input\n          className=\"input-primary flex-1\"\n          type=\"text\"\n          placeholder=\"Add custom issue\"\n          value={customGoal}\n          onChange={e => setCustomGoal(e.target.value)}\n        />\n        <button className=\"btn-primary ml-2\" onClick={() => { if (customGoal) { toggleGoal(customGoal); setCustomGoal(''); } }}>Add</button>\n      </div>\n      <div className=\"flex justify-between\">\n        <button className=\"btn-secondary\" onClick={onBack}>Back</button>\n        <button className=\"btn-primary\" disabled={goals.length === 0} onClick={() => onNext({ goals })}>Next</button>\n      </div>\n    </div>\n  );\n}\n\nfunction SupplementsStep({ onNext, onBack, initial }: { onNext: (data: any) => void, onBack: () => void, initial?: any }) {\n  const [supplements, setSupplements] = useState(initial?.supplements || []);\n  const [name, setName] = useState('');\n  const [dosage, setDosage] = useState('');\n  const [timing, setTiming] = useState('');\n  const addSupplement = () => {\n    if (name && dosage && timing) {\n      setSupplements((prev: any[]) => [...prev, { name, dosage, timing }]);\n      setName(''); setDosage(''); setTiming('');\n    }\n  };\n  return (\n    <div className=\"max-w-md mx-auto mt-12 p-6 bg-white rounded shadow\">\n      <h2 className=\"text-2xl font-bold mb-4\">Upload your supplements</h2>\n      <p className=\"mb-4 text-gray-600\">Add photos or enter manually to get AI guidance.</p>\n      <div className=\"mb-4\">\n        <input className=\"input-primary mb-2\" type=\"text\" placeholder=\"Supplement name\" value={name} onChange={e => setName(e.target.value)} />\n        <input className=\"input-primary mb-2\" type=\"text\" placeholder=\"Dosage\" value={dosage} onChange={e => setDosage(e.target.value)} />\n        <input className=\"input-primary mb-2\" type=\"text\" placeholder=\"Timing (e.g. morning)\" value={timing} onChange={e => setTiming(e.target.value)} />\n        <button className=\"btn-primary w-full\" onClick={addSupplement}>Add Supplement</button>\n      </div>\n      <ul className=\"mb-4\">\n        {supplements.map((s: any, i: number) => (\n          <li key={i} className=\"mb-1\">{s.name} - {s.dosage} - {s.timing}</li>\n        ))}\n      </ul>\n      <div className=\"flex justify-between\">\n        <button className=\"btn-secondary\" onClick={onBack}>Back</button>\n        <button className=\"btn-primary\" onClick={() => onNext({ supplements })}>Next</button>\n      </div>\n    </div>\n  );\n}\n\nfunction MedicationsStep({ onNext, onBack, initial }: { onNext: (data: any) => void, onBack: () => void, initial?: any }) {\n  const [medications, setMedications] = useState(initial?.medications || []);\n  const [name, setName] = useState('');\n  const [dosage, setDosage] = useState('');\n  const [timing, setTiming] = useState('');\n  const addMedication = () => {\n    if (name && dosage && timing) {\n      setMedications((prev: any[]) => [...prev, { name, dosage, timing }]);\n      setName(''); setDosage(''); setTiming('');\n    }\n  };\n  return (\n    <div className=\"max-w-md mx-auto mt-12 p-6 bg-white rounded shadow\">\n      <h2 className=\"text-2xl font-bold mb-4\">Add your medications</h2>\n      <p className=\"mb-4 text-gray-600\">This helps us check for supplement-medication conflicts.</p>\n      <div className=\"mb-4\">\n        <input className=\"input-primary mb-2\" type=\"text\" placeholder=\"Medication name\" value={name} onChange={e => setName(e.target.value)} />\n        <input className=\"input-primary mb-2\" type=\"text\" placeholder=\"Dosage\" value={dosage} onChange={e => setDosage(e.target.value)} />\n        <input className=\"input-primary mb-2\" type=\"text\" placeholder=\"Timing (e.g. night)\" value={timing} onChange={e => setTiming(e.target.value)} />\n        <button className=\"btn-primary w-full\" onClick={addMedication}>Add Medication</button>\n      </div>\n      <ul className=\"mb-4\">\n        {medications.map((m: any, i: number) => (\n          <li key={i} className=\"mb-1\">{m.name} - {m.dosage} - {m.timing}</li>\n        ))}\n      </ul>\n      <div className=\"flex justify-between\">\n        <button className=\"btn-secondary\" onClick={onBack}>Back</button>\n        <button className=\"btn-primary\" onClick={() => onNext({ medications })}>Analyze for Contradictions</button>\n      </div>\n    </div>\n  );\n}\n\nfunction AIInsightsStep({ onNext, onBack, initial }: { onNext: (data: any) => void, onBack: () => void, initial?: any }) {\n  const [wantInsights, setWantInsights] = useState(initial?.wantInsights || '');\n  return (\n    <div className=\"max-w-md mx-auto mt-12 p-6 bg-white rounded shadow\">\n      <h2 className=\"text-2xl font-bold mb-4\">Want AI-generated insights in 7 days?</h2>\n      <p className=\"mb-4 text-gray-600\">Our AI will analyze trends and send a custom health report.</p>\n      <div className=\"flex gap-4 mb-6\">\n        <button className={`flex-1 p-4 rounded border ${wantInsights === 'yes' ? 'bg-helfi-green text-white' : 'border-helfi-green'}`} onClick={() => setWantInsights('yes')}>Yes</button>\n        <button className={`flex-1 p-4 rounded border ${wantInsights === 'no' ? 'bg-helfi-green text-white' : 'border-helfi-green'}`} onClick={() => setWantInsights('no')}>No Thanks</button>\n      </div>\n      <div className=\"flex justify-between\">\n        <button className=\"btn-secondary\" onClick={onBack}>Back</button>\n        <button className=\"btn-primary\" disabled={!wantInsights} onClick={() => onNext({ wantInsights })}>Next</button>\n      </div>\n    </div>\n  );\n}\n\nfunction ReviewStep({ onBack, data }: { onBack: () => void, data: any }) {\n  return (\n    <div className=\"max-w-md mx-auto mt-12 p-6 bg-white rounded shadow\">\n      <h2 className=\"text-2xl font-bold mb-4\">Here's what we have so far</h2>\n      <p className=\"mb-4 text-gray-600\">Double-check your inputs before we take you to your dashboard.</p>\n      <div className=\"mb-4 text-left\">\n        <div><b>Gender:</b> {data.gender}</div>\n        <div><b>Weight:</b> {data.weight}</div>\n        <div><b>Height:</b> {data.height}</div>\n        <div><b>Body Type:</b> {data.bodyType}</div>\n        <div><b>Health Goals:</b> {(data.goals || []).join(', ')}</div>\n        <div><b>Supplements:</b> {(data.supplements || []).map((s: any) => `${s.name} (${s.dosage}, ${s.timing})`).join('; ')}</div>\n        <div><b>Medications:</b> {(data.medications || []).map((m: any) => `${m.name} (${m.dosage}, ${m.timing})`).join('; ')}</div>\n        <div><b>AI Insights:</b> {data.wantInsights === 'yes' ? 'Yes' : 'No'}</div>\n      </div>\n      <div className=\"flex justify-between\">\n        <button className=\"btn-secondary\" onClick={onBack}>Back</button>\n        <button className=\"btn-primary\" onClick={() => window.location.href = '/dashboard'}>Confirm &amp; Begin</button>\n      </div>\n    </div>\n  );\n}\n\nexport default function Onboarding() {\n  const [step, setStep] = useState(0);\n  const [form, setForm] = useState<any>({});\n\n  const handleNext = (data: any) => {\n    setForm((prev: any) => ({ ...prev, ...data }));\n    setStep((prev) => prev + 1);\n  };\n  const handleBack = () => setStep((prev) => Math.max(0, prev - 1));\n\n  if (steps[step] === 'gender') {\n    return <GenderStep onNext={handleNext} initial={form.gender} />;\n  }\n  if (steps[step] === 'physical') {\n    return <PhysicalStep onNext={handleNext} onBack={handleBack} initial={form} />;\n  }\n  if (steps[step] === 'healthGoals') {\n    return <HealthGoalsStep onNext={handleNext} onBack={handleBack} initial={form} />;\n  }\n  if (steps[step] === 'supplements') {\n    return <SupplementsStep onNext={handleNext} onBack={handleBack} initial={form} />;\n  }\n  if (steps[step] === 'medications') {\n    return <MedicationsStep onNext={handleNext} onBack={handleBack} initial={form} />;\n  }\n  if (steps[step] === 'aiInsights') {\n    return <AIInsightsStep onNext={handleNext} onBack={handleBack} initial={form} />;\n  }\n  if (steps[step] === 'review') {\n    return <ReviewStep onBack={handleBack} data={form} />;\n  }\n  return null;\n}","truncated":false,"size":13860},{"path":"app/onboarding/page.tsx","content":"'use client';\n// Fixed: Added use client directive for useState compatibility\n\nimport React, { useState, useEffect, useRef, useCallback, memo } from 'react';\nimport { useSession, signOut } from 'next-auth/react';\nimport Image from 'next/image';\nimport Link from 'next/link';\nimport { flushSync } from 'react-dom';\nimport { useRouter } from 'next/navigation';\nimport CreditPurchaseModal from '@/components/CreditPurchaseModal';\nimport { useUserData } from '@/components/providers/UserDataProvider';\nimport MobileMoreMenu from '@/components/MobileMoreMenu';\nimport UsageMeter from '@/components/UsageMeter';\nimport InsightsProgressBar from '@/components/InsightsProgressBar';\nimport { UserIcon, InformationCircleIcon } from '@heroicons/react/24/outline';\nimport MaterialSymbol from '@/components/MaterialSymbol';\nimport { DIET_CATEGORIES, DIET_OPTIONS, getDietOption, normalizeDietTypes } from '@/lib/diets';\n\nconst sanitizeUserDataPayload = (payload: any) => {\n  if (!payload || typeof payload !== 'object') return payload;\n  // Strip food diary and favorites fields so health-setup autosaves cannot overwrite them\n  const { todaysFoods, favorites, ...rest } = payload as any;\n  return rest;\n};\n\n// Auth-enabled onboarding flow\n\n// Update Insights Popup Component\nfunction UpdateInsightsPopup({ \n  isOpen, \n  onClose, \n  onUpdateInsights, \n  isGenerating,\n  onAddMore,\n}: { \n  isOpen: boolean\n  onClose: () => void\n  onUpdateInsights: () => void\n  isGenerating: boolean\n  onAddMore?: () => void\n}) {\n  if (!isOpen) return null;\n\n  return (\n    <div className=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4\">\n      <div className=\"bg-white rounded-lg shadow-xl max-w-md w-full p-6\">\n        <div className=\"flex items-center mb-4\">\n          <div className=\"flex-shrink-0\">\n            <svg className=\"h-6 w-6 text-helfi-green\" fill=\"currentColor\" viewBox=\"0 0 20 20\">\n              <path fillRule=\"evenodd\" d=\"M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z\" clipRule=\"evenodd\" />\n            </svg>\n          </div>\n          <h3 className=\"ml-3 text-lg font-medium text-gray-900\">\n            Update Insights?\n          </h3>\n        </div>\n        \n        <div className=\"mb-6\">\n          <p className=\"text-sm text-gray-600 mb-4\">\n            You've changed your health information. Would you like to update your insights now? This will regenerate AI insights, update Talk to AI, and refresh all AI-powered sections with your latest data.\n          </p>\n          <p className=\"text-xs text-gray-500 mb-3\">\n            Credits will be charged after generation based on actual AI usage.\n          </p>\n          {isGenerating && (\n            <div className=\"mb-4\">\n              <InsightsProgressBar isGenerating={true} message=\"Generating insights...\" />\n            </div>\n          )}\n        </div>\n        \n        <div className=\"flex flex-col space-y-3\">\n          <button\n            onClick={onUpdateInsights}\n            disabled={isGenerating}\n            className=\"w-full px-4 py-3 bg-helfi-green text-white rounded-lg hover:bg-helfi-green/90 transition-colors disabled:opacity-60 disabled:cursor-not-allowed font-medium\"\n            type=\"button\"\n          >\n            {isGenerating ? (\n              <>\n                <span className=\"inline-block h-4 w-4 animate-spin rounded-full border-2 border-white border-t-transparent mr-2\"></span>\n                Updating Insights...\n              </>\n            ) : (\n              'Update Insights'\n            )}\n          </button>\n          <button\n            onClick={() => {\n              if (onAddMore) {\n                onAddMore();\n              } else {\n                onClose();\n              }\n            }}\n            disabled={isGenerating}\n            className=\"w-full px-4 py-3 border border-gray-300 text-gray-700 rounded-lg hover:bg-gray-50 transition-colors disabled:opacity-60 disabled:cursor-not-allowed\"\n            type=\"button\"\n          >\n            Add More\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n}\n\nconst steps = [\n  'gender',\n  'physical',\n  'exercise',\n  'healthGoals',\n  'healthSituations',\n  'supplements',\n  'medications',\n  'bloodResults',\n  'aiInsights',\n  'review',\n];\n\ntype InsightChangeType =\n  | 'supplements'\n  | 'medications'\n  | 'food'\n  | 'exercise'\n  | 'health_goals'\n  | 'health_situations'\n  | 'profile'\n  | 'blood_results';\n\nfunction normalizeForComparison(value: any): any {\n  if (Array.isArray(value)) {\n    return [...value]\n      .map((item) => normalizeForComparison(item))\n      .sort((a, b) => {\n        const aStr = JSON.stringify(a) || '';\n        const bStr = JSON.stringify(b) || '';\n        return aStr.localeCompare(bStr);\n      });\n  }\n  if (value && typeof value === 'object') {\n    return Object.keys(value)\n      .sort()\n      .reduce((acc: Record<string, any>, key) => {\n        acc[key] = normalizeForComparison((value as any)[key]);\n        return acc;\n      }, {});\n  }\n  return value ?? null;\n}\n\nfunction getInsightsRelevantOnboardingFormSnapshot(source: any): any {\n  const sanitized = sanitizeUserDataPayload(source) || {};\n  const normalizeRoundedNumberString = (raw: any) => {\n    if (raw === null || raw === undefined || raw === '') return ''\n    const n = typeof raw === 'number' ? raw : Number(String(raw))\n    if (!Number.isFinite(n)) return (raw || '').toString()\n    return String(Math.round(n))\n  }\n  const healthSituationsDefault = {\n    healthIssues: '',\n    healthProblems: '',\n    additionalInfo: '',\n    skipped: false,\n  };\n\n  return {\n    gender: typeof sanitized.gender === 'string' ? sanitized.gender : '',\n    // Important: backend may load these as numbers (DB Floats) while the form saves strings.\n    // Normalizing prevents false \"Update Insights\" prompts when the value is the same.\n    weight: normalizeRoundedNumberString((sanitized as any).weight),\n    height: normalizeRoundedNumberString((sanitized as any).height),\n    bodyType: typeof sanitized.bodyType === 'string' ? sanitized.bodyType : '',\n    birthdate: typeof sanitized.birthdate === 'string' ? sanitized.birthdate : '',\n    dietTypes: normalizeDietTypes((sanitized as any)?.dietTypes ?? (sanitized as any)?.dietType).sort(),\n    goalChoice: typeof sanitized.goalChoice === 'string' ? sanitized.goalChoice : '',\n    goalIntensity: (sanitized.goalIntensity || 'standard').toString().toLowerCase(),\n    profileInfo: sanitized.profileInfo && typeof sanitized.profileInfo === 'object' ? sanitized.profileInfo : {},\n    allergies: Array.isArray(sanitized.allergies) ? sanitized.allergies : [],\n    diabetesType: typeof sanitized.diabetesType === 'string' ? sanitized.diabetesType : '',\n\n    goals: Array.isArray(sanitized.goals) ? sanitized.goals : [],\n    healthSituations:\n      sanitized.healthSituations && typeof sanitized.healthSituations === 'object'\n        ? { ...healthSituationsDefault, ...sanitized.healthSituations }\n        : healthSituationsDefault,\n    supplements: Array.isArray(sanitized.supplements) ? sanitized.supplements : [],\n    medications: Array.isArray(sanitized.medications) ? sanitized.medications : [],\n    bloodResults:\n      sanitized.bloodResults && typeof sanitized.bloodResults === 'object' ? sanitized.bloodResults : {},\n  };\n}\n\nfunction pickFields(source: any, fields: string[]) {\n  const result: Record<string, any> = {};\n  for (const field of fields) {\n    if (source && Object.prototype.hasOwnProperty.call(source, field)) {\n      result[field] = source[field];\n    }\n  }\n\n... [truncated] ...\n\n          try {\n            window.dispatchEvent(new Event('userData:refresh'));\n          } catch {}\n\n              // Step 2: Fire regen in background WITHOUT waiting (only when change types exist)\n              if (changeTypes.length) {\n                fireAndForgetInsightsRegen(changeTypes);\n              }\n              \n              // Step 3: Close popup immediately - data is saved, regen is in background\n              setHasGlobalUnsavedChanges(false);\n              syncFormBaseline();\n              setShowGlobalUpdatePopup(false);\n              runPendingNavigation();\n            } catch (error) {\n              console.warn('Error saving data:', error);\n              alert('Failed to save your changes. Please try again.');\n            } finally {\n              setIsGlobalGenerating(false);\n            }\n          }}\n          isGenerating={isGlobalGenerating}\n        />\n\n        {/* Mobile Bottom Navigation */}\n        <nav className=\"md:hidden fixed bottom-0 left-0 right-0 bg-white border-t border-gray-200 px-4 py-2 z-40\">\n          <div className=\"flex items-center justify-around\">\n            \n            {/* Dashboard */}\n            <Link href=\"/dashboard\" className=\"flex flex-col items-center py-2 px-1 min-w-0 flex-1\">\n              <div className=\"text-gray-400\">\n                <svg className=\"w-6 h-6\" fill=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path d=\"M3 13h8V3H3v10zm0 8h8v-6H3v6zm10 0h8V11h-8v10zm0-18v6h8V3h-8z\"/>\n                </svg>\n              </div>\n              <span className=\"text-xs text-gray-400 mt-1 font-medium truncate\">Dashboard</span>\n            </Link>\n\n            {/* Insights */}\n            <Link href=\"/insights\" className=\"flex flex-col items-center py-2 px-1 min-w-0 flex-1\">\n              <div className=\"text-gray-400\">\n                <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z\" />\n                </svg>\n              </div>\n              <span className=\"text-xs text-gray-400 mt-1 font-medium truncate\">Insights</span>\n            </Link>\n\n            {/* Food */}\n            <Link href=\"/food\" className=\"flex flex-col items-center py-2 px-1 min-w-0 flex-1\">\n              <div className=\"text-gray-400\">\n                <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10\" />\n                </svg>\n              </div>\n              <span className=\"text-xs text-gray-400 mt-1 font-medium truncate\">Food</span>\n            </Link>\n\n            {/* More */}\n            <MobileMoreMenu />\n\n            {/* Settings */}\n            <Link href=\"/settings\" className=\"flex flex-col items-center py-2 px-1 min-w-0 flex-1\">\n              <div className=\"text-gray-400\">\n                <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756.426-1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37\" />\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M15 12a3 3 0 11-6 0 3 3 0 016 0z\" />\n                </svg>\n              </div>\n              <span className=\"text-xs text-gray-400 mt-1 font-medium truncate\">Settings</span>\n            </Link>\n          </div>\n        </nav>\n\n        {/* Reset Confirmation Popup */}\n        {showResetConfirm && (\n          <div className=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4\">\n            <div className=\"bg-white rounded-lg p-6 max-w-md w-full\">\n              <h3 className=\"text-lg font-semibold text-gray-900 mb-4\">Reset Page Data</h3>\n              <p className=\"text-gray-600 mb-6\">\n                Are you sure you want to reset all data on this page? This will clear all your current progress and cannot be undone.\n              </p>\n              <div className=\"flex space-x-3\">\n                <button\n                  onClick={() => setShowResetConfirm(false)}\n                  className=\"flex-1 px-4 py-2 border border-gray-300 rounded-lg text-gray-700 hover:bg-gray-50\"\n                >\n                  Cancel\n                </button>\n                <button\n                  onClick={() => {\n                    window.location.reload();\n                    setShowResetConfirm(false);\n                  }}\n                  className=\"flex-1 px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700\"\n                >\n                  Reset Page\n                </button>\n              </div>\n            </div>\n          </div>\n        )}\n        \n        {/* Background Regen Status Indicator */}\n        {backgroundRegenStatus.isRegenerating && (\n          <div className=\"fixed bottom-20 md:bottom-4 left-1/2 transform -translate-x-1/2 z-50 animate-in fade-in duration-300\">\n            <div className=\"bg-gray-900 text-white px-4 py-2 rounded-full shadow-lg flex items-center space-x-2\">\n              <svg className=\"w-4 h-4 animate-spin\" fill=\"none\" viewBox=\"0 0 24 24\">\n                <circle className=\"opacity-25\" cx=\"12\" cy=\"12\" r=\"10\" stroke=\"currentColor\" strokeWidth=\"4\"></circle>\n                <path className=\"opacity-75\" fill=\"currentColor\" d=\"M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z\"></path>\n              </svg>\n              <span className=\"text-sm font-medium\">{backgroundRegenStatus.message || 'Updating insights...'}</span>\n            </div>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n","truncated":true,"size":324163},{"path":"app/onboarding/PhysicalMetrics.tsx","content":" ","truncated":false,"size":1},{"path":"app/onboarding/Review.tsx","content":" ","truncated":false,"size":1},{"path":"app/onboarding/SignUp.tsx","content":" ","truncated":false,"size":1},{"path":"app/onboarding/Supplements.tsx","content":" ","truncated":false,"size":1},{"path":"app/page.tsx","content":"'use client'\n\nimport React, { useState, useEffect, useRef } from 'react'\nimport Link from 'next/link'\nimport Image from 'next/image'\nimport { useSession } from 'next-auth/react'\nimport HeroCarousel from '@/components/HeroCarousel'\n// Back to Top Button Component\nfunction BackToTopButton() {\n  const [isVisible, setIsVisible] = useState(false)\n\n  useEffect(() => {\n    const toggleVisibility = () => {\n      if (window.pageYOffset > 300) {\n        setIsVisible(true)\n      } else {\n        setIsVisible(false)\n      }\n    }\n\n    window.addEventListener('scroll', toggleVisibility)\n    return () => window.removeEventListener('scroll', toggleVisibility)\n  }, [])\n\n  const scrollToTop = () => {\n    window.scrollTo({\n      top: 0,\n      behavior: 'smooth'\n    })\n  }\n\n  return (\n    <button\n      onClick={scrollToTop}\n      className={`fixed bottom-8 right-8 z-50 bg-helfi-green text-white p-3 rounded-full shadow-lg hover:bg-helfi-green/90 transition-all duration-300 transform ${\n        isVisible ? 'translate-y-0 opacity-100' : 'translate-y-16 opacity-0'\n      }`}\n      aria-label=\"Back to top\"\n    >\n      <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n        <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M5 10l7-7m0 0l7 7m-7-7v18\" />\n      </svg>\n    </button>\n  )\n}\n\nexport default function SplashPage() {\n  const { data: session, status } = useSession()\n  const [showDemoModal, setShowDemoModal] = useState(false)\n  const [videoLoaded, setVideoLoaded] = useState(false)\n  const videoRef = useRef<HTMLVideoElement>(null)\n\n  // Handle subscription plan selection\n  const handlePlanSelection = async (planId: string) => {\n    // If user is authenticated, go directly to checkout\n    if (status === 'authenticated' && session) {\n      try {\n        const res = await fetch('/api/billing/create-checkout-session', {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({ plan: planId }),\n        })\n        if (res.ok) {\n          const { url } = await res.json()\n          if (url) {\n            window.location.href = url\n            return\n          }\n        }\n      } catch (error) {\n        console.error('Checkout error:', error)\n      }\n    }\n    // If not authenticated, redirect to signin with plan parameter\n    window.location.href = `/auth/signin?plan=${encodeURIComponent(planId)}`\n  }\n\n  // Handle credit purchase\n  const handleCreditPurchase = async (planId: string) => {\n    // If user is authenticated, go directly to checkout\n    if (status === 'authenticated' && session) {\n      try {\n        const res = await fetch('/api/billing/create-checkout-session', {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({ plan: planId }),\n        })\n        if (res.ok) {\n          const { url } = await res.json()\n          if (url) {\n            window.location.href = url\n            return\n          }\n        }\n      } catch (error) {\n        console.error('Checkout error:', error)\n      }\n    }\n    // If not authenticated, redirect to signin with plan parameter\n    window.location.href = `/auth/signin?plan=${encodeURIComponent(planId)}`\n  }\n\n  const handleDemoModalClose = () => {\n    setShowDemoModal(false)\n  }\n\n  const loginHref = '/auth/signin'\n  const signupHref = '/auth/signin?mode=signup'\n  return (\n    <div className=\"min-h-screen bg-gradient-to-br from-helfi-green/5 via-white to-blue-50\">\n      {/* Medical Disclaimer Banner */}\n      <div className=\"bg-helfi-green p-4\">\n        <div className=\"max-w-6xl mx-auto text-center\">\n          <div className=\"inline-flex items-center bg-white text-helfi-green px-3 py-1 rounded-full font-semibold text-sm mb-2\">\n            Medical Disclaimer\n          </div>\n          <p className=\"text-sm text-white\">\n            Helfi is not a medical device and does not provide medical advice, diagnosis, or treatment. Always consult with a qualified healthcare provider before making health-related decisions. <Link href=\"/terms\" className=\"underline text-white hover:text-white/90\">View full disclaimer</Link>\n          </p>\n        </div>\n      </div>\n\n      {/* Navigation */}\n      <nav className=\"relative z-10 px-6 py-1\">\n        <div className=\"max-w-6xl mx-auto flex justify-between items-center\">\n          <div className=\"flex items-center\">\n            <button \n              onClick={() => window.location.reload()}\n              className=\"w-28 h-28 md:w-40 md:h-40 cursor-pointer hover:opacity-80 transition-opacity\"\n            >\n              <Image\n                src=\"/mobile-assets/LOGOS/helfi-01-01.png\"\n                alt=\"Helfi Logo\"\n                width={160}\n                height={160}\n                className=\"w-full h-full object-contain\"\n                priority\n              />\n            </button>\n          </div>\n          \n          {/* Desktop Menu */}\n          <div className=\"hidden md:flex items-center space-x-8\">\n            <button \n              onClick={() => document.getElementById('features')?.scrollIntoView({ behavior: 'smooth' })}\n              className=\"text-gray-700 hover:text-helfi-green transition-colors font-medium text-lg\"\n            >\n              Features\n            </button>\n            <button \n              onClick={() => document.getElementById('pricing')?.scrollIntoView({ behavior: 'smooth' })}\n              className=\"text-gray-700 hover:text-helfi-green transition-colors font-medium text-lg\"\n            >\n              Pricing\n            </button>\n            <button \n              onClick={() => document.getElementById('why-helfi')?.scrollIntoView({ behavior: 'smooth' })}\n              className=\"text-gray-700 hover:text-helfi-green transition-colors font-medium text-lg\"\n            >\n              Why Helfi\n            </button>\n            <button \n              onClick={() => document.getElementById('faq')?.scrollIntoView({ behavior: 'smooth' })}\n              className=\"text-gray-700 hover:text-helfi-green transition-colors font-medium text-lg\"\n            >\n              FAQ\n            </button>\n            {status === 'authenticated' ? (\n              <Link\n                href=\"/dashboard\"\n                className=\"btn-primary text-lg px-6 py-3 bg-helfi-green hover:bg-green-600 text-white\"\n              >\n                Go to Dashboard\n              </Link>\n            ) : (\n              <div className=\"flex items-center gap-3\">\n                <Link\n                  href={loginHref}\n                  className=\"btn-secondary text-lg px-6 py-3 text-helfi-green hover:bg-helfi-green hover:text-white transition-colors\"\n                >\n                  Log in\n                </Link>\n                <Link\n                  href={signupHref}\n                  className=\"btn-primary text-lg px-6 py-3 bg-helfi-green hover:bg-green-600 text-white\"\n                >\n                  Create account\n                </Link>\n              </div>\n            )}\n          </div>\n\n          {/* Mobile Menu */}\n          <div className=\"md:hidden flex items-center space-x-3\">\n            {status === 'authenticated' ? (\n              <Link\n                href=\"/dashboard\"\n                className=\"btn-primary text-base px-3 py-2 bg-helfi-green hover:bg-green-600 text-white\"\n              >\n                Dashboard\n              </Link>\n            ) : (\n              <>\n                <Link\n                  href={loginHref}\n                  className=\"btn-secondary text-base px-3 py-2 text-helfi-green hover:bg-helfi-green hover:text-white transition-colors\"\n                >\n                  Log in\n                </Link>\n                <Link\n                  href={signupHref}\n                  className=\"btn-primary text-base px-3 py-2 bg-helfi-green hover:bg-green-600 text-white\"\n                >\n                  Sign up\n                </Link>\n              </>\n            )}\n          </div>\n        </div>\n      </nav>\n\n      {/* Hero Section */}\n      <section className=\"relative w-full min-h-screen flex flex-col overflow-visible bg-gray-900\" style={{ overflow: 'visible' }}>\n        {/* Full-Width Background Video */}\n        <div className=\"absolute inset-0 z-0\">\n          <video\n            ref={videoRef}\n            autoPlay\n            loop\n            muted\n            playsInline\n            preload=\"auto\"\n            poster=\"/screenshots/hero/hero-poster.jpg\"\n            className=\"absolute inset-0 w-full h-full object-cover z-0\"\n            onCanPlay={() => setVideoLoaded(true)}\n            onLoadedData={() => setVideoLoaded(true)}\n            onError={(e) => {\n              console.error('Video error:', e)\n              setVideoLoaded(false)\n            }}\n            style={{ width: '100%', height: '100%', objectFit: 'cover' }}\n          >\n            <source src=\"/screenshots/hero/hero-background.mp4\" type=\"video/mp4\" />\n            Your browser does not support the video tag.\n          </video>\n          {/* Dark overlay on video */}\n          <div className=\"absolute inset-0 bg-black/60 z-[1]\" />\n          {/* Dark background fallback - only shown when video doesn't load */}\n          {!videoLoaded && (\n            <div className=\"absolute inset-0 bg-gray-900 z-0\" />\n          )}\n        </div>\n\n        {/* Content Container */}\n        <div className=\"relative z-10 w-full max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pt-4 md:pt-8 pb-2 md:pb-4\">\n          {/* Text Content */}\n          <div className=\"text-center mb-6\">\n            <h1 className=\"text-5xl sm:text-6xl md:text-7xl lg:text-8xl font-bold text-white mb-6 leading-tight\">\n              Your Personal <span className=\"text-helfi-green\">Health Intelligence Platform</span>\n            </h1>\n            <p className=\"text-xl md:text-2xl text-white/90 mb-10 leading-relaxed max-w-4xl mx-auto\">\n              Track your health metrics, supplements, and medications. Get AI-powered insights \n              and personalized recommendations to optimize your wellbeing. Analyze food photos, \n              lab reports, and medical images‚Äîall in one intelligent platform.\n            </p>\n            <div className=\"flex flex-col sm:flex-row gap-4 justify-center\">\n              <button \n                onClick={() => setShowDemoModal(true)}\n                className=\"btn-secondary text-lg px-8 py-4 bg-white/10 backdrop-blur-sm border-2 border-white/30 text-white hover:bg-white/20\"\n              >\n                Watch Demo\n              </button>\n            </div>\n          </div>\n        </div>\n\n        {/* Full-Screen Horizontal Scrolling Carousel */}\n        <div className=\"relative z-10 w-full\">\n          <HeroCarousel />\n        </div>\n      </section>\n\n      {/* Features Section */}\n      <section id=\"features\" className=\"px-4 sm:px-6 lg:px-10 xl:px-16 py-16 lg:py-20 bg-white\">\n        <div className=\"max-w-6xl mx-auto\">\n          <div className=\"text-center mb-16\">\n            <h2 className=\"text-4xl font-bold text-helfi-black mb-4\">\n              Everything you need for optimal health\n            </h2>\n            <p className=\"text-xl text-gray-600\">\n              Comprehensive health tracking meets artificial intelligence\n            </p>\n          </div>\n\n          <div className=\"grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6 lg:gap-8\">\n            <div className=\"bg-white rounded-xl p-8 shadow-sm border border-gray-100 hover:shadow-md transition-all duration-300 hover:-translate-y-1\">\n              <div className=\"w-16 h-16 bg-helfi-green/10 rounded-full flex items-center justify-center mx-auto mb-6\">\n                <svg className=\"w-8 h-8 text-helfi-green\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z\" />\n                </svg>\n              </div>\n              <h3 className=\"text-2xl font-bold text-helfi-black mb-4\">Smart Health Tracking</h3>\n              <p className=\"text-gray-600 leading-relaxed\">\n                Track weight, sleep, mood, energy levels, and custom health metrics with intelligent pattern recognition. Connect wearables for automatic data sync.\n              </p>\n            </div>\n\n            <div className=\"bg-white rounded-xl p-8 shadow-sm border border-gray-100 hover:shadow-md transition-all duration-300 hover:-translate-y-1\">\n              <div className=\"w-16 h-16 bg-blue-100 rounded-full flex items-center justify-center mx-auto mb-6\">\n                <svg className=\"w-8 h-8 text-blue-600\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z\" />\n                </svg>\n              </div>\n              <h3 className=\"text-2xl font-bold text-helfi-black mb-4\">AI-Powered Insights</h3>\n              <p className=\"text-gray-600 leading-relaxed\">\n                Get personalized recommendations based on your unique health patterns and goals. Advanced AI analyzes correlations across nutrition, supplements, sleep, and symptoms.\n              </p>\n            </div>\n\n            <div className=\"bg-white rounded-xl p-8 shadow-sm border border-gray-100 hover:shadow-md transition-all duration-300 hover:-translate-y-1\">\n              <div className=\"w-16 h-16 bg-purple-100 rounded-full flex items-center justify-center mx-auto mb-6\">\n                <svg className=\"w-8 h-8 text-purple-600\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M19.428 15.428a2 2 0 00-1.022-.547l-2.387-.477a6 6 0 00-3.86.517l-.318.158a6 6 0 01-3.86.517L6.05 15.21a2 2 0 00-1.806.547M8 4h8l-1 1v5.172a2 2 0 00.586 1.414l5 5c1.26 1.26.367 3.414-1.415 3.414H4.828c-1.782 0-2.674-2.154-1.414-3.414l5-5A2 2 0 009 10.172V5L8 4z\" />\n                </svg>\n              </div>\n              <h3 className=\"text-2xl font-bold text-helfi-black mb-4\">Medication & Supplement Safety</h3>\n              <p className=\"text-gray-600 leading-relaxed\">\n                Track supplements and medications with photo recognition. Automatic interaction checking alerts you to dangerous combinations and optimal timing recommendations.\n              </p>\n            </div>\n\n            <div className=\"bg-white rounded-xl p-8 shadow-sm border border-gray-100 hover:shadow-md transition-all duration-300 hover:-translate-y-1\">\n              <div className=\"w-16 h-16 bg-red-100 rounded-full flex items-center justify-center mx-auto mb-6\">\n                <svg className=\"w-8 h-8 text-red-600\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z\" />\n                </svg>\n              </div>\n              <h3 className=\"text-2xl font-bold text-helfi-black mb-4\">Food Photo Analysis</h3>\n              <p className=\"text-gray-600 leading-relaxed\">\n                Simply snap a photo of your meal. AI identifies ingredients, estimates portions, and calculates complete nutritional breakdown including macros, vitamins, and minerals.\n              </p>\n            </div>\n\n            <div className=\"bg-white rounded-xl p-8 shadow-sm border border-gray-100 hover:shadow-md transition-all duration-300 hover:-translate-y-1\">\n              <div className=\"w-16 h-16 bg-orange-100 rounded-full flex items-center justify-center mx-auto mb-6\">\n                <svg className=\"w-8 h-8 text-orange-600\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z\" />\n                </svg>\n              </div>\n              <h3 className=\"text-2xl font-bold text-helfi-black mb-4\">Lab Report Analysis</h3>\n              <p className=\"text-gray-600 leading-relaxed\">\n                Upload PDF lab reports or photos. AI extracts and tracks biomarkers over time, identifying trends and flagging values that need attention. Encrypted and secure.\n              </p>\n            </div>\n\n            <div className=\"bg-white rounded-xl p-8 shadow-sm border border-gray-100 hover:shadow-md transition-all duration-300 hover:-translate-y-1\">\n              <div className=\"w-16 h-16 bg-indigo-100 rounded-full flex items-center justify-center mx-auto mb-6\">\n                <svg className=\"w-8 h-8 text-indigo-600\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M7 8h10M7 12h4m1 8l-4-4H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-3l-4 4z\" />\n                </svg>\n              </div>\n              <h3 className=\"text-2xl font-bold text-helfi-black mb-4\">Symptom Tracking & Analysis</h3>\n              <p className=\"text-gray-600 leading-relaxed\">\n                Log symptoms with photos and descriptions. AI identifies patterns, correlates with your nutrition and supplement intake, and suggests potential causes.\n              </p>\n            </div>\n          </div>\n        </div>\n      </section>\n\n      {/* Why Health Tracking Matters Section */}\n      <section id=\"why-helfi\" className=\"px-6 py-20 bg-gradient-to-br from-green-50 to-blue-50\">\n        <div className=\"max-w-6xl mx-auto\">\n          <div className=\"text-center mb-16\">\n            <h2 className=\"text-4xl font-bold text-helfi-black mb-6\">\n              Why Personal Health Intelligence Matters\n            </h2>\n            <p className=\"text-xl text-gray-600 max-w-3xl mx-auto leading-relaxed\">\n              In today's fast-paced world, maintaining optimal health requires more than just good intentions. \n              Our AI-powered health intelligence platform transforms how you understand and optimize your wellbeing.\n            </p>\n          </div>\n\n          <div className=\"grid grid-cols-1 lg:grid-cols-2 gap-16 items-start mt-16\">\n            <div className=\"space-y-8\">\n              <div className=\"flex items-start space-x-4\">\n                <div className=\"bg-red-100 rounded-full p-3 mt-1 flex-shrink-0\">\n                  <svg className=\"w-6 h-6 text-red-600\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                    <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z\" />\n                  </svg>\n                </div>\n                <div>\n                  <h3 className=\"text-xl font-bold text-helfi-black mb-3\">Hidden Health Patterns</h3>\n                  <p className=\"text-gray-600\">\n                    Many health issues develop silently over time. Without consistent tracking, patterns that could \n                    indicate emerging problems often go unnoticed until they become serious.\n                  </p>\n                </div>\n              </div>\n\n              <div className=\"flex items-start space-x-4\">\n                <div className=\"bg-yellow-100 rounded-full p-3 mt-1 flex-shrink-0\">\n                  <svg className=\"w-6 h-6 text-yellow-600\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                    <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z\" />\n                  </svg>\n                </div>\n                <div>\n                  <h3 className=\"text-xl font-bold text-helfi-black mb-3\">Supplement Confusion</h3>\n                  <p className=\"text-gray-600\">\n                    With thousands of supplements available, knowing what works, what's safe, and what interacts \n                    with your medications is overwhelming without expert guidance.\n                  </p>\n                </div>\n              </div>\n\n              <div className=\"flex items-start space-x-4\">\n                <div className=\"bg-orange-100 rounded-full p-3 mt-1 flex-shrink-0\">\n                  <svg className=\"w-6 h-6 text-orange-600\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                    <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4.5c-.77-.833-1.996-.833-2.764 0L3.052 16.5c-.77.833.192 2.5 1.732 2.5z\" />\n                  </svg>\n                </div>\n                <div>\n                  <h3 className=\"text-xl font-bold text-helfi-black mb-3\">Safety &amp; Interaction Alerts</h3>\n                  <p className=\"text-gray-600\">\n                    Stay safe with automatic detection of dangerous drug interactions, supplement conflicts, and personalized warnings.\n                  </p>\n                </div>\n              </div>\n            </div>\n\n            <div className=\"space-y-8\">\n              <div className=\"flex items-start space-x-4\">\n                <div className=\"bg-helfi-green/20 rounded-full p-3 mt-1 flex-shrink-0\">\n                  <svg className=\"w-6 h-6 text-helfi-green\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                    <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z\" />\n                  </svg>\n                </div>\n                <div>\n                  <h3 className=\"text-xl font-bold text-helfi-black mb-3\">Personalized Insights</h3>\n                  <p className=\"text-gray-600\">\n                    Our AI learns your unique patterns and provides recommendations tailored specifically to your \n                    body, lifestyle, and health goals.\n                  </p>\n                </div>\n              </div>\n\n              <div className=\"flex items-start space-x-4\">\n                <div className=\"bg-blue-100 rounded-full p-3 mt-1 flex-shrink-0\">\n                  <svg className=\"w-6 h-6 text-blue-600\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                    <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M13 10V3L4 14h7v7l9-11h-7z\" />\n                  </svg>\n                </div>\n                <div>\n                  <h3 className=\"text-xl font-bold text-helfi-black mb-3\">Proactive Prevention</h3>\n                  <p className=\"text-gray-600\">\n                    Identify potential health issues before they become problems, allowing you to take preventive \n                    action and maintain optimal wellness.\n                  </p>\n                </div>\n              </div>\n\n              <div className=\"flex items-start space-x-4\">\n                <div className=\"bg-purple-100 rounded-full p-3 mt-1 flex-shrink-0\">\n                  <svg className=\"w-6 h-6 text-purple-600\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                    <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M19.428 15.428a2 2 0 00-1.022-.547l-2.387-.477a6 6 0 00-3.86.517l-.318.158a6 6 0 01-3.86.517L6.05 15.21a2 2 0 00-1.806.547M8 4h8l-1 1v5.172a2 2 0 00.586 1.414l5 5c1.26 1.26.367 3.414-1.415 3.414H4.828c-1.782 0-2.674-2.154-1.414-3.414l5-5A2 2 0 009 10.172V5L8 4z\" />\n                  </svg>\n                </div>\n                <div>\n                  <h3 className=\"text-xl font-bold text-helfi-black mb-3\">Optimization Guidance</h3>\n                  <p className=\"text-gray-600\">\n                    Get science-backed recommendations for supplements, timing, dosages, and lifestyle changes \n                    to maximize your health outcomes.\n                  </p>\n                </div>\n              </div>\n            </div>\n          </div>\n        </div>\n      </section>\n\n      {/* Health Intelligence Benefits Section */}\n      <section className=\"px-4 sm:px-6 lg:px-10 xl:px-16 py-16 lg:py-20 bg-white\">\n        <div className=\"max-w-7xl mx-auto\">\n          <div className=\"text-center mb-16\">\n            <h2 className=\"text-4xl font-bold text-helfi-black mb-6\">\n              Transform Your Health with AI Intelligence\n            </h2>\n            <p className=\"text-xl text-gray-600 max-w-3xl mx-auto\">\n              Discover how artificial intelligence can revolutionize your approach to wellness, nutrition, and longevity.\n            </p>\n          </div>\n\n          <div className=\"grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6 lg:gap-8\">\n            <div className=\"text-center p-6 bg-gradient-to-br from-green-50 to-blue-50 rounded-2xl\">\n              <div className=\"w-16 h-16 bg-helfi-green/10 rounded-full flex items-center justify-center mx-auto mb-4\">\n                <svg className=\"w-8 h-8 text-helfi-green\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M12 6V4m0 2a2 2 0 100 4m0-4a2 2 0 110 4m-6 8a2 2 0 100-4m0 4a2 2 0 100 4m0-4v2m0-6V4m6 6v10m6-2a2 2 0 100-4m0 4a2 2 0 100 4m0-4v2m0-6V4\" />\n                </svg>\n              </div>\n              <h3 className=\"text-xl font-bold text-helfi-black mb-3\">Smart Supplement Optimization</h3>\n              <p className=\"text-gray-600 text-sm\">\n                Optimize your supplement timing, dosages, and combinations based on your unique metabolism and health goals.\n              </p>\n            </div>\n\n            <div className=\"text-center p-6 bg-gradient-to-br from-blue-50 to-purple-50 rounded-2xl\">\n              <div className=\"w-16 h-16 bg-blue-100 rounded-full flex items-center justify-center mx-auto mb-4\">\n                <svg className=\"w-8 h-8 text-blue-600\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M13 10V3L4 14h7v7l9-11h-7z\" />\n                </svg>\n              </div>\n              <h3 className=\"text-xl font-bold text-helfi-black mb-3\">Instant Health Insights</h3>\n              <p className=\"text-gray-600 text-sm\">\n                Get real-time analysis of how your lifestyle choices affect your energy, mood, sleep quality, and overall wellbeing.\n              </p>\n            </div>\n\n            <div className=\"text-center p-6 bg-gradient-to-br from-purple-50 to-pink-50 rounded-2xl\">\n              <div className=\"w-16 h-16 bg-purple-100 rounded-full flex items-center justify-center mx-auto mb-4\">\n                <svg className=\"w-8 h-8 text-purple-600\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z\" />\n                </svg>\n              </div>\n              <h3 className=\"text-xl font-bold text-helfi-black mb-3\">Predictive Health Analytics</h3>\n              <p className=\"text-gray-600 text-sm\">\n                Identify health trends before they become problems with advanced pattern recognition and predictive modeling.\n              </p>\n            </div>\n\n            <div className=\"text-center p-6 bg-gradient-to-br from-orange-50 to-red-50 rounded-2xl\">\n              <div className=\"w-16 h-16 bg-orange-100 rounded-full flex items-center justify-center mx-auto mb-4\">\n                <svg className=\"w-8 h-8 text-orange-600\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4.5c-.77-.833-1.996-.833-2.764 0L3.052 16.5c-.77.833.192 2.5 1.732 2.5z\" />\n                </svg>\n              </div>\n              <h3 className=\"text-xl font-bold text-helfi-black mb-3\">Safety & Interaction Alerts</h3>\n              <p className=\"text-gray-600 text-sm\">\n                Stay safe with automatic detection of dangerous drug interactions, supplement conflicts, and personalized warnings.\n              </p>\n            </div>\n          </div>\n        </div>\n      </section>\n\n      {/* Voice AI Section */}\n      <section className=\"px-4 sm:px-6 lg:px-10 xl:px-16 py-16 lg:py-20 bg-gradient-to-r from-purple-50 to-blue-50\">\n        <div className=\"max-w-6xl mx-auto\">\n          <div className=\"grid grid-cols-1 lg:grid-cols-2 gap-12 items-center\">\n            <div>\n              <h2 className=\"text-4xl font-bold text-helfi-black mb-6\">\n                Meet Your AI Health Assistant\n              </h2>\n              <p className=\"text-xl text-gray-600 mb-8\">\n                Experience the future of health tracking with our revolutionary voice AI technology. \n                Simply speak naturally and let Helfi handle the complex analysis.\n              </p>\n              \n              <div className=\"space-y-6\">\n                <div className=\"bg-white p-6 rounded-xl shadow-sm border border-purple-100\">\n                  <div className=\"flex items-start space-x-4\">\n                    <div className=\"bg-purple-100 rounded-full p-2 mt-1\">\n                      <svg className=\"w-6 h-6 text-purple-600\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                        <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z\" />\n                      </svg>\n                    </div>\n                    <div>\n                      <h4 className=\"font-semibold text-gray-900 mb-2\">Natural Voice Commands</h4>\n                      <p className=\"text-gray-600 text-sm\">\"Hey Helfi, I just went for a 5km run and feeling great!\"</p>\n                    </div>\n                  </div>\n                </div>\n                \n                <div className=\"bg-white p-6 rounded-xl shadow-sm border border-blue-100\">\n                  <div className=\"flex items-start space-x-4\">\n                    <div className=\"bg-blue-100 rounded-full p-2 mt-1\">\n                      <svg className=\"w-6 h-6 text-blue-600\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                        <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M13 10V3L4 14h7v7l9-11h-7z\" />\n                      </svg>\n                    </div>\n                    <div>\n                      <h4 className=\"font-semibold text-gray-900 mb-2\">Instant Analysis</h4>\n                      <p className=\"text-gray-600 text-sm\">\"I'm feeling tired after lunch, what might be causing this?\"</p>\n                    </div>\n                  </div>\n                </div>\n                \n                <div className=\"bg-white p-6 rounded-xl shadow-sm border border-green-100\">\n                  <div className=\"flex items-start space-x-4\">\n                    <div className=\"bg-helfi-green/20 rounded-full p-2 mt-1\">\n                      <svg className=\"w-6 h-6 text-helfi-green\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                        <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z\" />\n                      </svg>\n                    </div>\n                    <div>\n                      <h4 className=\"font-semibold text-gray-900 mb-2\">Smart Recommendations</h4>\n                      <p className=\"text-gray-600 text-sm\">\"Based on your pattern, try taking magnesium 2 hours before your usual sleep time.\"</p>\n                    </div>\n                  </div>\n                </div>\n              </div>\n            </div>\n\n            <div className=\"flex justify-center\">\n              <div className=\"w-full max-w-lg h-96 bg-gradient-to-br from-purple-100 to-blue-100 rounded-2xl shadow-2xl overflow-hidden\">\n                <img \n                  src=\"https://res.cloudinary.com/dh7qpr43n/image/upload/v1749922074/WOMAN_TALKING_INTO_HER_PHONE_zi9fh8.jpg\"\n                  alt=\"Woman speaking into phone using voice AI\"\n                  className=\"w-full h-full object-cover object-center\"\n                  style={{objectPosition: 'center 20%'}}\n                />\n              </div>\n            </div>\n          </div>\n        </div>\n      </section>\n\n      {/* Pricing Section */}\n      <section id=\"pricing\" className=\"px-4 sm:px-6 lg:px-10 xl:px-16 py-16 lg:py-20 bg-gray-50\">\n        <div className=\"max-w-6xl mx-auto\">\n          <div className=\"text-center mb-16\">\n            <h2 className=\"text-4xl font-bold text-helfi-black mb-4\">\n              Simple, Transparent Pricing\n            </h2>\n            <p className=\"text-xl text-gray-600\">\n              Choose the plan that fits your health journey\n            </p>\n          </div>\n\n          {/* Plans Section */}\n          <div className=\"bg-white rounded-lg shadow-sm p-6 mb-8\">\n            <h2 className=\"text-2xl font-bold text-gray-900 mb-6 text-center\">Plans</h2>\n            <div className=\"grid grid-cols-1 lg:grid-cols-4 gap-8\">\n              {/* $10 plan */}\n              <div className=\"border border-gray-200 rounded-2xl p-8 shadow-sm hover:shadow-md transition-shadow bg-white\">\n                <h3 className=\"text-lg font-semibold text-gray-900 mb-2\">$10 / month</h3>\n                <p className=\"text-3xl font-bold text-gray-900 mb-1\">Monthly wallet: 700 credits</p>\n                <p className=\"text-xs text-gray-500 mb-4\">Credits refresh monthly. No rollover.</p>\n                <ul className=\"space-y-2 mb-6 text-sm text-gray-600\">\n                  <li className=\"flex items-center\"><span className=\"w-4 h-4 text-green-500 mr-2\">‚úì</span> All features unlocked</li>\n                  <li className=\"flex items-center\"><span className=\"w-4 h-4 text-green-500 mr-2\">‚úì</span> Percentage‚Äëbased usage meter</li>\n                  <li className=\"flex items-center\"><span className=\"w-4 h-4 text-green-500 mr-2\">‚úì</span> Top‚Äëups valid 12 months</li>\n                </ul>\n                <button onClick={() => handlePlanSelection('plan_10_monthly')} className=\"w-full bg-helfi-green text-white px-4 py-2 rounded-lg hover:bg-helfi-green/90 transition-colors\" type=\"button\">\n                  Choose $10 Plan\n                </button>\n              </div>\n\n              {/* $20 plan */}\n              <div className=\"border border-gray-200 rounded-2xl p-8 shadow-sm hover:shadow-md transition-shadow bg-white\">\n                <h3 className=\"text-lg font-semibold text-gray-900 mb-2\">$20 / month</h3>\n                <p className=\"text-3xl font-bold text-gray-900 mb-1\">Monthly wallet: 1,400 credits</p>\n                <p className=\"text-xs text-gray-500 mb-4\">Credits refresh monthly. No rollover.</p>\n                <ul className=\"space-y-2 mb-6 text-sm text-gray-600\">\n                  <li className=\"flex items-center\"><span className=\"w-4 h-4 text-green-500 mr-2\">‚úì</span> All features unlocked</li>\n                  <li className=\"flex items-center\"><span className=\"w-4 h-4 text-green-500 mr-2\">‚úì</span> Percentage‚Äëbased usage meter</li>\n                  <li className=\"flex items-center\"><span className=\"w-4 h-4 text-green-500 mr-2\">‚úì</span> Top‚Äëups valid 12 months</li>\n                </ul>\n                <button onClick={() => handlePlanSelection('plan_20_monthly')} className=\"w-full bg-helfi-green text-white px-4 py-2 rounded-lg hover:bg-helfi-green/90 transition-colors\" type=\"button\">\n                  Choose $20 Plan\n                </button>\n              </div>\n\n              {/* $30 plan */}\n              <div className=\"border-2 border-helfi-green rounded-2xl p-8 relative shadow-sm hover:shadow-lg transition-shadow bg-white\">\n                <div className=\"absolute -top-3 left-1/2 transform -translate-x-1/2\">\n                  <span className=\"bg-helfi-green text-white px-3 py-1 rounded-full text-sm font-medium\">Most Popular</span>\n                </div>\n                <h3 className=\"text-lg font-semibold text-gray-900 mb-2\">$30 / month</h3>\n                <p className=\"text-3xl font-bold text-gray-900 mb-1\">Monthly wallet: 2,100 credits</p>\n                <p className=\"text-xs text-gray-500 mb-4\">Credits refresh monthly. No rollover.</p>\n                <ul className=\"space-y-2 mb-6 text-sm text-gray-600\">\n                  <li className=\"flex items-center\"><span className=\"w-4 h-4 text-green-500 mr-2\">‚úì</span> All features unlocked</li>\n                  <li className=\"flex items-center\"><span className=\"w-4 h-4 text-green-500 mr-2\">‚úì</span> Percentage‚Äëbased usage meter</li>\n                  <li className=\"flex items-center\"><span className=\"w-4 h-4 text-green-500 mr-2\">‚úì</span> Top‚Äëups valid 12 months</li>\n                </ul>\n                <button onClick={() => handlePlanSelection('plan_30_monthly')} className=\"w-full bg-helfi-green text-white px-4 py-2 rounded-lg hover:bg-helfi-green/90 transition-colors\" type=\"button\">\n                  Choose $30 Plan\n                </button>\n              </div>\n\n              {/* $50 plan */}\n              <div className=\"border border-gray-200 rounded-2xl p-8 shadow-sm hover:shadow-md transition-shadow bg-white\">\n                <h3 className=\"text-lg font-semibold text-gray-900 mb-2\">$50 / month</h3>\n                <p className=\"text-3xl font-bold text-gray-900 mb-1\">Monthly wallet: 3,500 credits</p>\n                <p className=\"text-xs text-gray-500 mb-4\">Credits refresh monthly. No rollover.</p>\n                <ul className=\"space-y-2 mb-6 text-sm text-gray-600\">\n                  <li className=\"flex items-center\"><span className=\"w-4 h-4 text-green-500 mr-2\">‚úì</span> All features unlocked</li>\n                  <li className=\"flex items-center\"><span className=\"w-4 h-4 text-green-500 mr-2\">‚úì</span> Percentage‚Äëbased usage meter</li>\n                  <li className=\"flex items-center\"><span className=\"w-4 h-4 text-green-500 mr-2\">‚úì</span> Top‚Äëups valid 12 months</li>\n                </ul>\n                <button onClick={() => handlePlanSelection('plan_50_monthly')} className=\"w-full bg-gray-900 text-white px-4 py-2 rounded-lg hover:bg-gray-800 transition-colors\" type=\"button\">\n                  Choose $50 Plan\n                </button>\n              </div>\n            </div>\n          </div>\n\n          {/* Buy Extra Credits Section */}\n          <div className=\"bg-white rounded-lg shadow-sm p-6 mb-8\">\n            <h2 className=\"text-2xl font-bold text-gray-900 mb-6 text-center\">Buy Extra Credits</h2>\n            <div className=\"grid grid-cols-1 sm:grid-cols-3 gap-6\">\n              <div className=\"border border-gray-200 rounded-lg p-6\">\n                <h3 className=\"text-lg font-semibold text-gray-900 mb-2\">Try with $5 (250 credits)</h3>\n                <p className=\"text-sm text-gray-600 mb-6\">One‚Äëtime top‚Äëup. Credits valid for 12 months.</p>\n                <button onClick={() => handleCreditPurchase('credits_250')} className=\"w-full bg-helfi-green text-white px-4 py-2 rounded-lg hover:bg-helfi-green/90 transition-colors\" type=\"button\">\n                  Buy $5 Credits\n                </button>\n              </div>\n              <div className=\"border border-gray-200 rounded-lg p-6\">\n                <h3 className=\"text-lg font-semibold text-gray-900 mb-2\">$10 (500 credits)</h3>\n                <p className=\"text-sm text-gray-600 mb-6\">One‚Äëtime top‚Äëup. Credits valid for 12 months.</p>\n                <button onClick={() => handleCreditPurchase('credits_500')} className=\"w-full bg-helfi-green text-white px-4 py-2 rounded-lg hover:bg-helfi-green/90 transition-colors\" type=\"button\">\n                  Buy $10 Credits\n                </button>\n              </div>\n              <div className=\"border border-gray-200 rounded-lg p-6\">\n                <h3 className=\"text-lg font-semibold text-gray-900 mb-2\">$20 (1,000 credits)</h3>\n                <p className=\"text-sm text-gray-600 mb-6\">One‚Äëtime top‚Äëup. Credits valid for 12 months.</p>\n                <button onClick={() => handleCreditPurchase('credits_1000')} className=\"w-full bg-helfi-green text-white px-4 py-2 rounded-lg hover:bg-helfi-green/90 transition-colors\" type=\"button\">\n                  Buy $20 Credits\n                </button>\n              </div>\n            </div>\n          </div>\n        </div>\n      </section>\n\n      {/* FAQ Section */}\n      <section id=\"faq\" className=\"px-6 py-20 bg-white\">\n        <div className=\"max-w-6xl mx-auto\">\n          <div className=\"text-center mb-16\">\n            <h2 className=\"text-4xl font-bold text-helfi-black mb-6\">\n              Frequently Asked Questions\n            </h2>\n            <p className=\"text-xl text-gray-600\">\n              Everything you need to know about Helfi's AI-powered health intelligence platform\n            </p>\n          </div>\n\n          <div className=\"space-y-8\">\n            <div className=\"bg-gray-50 rounded-2xl p-8\">\n              <h3 className=\"text-xl font-bold text-helfi-black mb-4\">\n                How does Helfi's AI analyze my health data?\n              </h3>\n              <p className=\"text-gray-600 leading-relaxed\">\n                Our advanced AI engine uses machine learning algorithms to analyze patterns in your nutrition, supplement intake, \n                sleep, exercise, and mood data. It identifies correlations that humans might miss, providing personalized insights \n                about what works best for your unique body and lifestyle. The more data you provide, the more accurate and \n                personalized your recommendations become.\n              </p>\n            </div>\n\n            <div className=\"bg-gray-50 rounded-2xl p-8\">\n              <h3 className=\"text-xl font-bold text-helfi-black mb-4\">\n                Is my health data secure and private?\n              </h3>\n              <p className=\"text-gray-600 leading-relaxed\">\n                Absolutely. Your health data is encrypted using bank-level security (AES-256 encryption) and stored in \n                HIPAA-compliant servers. We never sell your personal information to third parties, and you maintain complete \n                control over your data. You can export or delete your information at any time. Our AI processing happens \n                securely on our servers, ensuring your sensitive health information never leaves our protected environment.\n              </p>\n            </div>\n\n            <div className=\"bg-gray-50 rounded-2xl p-8\">\n              <h3 className=\"text-xl font-bold text-helfi-black mb-4\">\n                Can Helfi detect dangerous supplement and medication interactions?\n              </h3>\n              <p className=\"text-gray-600 leading-relaxed\">\n                Yes! One of Helfi's most important features is our comprehensive interaction checker. Our database contains \n                thousands of known interactions between supplements, medications, and nutrients. When you log new supplements \n                or medications, Helfi automatically checks for potential conflicts and alerts you immediately. This includes \n                interactions that affect absorption, effectiveness, or could cause adverse effects.\n              </p>\n            </div>\n\n            <div className=\"bg-gray-50 rounded-2xl p-8\">\n              <h3 className=\"text-xl font-bold text-helfi-black mb-4\">\n                How accurate is the food photo recognition?\n              </h3>\n              <p className=\"text-gray-600 leading-relaxed\">\n                Our AI food recognition system has been trained on millions of food images and achieves over 85% accuracy for \n                common foods. It can identify ingredients, estimate portion sizes, and calculate nutritional content including \n                calories, macronutrients, vitamins, and minerals. For best results, take photos in good lighting and include \n                reference objects for size. You can always edit the AI's suggestions to ensure accuracy.\n              </p>\n            </div>\n\n            <div className=\"bg-gray-50 rounded-2xl p-8\">\n              <h3 className=\"text-xl font-bold text-helfi-black mb-4\">\n                What devices can I connect to Helfi?\n              </h3>\n              <p className=\"text-gray-600 leading-relaxed\">\n                Helfi integrates with popular fitness and health devices including Fitbit, Apple Watch, Oura Ring, Garmin watches, \n                Google Fit, Samsung Health, Withings smart scales, and Polar heart rate monitors. These integrations provide \n                automatic tracking of steps, heart rate, sleep patterns, weight, and exercise data, giving our AI more comprehensive \n                information to provide better health insights and recommendations.\n              </p>\n            </div>\n\n            <div className=\"bg-gray-50 rounded-2xl p-8\">\n              <h3 className=\"text-xl font-bold text-helfi-black mb-4\">\n                How does the voice AI feature work?\n              </h3>\n              <p className=\"text-gray-600 leading-relaxed\">\n                Our voice AI assistant allows you to interact with Helfi using natural speech. Simply say commands like \n                \"Hey Helfi, I just took my morning vitamins\" or \"I'm feeling tired, what might be causing this?\" The AI \n                processes your speech, logs relevant information automatically, and provides instant analysis and recommendations. \n                It's designed to understand context and natural language, making health tracking as simple as having a conversation.\n              </p>\n            </div>\n          </div>\n        </div>\n      </section>\n\n      {/* Benefits for Health Optimization Section */}\n      <section className=\"px-4 sm:px-6 lg:px-10 xl:px-16 py-16 lg:py-20 bg-gradient-to-br from-helfi-green/5 to-blue-50\">\n        <div className=\"max-w-6xl mx-auto\">\n          <div className=\"text-center mb-16\">\n            <h2 className=\"text-4xl font-bold text-helfi-black mb-6\">\n              Why Health Optimization Matters More Than Ever\n            </h2>\n            <p className=\"text-xl text-gray-600 max-w-3xl mx-auto leading-relaxed\">\n              In 2024, chronic diseases affect 6 in 10 adults in the US. Many of these conditions are preventable \n              through proper nutrition, supplement optimization, and lifestyle tracking.\n            </p>\n          </div>\n\n          <div className=\"grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6 lg:gap-8\">\n            <div className=\"bg-white p-8 rounded-2xl shadow-sm border border-gray-100\">\n              <div className=\"text-4xl mb-4\">üìà</div>\n              <h3 className=\"text-xl font-bold text-helfi-black mb-4\">Prevent Chronic Disease</h3>\n              <p className=\"text-gray-600\">\n                Studies show that proper nutrition tracking and supplement optimization can reduce the risk of heart disease, \n                diabetes, and other chronic conditions by up to 40%. Early intervention through data-driven insights is key.\n              </p>\n            </div>\n\n            <div className=\"bg-white p-8 rounded-2xl shadow-sm border border-gray-100\">\n              <div className=\"text-4xl mb-4\">üíä</div>\n              <h3 className=\"text-xl font-bold text-helfi-black mb-4\">Optimize Supplement Efficacy</h3>\n              <p className=\"text-gray-600\">\n                Most people take supplements incorrectly, reducing their effectiveness by 50-70%. Proper timing, dosages, \n                and interaction awareness can dramatically improve health outcomes and save money on ineffective supplementation.\n              </p>\n            </div>\n\n            <div className=\"bg-white p-8 rounded-2xl shadow-sm border border-gray-100\">\n              <div className=\"text-4xl mb-4\">üß†</div>\n              <h3 className=\"text-xl font-bold text-helfi-black mb-4\">Enhance Mental Performance</h3>\n              <p className=\"text-gray-600\">\n                Tracking correlations between nutrition, supplements, and cognitive performance helps identify what boosts \n                your mental clarity, focus, and mood. Personalized insights lead to sustained cognitive enhancement.\n              </p>\n            </div>\n\n            <div className=\"bg-white p-8 rounded-2xl shadow-sm border border-gray-100\">\n              <div className=\"text-4xl mb-4\">‚ö°</div>\n              <h3 className=\"text-xl font-bold text-helfi-black mb-4\">Increase Energy Levels</h3>\n              <p className=\"text-gray-600\">\n                By analyzing patterns in your sleep, nutrition, and supplement intake, Helfi identifies what factors \n                contribute to energy crashes and sustained vitality, helping you maintain consistent energy throughout the day.\n              </p>\n            </div>\n\n            <div className=\"bg-white p-8 rounded-2xl shadow-sm border border-gray-100\">\n              <div className=\"text-4xl mb-4\">üèÉ</div>\n              <h3 className=\"text-xl font-bold text-helfi-black mb-4\">Improve Athletic Performance</h3>\n              <p className=\"text-gray-600\">\n                Athletes who track nutrition and supplementation with AI guidance show 20-30% improvements in recovery time \n                and performance metrics compared to those using generic approaches.\n              </p>\n            </div>\n\n            <div className=\"bg-white p-8 rounded-2xl shadow-sm border border-gray-100\">\n              <div className=\"text-4xl mb-4\">üí∞</div>\n              <h3 className=\"text-xl font-bold text-helfi-black mb-4\">Save Money on Healthcare</h3>\n              <p className=\"text-gray-600\">\n                Preventive health optimization through proper tracking and AI insights can reduce healthcare costs by \n                thousands of dollars annually by preventing costly chronic diseases and optimizing supplement spending.\n              </p>\n            </div>\n          </div>\n        </div>\n      </section>\n\n      {/* Footer */}\n      <footer className=\"bg-helfi-black text-white px-4 py-12\">\n        <div className=\"max-w-6xl mx-auto\">\n          <div className=\"grid grid-cols-1 md:grid-cols-5 gap-8\">\n            <div className=\"md:col-span-2\">\n              <div className=\"text-2xl font-bold mb-4\">\n                <span className=\"text-helfi-green\">Helfi</span>\n              </div>\n              <p className=\"text-gray-400 mb-4\">\n                Your personal health intelligence platform. Track, analyze, and optimize your wellbeing with AI-powered insights.\n              </p>\n            </div>\n            \n            <div>\n              <h4 className=\"font-semibold mb-4\">Platform</h4>\n              <ul className=\"space-y-2 text-gray-400\">\n                <li>\n                  <button \n                    onClick={() => document.getElementById('features')?.scrollIntoView({ behavior: 'smooth' })}\n                    className=\"hover:text-white text-left\"\n                  >\n                    Features\n                  </button>\n                </li>\n                <li>\n                  <button \n                    onClick={() => document.getElementById('pricing')?.scrollIntoView({ behavior: 'smooth' })}\n                    className=\"hover:text-white text-left\"\n                  >\n                    Pricing\n                  </button>\n                </li>\n                <li>\n                  <button \n                    onClick={() => document.getElementById('why-helfi')?.scrollIntoView({ behavior: 'smooth' })}\n                    className=\"hover:text-white text-left\"\n                  >\n                    Why Helfi\n                  </button>\n                </li>\n                <li>\n                  <button \n                    onClick={() => document.getElementById('faq')?.scrollIntoView({ behavior: 'smooth' })}\n                    className=\"hover:text-white text-left\"\n                  >\n                    FAQ\n                  </button>\n                </li>\n              </ul>\n            </div>\n\n            <div>\n              <h4 className=\"font-semibold mb-4\">Affiliates</h4>\n              <p className=\"text-gray-400 mb-3 text-sm\">\n                Earn by sharing Helfi.\n              </p>\n              <ul className=\"space-y-2 text-gray-400 text-sm\">\n                <li>\n                  <Link href=\"/affiliate/apply\" className=\"hover:text-white\">\n                    Apply to the affiliate program\n                  </Link>\n                </li>\n                <li>\n                  <Link href=\"/affiliate/terms\" className=\"hover:text-white\">\n                    Affiliate Terms\n                  </Link>\n                </li>\n              </ul>\n            </div>\n            \n            <div>\n              <h4 className=\"font-semibold mb-4\">Legal</h4>\n              <ul className=\"space-y-2 text-gray-400\">\n                <li><Link href=\"/privacy\" className=\"hover:text-white\">Privacy Policy</Link></li>\n                <li><Link href=\"/terms\" className=\"hover:text-white\">Terms of Service</Link></li>\n                <li><Link href=\"/support\" className=\"hover:text-white\">Contact</Link></li>\n              </ul>\n            </div>\n          </div>\n          \n          <div className=\"border-t border-gray-800 mt-8 pt-8 text-center text-gray-400\">\n            <p>&copy; 2024 Helfi. All rights reserved.</p>\n          </div>\n        </div>\n      </footer>\n\n      {/* Back to Top Button */}\n      <BackToTopButton />\n\n      {/* Demo Modal */}\n      {showDemoModal && (\n        <div \n          className=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4\"\n          onClick={handleDemoModalClose}\n        >\n          <div \n            className=\"bg-white rounded-2xl max-w-md w-full p-8 shadow-xl\"\n            onClick={(e) => e.stopPropagation()}\n          >\n            <div className=\"flex justify-between items-start mb-6\">\n              <div className=\"flex items-center gap-3\">\n                <div className=\"w-12 h-12 bg-gradient-to-br from-helfi-green/20 to-blue-100 rounded-full flex items-center justify-center\">\n                  <svg className=\"w-6 h-6 text-helfi-green\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                    <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z\" />\n                    <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M21 12a9 9 0 11-18 0 9 9 0 0118 0z\" />\n                  </svg>\n                </div>\n                <h3 className=\"text-2xl font-bold text-gray-900\">Demo Video</h3>\n              </div>\n              <button\n                onClick={handleDemoModalClose}\n                className=\"text-gray-400 hover:text-gray-600 transition-colors\"\n                aria-label=\"Close\"\n              >\n                <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M6 18L18 6M6 6l12 12\" />\n                </svg>\n              </button>\n            </div>\n            <div className=\"mb-6\">\n              <p className=\"text-gray-600 text-lg leading-relaxed mb-4\">\n                We're finalizing an updated demo video to show you all the amazing features of Helfi.\n              </p>\n              <p className=\"text-gray-600 leading-relaxed\">\n                Stay tuned for a comprehensive walkthrough of how our AI-powered health intelligence platform can transform your wellness journey!\n              </p>\n            </div>\n            <div className=\"flex gap-3\">\n              <button\n                onClick={handleDemoModalClose}\n                className=\"flex-1 bg-gray-100 text-gray-700 px-6 py-3 rounded-lg hover:bg-gray-200 transition-colors font-medium\"\n              >\n                Got it\n              </button>\n              {status === 'authenticated' ? (\n                <Link\n                  href=\"/dashboard\"\n                  onClick={() => setShowDemoModal(false)}\n                  className=\"flex-1 bg-helfi-green text-white px-6 py-3 rounded-lg hover:bg-helfi-green/90 transition-colors font-medium text-center\"\n                >\n                  Go to Dashboard\n                </Link>\n              ) : (\n                <Link\n                  href={signupHref}\n                  onClick={() => setShowDemoModal(false)}\n                  className=\"flex-1 bg-helfi-green text-white px-6 py-3 rounded-lg hover:bg-helfi-green/90 transition-colors font-medium text-center\"\n                >\n                  Create account\n                </Link>\n              )}\n            </div>\n          </div>\n        </div>\n      )}\n\n    </div>\n  )\n} \n","truncated":false,"size":57159},{"path":"app/privacy/page.tsx","content":"'use client'\n\nimport React from 'react';\nimport Image from 'next/image';\nimport Link from 'next/link';\nimport { useRouter } from 'next/navigation';\n\nexport default function PrivacyPage() {\n  const router = useRouter();\n  const handleBack = () => {\n    if (typeof window !== 'undefined' && window.history.length > 1) {\n      router.back();\n    } else {\n      router.push('/dashboard');\n    }\n  };\n\n  return (\n    <div className=\"min-h-screen bg-gray-50\">\n      {/* Navigation Header */}\n      <nav className=\"bg-white border-b border-gray-200 px-4 py-3\">\n        <div className=\"max-w-7xl mx-auto flex justify-between items-center\">\n          {/* Logo on the left */}\n          <div className=\"flex items-center\">\n            <Link href=\"/\" className=\"w-16 h-16 md:w-20 md:h-20 cursor-pointer hover:opacity-80 transition-opacity\">\n              <Image\n                src=\"/mobile-assets/LOGOS/helfi-01-01.png\"\n                alt=\"Helfi Logo\"\n                width={80}\n                height={80}\n                className=\"w-full h-full object-contain\"\n                priority\n              />\n            </Link>\n          </div>\n          \n          {/* Back to Home button on the right */}\n          <div>\n            <button\n              type=\"button\"\n              onClick={handleBack}\n              className=\"bg-helfi-green text-white px-4 py-2 rounded-lg hover:bg-helfi-green/90 transition-colors font-medium\"\n            >\n              Back\n            </button>\n          </div>\n        </div>\n      </nav>\n\n      {/* Page Title */}\n      <div className=\"bg-white border-b border-gray-200 px-4 py-4\">\n        <div className=\"max-w-7xl mx-auto text-center\">\n          <h1 className=\"text-lg md:text-xl font-semibold text-gray-900\">Privacy Policy</h1>\n          <p className=\"text-sm text-gray-500 hidden sm:block\">How we collect, use, and protect your information</p>\n        </div>\n      </div>\n\n      {/* Main Content */}\n      <div className=\"max-w-4xl mx-auto p-8 bg-white mt-8 rounded-lg shadow-sm\">\n        <div className=\"prose prose-lg max-w-none\">\n          <h1 className=\"text-4xl font-bold text-center mb-2 text-gray-900\">Helfi Privacy Policy</h1>\n          <p className=\"text-center text-gray-600 mb-8 text-lg\">Last updated: December 29, 2025</p>\n          \n          <div className=\"bg-blue-50 border border-blue-200 rounded-lg p-6 mb-8\">\n            <p className=\"text-gray-700 leading-relaxed\">\n              This Privacy Policy explains how Helfi (\"we,\" \"us,\" or \"our\") collects, uses, discloses, and protects your information when you use our mobile application and associated services (collectively, the \"App\").\n            </p>\n            <p className=\"text-gray-700 leading-relaxed mt-3\">\n              By using the App, you consent to the practices described in this policy. If you do not agree with this Privacy Policy, do not use the App.\n            </p>\n          </div>\n\n          <div className=\"space-y-8\">\n            <section>\n              <h2 className=\"text-2xl font-bold text-gray-900 mb-4 border-b-2 border-green-500 pb-2\">1. Information We Collect</h2>\n              \n              <div className=\"mb-4\">\n                <h3 className=\"text-xl font-semibold text-gray-800 mb-3\">a. Information You Provide Directly:</h3>\n                <ul className=\"text-gray-700 leading-relaxed space-y-2 list-disc pl-6\">\n                  <li>Name, email address, gender, age, height, weight, and other demographic data</li>\n                  <li>Health goals, symptom ratings, supplement and medication data</li>\n                  <li>Uploaded content (e.g., supplement labels, symptom images, notes)</li>\n                  <li>Laboratory report PDFs and extracted lab test results (analyte names, values, units, reference ranges, collection dates, accession numbers, and laboratory names)</li>\n                  <li>Payment and subscription information</li>\n                  <li>Customer support communications</li>\n                </ul>\n              </div>\n\n              <div className=\"mb-4\">\n                <h3 className=\"text-xl font-semibold text-gray-800 mb-3\">b. Automatically Collected Data:</h3>\n                <ul className=\"text-gray-700 leading-relaxed space-y-2 list-disc pl-6\">\n                  <li>Device information (type, OS version, IP address)</li>\n                  <li>App usage logs and activity patterns</li>\n                  <li>Error and crash reports</li>\n                </ul>\n              </div>\n\n              <div>\n                <h3 className=\"text-xl font-semibold text-gray-800 mb-3\">c. Data from Wearables & Third-Party Integrations (with your permission):</h3>\n                <ul className=\"text-gray-700 leading-relaxed space-y-2 list-disc pl-6\">\n                  <li>Apple Health, Google Fit, Garmin, Withings, etc.</li>\n                  <li>Steps, heart rate, distance, sleep, calories, etc.</li>\n                </ul>\n              </div>\n\n              <div className=\"mb-4 mt-6\">\n                <h3 className=\"text-xl font-semibold text-gray-800 mb-3\">User Consent for Report Uploads</h3>\n                <p className=\"text-gray-700 leading-relaxed mb-3\">\n                  When you upload a laboratory or medical report (for example, a PDF of blood results) and supply any associated password, you explicitly authorise Helfi to temporarily use that password to decrypt the file and extract relevant medical markers.\n                </p>\n                <ul className=\"text-gray-700 leading-relaxed space-y-2 list-disc pl-6\">\n                  <li>The password is never stored, logged, or reused.</li>\n                  <li>Once extraction is complete, the structured data is securely stored in encrypted form and the original file is deleted unless you choose to retain an encrypted copy for your records.</li>\n                </ul>\n              </div>\n            </section>\n\n            <section>\n              <h2 className=\"text-2xl font-bold text-gray-900 mb-4 border-b-2 border-green-500 pb-2\">2. How We Use Your Data</h2>\n              <div className=\"text-gray-700 leading-relaxed mb-3\">We use your data to:</div>\n              <ul className=\"text-gray-700 leading-relaxed space-y-2 list-disc pl-6\">\n                <li>Provide and personalize the App's features</li>\n                <li>Deliver AI-generated reports and symptom analysis</li>\n                <li>Parse, normalize, display, and analyze laboratory test results for your personal use</li>\n                <li>Improve app functionality and AI accuracy through anonymized training data</li>\n                <li>Process payments and manage subscriptions</li>\n                <li>Send reminders, updates, and relevant notifications</li>\n                <li>Respond to support requests and inquiries</li>\n                <li>Comply with legal obligations and enforce our Terms of Use</li>\n              </ul>\n            </section>\n\n            <section>\n              <h2 className=\"text-2xl font-bold text-gray-900 mb-4 border-b-2 border-green-500 pb-2\">3. How We Share Your Data</h2>\n              <div className=\"text-gray-700 leading-relaxed mb-3\">\n                We do not sell your personal data. We only share it as follows:\n              </div>\n              <ul className=\"text-gray-700 leading-relaxed space-y-2 list-disc pl-6\">\n                <li><strong>Service Providers:</strong> For hosting, analytics, payment processing, and technical support</li>\n                <li><strong>Legal Requirements:</strong> If required by law, court order, or regulatory request</li>\n                <li><strong>Business Transfers:</strong> If Helfi is involved in a merger, acquisition, or sale of assets, your data may be transferred</li>\n                <li><strong>With Consent:</strong> We may share data if you provide explicit permission</li>\n              </ul>\n            </section>\n\n            <section>\n              <h2 className=\"text-2xl font-bold text-gray-900 mb-4 border-b-2 border-green-500 pb-2\">4. Data Security</h2>\n              <p className=\"text-gray-700 leading-relaxed mb-3\">\n                We use encryption, secure cloud storage, and access control measures to protect your data. Despite best efforts, no system is completely secure. You use the App at your own risk.\n              </p>\n\n              <div className=\"mt-6 mb-4\">\n                <h3 className=\"text-xl font-semibold text-gray-800 mb-3\">Data Security and Encryption</h3>\n                <p className=\"text-gray-700 leading-relaxed mb-3\">\n                  We use industry-standard encryption to protect your data both in transit and at rest. All data transmitted between the App and our servers uses TLS 1.2 or higher.\n                </p>\n                <ul className=\"text-gray-700 leading-relaxed space-y-2 list-disc pl-6\">\n                  <li>Uploaded documents (such as laboratory reports or blood test PDFs) are stored securely in encrypted cloud storage.</li>\n                  <li>Sensitive health data and structured lab results are encrypted at rest using AES-256-GCM encryption, which is an industry-standard encryption algorithm.</li>\n                  <li>Structured health data is encrypted at the field level with unique per-record encryption keys, ensuring that each piece of data has its own encryption key.</li>\n                  <li>Data encryption keys are protected using envelope encryption, where keys are encrypted with a master key stored securely in environment variables.</li>\n                  <li>We maintain strict access controls ‚Äî only authorised personnel can access sensitive data, and all access is logged and audited.</li>\n                </ul>\n              </div>\n\n              <div className=\"bg-blue-50 border border-blue-200 rounded-lg p-4 mt-4\">\n                <h3 className=\"text-blue-900 font-semibold mb-2\">Laboratory Report Security</h3>\n                <ul className=\"text-blue-800 text-sm space-y-1 list-disc list-inside\">\n                  <li><strong>TLS in transit:</strong> All data is encrypted during transmission using TLS 1.2 or higher</li>\n                  <li><strong>Encryption at rest:</strong> Structured lab data is encrypted using AES-256-GCM with per-record encryption keys</li>\n                  <li><strong>Envelope encryption:</strong> Data encryption keys are wrapped using a master encryption key for additional security</li>\n                  <li><strong>Secure cloud storage:</strong> Original PDFs (if retained) are stored in encrypted cloud storage with access controls</li>\n                  <li><strong>Restricted access:</strong> Only authorized systems and personnel can decrypt and process PDFs</li>\n                  <li><strong>Audit logs:</strong> Full audit trail maintained for all processing activities, including uploads, decryption, extraction, and deletion</li>\n                  <li><strong>Password handling:</strong> PDF passwords are used only once for decryption and are never stored, logged, or reused</li>\n                </ul>\n              </div>\n              <p className=\"text-gray-700 leading-relaxed mt-4\">\n                <strong>Breach notification:</strong> If a breach occurs that may cause harm, Helfi will notify affected users and authorities per the Australian Notifiable Data Breaches scheme.\n              </p>\n            </section>\n\n            <section>\n              <h2 className=\"text-2xl font-bold text-gray-900 mb-4 border-b-2 border-green-500 pb-2\">5. Your Rights and Choices</h2>\n              <div className=\"text-gray-700 leading-relaxed mb-3\">\n                Depending on your location, you may have the right to:\n              </div>\n              <ul className=\"text-gray-700 leading-relaxed space-y-2 list-disc pl-6\">\n                <li>Access the data we hold about you</li>\n                <li>Request correction or deletion of your data</li>\n                <li>Object to or restrict our data processing</li>\n                <li>Withdraw consent at any time (affects future processing only)</li>\n                <li>Lodge a complaint with a data protection authority</li>\n              </ul>\n              <p className=\"text-gray-700 leading-relaxed mt-3\">\n                To exercise your rights, contact us at: <a href=\"mailto:support@helfi.ai\" className=\"text-green-600 hover:text-green-800 font-medium\">support@helfi.ai</a>\n              </p>\n            </section>\n\n            <section>\n              <h2 className=\"text-2xl font-bold text-gray-900 mb-4 border-b-2 border-green-500 pb-2\">6. International Users</h2>\n              <p className=\"text-gray-700 leading-relaxed\">\n                We are based in Australia but serve users worldwide. Your information may be processed in countries with different data protection laws. By using the App, you consent to this transfer and processing.\n              </p>\n            </section>\n\n            <section>\n              <h2 className=\"text-2xl font-bold text-gray-900 mb-4 border-b-2 border-green-500 pb-2\">7. Data Retention and Deletion</h2>\n              <p className=\"text-gray-700 leading-relaxed mb-3\">\n                By default, Helfi deletes original uploaded documents (such as PDFs) immediately after extraction. If you opt to retain a copy, it remains encrypted and accessible only through your authenticated account.\n              </p>\n              <ul className=\"text-gray-700 leading-relaxed space-y-2 list-disc pl-6 mb-3\">\n                <li>Structured health data is retained until you delete your account or request deletion.</li>\n                <li>System audit logs are maintained for security and compliance purposes. We retain audit logs as necessary to comply with legal obligations and for security monitoring.</li>\n                <li>You can request data deletion or export at any time via in-app settings or by contacting us at <a href=\"mailto:support@helfi.ai\" className=\"text-green-600 hover:text-green-800 font-medium\">support@helfi.ai</a></li>\n              </ul>\n              <div className=\"bg-gray-50 border border-gray-200 rounded-lg p-4 mt-4\">\n                <h3 className=\"text-gray-900 font-semibold mb-2\">Laboratory Report Retention</h3>\n                <ul className=\"text-gray-700 text-sm space-y-1 list-disc list-inside\">\n                  <li><strong>Structured data:</strong> Lab values are retained until account deletion or until you request deletion</li>\n                  <li><strong>Original PDFs:</strong> Deleted by default immediately after extraction unless you choose to retain them</li>\n                  <li><strong>Consent records:</strong> Retained for compliance and audit purposes</li>\n                  <li><strong>Audit events:</strong> Retained for security monitoring and compliance with legal requirements</li>\n                </ul>\n              </div>\n            </section>\n\n            <section>\n              <h2 className=\"text-2xl font-bold text-gray-900 mb-4 border-b-2 border-green-500 pb-2\">8. Children's Privacy</h2>\n              <p className=\"text-gray-700 leading-relaxed\">\n                The App is not intended for users under the age of 18. We do not knowingly collect data from anyone under 18. If we become aware of such data, we will delete it immediately.\n              </p>\n            </section>\n\n            <section>\n              <h2 className=\"text-2xl font-bold text-gray-900 mb-4 border-b-2 border-green-500 pb-2\">9. Cookies & Tracking Technologies</h2>\n              <p className=\"text-gray-700 leading-relaxed\">\n                We may use cookies or similar technologies for app functionality, usage analytics, and performance tracking. You can disable tracking through your device settings.\n              </p>\n            </section>\n\n            <section>\n              <h2 className=\"text-2xl font-bold text-gray-900 mb-4 border-b-2 border-green-500 pb-2\">10. Changes to This Policy</h2>\n              <p className=\"text-gray-700 leading-relaxed\">\n                We may update this Privacy Policy from time to time. Material changes will be notified within the App or via email. Continued use of the App after changes are posted constitutes your acceptance.\n              </p>\n            </section>\n\n            <section>\n              <h2 className=\"text-2xl font-bold text-gray-900 mb-4 border-b-2 border-green-500 pb-2\">11. Contact Us</h2>\n              <div className=\"text-gray-700 leading-relaxed\">\n                <p className=\"mb-2\">For questions about this Privacy Policy or your personal data, contact:</p>\n                <p><strong>Email:</strong> <a href=\"mailto:support@helfi.ai\" className=\"text-green-600 hover:text-green-800 font-medium\">support@helfi.ai</a></p>\n                <p><strong>Mailing Address:</strong> [Insert Business Address Here]</p>\n              </div>\n            </section>\n          </div>\n\n          <div className=\"bg-green-50 border border-green-200 rounded-lg p-6 mt-12\">\n            <p className=\"text-gray-700 leading-relaxed font-medium\">\n              By using Helfi, you confirm that you have read, understood, and agreed to the terms of this Privacy Policy.\n            </p>\n          </div>\n\n          <div className=\"text-center mt-8 pt-8 border-t border-gray-200\">\n            <p className=\"text-gray-600\">\n              For questions or concerns about your privacy, please contact us at: <a href=\"mailto:support@helfi.ai\" className=\"text-green-600 hover:text-green-800 font-medium\">support@helfi.ai</a>\n            </p>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n} \n","truncated":false,"size":17499},{"path":"app/profile/image/page.tsx","content":"'use client'\n\nimport React, { useState, useEffect, useRef } from 'react'\nimport { useSession, signOut } from 'next-auth/react'\nimport Link from 'next/link'\nimport Image from 'next/image'\nimport { useUserData } from '@/components/providers/UserDataProvider'\nimport { UserIcon } from '@heroicons/react/24/outline'\n\nexport default function ProfileImage() {\n  const { data: session } = useSession()\n  const { updateProfileImage } = useUserData()\n  const [saveStatus, setSaveStatus] = useState<'idle' | 'saving' | 'saved'>('idle')\n  const [selectedImage, setSelectedImage] = useState<File | null>(null)\n  const [imagePreview, setImagePreview] = useState<string | null>(null)\n  const [currentProfileImage, setCurrentProfileImage] = useState<string | null>(null)\n  const [showCamera, setShowCamera] = useState(false)\n  const [dropdownOpen, setDropdownOpen] = useState(false)\n  const videoRef = useRef<HTMLVideoElement>(null)\n  const canvasRef = useRef<HTMLCanvasElement>(null)\n  const fileInputRef = useRef<HTMLInputElement>(null)\n\n  // Profile data - prefer real photos; fall back to professional icon\n  const hasProfileImage = !!(currentProfileImage || session?.user?.image)\n  const userImage = (currentProfileImage || session?.user?.image || '') as string\n  const userName = session?.user?.name || 'User';\n\n  // Close dropdown on outside click\n  useEffect(() => {\n    function handleClick(e: MouseEvent) {\n      if (!(e.target as HTMLElement).closest('#profile-dropdown')) {\n        setDropdownOpen(false);\n      }\n    }\n    if (dropdownOpen) {\n      document.addEventListener('mousedown', handleClick);\n    } else {\n      document.removeEventListener('mousedown', handleClick);\n    }\n    return () => document.removeEventListener('mousedown', handleClick);\n  }, [dropdownOpen]);\n\n  // Load current profile image on mount\n  useEffect(() => {\n    const loadCurrentImage = async () => {\n      try {\n        console.log('Profile/Image page - Loading profile image from database...');\n        const response = await fetch('/api/user-data', {\n          cache: 'no-cache',\n          headers: {\n            'Cache-Control': 'no-cache'\n          }\n        });\n        if (response.ok) {\n          const result = await response.json();\n          console.log('Profile/Image page - API response:', { hasData: !!result.data, hasProfileImage: !!(result.data?.profileImage) });\n          if (result.data && result.data.profileImage) {\n            console.log('Profile/Image page - Setting profile image from database (Cloudinary URL)');\n            setCurrentProfileImage(result.data.profileImage);\n            \n            // Clean up old localStorage entries (migration cleanup)\n            if (session?.user?.id) {\n              localStorage.removeItem(`profileImage_${session.user.id}`);\n            }\n          } else {\n            console.log('Profile/Image page - No profile image found in database response');\n          }\n        } else {\n          console.error('Profile/Image page - API call failed:', response.status, response.statusText);\n        }\n      } catch (error) {\n        console.error('Error loading profile image:', error);\n      }\n    };\n\n    loadCurrentImage();\n  }, [session?.user?.id]);\n\n  // Auto-save when image changes\n  useEffect(() => {\n    if (!selectedImage) return;\n\n    const saveImage = async () => {\n      setSaveStatus('saving');\n      \n      try {\n        // Upload to Cloudinary via new API\n        const formData = new FormData();\n        formData.append('image', selectedImage);\n        \n        console.log('Uploading image to Cloudinary...');\n        console.log('Session status before upload:', { hasSession: !!session, userEmail: session?.user?.email });\n        const response = await fetch('/api/upload-profile-image', {\n          method: 'POST',\n          body: formData,\n          credentials: 'include' // Ensure cookies are sent\n        });\n\n        const result = await response.json();\n        \n        if (result.success) {\n          console.log('Cloudinary upload successful:', result);\n          \n          // Set the Cloudinary URL as the profile image\n          setCurrentProfileImage(result.imageUrl);\n          // Broadcast to shared data provider so other pages update instantly\n          try {\n            updateProfileImage(result.imageUrl)\n          } catch (e) {\n            console.warn('Could not update shared profile image provider:', e)\n          }\n          \n          // Clear localStorage (no longer needed with Cloudinary)\n          if (session?.user?.id) {\n            localStorage.removeItem(`profileImage_${session.user.id}`);\n            // Also set the cached key used by Dashboard for instant display\n            try {\n              localStorage.setItem(`cachedProfileImage_${session.user.id}`, result.imageUrl)\n            } catch {}\n          }\n          \n          setSaveStatus('saved');\n          setTimeout(() => setSaveStatus('idle'), 2000);\n          \n          console.log('Image optimization stats:', result.optimizations);\n        } else {\n          throw new Error(result.error || 'Upload failed');\n        }\n      } catch (error) {\n        console.error('Error uploading image:', error);\n        setSaveStatus('idle');\n        alert('Failed to upload image. Please try again.');\n      }\n    };\n\n    saveImage();\n  }, [selectedImage, session?.user?.id]);\n\n  const handleFileSelect = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const file = e.target.files?.[0];\n    if (file) {\n      // Validate file type\n      if (!file.type.startsWith('image/')) {\n        alert('Please select an image file');\n        return;\n      }\n      \n      // Validate file size (5MB limit)\n      if (file.size > 5 * 1024 * 1024) {\n        alert('File size must be less than 5MB');\n        return;\n      }\n\n      setSelectedImage(file);\n      \n      // Create preview\n      const reader = new FileReader();\n      reader.onload = (e) => {\n        setImagePreview(e.target?.result as string);\n      };\n      reader.readAsDataURL(file);\n    }\n  };\n\n  const startCamera = async () => {\n    try {\n      // Check if camera is supported\n      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {\n        alert('Camera not supported on this device or browser.');\n        return;\n      }\n\n      const stream = await navigator.mediaDevices.getUserMedia({ \n        video: { \n          facingMode: 'user',\n          width: { ideal: 640 },\n          height: { ideal: 480 }\n        }\n      });\n      \n      if (videoRef.current) {\n        videoRef.current.srcObject = stream;\n        videoRef.current.onloadedmetadata = () => {\n          videoRef.current?.play();\n        };\n        setShowCamera(true);\n      }\n          } catch (error: any) {\n        console.error('Error accessing camera:', error);\n        let errorMessage = 'Unable to access camera. ';\n        \n        if (error?.name === 'NotAllowedError') {\n          errorMessage += 'Please allow camera permissions in your browser settings.';\n        } else if (error?.name === 'NotFoundError') {\n          errorMessage += 'No camera found on this device.';\n        } else if (error?.name === 'NotSupportedError') {\n          errorMessage += 'Camera not supported on this browser.';\n        } else {\n          errorMessage += 'Please check your camera and permissions.';\n        }\n        \n        alert(errorMessage);\n      }\n  };\n\n  const capturePhoto = () => {\n    if (videoRef.current && canvasRef.current) {\n      const video = videoRef.current;\n      const canvas = canvasRef.current;\n      const context = canvas.getContext('2d');\n\n      canvas.width = video.videoWidth;\n      canvas.height = video.videoHeight;\n      \n      if (context) {\n        context.drawImage(video, 0, 0);\n        \n        canvas.toBlob((blob) => {\n          if (blob) {\n            const file = new File([blob], 'profile-photo.jpg', { type: 'image/jpeg' });\n            setSelectedImage(file);\n            \n            // Create preview\n            const reader = new FileReader();\n            reader.onload = (e) => {\n              setImagePreview(e.target?.result as string);\n            };\n            reader.readAsDataURL(file);\n            \n            // Stop camera\n            stopCamera();\n          }\n        }, 'image/jpeg', 0.8);\n      }\n    }\n  };\n\n  const stopCamera = () => {\n    if (videoRef.current && videoRef.current.srcObject) {\n      const stream = videoRef.current.srcObject as MediaStream;\n      stream.getTracks().forEach(track => track.stop());\n      videoRef.current.srcObject = null;\n    }\n    setShowCamera(false);\n  };\n\n  const removeCurrentImage = async () => {\n    if (confirm('Are you sure you want to remove your profile picture?')) {\n      setSaveStatus('saving');\n      \n      try {\n        // Remove profile image (set to null in database)\n        const response = await fetch('/api/user-data', {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({ profileImage: null })\n        });\n\n        if (response.ok) {\n          // Clear localStorage (no longer needed)\n          if (session?.user?.id) {\n            localStorage.removeItem(`profileImage_${session.user.id}`);\n          }\n          \n          setCurrentProfileImage(null);\n          setSelectedImage(null);\n          setImagePreview(null);\n          // Broadcast removal to shared provider and clear dashboard cache\n          try {\n            updateProfileImage('')\n          } catch {}\n          if (session?.user?.id) {\n            try { localStorage.removeItem(`cachedProfileImage_${session.user.id}`) } catch {}\n          }\n          setSaveStatus('saved');\n          setTimeout(() => setSaveStatus('idle'), 2000);\n        } else {\n          throw new Error('Failed to remove image');\n        }\n      } catch (error) {\n        console.error('Error removing image:', error);\n        setSaveStatus('idle');\n        alert('Failed to remove image. Please try again.');\n      }\n    }\n  };\n\n  return (\n    <div className=\"min-h-screen bg-gray-50\">\n      {/* Header with Profile Dropdown */}\n      <div className=\"bg-white border-b border-gray-200\">\n        <div className=\"max-w-4xl mx-auto px-4 py-4\">\n          <div className=\"flex items-center justify-between\">\n            {/* Back button - clean and minimal */}\n            <Link \n              href=\"/profile\" \n              className=\"flex items-center text-gray-600 hover:text-gray-900 transition-colors\"\n            >\n              <svg className=\"w-5 h-5 mr-2\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M15 19l-7-7 7-7\" />\n              </svg>\n              <span className=\"font-medium\">Back</span>\n            </Link>\n\n            {/* Page title - centered and clean */}\n            <div className=\"text-center\">\n              <h1 className=\"text-xl font-semibold text-gray-900\">Profile Picture</h1>\n            </div>\n\n            {/* Profile Dropdown and Save Status */}\n            <div className=\"flex items-center space-x-4\">\n              {/* Auto-save status - subtle and clean */}\n              <div className=\"flex items-center\">\n                {saveStatus === 'saving' && (\n                  <div className=\"flex items-center text-blue-600\">\n                    <div className=\"w-4 h-4 border-2 border-blue-600 border-t-transparent rounded-full animate-spin mr-2\"></div>\n                    <span className=\"text-sm\">Saving...</span>\n                  </div>\n                )}\n                {saveStatus === 'saved' && (\n                  <div className=\"flex items-center text-green-600\">\n                    <svg className=\"w-4 h-4 mr-1\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                      <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M5 13l4 4L19 7\" />\n                    </svg>\n                    <span className=\"text-sm\">Saved</span>\n                  </div>\n                )}\n              </div>\n\n              {/* Profile Avatar & Dropdown */}\n              <div className=\"relative dropdown-container\" id=\"profile-dropdown\">\n                <button\n                  onClick={() => setDropdownOpen((v) => !v)}\n                  className=\"focus:outline-none\"\n                  aria-label=\"Open profile menu\"\n                >\n                  {hasProfileImage ? (\n                    <Image\n                      src={userImage}\n                      alt=\"Profile\"\n                      width={36}\n                      height={36}\n                      className=\"w-9 h-9 rounded-full border-2 border-helfi-green shadow-sm object-cover\"\n                    />\n                  ) : (\n                    <div className=\"w-9 h-9 rounded-full bg-helfi-green shadow-sm flex items-center justify-center\">\n                      <UserIcon className=\"w-5 h-5 text-white\" aria-hidden=\"true\" />\n                    </div>\n                  )}\n                </button>\n                {dropdownOpen && (\n                  <div className=\"absolute right-0 mt-2 w-64 bg-white rounded-xl shadow-lg py-2 z-50 border border-gray-100\">\n                    <div className=\"flex items-center px-4 py-3 border-b border-gray-100\">\n                      {hasProfileImage ? (\n                        <Image\n                          src={userImage}\n                          alt=\"Profile\"\n                          width={40}\n                          height={40}\n                          className=\"w-10 h-10 rounded-full object-cover mr-3\"\n                        />\n                      ) : (\n                        <div className=\"w-10 h-10 rounded-full bg-helfi-green flex items-center justify-center mr-3\">\n                          <UserIcon className=\"w-6 h-6 text-white\" aria-hidden=\"true\" />\n                        </div>\n                      )}\n                      <div>\n                        <div className=\"font-semibold text-gray-900\">{userName}</div>\n                        <div className=\"text-xs text-gray-500\">{session?.user?.email || 'user@email.com'}</div>\n                      </div>\n                    </div>\n                    <Link href=\"/profile\" className=\"block px-4 py-2 text-gray-700 hover:bg-gray-50\">Profile</Link>\n                    <Link href=\"/account\" className=\"block px-4 py-2 text-gray-700 hover:bg-gray-50\">Account Settings</Link>\n                    <Link href=\"/profile/image\" className=\"block px-4 py-2 text-gray-700 hover:bg-gray-50 bg-gray-50 font-medium\">Upload/Change Profile Photo</Link>\n                    <Link href=\"/billing\" className=\"block px-4 py-2 text-gray-700 hover:bg-gray-50\">Subscription & Billing</Link>\n                    <Link href=\"/notifications\" className=\"block px-4 py-2 text-gray-700 hover:bg-gray-50\">Notifications</Link>\n                    <Link href=\"/privacy\" className=\"block px-4 py-2 text-gray-700 hover:bg-gray-50\">Privacy Settings</Link>\n                    <Link href=\"/help\" className=\"block px-4 py-2 text-gray-700 hover:bg-gray-50\">Help & Support</Link>\n                    <button\n                      onClick={() => signOut({ callbackUrl: '/auth/signin' })}\n                      className=\"block w-full text-left px-4 py-2 text-red-600 hover:bg-gray-50 font-semibold\"\n                    >\n                      Logout\n                    </button>\n                  </div>\n                )}\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n\n      {/* Main Content */}\n      <div className=\"max-w-2xl mx-auto px-4 py-12\">\n        <div className=\"bg-white rounded-2xl shadow-sm border border-gray-200 overflow-hidden\">\n          {/* Content header */}\n          <div className=\"px-8 py-6 border-b border-gray-100\">\n            <div className=\"text-center\">\n              <h2 className=\"text-2xl font-medium text-gray-900 mb-2\">Upload Profile Picture</h2>\n              <p className=\"text-gray-600\">Changes are automatically saved</p>\n            </div>\n          </div>\n          \n          {/* Current Profile Picture Section */}\n          <div className=\"px-8 py-12 text-center border-b border-gray-100\">\n            <div className=\"w-32 h-32 mx-auto mb-8 relative\">\n              {(imagePreview || currentProfileImage) ? (\n                <div className=\"relative\">\n                  <Image\n                    src={imagePreview || currentProfileImage || ''}\n                    alt=\"Profile Picture\"\n                    width={128}\n                    height={128}\n                    className=\"w-32 h-32 object-cover rounded-full border-3 border-gray-200 shadow-sm\"\n                  />\n                  {imagePreview && (\n                    <div className=\"absolute -top-1 -right-1 bg-green-500 text-white rounded-full p-1.5 shadow-sm\">\n                      <svg className=\"w-3 h-3\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                        <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={3} d=\"M5 13l4 4L19 7\" />\n                      </svg>\n                    </div>\n                  )}\n                </div>\n              ) : (\n                <div className=\"w-full h-full bg-gray-100 rounded-full flex items-center justify-center border-3 border-gray-200\">\n                  <div className=\"w-16 h-16 bg-green-500 rounded-full flex items-center justify-center\">\n                    <svg className=\"w-8 h-8 text-white\" fill=\"currentColor\" viewBox=\"0 0 24 24\">\n                      <path d=\"M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z\"/>\n                    </svg>\n                  </div>\n                </div>\n              )}\n            </div>\n            \n            <div className=\"space-y-3\">\n              <p className=\"text-lg font-medium text-gray-900\">\n                {imagePreview ? 'New Profile Picture' : currentProfileImage ? 'Current Profile Picture' : 'No Profile Picture'}\n              </p>\n              {imagePreview && (\n                <p className=\"text-sm text-green-600 font-medium\">‚úì Automatically saved</p>\n              )}\n              {imagePreview && (\n                <button\n                  onClick={() => {\n                    setImagePreview(null);\n                    setSelectedImage(null);\n                  }}\n                  className=\"text-sm text-gray-500 hover:text-gray-700 transition-colors\"\n                >\n                  Remove preview\n                </button>\n              )}\n            </div>\n          </div>\n\n          {/* Camera Modal */}\n          {showCamera && (\n            <div className=\"fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50\">\n              <div className=\"bg-white rounded-lg p-6 max-w-md w-full mx-4\">\n                <div className=\"text-center mb-4\">\n                  <h3 className=\"text-lg font-semibold\">Take a Photo</h3>\n                  <p className=\"text-sm text-gray-600\">Position your face in the frame and tap capture</p>\n                </div>\n                <div className=\"relative mb-4\">\n                  <video\n                    ref={videoRef}\n                    autoPlay\n                    playsInline\n                    className=\"w-full rounded-lg\"\n                  />\n                  {/* Overlay guide for face positioning */}\n                  <div className=\"absolute inset-0 flex items-center justify-center pointer-events-none\">\n                    <div className=\"w-48 h-48 border-2 border-white border-dashed rounded-full opacity-50\"></div>\n                  </div>\n                </div>\n                <div className=\"flex space-x-3\">\n                  <button\n                    onClick={stopCamera}\n                    className=\"flex-1 bg-red-100 text-red-700 px-4 py-2 rounded-lg hover:bg-red-200 transition-colors font-medium\"\n                  >\n                    üî¥ Stop Camera\n                  </button>\n                  <button\n                    onClick={capturePhoto}\n                    className=\"flex-1 bg-helfi-green text-white px-4 py-2 rounded-lg hover:bg-helfi-green/90 transition-colors font-medium\"\n                  >\n                    üì∑ Capture Photo\n                  </button>\n                </div>\n                <div className=\"mt-3 text-center\">\n                  <p className=\"text-xs text-gray-500\">\n                    üîí Camera will automatically stop after taking a photo for your privacy\n                  </p>\n                </div>\n              </div>\n            </div>\n          )}\n\n          {/* Upload Options - Google-style clean design */}\n          <div className=\"px-8 py-8 space-y-8\">\n            {/* Upload from device */}\n            <div className=\"border border-gray-200 rounded-xl p-6 hover:border-gray-300 hover:shadow-sm transition-all\">\n              <div className=\"flex items-center space-x-4 mb-4\">\n                <div className=\"w-12 h-12 bg-blue-50 rounded-full flex items-center justify-center\">\n                  <svg className=\"w-6 h-6 text-blue-600\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                    <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12\" />\n                  </svg>\n                </div>\n                <div className=\"flex-1\">\n                  <h3 className=\"text-lg font-medium text-gray-900\">Upload from device</h3>\n                  <p className=\"text-sm text-gray-600\">PNG, JPG up to 5MB</p>\n                </div>\n              </div>\n              <div className=\"flex justify-center\">\n                <input\n                  ref={fileInputRef}\n                  type=\"file\"\n                  accept=\"image/*\"\n                  onChange={handleFileSelect}\n                  className=\"hidden\"\n                  id=\"file-upload\"\n                />\n                <label\n                  htmlFor=\"file-upload\"\n                  className=\"bg-white border border-gray-300 text-gray-700 px-6 py-3 rounded-lg hover:bg-gray-50 hover:border-gray-400 transition-all cursor-pointer font-medium\"\n                >\n                  Choose Photo\n                </label>\n              </div>\n            </div>\n\n            {/* Take photo - Hidden on mobile, shown on desktop only */}\n            <div className=\"hidden md:block border border-gray-200 rounded-xl p-6 hover:border-gray-300 hover:shadow-sm transition-all\">\n              <div className=\"flex items-center space-x-4\">\n                <div className=\"w-12 h-12 bg-green-50 rounded-full flex items-center justify-center\">\n                  <svg className=\"w-6 h-6 text-green-600\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                    <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M3 9a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A2 2 0 0110.07 4h3.86a2 2 0 011.664.89l.812 1.22A2 2 0 0018.07 7H19a2 2 0 012 2v9a2 2 0 01-2 2H5a2 2 0 01-2-2V9z\" />\n                    <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M15 13a3 3 0 11-6 0 3 3 0 016 0z\" />\n                  </svg>\n                </div>\n                <div className=\"flex-1\">\n                  <h3 className=\"text-lg font-medium text-gray-900\">Take a photo</h3>\n                  <p className=\"text-sm text-gray-600\">Use your webcam camera</p>\n                </div>\n                <button \n                  onClick={startCamera}\n                  className=\"bg-white border border-gray-300 text-gray-700 px-4 py-2 rounded-lg hover:bg-gray-50 hover:border-gray-400 transition-all font-medium\"\n                >\n                  Open Camera\n                </button>\n              </div>\n            </div>\n          </div>\n\n          {/* Action Buttons */}\n          {(currentProfileImage || imagePreview) && (\n            <div className=\"flex justify-center mt-8\">\n              <button \n                onClick={removeCurrentImage}\n                className=\"bg-red-100 text-red-700 px-6 py-2 rounded-lg hover:bg-red-200 transition-colors\"\n              >\n                Remove Picture\n              </button>\n            </div>\n          )}\n\n          {/* Hidden canvas for photo capture */}\n          <canvas ref={canvasRef} className=\"hidden\" />\n        </div>\n      </div>\n    </div>\n  )\n} ","truncated":false,"size":24315},{"path":"app/profile/page.tsx","content":"'use client'\nimport { Cog6ToothIcon, UserIcon } from '@heroicons/react/24/outline'\n\nimport React, { useState, useEffect } from 'react'\nimport { useSession, signOut } from 'next-auth/react'\nimport Link from 'next/link'\nimport Image from 'next/image'\nimport { useUserData } from '@/components/providers/UserDataProvider'\nimport MobileMoreMenu from '@/components/MobileMoreMenu'\nimport PageHeader from '@/components/PageHeader'\n\nexport default function Profile() {\n  const { data: session } = useSession()\n  const { userData, profileImage, updateUserData, updateProfileImage, refreshData } = useUserData()\n  const [saveStatus, setSaveStatus] = useState<'idle' | 'saving' | 'saved'>('idle')\n  const [dropdownOpen, setDropdownOpen] = useState(false)\n  const [profileData, setProfileData] = useState({\n    firstName: '',\n    lastName: '',\n    email: session?.user?.email || '',\n    bio: '',\n    dateOfBirth: '',\n    gender: ''\n  })\n\n  // Profile data - prefer real photos; fall back to professional icon\n  const hasProfileImage = !!(profileImage || session?.user?.image)\n  const userImage = (profileImage || session?.user?.image || '') as string\n  const userName = session?.user?.name || 'User';\n\n  // Close dropdown on outside click\n  useEffect(() => {\n    function handleClick(e: MouseEvent) {\n      const target = e.target as HTMLElement;\n      // Check if click is outside both the button and the dropdown content\n      if (!target.closest('.dropdown-container')) {\n        setDropdownOpen(false);\n      }\n    }\n    if (dropdownOpen) {\n      document.addEventListener('mousedown', handleClick);\n      return () => document.removeEventListener('mousedown', handleClick);\n    }\n  }, [dropdownOpen]);\n\n  // Load cached data from provider (no API call needed!)\n  useEffect(() => {\n    if (userData && session) {\n      console.log('Profile page - Loading data from UserDataProvider cache (no API call)...');\n      // Use cached data from provider instead of making API call\n      const mergedData = {\n        firstName: userData.profileInfo?.firstName || '',\n        lastName: userData.profileInfo?.lastName || '',\n        bio: userData.profileInfo?.bio || '',\n        dateOfBirth: userData.profileInfo?.dateOfBirth || '',\n        gender: userData.profileInfo?.gender || userData.gender || '',\n        email: session?.user?.email || ''\n      };\n      \n      // üîß FIX: Only update state if current state is empty (initial load)\n      // This prevents overwriting user input during active editing\n      setProfileData(prev => {\n        // If user hasn't entered any data yet, load from cache\n        if (!prev.firstName && !prev.lastName && !prev.bio && !prev.dateOfBirth && !prev.gender) {\n          return mergedData;\n        }\n        \n        // If user has data, only update email and keep their current input\n        return {\n          ...prev,\n          email: session?.user?.email || prev.email\n        };\n      });\n      \n      console.log('Profile page - Data loaded from cache instantly!');\n    } else if (!userData && session) {\n      // Fallback to localStorage while provider loads\n      const savedProfile = localStorage.getItem('profileData');\n      if (savedProfile) {\n        try {\n          const parsed = JSON.parse(savedProfile);\n          setProfileData(prev => ({\n            ...prev,\n            ...parsed,\n            email: session?.user?.email || prev.email\n          }));\n          console.log('Profile page - Loaded from localStorage fallback');\n        } catch (e) {\n          console.error('Error parsing saved profile:', e);\n        }\n      }\n    }\n  }, [userData, session]);\n\n  // Auto-save when data changes\n  useEffect(() => {\n    if (!profileData.firstName && !profileData.lastName && !profileData.bio) return; // Don't save empty initial state\n    \n    setSaveStatus('saving');\n    const saveTimer = setTimeout(async () => {\n      try {\n        // Save to database\n        const response = await fetch('/api/user-data', {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({ profileInfo: profileData })\n        });\n\n        if (response.ok) {\n          // Successful save to database - update provider cache too!\n          updateUserData({ profileInfo: profileData });\n          localStorage.setItem('profileData', JSON.stringify(profileData));\n          setSaveStatus('saved');\n          console.log('Profile auto-saved successfully to database and cache updated!');\n        } else {\n          throw new Error(`Failed to save: ${response.status} ${response.statusText}`);\n        }\n        \n        setTimeout(() => setSaveStatus('idle'), 2000);\n      } catch (error) {\n        console.error('Error saving profile to database:', error);\n        // Save to localStorage as fallback\n        localStorage.setItem('profileData', JSON.stringify(profileData));\n        setSaveStatus('saved');\n        console.log('Profile saved to localStorage as fallback');\n        setTimeout(() => setSaveStatus('idle'), 2000);\n      }\n    }, 1000); // Debounce saves by 1 second\n\n    return () => clearTimeout(saveTimer);\n  }, [profileData]);\n\n  const updateProfileData = (field: string, value: string) => {\n    setProfileData(prev => ({\n      ...prev,\n      [field]: value\n    }));\n  };\n\n  return (\n    <div className=\"min-h-screen bg-gray-50\">\n      <PageHeader title=\"Profile\" />\n\n      {/* Main Content */}\n      <div className=\"max-w-3xl mx-auto px-4 py-8 pb-24 md:pb-8\">\n        <div className=\"bg-white rounded-lg shadow-sm p-6\">\n          <div className=\"flex items-center justify-between mb-6\">\n            <h2 className=\"text-2xl font-bold text-gray-900\">Profile Information</h2>\n            \n            {/* Auto-save Notice */}\n            <div className=\"text-sm text-gray-500\">\n              Changes are saved automatically\n            </div>\n          </div>\n          \n          {/* Auto-save Notice */}\n          <div className=\"bg-blue-50 border border-blue-200 rounded-xl p-4 mb-6\">\n            <div className=\"flex items-center\">\n              <svg className=\"w-5 h-5 text-blue-500 mr-3\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z\" />\n              </svg>\n              <p className=\"text-blue-700 text-sm\">\n                <span className=\"font-medium\">Auto-save enabled:</span> Your changes are automatically saved as you type.\n              </p>\n            </div>\n          </div>\n          \n          {/* Profile Photo */}\n          <div className=\"mb-8 text-center\">\n            {hasProfileImage ? (\n              <Image\n                src={userImage}\n                alt={userName}\n                width={96}\n                height={96}\n                className=\"w-24 h-24 rounded-full object-cover mx-auto mb-4\"\n                priority\n              />\n            ) : (\n              <div className=\"w-24 h-24 rounded-full bg-helfi-green flex items-center justify-center mx-auto mb-4\">\n                <UserIcon className=\"w-12 h-12 text-white\" aria-hidden=\"true\" />\n              </div>\n            )}\n            <Link href=\"/profile/image\" className=\"text-helfi-green hover:underline\">\n              Change Profile Photo\n            </Link>\n          </div>\n\n          {/* Profile Form */}\n          <div className=\"space-y-6\">\n            <div className=\"grid grid-cols-1 md:grid-cols-2 gap-6\">\n              <div>\n                <label className=\"block text-sm font-medium text-gray-700 mb-2\">First Name</label>\n                <input\n                  type=\"text\"\n                  value={profileData.firstName}\n                  onChange={(e) => updateProfileData('firstName', e.target.value)}\n                  className=\"w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-helfi-green focus:border-helfi-green\"\n                  placeholder=\"Enter your first name\"\n                />\n              </div>\n              <div>\n                <label className=\"block text-sm font-medium text-gray-700 mb-2\">Last Name</label>\n                <input\n                  type=\"text\"\n                  value={profileData.lastName}\n                  onChange={(e) => updateProfileData('lastName', e.target.value)}\n                  className=\"w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-helfi-green focus:border-helfi-green\"\n                  placeholder=\"Enter your last name\"\n                />\n              </div>\n            </div>\n\n            <div>\n              <label className=\"block text-sm font-medium text-gray-700 mb-2\">Bio</label>\n              <textarea\n                rows={4}\n                value={profileData.bio}\n                onChange={(e) => updateProfileData('bio', e.target.value)}\n                className=\"w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-helfi-green focus:border-helfi-green\"\n                placeholder=\"Tell us about yourself...\"\n              />\n            </div>\n\n            <div className=\"grid grid-cols-1 md:grid-cols-2 gap-6\">\n              <div>\n                <label className=\"block text-sm font-medium text-gray-700 mb-2\">Date of Birth</label>\n                <input\n                  type=\"date\"\n                  value={profileData.dateOfBirth}\n                  onChange={(e) => updateProfileData('dateOfBirth', e.target.value)}\n                  className=\"w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-helfi-green focus:border-helfi-green\"\n                />\n              </div>\n              <div>\n                <label className=\"block text-sm font-medium text-gray-700 mb-2\">Gender</label>\n                <select \n                  value={profileData.gender}\n                  onChange={(e) => updateProfileData('gender', e.target.value)}\n                  className=\"w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-helfi-green focus:border-helfi-green\"\n                >\n                  <option value=\"\">Select gender</option>\n                  <option value=\"male\">Male</option>\n                  <option value=\"female\">Female</option>\n                  <option value=\"other\">Other</option>\n                  <option value=\"prefer-not-to-say\">Prefer not to say</option>\n                </select>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n\n      {/* Mobile Bottom Navigation - Inspired by Google, Facebook, Amazon mobile apps */}\n      <nav className=\"md:hidden fixed bottom-0 left-0 right-0 bg-white border-t border-gray-200 px-4 py-2 z-40\">\n        <div className=\"flex items-center justify-around\">\n          \n          {/* Dashboard */}\n          <Link href=\"/dashboard\" className=\"flex flex-col items-center py-2 px-1 min-w-0 flex-1\">\n            <div className=\"text-gray-400\">\n              <svg className=\"w-6 h-6\" fill=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path d=\"M3 13h8V3H3v10zm0 8h8v-6H3v6zm10 0h8V11h-8v10zm0-18v6h8V3h-8z\"/>\n              </svg>\n            </div>\n            <span className=\"text-xs text-gray-400 mt-1 font-medium truncate\">Dashboard</span>\n          </Link>\n\n          {/* Insights */}\n          <Link href=\"/insights\" className=\"flex flex-col items-center py-2 px-1 min-w-0 flex-1\">\n            <div className=\"text-gray-400\">\n              <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z\" />\n              </svg>\n            </div>\n            <span className=\"text-xs text-gray-400 mt-1 font-medium truncate\">Insights</span>\n          </Link>\n\n          {/* Food */}\n          <Link href=\"/food\" className=\"flex flex-col items-center py-2 px-1 min-w-0 flex-1\">\n            <div className=\"text-gray-400\">\n              <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10\" />\n              </svg>\n            </div>\n            <span className=\"text-xs text-gray-400 mt-1 font-medium truncate\">Food</span>\n          </Link>\n\n          {/* Intake (Onboarding) */}\n          <MobileMoreMenu />\n\n          {/* Settings */}\n          <Link href=\"/settings\" className=\"flex flex-col items-center py-2 px-1 min-w-0 flex-1\">\n            <div className=\"text-gray-400\">\n              <Cog6ToothIcon className=\"w-6 h-6 flex-shrink-0\" style={{ minWidth: '24px', minHeight: '24px' }} />\n            </div>\n            <span className=\"text-xs text-gray-400 mt-1 font-medium truncate\">Settings</span>\n          </Link>\n\n        </div>\n      </nav>\n    </div>\n  )\n} ","truncated":false,"size":13054},{"path":"app/pwa-entry/page.tsx","content":"import { cookies } from 'next/headers'\nimport { redirect } from 'next/navigation'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\n\nexport const dynamic = 'force-dynamic'\n\n// Paths that should never be used as \"last page\" destinations\nconst disallowedPrefixes = ['/auth', '/onboarding', '/privacy', '/terms', '/help', '/faq']\nconst disallowedExact = ['/', '/healthapp']\n\nfunction getSafeLastPath(raw?: string | null) {\n  if (!raw) return null\n  let decoded = raw\n  try {\n    decoded = decodeURIComponent(raw)\n  } catch {\n    // Fall back to raw if decoding fails\n  }\n\n  if (!decoded.startsWith('/')) return null\n  if (disallowedExact.includes(decoded)) return null\n  if (disallowedPrefixes.some((prefix) => decoded.startsWith(prefix))) return null\n  return decoded\n}\n\nexport default async function PwaEntryPage() {\n  const session = await getServerSession(authOptions)\n  const email = session?.user?.email?.toLowerCase()\n  if (!email) {\n    redirect('/auth/signin')\n  }\n\n  // Read the last in-app page recorded by the client.\n  const lastPathCookie = cookies().get('helfi-last-path')?.value\n  const lastPath = getSafeLastPath(lastPathCookie)\n\n  // Guard rail: keep the Health Setup definition identical to HEALTH_SETUP_PROTECTION.md.\n  const user = await prisma.user.findUnique({\n    where: { email },\n    include: {\n      healthGoals: { select: { name: true } },\n      supplements: { select: { id: true } },\n      medications: { select: { id: true } },\n    },\n  })\n\n  if (!user) {\n    redirect('/auth/signin')\n  }\n\n  const visibleGoals = user.healthGoals.filter((goal) => !goal.name.startsWith('__'))\n  const hasBasicProfile = !!(user.gender && user.weight && user.height)\n  const hasGoals = visibleGoals.length > 0\n  const onboardingComplete = hasBasicProfile && hasGoals\n\n  if (!onboardingComplete) {\n    redirect('/onboarding')\n  }\n\n  if (lastPath) {\n    redirect(lastPath)\n  }\n\n  redirect('/dashboard')\n}\n","truncated":false,"size":1985},{"path":"app/r/[code]/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\nimport {\n  AFFILIATE_COOKIE_MAX_AGE_SECONDS,\n  AFFILIATE_COOKIES,\n  getOrCreateVisitorId,\n  normalizeAffiliateCode,\n} from '@/lib/affiliate-cookies'\nimport { consumeRateLimit } from '@/lib/rate-limit'\n\nexport const runtime = 'nodejs'\nexport const dynamic = 'force-dynamic'\n\nconst RATE_LIMIT_WINDOW_MS = 5 * 60 * 1000\nconst RATE_LIMIT_MAX_REQUESTS = 20\n\nfunction getClientIp(request: NextRequest): string | null {\n  const header = request.headers.get('x-forwarded-for')\n  if (!header) return null\n  const first = header.split(',')[0]?.trim()\n  return first || null\n}\n\nexport async function GET(request: NextRequest, context: { params: { code: string } }) {\n  const code = normalizeAffiliateCode(context.params.code)\n\n  const url = new URL(request.url)\n  const destination = url.searchParams.get('to') || '/'\n  const destinationPath = destination.startsWith('/') ? destination : '/'\n\n  const affiliate = await prisma.affiliate.findUnique({\n    where: { code },\n    select: { id: true, status: true },\n  })\n\n  if (!affiliate || affiliate.status !== 'ACTIVE') {\n    return NextResponse.redirect(new URL('/', request.url))\n  }\n\n  const visitorId = getOrCreateVisitorId(request)\n  const ip = getClientIp(request)\n  const limiterKey = ip || visitorId\n  const rateLimit = await consumeRateLimit('affiliate_click', limiterKey, RATE_LIMIT_MAX_REQUESTS, RATE_LIMIT_WINDOW_MS)\n  if (!rateLimit.allowed) {\n    return NextResponse.redirect(new URL(destinationPath, request.url))\n  }\n\n  const referer = request.headers.get('referer')\n  const userAgent = request.headers.get('user-agent')\n  const landingPath = url.pathname\n\n  const click = await prisma.affiliateClick.create({\n    data: {\n      affiliateId: affiliate.id,\n      visitorId,\n      ip,\n      userAgent,\n      referer,\n      landingPath,\n      destinationPath,\n    },\n    select: { id: true, createdAt: true },\n  })\n\n  const response = NextResponse.redirect(new URL(destinationPath, request.url))\n\n  response.cookies.set(AFFILIATE_COOKIES.visitorId, visitorId, {\n    httpOnly: true,\n    maxAge: AFFILIATE_COOKIE_MAX_AGE_SECONDS,\n    path: '/',\n    sameSite: 'lax',\n    secure: request.nextUrl.protocol === 'https:',\n  })\n  response.cookies.set(AFFILIATE_COOKIES.code, code, {\n    httpOnly: true,\n    maxAge: AFFILIATE_COOKIE_MAX_AGE_SECONDS,\n    path: '/',\n    sameSite: 'lax',\n    secure: request.nextUrl.protocol === 'https:',\n  })\n  response.cookies.set(AFFILIATE_COOKIES.clickId, click.id, {\n    httpOnly: true,\n    maxAge: AFFILIATE_COOKIE_MAX_AGE_SECONDS,\n    path: '/',\n    sameSite: 'lax',\n    secure: request.nextUrl.protocol === 'https:',\n  })\n  response.cookies.set(AFFILIATE_COOKIES.clickedAtMs, String(click.createdAt.getTime()), {\n    httpOnly: true,\n    maxAge: AFFILIATE_COOKIE_MAX_AGE_SECONDS,\n    path: '/',\n    sameSite: 'lax',\n    secure: request.nextUrl.protocol === 'https:',\n  })\n\n  return response\n}\n","truncated":false,"size":2965},{"path":"app/reports/page.tsx","content":"'use client'\n\nimport React, { useState, useEffect } from 'react'\nimport { useSession, signOut } from 'next-auth/react'\nimport Link from 'next/link'\nimport { usePathname } from 'next/navigation'\nimport Image from 'next/image'\nimport { UserIcon } from '@heroicons/react/24/outline'\nimport { useUserData } from '@/components/providers/UserDataProvider'\nimport MobileMoreMenu from '@/components/MobileMoreMenu'\n\nexport default function Reports() {\n  const { data: session } = useSession()\n  const pathname = usePathname()\n  const { userData, profileImage } = useUserData()\n  const [dropdownOpen, setDropdownOpen] = useState(false)\n\n  // Profile data - prefer real photos; fall back to professional icon\n  const hasProfileImage = !!(profileImage || session?.user?.image)\n  const userImage = (profileImage || session?.user?.image || '') as string\n  const userName = session?.user?.name || 'User';\n\n  // Close dropdown on outside click\n  useEffect(() => {\n    function handleClick(e: MouseEvent) {\n      const target = e.target as HTMLElement;\n      // Check if click is outside both the button and the dropdown content\n      if (!target.closest('.dropdown-container')) {\n        setDropdownOpen(false);\n      }\n    }\n    if (dropdownOpen) {\n      document.addEventListener('mousedown', handleClick);\n      return () => document.removeEventListener('mousedown', handleClick);\n    }\n  }, [dropdownOpen]);\n\n  const [reports, setReports] = useState<any[]>([])\n  const [loadingPreview, setLoadingPreview] = useState<boolean>(false)\n\n  useEffect(() => {\n    async function loadPreview() {\n      try {\n        setLoadingPreview(true)\n        const res = await fetch('/api/reports/weekly/list?preview=1', { cache: 'no-cache' })\n        const data = await res.json().catch(() => ({}))\n        if (data?.reports && Array.isArray(data.reports)) {\n          setReports(data.reports)\n        }\n      } catch (e) {\n        // ignore preview errors\n      } finally {\n        setLoadingPreview(false)\n      }\n    }\n    loadPreview()\n  }, [])\n\n  // Profile image now loaded from UserDataProvider cache - no API call needed!\n\n  return (\n    <div className=\"min-h-screen bg-gray-50\">\n      {/* Navigation Header - CONSISTENT WITH OTHER PAGES */}\n      <nav className=\"bg-white border-b border-gray-200 px-4 py-3\">\n        <div className=\"max-w-7xl mx-auto flex justify-between items-center\">\n          {/* Logo on the left */}\n          <div className=\"flex items-center\">\n            <Link href=\"/\" className=\"w-16 h-16 md:w-20 md:h-20 cursor-pointer hover:opacity-80 transition-opacity\">\n              <Image\n                src=\"/mobile-assets/LOGOS/helfi-01-01.png\"\n                alt=\"Helfi Logo\"\n                width={80}\n                height={80}\n                className=\"w-full h-full object-contain dark:hidden\"\n                priority\n              />\n              <Image\n                src=\"/mobile-assets/LOGOS/helfi-01-06.png\"\n                alt=\"Helfi Logo\"\n                width={80}\n                height={80}\n                className=\"w-full h-full object-contain hidden dark:block\"\n                priority\n              />\n            </Link>\n          </div>\n          \n          {/* Profile Avatar & Dropdown on the right */}\n          <div className=\"relative dropdown-container\" id=\"profile-dropdown\">\n            <button\n              onClick={() => setDropdownOpen((v) => !v)}\n              className=\"focus:outline-none\"\n              aria-label=\"Open profile menu\"\n            >\n              {hasProfileImage ? (\n                <Image\n                  src={userImage}\n                  alt=\"Profile\"\n                  width={48}\n                  height={48}\n                  className=\"w-12 h-12 rounded-full border-2 border-helfi-green shadow-sm object-cover\"\n                />\n              ) : (\n                <div className=\"w-12 h-12 rounded-full bg-helfi-green shadow-sm flex items-center justify-center\">\n                  <UserIcon className=\"w-6 h-6 text-white\" aria-hidden=\"true\" />\n                </div>\n              )}\n            </button>\n            {dropdownOpen && (\n              <div className=\"absolute right-0 mt-2 w-64 bg-white rounded-xl shadow-lg py-2 z-50 border border-gray-100 animate-fade-in\">\n                <div className=\"flex items-center px-4 py-3 border-b border-gray-100\">\n                  {hasProfileImage ? (\n                    <Image\n                      src={userImage}\n                      alt=\"Profile\"\n                      width={40}\n                      height={40}\n                      className=\"w-10 h-10 rounded-full object-cover mr-3\"\n                    />\n                  ) : (\n                    <div className=\"w-10 h-10 rounded-full bg-helfi-green flex items-center justify-center mr-3\">\n                      <UserIcon className=\"w-5 h-5 text-white\" aria-hidden=\"true\" />\n                    </div>\n                  )}\n                  <div>\n                    <div className=\"font-semibold text-gray-900\">{userName}</div>\n                    <div className=\"text-xs text-gray-500\">{session?.user?.email || 'user@email.com'}</div>\n                  </div>\n                </div>\n                <Link href=\"/profile\" className=\"block px-4 py-2 text-gray-700 hover:bg-gray-50\">Profile</Link>\n                <Link href=\"/account\" className=\"block px-4 py-2 text-gray-700 hover:bg-gray-50\">Account Settings</Link>\n                <Link href=\"/profile/image\" className=\"block px-4 py-2 text-gray-700 hover:bg-gray-50\">Upload/Change Profile Photo</Link>\n                <Link href=\"/billing\" className=\"block px-4 py-2 text-gray-700 hover:bg-gray-50\">Subscription & Billing</Link>\n                <Link href=\"/notifications\" className=\"block px-4 py-2 text-gray-700 hover:bg-gray-50\">Notifications</Link>\n                <Link href=\"/privacy\" className=\"block px-4 py-2 text-gray-700 hover:bg-gray-50\">Privacy Settings</Link>\n                <Link href=\"/help\" className=\"block px-4 py-2 text-gray-700 hover:bg-gray-50\">Help & Support</Link>\n                <button\n                  onClick={() => signOut({ callbackUrl: '/auth/signin' })}\n                  className=\"block w-full text-left px-4 py-2 text-red-600 hover:bg-gray-50 font-semibold\"\n                >\n                  Logout\n                </button>\n              </div>\n            )}\n          </div>\n        </div>\n      </nav>\n\n      {/* Second Row - Page Title Centered (CONSISTENT WITH OTHER PAGES) */}\n      <div className=\"bg-white border-b border-gray-200 px-4 py-4\">\n        <div className=\"max-w-7xl mx-auto text-center\">\n          <h1 className=\"text-lg md:text-xl font-semibold text-gray-900\">Health Reports</h1>\n          <p className=\"text-sm text-gray-500 hidden sm:block\">Weekly health analysis and trends</p>\n        </div>\n      </div>\n\n      {/* Main Content */}\n      <div className=\"max-w-7xl mx-auto px-4 py-8 pb-24 md:pb-8\">\n        <div className=\"bg-white rounded-lg shadow-sm p-8\">\n          <div className=\"text-center mb-8\">\n            <h1 className=\"text-3xl font-bold text-helfi-black dark:text-white mb-4\">\n              Health Reports\n            </h1>\n            <p className=\"text-gray-600\">\n              Comprehensive analysis of your health trends and progress over time.\n            </p>\n          </div>\n\n          <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6\">\n            {reports.length > 0 ? (\n              reports.map((r) => (\n                <div key={r.id} className=\"bg-purple-50 dark:bg-gray-800 p-6 rounded-lg border-2 border-purple-200 dark:border-gray-700\">\n                  <h3 className=\"font-semibold text-helfi-black dark:text-white mb-1\">üìä Weekly Summary</h3>\n                  <p className=\"text-sm text-gray-600 mb-2\">Week starting {r.weekStart}</p>\n                  <div className=\"text-sm text-purple-800 dark:text-purple-200\">{r.summary}</div>\n                </div>\n              ))\n            ) : (\n              <div className=\"text-sm text-gray-600\">{loadingPreview ? 'Loading preview‚Ä¶' : 'No reports yet.'}</div>\n            )}\n          </div>\n        </div>\n      </div>\n\n      {/* Mobile Bottom Navigation - with pressed, ripple and active states */}\n      <nav className=\"md:hidden fixed bottom-0 left-0 right-0 bg-white border-t border-gray-200 px-4 py-2 z-40\">\n        <div className=\"flex items-center justify-around\">\n          \n          {/* Dashboard */}\n          <Link href=\"/dashboard\" className=\"pressable ripple flex flex-col items-center py-2 px-1 min-w-0 flex-1\" onClick={() => { try { const reduced = window.matchMedia('(prefers-reduced-motion: reduce)')?.matches; const pref = localStorage.getItem('hapticsEnabled'); const enabled = pref === null ? true : pref === 'true'; if (enabled && !reduced && 'vibrate' in navigator) navigator.vibrate(10) } catch {} }}>\n            <div className={`icon ${pathname === '/dashboard' ? 'text-helfi-green' : 'text-gray-400'}`}>\n              <svg className=\"w-6 h-6\" fill=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path d=\"M3 13h8V3H3v10zm0 8h8v-6H3v6zm10 0h8V11h-8v10zm0-18v6h8V3h-8z\"/>\n              </svg>\n            </div>\n            <span className={`label text-xs mt-1 truncate ${pathname === '/dashboard' ? 'text-helfi-green font-bold' : 'text-gray-400 font-medium'}`}>Dashboard</span>\n          </Link>\n\n          {/* Health */}\n          <Link href=\"/health-tracking\" className=\"pressable ripple flex flex-col items-center py-2 px-1 min-w-0 flex-1\" onClick={() => { try { const reduced = window.matchMedia('(prefers-reduced-motion: reduce)')?.matches; const pref = localStorage.getItem('hapticsEnabled'); const enabled = pref === null ? true : pref === 'true'; if (enabled && !reduced && 'vibrate' in navigator) navigator.vibrate(10) } catch {} }}>\n            <div className={`icon ${pathname === '/health-tracking' ? 'text-helfi-green' : 'text-gray-400'}`}>\n              <svg className=\"w-6 h-6\" fill=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path d=\"M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z\"/>\n              </svg>\n            </div>\n            <span className={`label text-xs mt-1 truncate ${pathname === '/health-tracking' ? 'text-helfi-green font-bold' : 'text-gray-400 font-medium'}`}>Health</span>\n          </Link>\n\n          {/* Food */}\n          <Link href=\"/food\" className=\"pressable ripple flex flex-col items-center py-2 px-1 min-w-0 flex-1\" onClick={() => { try { const reduced = window.matchMedia('(prefers-reduced-motion: reduce)')?.matches; const pref = localStorage.getItem('hapticsEnabled'); const enabled = pref === null ? true : pref === 'true'; if (enabled && !reduced && 'vibrate' in navigator) navigator.vibrate(10) } catch {} }}>\n            <div className={`icon ${pathname === '/food' ? 'text-helfi-green' : 'text-gray-400'}`}>\n              <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10\" />\n              </svg>\n            </div>\n            <span className={`label text-xs mt-1 truncate ${pathname === '/food' ? 'text-helfi-green font-bold' : 'text-gray-400 font-medium'}`}>Food</span>\n          </Link>\n\n          {/* Insights */}\n          <Link href=\"/insights\" className=\"pressable ripple flex flex-col items-center py-2 px-1 min-w-0 flex-1\" onClick={() => { try { const reduced = window.matchMedia('(prefers-reduced-motion: reduce)')?.matches; const pref = localStorage.getItem('hapticsEnabled'); const enabled = pref === null ? true : pref === 'true'; if (enabled && !reduced && 'vibrate' in navigator) navigator.vibrate(10) } catch {} }}>\n            <div className={`icon ${pathname === '/insights' ? 'text-helfi-green' : 'text-gray-400'}`}>\n              <svg className=\"w-6 h-6\" fill=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path d=\"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z\"/>\n              </svg>\n            </div>\n            <span className={`label text-xs mt-1 truncate ${pathname === '/insights' ? 'text-helfi-green font-bold' : 'text-gray-400 font-medium'}`}>Insights</span>\n          </Link>\n\n          {/* Reports (Active) */}\n          <Link href=\"/reports\" className=\"pressable ripple flex flex-col items-center py-2 px-1 min-w-0 flex-1\" onClick={() => { try { const reduced = window.matchMedia('(prefers-reduced-motion: reduce)')?.matches; const pref = localStorage.getItem('hapticsEnabled'); const enabled = pref === null ? true : pref === 'true'; if (enabled && !reduced && 'vibrate' in navigator) navigator.vibrate(10) } catch {} }}>\n            <div className={`icon ${pathname === '/reports' ? 'text-helfi-green' : 'text-gray-400'}`}>\n              <svg className=\"w-6 h-6\" fill=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path d=\"M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 17H7v-7h2v7zm4 0h-2V7h2v10zm4 0h-2v-4h2v4z\"/>\n              </svg>\n            </div>\n            <span className={`label text-xs mt-1 truncate ${pathname === '/reports' ? 'text-helfi-green font-bold' : 'text-gray-400 font-medium'}`}>Reports</span>\n          </Link>\n\n          {/* Intake (Onboarding) */}\n          <MobileMoreMenu />\n\n        </div>\n      </nav>\n    </div>\n  )\n} ","truncated":false,"size":13520},{"path":"app/settings/page.tsx","content":"'use client'\nimport { Cog6ToothIcon, UserIcon } from '@heroicons/react/24/outline'\n\nimport React, { useState, useEffect } from 'react'\nimport { useSession, signOut } from 'next-auth/react'\nimport Link from 'next/link'\nimport { usePathname } from 'next/navigation'\nimport Image from 'next/image'\nimport { useUserData } from '@/components/providers/UserDataProvider'\nimport MobileMoreMenu from '@/components/MobileMoreMenu'\n\n// Global dark mode function type\ndeclare global {\n  interface Window {\n    toggleDarkMode: (enabled: boolean) => void;\n  }\n}\n\nexport default function Settings() {\n  const { data: session } = useSession()\n  const { userData, profileImage } = useUserData()\n  const [dropdownOpen, setDropdownOpen] = useState(false)\n  const pathname = usePathname()\n  \n  // Settings states with automatic saving\n  const [darkMode, setDarkMode] = useState(false)\n  const [emailNotifications, setEmailNotifications] = useState(true)\n  const [pushNotifications, setPushNotifications] = useState(false)\n  const [profileVisibility, setProfileVisibility] = useState('private')\n  const [dataAnalytics, setDataAnalytics] = useState(true)\n  const [hapticsEnabled, setHapticsEnabled] = useState(true)\n  // Prevent \"auto-save\" effects from overwriting stored values on first load\n  const [localPrefsLoaded, setLocalPrefsLoaded] = useState(false)\n  const [showPdf, setShowPdf] = useState(false)\n  const [pdfUrl, setPdfUrl] = useState<string>('')\n  const [exporting, setExporting] = useState(false)\n  // Reminder settings (multiple reminders per day)\n  const [time1, setTime1] = useState('12:30')\n  const [time2, setTime2] = useState('18:30')\n  const [time3, setTime3] = useState('21:30')\n  const [tz, setTz] = useState('Australia/Melbourne')\n  const [frequency, setFrequency] = useState(3)\n  const [savingTimes, setSavingTimes] = useState(false)\n  const [loadingSettings, setLoadingSettings] = useState(true)\n  const [showIOSInstructions, setShowIOSInstructions] = useState(false)\n  // Curated timezone list (IANA names)\n  const baseTimezones = [\n    'UTC','Europe/London','Europe/Paris','Europe/Berlin','Europe/Madrid','Europe/Rome','Europe/Amsterdam','Europe/Zurich','Europe/Stockholm','Europe/Athens',\n    'Africa/Johannesburg','Asia/Dubai','Asia/Kolkata','Asia/Bangkok','Asia/Singapore','Asia/Kuala_Lumpur','Asia/Hong_Kong','Asia/Tokyo','Asia/Seoul','Asia/Shanghai',\n    'Australia/Perth','Australia/Adelaide','Australia/Melbourne','Australia/Sydney','Pacific/Auckland',\n    'America/New_York','America/Chicago','America/Denver','America/Los_Angeles','America/Toronto','America/Vancouver','America/Mexico_City','America/Bogota','America/Sao_Paulo'\n  ]\n\n  function normalizeTime(input: string): string {\n    if (!input) return '00:00'\n    const s = input.trim().toLowerCase()\n    // Already 24h HH:MM\n    const m24 = s.match(/^([01]?\\d|2[0-3]):([0-5]\\d)$/)\n    if (m24) return `${m24[1].padStart(2,'0')}:${m24[2]}`\n    // 12h like 12:30 pm or 7:05am\n    const m12 = s.match(/^([0-1]?\\d):([0-5]\\d)\\s*(am|pm)$/)\n    if (m12) {\n      let h = parseInt(m12[1], 10)\n      const mm = m12[2]\n      const ap = m12[3]\n      if (ap === 'pm' && h !== 12) h += 12\n      if (ap === 'am' && h === 12) h = 0\n      return `${String(h).padStart(2,'0')}:${mm}`\n    }\n    // Fallback: strip non-digits and try first 4 digits\n    const digits = s.replace(/[^0-9]/g, '')\n    if (digits.length >= 3) {\n      const h = digits.slice(0, digits.length - 2)\n      const mm = digits.slice(-2)\n      const hh = Math.max(0, Math.min(23, parseInt(h, 10)))\n      const m = Math.max(0, Math.min(59, parseInt(mm, 10)))\n      return `${String(hh).padStart(2,'0')}:${String(m).padStart(2,'0')}`\n    }\n    return '00:00'\n  }\n  \n  // iOS detection for push notifications\n  const [isIOS, setIsIOS] = useState(false)\n  const [isInstalled, setIsInstalled] = useState(false)\n\n  // Initialize settings from localStorage\n  useEffect(() => {\n    try {\n      const savedDarkMode = localStorage.getItem('darkMode')\n      const savedEmailNotifications = localStorage.getItem('emailNotifications')\n      const savedPushNotifications = localStorage.getItem('pushNotifications')\n      const savedProfileVisibility = localStorage.getItem('profileVisibility')\n      const savedDataAnalytics = localStorage.getItem('dataAnalytics')\n      const savedHaptics = localStorage.getItem('hapticsEnabled')\n      \n      if (savedDarkMode !== null) setDarkMode(savedDarkMode === 'true')\n      if (savedEmailNotifications !== null) setEmailNotifications(savedEmailNotifications === 'true')\n      if (savedPushNotifications !== null) setPushNotifications(savedPushNotifications === 'true')\n      if (savedProfileVisibility) setProfileVisibility(savedProfileVisibility)\n      if (savedDataAnalytics !== null) setDataAnalytics(savedDataAnalytics === 'true')\n      if (savedHaptics !== null) setHapticsEnabled(savedHaptics === 'true')\n    } catch {\n      // If storage is blocked/unavailable, keep defaults\n    }\n    \n    // Detect iOS devices\n    const isIOSDevice = /iPad|iPhone|iPod/.test(navigator.userAgent) || \n                       (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1)\n    setIsIOS(isIOSDevice)\n    // Detect installed PWA/standalone\n    const standalone = (window.navigator as any).standalone === true || \n      (window.matchMedia && window.matchMedia('(display-mode: standalone)').matches)\n    setIsInstalled(standalone)\n    \n    // Listen for dark mode changes from other sources\n    const handleDarkModeChange = (e: CustomEvent) => {\n      setDarkMode(e.detail)\n    }\n    \n    window.addEventListener('darkModeChanged', handleDarkModeChange as EventListener)\n    // Mark local settings as loaded (enables auto-save effects without overwriting on first paint)\n    setLocalPrefsLoaded(true)\n    return () => window.removeEventListener('darkModeChanged', handleDarkModeChange as EventListener)\n  }, [])\n\n  // Auto-save dark mode changes\n  useEffect(() => {\n    if (!localPrefsLoaded) return\n    localStorage.setItem('darkMode', darkMode.toString())\n    if (window.toggleDarkMode) {\n      window.toggleDarkMode(darkMode)\n    }\n  }, [darkMode, localPrefsLoaded])\n\n  // Auto-save haptics changes\n  useEffect(() => {\n    if (!localPrefsLoaded) return\n    localStorage.setItem('hapticsEnabled', hapticsEnabled.toString())\n  }, [hapticsEnabled, localPrefsLoaded])\n\n  // Auto-save email notifications\n  useEffect(() => {\n    if (!localPrefsLoaded) return\n    localStorage.setItem('emailNotifications', emailNotifications.toString())\n    // TODO: Send to backend API to update user preferences\n  }, [emailNotifications, localPrefsLoaded])\n\n  // Auto-save push notifications\n  useEffect(() => {\n    if (!localPrefsLoaded) return\n    localStorage.setItem('pushNotifications', pushNotifications.toString())\n    // TODO: Send to backend API to update user preferences\n  }, [pushNotifications, localPrefsLoaded])\n\n  // Detect existing subscription on load and reflect in UI\n  useEffect(() => {\n    (async () => {\n      try {\n        if ('serviceWorker' in navigator) {\n          const reg = await navigator.serviceWorker.getRegistration()\n          if (reg) {\n            const sub = await reg.pushManager.getSubscription()\n            if (sub && Notification.permission === 'granted') {\n              setPushNotifications(true)\n            }\n          }\n        }\n      } catch {}\n    })()\n  }, [])\n\n  // Load reminder settings from API\n  useEffect(() => {\n    (async () => {\n      try {\n        const res = await fetch('/api/checkins/settings', { cache: 'no-store' as any })\n        if (res.ok) {\n          const data = await res.json()\n          if (data.time1) setTime1(data.time1)\n          if (data.time2) setTime2(data.time2)\n          if (data.time3) setTime3(data.time3)\n          if (data.timezone) setTz(data.timezone)\n          if (data.frequency !== undefined) setFrequency(data.frequency)\n        }\n      } catch (e) {\n        console.error('Failed to load reminder settings', e)\n      } finally {\n        setLoadingSettings(false)\n      }\n    })()\n  }, [])\n\n  // Detect existing subscription on load\n  useEffect(() => {\n    (async () => {\n      try {\n        if ('serviceWorker' in navigator) {\n          const reg = await navigator.serviceWorker.getRegistration()\n          if (reg) {\n            const sub = await reg.pushManager.getSubscription()\n            if (sub && Notification.permission === 'granted') {\n              setPushNotifications(true)\n            }\n          }\n        }\n      } catch {}\n    })()\n  }, [])\n\n  // Auto-save profile visibility\n  useEffect(() => {\n    if (!localPrefsLoaded) return\n    localStorage.setItem('profileVisibility', profileVisibility)\n    // TODO: Send to backend API to update user preferences\n  }, [profileVisibility, localPrefsLoaded])\n\n  // Auto-save data analytics with comprehensive tracking\n  useEffect(() => {\n    if (!localPrefsLoaded) return\n    localStorage.setItem('dataAnalytics', dataAnalytics.toString())\n    \n    // Track analytics events if user has opted in\n    if (dataAnalytics && session?.user?.email) {\n      const analyticsEvent = {\n        userId: session.user.email,\n        action: 'settings_page_interaction',\n        timestamp: new Date().toISOString(),\n        page: '/settings',\n        userAgent: navigator.userAgent,\n        viewport: {\n          width: window.innerWidth,\n          height: window.innerHeight\n        },\n        settings: {\n          darkMode,\n          emailNotifications,\n          pushNotifications,\n          profileVisibility,\n          dataAnalytics\n        },\n        deviceInfo: {\n          platform: navigator.platform,\n          language: navigator.language,\n          cookieEnabled: navigator.cookieEnabled\n        }\n      }\n      \n      // Send to analytics API\n      fetch('/api/analytics', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(analyticsEvent)\n      }).catch(err => console.log('üìä Analytics tracking error:', err))\n    }\n  }, [dataAnalytics, session, darkMode, emailNotifications, pushNotifications, profileVisibility, localPrefsLoaded])\n\n  // Track individual setting changes\n  const trackSettingChange = (settingName: string, newValue: any) => {\n    if (dataAnalytics && session?.user?.email) {\n      const changeEvent = {\n        userId: session.user.email,\n        action: `setting_changed_${settingName}`,\n        timestamp: new Date().toISOString(),\n        page: '/settings',\n        data: {\n          setting: settingName,\n          newValue,\n          previousValue: settingName === 'darkMode' ? !newValue : \n                        settingName === 'emailNotifications' ? !newValue :\n                        settingName === 'pushNotifications' ? !newValue :\n                        settingName === 'dataAnalytics' ? !newValue : 'unknown'\n        }\n      }\n      \n      fetch('/api/analytics', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(changeEvent)\n      }).catch(err => console.log('üìä Setting change tracking error:', err))\n    }\n  }\n\n  // Handle push notifications toggle with iOS detection\n  const handlePushNotificationToggle = async (enabled: boolean) => {\n    if (isIOS && !isInstalled && enabled) {\n      alert('To enable notifications on iPhone, first Add to Home Screen, then open the Helfi app icon and enable here.')\n      return\n    }\n    \n    setPushNotifications(enabled)\n    \n    // Request permission and subscribe (works for Android, Desktop, and iOS PWA 16.4+)\n    if (enabled && 'Notification' in window) {\n      const permission = await Notification.requestPermission()\n      if (permission !== 'granted') {\n        setPushNotifications(false)\n        alert('Push notifications were denied. Please enable them in your browser settings.')\n        return\n      }\n      // Register service worker and subscribe\n      try {\n        // Ensure service worker is registered\n        const reg = (await navigator.serviceWorker.getRegistration()) || (await navigator.serviceWorker.register('/sw.js'))\n        const vapid = await fetch('/api/push/vapid').then(r=>r.json()).catch(()=>({ publicKey: '' }))\n        if (!vapid.publicKey) {\n          alert('Notifications are not yet fully enabled by the server. Please try again later.')\n          return\n        }\n        const sub = await reg.pushManager.subscribe({\n          userVisibleOnly: true,\n          applicationServerKey: urlBase64ToUint8Array(vapid.publicKey)\n        })\n        await fetch('/api/push/subscribe', {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({ subscription: sub })\n        })\n        alert('Notifications enabled')\n      } catch (e) {\n        console.error('push enable error', e)\n        alert('Could not enable notifications on this device.')\n      }\n    }\n    if (!enabled) {\n      try {\n        await fetch('/api/push/unsubscribe', { method: 'POST' })\n      } catch {}\n    }\n  }\n\n  // One-click save/re-save subscription\n  const saveSubscription = async () => {\n    try {\n      const reg = (await navigator.serviceWorker.getRegistration()) || (await navigator.serviceWorker.register('/sw.js'))\n      const vapid = await fetch('/api/push/vapid').then(r=>r.json()).catch(()=>({ publicKey: '' }))\n      if (!vapid.publicKey) { alert('Server VAPID key not available yet.'); return }\n      let sub = await reg.pushManager.getSubscription()\n      if (!sub) {\n        const permission = await Notification.requestPermission()\n        if (permission !== 'granted') { alert('Notifications permission not granted.'); return }\n        sub = await reg.pushManager.subscribe({ userVisibleOnly: true, applicationServerKey: urlBase64ToUint8Array(vapid.publicKey) })\n      }\n      const res = await fetch('/api/push/subscribe', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ subscription: sub }) })\n      if (res.ok) alert('Device subscription saved.')\n      else alert('Could not save subscription. Please try again.')\n    } catch (e) { alert('Subscription error. Please try again.') }\n  }\n\n  const resetSubscription = async () => {\n    try {\n      const reg = (await navigator.serviceWorker.getRegistration()) || (await navigator.serviceWorker.register('/sw.js'))\n      // Unsubscribe existing\n      const existing = await reg.pushManager.getSubscription()\n      if (existing) { try { await existing.unsubscribe() } catch {} }\n      // Fresh subscribe with current VAPID\n      const vapid = await fetch('/api/push/vapid').then(r=>r.json()).catch(()=>({ publicKey: '' }))\n      if (!vapid.publicKey) { alert('Server VAPID key not available yet.'); return }\n      const permission = await Notification.requestPermission()\n      if (permission !== 'granted') { alert('Notifications permission not granted.'); return }\n      const sub = await reg.pushManager.subscribe({ userVisibleOnly: true, applicationServerKey: urlBase64ToUint8Array(vapid.publicKey) })\n      const res = await fetch('/api/push/subscribe', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ subscription: sub }) })\n      if (res.ok) alert('Subscription reset and saved.')\n      else alert('Could not reset subscription. Please try again.')\n    } catch (e) { alert('Reset error. Please try again.') }\n  }\n\n  // Helper for VAPID key format\n  function urlBase64ToUint8Array(base64String: string) {\n    const padding = '='.repeat((4 - (base64String.length % 4)) % 4)\n    const base64 = (base64String + padding).replace(/-/g, '+').replace(/_/g, '/')\n    const rawData = window.atob(base64)\n    const outputArray = new Uint8Array(rawData.length)\n    for (let i = 0; i < rawData.length; ++i) {\n      outputArray[i] = rawData.charCodeAt(i)\n    }\n    return outputArray\n  }\n\n  // Profile data - prefer real photos; fall back to professional icon\n  const hasProfileImage = !!(profileImage || session?.user?.image)\n  const userImage = (profileImage || session?.user?.image || '') as string\n  const userName = session?.user?.name || 'User';\n\n  // Close dropdown on outside click\n  useEffect(() => {\n    function handleClick(e: MouseEvent) {\n      const target = e.target as HTMLElement;\n      if (!target.closest('.dropdown-container')) {\n        setDropdownOpen(false);\n      }\n    }\n    if (dropdownOpen) {\n      document.addEventListener('mousedown', handleClick);\n      return () => document.removeEventListener('mousedown', handleClick);\n    }\n  }, [dropdownOpen]);\n\n  return (\n    <div className=\"min-h-screen bg-gray-50 dark:bg-gray-900\">\n      {/* Header - No back button (main nav item) */}\n      <nav className=\"bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700 px-4 py-3\">\n        <div className=\"max-w-7xl mx-auto flex justify-between items-center\">\n          {/* Page Title - Mobile only */}\n          <h1 className=\"md:hidden flex-1 text-center text-lg font-semibold text-gray-900 dark:text-white\">Settings</h1>\n          <div className=\"hidden md:block\"></div>\n\n          {/* Profile Avatar & Dropdown */}\n          <div className=\"relative dropdown-container\" id=\"profile-dropdown\">\n            <button\n              onClick={() => setDropdownOpen((v) => !v)}\n              className=\"focus:outline-none\"\n              aria-label=\"Open profile menu\"\n            >\n              {hasProfileImage ? (\n                <Image\n                  src={userImage}\n                  alt=\"Profile\"\n                  width={40}\n                  height={40}\n                  className=\"w-10 h-10 rounded-full border-2 border-helfi-green shadow-sm object-cover\"\n                />\n              ) : (\n                <div className=\"w-10 h-10 rounded-full bg-helfi-green shadow-sm flex items-center justify-center\">\n                  <UserIcon className=\"w-6 h-6 text-white\" aria-hidden=\"true\" />\n                </div>\n              )}\n            </button>\n            {dropdownOpen && (\n              <div className=\"absolute right-0 mt-2 w-64 bg-white dark:bg-gray-800 rounded-xl shadow-lg py-2 z-50 border border-gray-100 dark:border-gray-700 animate-fade-in\">\n                <div className=\"flex items-center px-4 py-3 border-b border-gray-100 dark:border-gray-700\">\n                  {hasProfileImage ? (\n                    <Image\n                      src={userImage}\n                      alt=\"Profile\"\n                      width={40}\n                      height={40}\n                      className=\"w-10 h-10 rounded-full object-cover mr-3\"\n                    />\n                  ) : (\n                    <div className=\"w-10 h-10 rounded-full bg-helfi-green flex items-center justify-center mr-3\">\n                      <UserIcon className=\"w-6 h-6 text-white\" aria-hidden=\"true\" />\n                    </div>\n                  )}\n                  <div>\n                    <div className=\"font-semibold text-gray-900 dark:text-white\">{userName}</div>\n                    <div className=\"text-xs text-gray-500 dark:text-gray-400\">{session?.user?.email || 'user@email.com'}</div>\n                  </div>\n                </div>\n                <Link href=\"/profile\" className=\"block px-4 py-2 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-700\">Profile</Link>\n                <Link href=\"/account\" className=\"block px-4 py-2 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-700\">Account Settings</Link>\n                <Link href=\"/profile/image\" className=\"block px-4 py-2 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-700\">Upload/Change Profile Photo</Link>\n                <Link href=\"/billing\" className=\"block px-4 py-2 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-700\">Subscription & Billing</Link>\n                <Link href=\"/notifications\" className=\"block px-4 py-2 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-700\">Notifications</Link>\n                <Link href=\"/privacy\" className=\"block px-4 py-2 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-700\">Privacy Settings</Link>\n                <Link href=\"/help\" className=\"block px-4 py-2 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-700\">Help & Support</Link>\n                <div className=\"border-t border-gray-100 dark:border-gray-700 my-2\"></div>\n                <Link href=\"/reports\" className=\"block px-4 py-2 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-700\">Reports</Link>\n                <button\n                  onClick={() => signOut({ callbackUrl: '/auth/signin' })}\n                  className=\"block w-full text-left px-4 py-2 text-red-600 dark:text-red-400 hover:bg-gray-50 dark:hover:bg-gray-700 font-semibold\"\n                >\n                  Logout\n                </button>\n              </div>\n            )}\n          </div>\n        </div>\n      </nav>\n\n      {/* Main Content - Fixed bottom padding for mobile navigation */}\n      <div className=\"max-w-3xl mx-auto px-4 py-8 pb-24 md:pb-8\">\n        <div className=\"space-y-6\">\n          {/* General Settings */}\n          <div className=\"bg-white dark:bg-gray-800 rounded-lg shadow-sm p-6\">\n            <h2 className=\"text-xl font-bold text-gray-900 dark:text-white mb-6\">General Settings</h2>\n            \n            <div className=\"space-y-4\">\n              <div className=\"flex items-center justify-between\">\n                <div>\n                  <h3 className=\"font-medium text-gray-900 dark:text-white\">Dark Mode</h3>\n                  <p className=\"text-sm text-gray-600 dark:text-gray-400\">Switch to dark theme</p>\n                </div>\n                <label className=\"relative inline-flex items-center cursor-pointer\">\n                  <input \n                    type=\"checkbox\" \n                    className=\"sr-only peer\" \n                    checked={darkMode}\n                                          onChange={(e) => {\n                        setDarkMode(e.target.checked)\n                        trackSettingChange('darkMode', e.target.checked)\n                      }}\n                  />\n                  <div className=\"w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-helfi-green/20 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-helfi-green\"></div>\n                </label>\n              </div>\n\n              {!isIOS && (\n                <div className=\"flex items-center justify-between\">\n                  <div>\n                    <h3 className=\"font-medium text-gray-900 dark:text-white\">Haptic Tap Feedback</h3>\n                    <p className=\"text-sm text-gray-600 dark:text-gray-400\">Light vibration on nav taps (Android supported)</p>\n                  </div>\n                  <label className=\"relative inline-flex items-center cursor-pointer\">\n                    <input \n                      type=\"checkbox\" \n                      className=\"sr-only peer\" \n                      checked={hapticsEnabled}\n                      onChange={(e) => {\n                        setHapticsEnabled(e.target.checked)\n                        trackSettingChange('hapticsEnabled', e.target.checked)\n                      }}\n                    />\n                    <div className=\"w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-helfi-green/20 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-helfi-green\"></div>\n                  </label>\n                </div>\n              )}\n\n              <div className=\"flex items-center justify-between\">\n                <div>\n                  <h3 className=\"font-medium text-gray-900 dark:text-white\">Email Notifications</h3>\n                  <p className=\"text-sm text-gray-600 dark:text-gray-400\">Receive updates via email</p>\n                </div>\n                <label className=\"relative inline-flex items-center cursor-pointer\">\n                  <input \n                    type=\"checkbox\" \n                    className=\"sr-only peer\" \n                    checked={emailNotifications}\n                                            onChange={(e) => {\n                          setEmailNotifications(e.target.checked)\n                          trackSettingChange('emailNotifications', e.target.checked)\n                        }}\n                  />\n                  <div className=\"w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-helfi-green/20 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-helfi-green\"></div>\n                </label>\n              </div>\n              \n              <div className=\"flex items-center justify-between\">\n                <div>\n                  <h3 className=\"font-medium text-gray-900 dark:text-white\">Push Notifications</h3>\n                  <p className=\"text-sm text-gray-600 dark:text-gray-400\">\n                    {isIOS && !isInstalled\n                      ? 'On iPhone: Add to Home Screen, then open the app to enable'\n                      : 'Get daily check‚Äëin reminders on this device'}\n                  </p>\n                </div>\n                <label className={`relative inline-flex items-center ${(isIOS && !isInstalled) ? 'cursor-not-allowed' : 'cursor-pointer'}`}>\n                  <input \n                    type=\"checkbox\" \n                    className=\"sr-only peer\" \n                    checked={pushNotifications}\n                    disabled={isIOS && !isInstalled}\n                    onChange={(e) => handlePushNotificationToggle(e.target.checked)}\n                  />\n                  <div className={`w-11 h-6 ${(isIOS && !isInstalled) ? 'bg-gray-100 dark:bg-gray-600' : 'bg-gray-200'} peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-helfi-green/20 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all ${(isIOS && !isInstalled) ? '' : 'peer-checked:bg-helfi-green'} ${(isIOS && !isInstalled) ? 'opacity-50' : ''}`}></div>\n                </label>\n              </div>\n              {pushNotifications && (\n                <div className=\"flex items-center justify-between\">\n                  <div>\n                    <h4 className=\"font-medium text-gray-900 dark:text-white\">Test Notification</h4>\n                    <p className=\"text-xs text-gray-600 dark:text-gray-400\">Send yourself a test push now</p>\n                  </div>\n                  <button\n                    onClick={async () => {\n                      try {\n                        // Check notification permission first\n                        if (Notification.permission !== 'granted') {\n                          alert('Notifications are not enabled. Please enable them in your browser settings.')\n                          return\n                        }\n                        \n                        const res = await fetch('/api/push/test', { method: 'POST' })\n                        const data = await res.json().catch(() => ({}))\n                        \n                        if (!res.ok) {\n                          const errorMsg = data.error || 'Failed to send notification'\n                          if (errorMsg.includes('No subscription')) {\n                            alert('No push subscription found. Please toggle notifications off and on again to re-register.')\n                          } else if (errorMsg.includes('VAPID')) {\n                            alert('Server configuration error. Please contact support.')\n                          } else {\n                            alert(`Failed: ${errorMsg}`)\n                          }\n                          return\n                        }\n                        \n                        alert('Test notification sent! Check your browser notifications. If you don\\'t see it, check your browser\\'s notification settings.')\n                      } catch (e: any) {\n                        alert(`Error: ${e?.message || 'Could not send test notification. Make sure notifications are enabled.'}`)\n                      }\n                    }}\n                    className=\"px-3 py-1.5 rounded-md bg-helfi-green text-white text-sm font-medium hover:opacity-90\"\n                  >\n                    Send test\n                  </button>\n                </div>\n              )}\n              {pushNotifications && (\n                <div className=\"flex items-center justify-between mt-3\">\n                  <div>\n                    <h4 className=\"font-medium text-gray-900 dark:text-white\">Send reminder now</h4>\n                    <p className=\"text-xs text-gray-600 dark:text-gray-400\">Triggers the same path as the scheduler</p>\n                  </div>\n                  <button\n                    onClick={async () => {\n                      try {\n                        // Check notification permission first\n                        if (Notification.permission !== 'granted') {\n                          alert('Notifications are not enabled. Please enable them in your browser settings.')\n                          return\n                        }\n                        \n                        const res = await fetch('/api/push/send-reminder-now', { method: 'POST' })\n                        const data = await res.json().catch(() => ({}))\n                        \n                        if (!res.ok) {\n                          const errorMsg = data.error || 'Failed to send reminder'\n                          if (errorMsg.includes('No subscription')) {\n                            alert('No push subscription found. Please toggle notifications off and on again to re-register.')\n                          } else {\n                            alert(`Failed: ${errorMsg}`)\n                          }\n                          return\n                        }\n                        \n                        alert('Reminder sent! Check your browser notifications. Clicking it will open the check-in page.')\n                      } catch (e: any) {\n                        alert(`Error: ${e?.message || 'Could not send reminder.'}`)\n                      }\n                    }}\n                    className=\"px-3 py-1.5 rounded-md bg-helfi-green text-white text-sm font-medium hover:opacity-90\"\n                  >\n                    Send\n                  </button>\n                </div>\n              )}\n              {pushNotifications && (\n                <>\n                  {isIOS ? (\n                    <div className=\"mt-3 p-4 bg-gradient-to-br from-blue-50 to-blue-100 dark:from-blue-900/30 dark:to-blue-800/20 rounded-lg border-2 border-blue-300 dark:border-blue-700\">\n                      <div className=\"flex items-center gap-2 mb-3\">\n                        <svg className=\"w-5 h-5 text-blue-600 dark:text-blue-400\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                          <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z\" />\n                        </svg>\n                        <p className=\"text-sm font-bold text-blue-900 dark:text-blue-100\">\n                          Enable Notifications on iPhone\n                        </p>\n                      </div>\n                      \n                      {!isInstalled && (\n                        <div className=\"mb-4 p-3 bg-yellow-50 dark:bg-yellow-900/30 rounded-lg border border-yellow-300 dark:border-yellow-700\">\n                          <p className=\"text-xs font-semibold text-yellow-900 dark:text-yellow-100 mb-2\">\n                            üì± Step 0: Add to Home Screen First\n                          </p>\n                          <p className=\"text-xs text-yellow-800 dark:text-yellow-200 leading-relaxed\">\n                            In Safari, tap the <span className=\"font-bold\">Share button</span> (square with arrow ‚Üë) ‚Üí Select <span className=\"font-bold\">\"Add to Home Screen\"</span> ‚Üí Tap <span className=\"font-bold\">\"Add\"</span>. Then open the Helfi app from your home screen.\n                          </p>\n                        </div>\n                      )}\n\n                      <div className=\"space-y-3 text-sm\">\n                        <div className=\"flex items-start gap-3 p-2 bg-white/60 dark:bg-gray-800/40 rounded\">\n                          <span className=\"flex-shrink-0 w-6 h-6 rounded-full bg-blue-600 text-white text-xs font-bold flex items-center justify-center\">1</span>\n                          <div className=\"flex-1\">\n                            <p className=\"font-semibold text-blue-900 dark:text-blue-100\">Open Settings</p>\n                            <p className=\"text-xs mt-0.5 text-blue-700 dark:text-blue-300\">Tap the <span className=\"font-bold\">Settings</span> app icon on your iPhone home screen</p>\n                          </div>\n                        </div>\n                        \n                        <div className=\"flex items-start gap-3 p-2 bg-white/60 dark:bg-gray-800/40 rounded\">\n                          <span className=\"flex-shrink-0 w-6 h-6 rounded-full bg-blue-600 text-white text-xs font-bold flex items-center justify-center\">2</span>\n                          <div className=\"flex-1\">\n                            <p className=\"font-semibold text-blue-900 dark:text-blue-100\">Go to Notifications</p>\n                            <p className=\"text-xs mt-0.5 text-blue-700 dark:text-blue-300\">Scroll down and tap <span className=\"font-bold\">\"Notifications\"</span></p>\n                          </div>\n                        </div>\n                        \n                        <div className=\"flex items-start gap-3 p-2 bg-white/60 dark:bg-gray-800/40 rounded\">\n                          <span className=\"flex-shrink-0 w-6 h-6 rounded-full bg-blue-600 text-white text-xs font-bold flex items-center justify-center\">3</span>\n                          <div className=\"flex-1\">\n                            <p className=\"font-semibold text-blue-900 dark:text-blue-100\">Find Helfi</p>\n                            <p className=\"text-xs mt-0.5 text-blue-700 dark:text-blue-300\">\n                              {isInstalled \n                                ? <>Look for <span className=\"font-bold\">\"Helfi\"</span> in the alphabetical list and tap it</>\n                                : <>After adding to Home Screen, look for <span className=\"font-bold\">\"Helfi\"</span> in the list and tap it</>}\n                            </p>\n                          </div>\n                        </div>\n                        \n                        <div className=\"flex items-start gap-3 p-2 bg-white/60 dark:bg-gray-800/40 rounded\">\n                          <span className=\"flex-shrink-0 w-6 h-6 rounded-full bg-blue-600 text-white text-xs font-bold flex items-center justify-center\">4</span>\n                          <div className=\"flex-1\">\n                            <p className=\"font-semibold text-blue-900 dark:text-blue-100\">Enable Notifications</p>\n                            <p className=\"text-xs mt-0.5 text-blue-700 dark:text-blue-300\">Toggle <span className=\"font-bold\">\"Allow Notifications\"</span> to ON (green)</p>\n                          </div>\n                        </div>\n                      </div>\n\n                      <div className=\"mt-4 p-3 bg-blue-100 dark:bg-blue-900/40 rounded-lg border border-blue-300 dark:border-blue-700\">\n                        <p className=\"text-xs text-blue-900 dark:text-blue-100 font-medium\">\n                          üí° Tip: Follow the steps above to manually open Settings. iOS doesn't allow apps to open Settings automatically for security reasons.\n                        </p>\n                      </div>\n                    </div>\n                  ) : (\n                    <div className=\"mt-3 p-3 bg-blue-50 dark:bg-blue-900/20 rounded-lg\">\n                      <p className=\"text-xs text-blue-800 dark:text-blue-200\">\n                        <strong>Note:</strong> Notifications may not appear if your browser is in the foreground. Try minimizing the browser window or switching to another app.\n                      </p>\n                    </div>\n                  )}\n                </>\n              )}\n            </div>\n          </div>\n\n          {/* Privacy Settings */}\n          <div className=\"bg-white dark:bg-gray-800 rounded-lg shadow-sm p-6\">\n            <h2 className=\"text-xl font-bold text-gray-900 dark:text-white mb-6\">Privacy Settings</h2>\n            \n            <div className=\"space-y-4\">\n              <div className=\"space-y-2\">\n                <div>\n                  <h3 className=\"font-medium text-gray-900 dark:text-white\">Download my data (PDF)</h3>\n                  <p className=\"text-sm text-gray-600 dark:text-gray-400\">Get a nicely formatted health summary</p>\n                </div>\n                <button\n                  onClick={async () => {\n                    try {\n                      setExporting(true)\n                      const res = await fetch('/api/export/pdf')\n                      if (!res.ok) throw new Error('Export failed')\n                      const blob = await res.blob()\n                      const url = URL.createObjectURL(blob)\n                      setPdfUrl(url)\n                      setShowPdf(true)\n                    } catch (e) {\n                      alert('Could not start export.')\n                    } finally {\n                      setExporting(false)\n                    }\n                  }}\n                  className=\"inline-flex px-3 py-2 rounded-md bg-helfi-green text-white text-sm font-medium hover:opacity-90 disabled:opacity-60\"\n                  disabled={exporting}\n                >\n                  {exporting ? 'Preparing‚Ä¶' : 'Download PDF'}\n                </button>\n                <p className=\"text-xs text-gray-500 dark:text-gray-400\">Opens in a new tab so you can return to the app.</p>\n              </div>\n\n              <div className=\"flex items-center justify-between\">\n                <div>\n                  <h3 className=\"font-medium text-gray-900 dark:text-white\">Profile Visibility</h3>\n                  <p className=\"text-sm text-gray-600 dark:text-gray-400\">Make your profile visible to others</p>\n                </div>\n                <select \n                  className=\"px-3 py-1 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-gray-900 dark:text-white\"\n                  value={profileVisibility}\n                  onChange={(e) => {\n                    setProfileVisibility(e.target.value)\n                    trackSettingChange('profileVisibility', e.target.value)\n                  }}\n                >\n                  <option value=\"private\">Private</option>\n                  <option value=\"public\">Public</option>\n                  <option value=\"friends\">Friends Only</option>\n                </select>\n              </div>\n              \n              <div className=\"flex items-center justify-between\">\n                <div>\n                  <h3 className=\"font-medium text-gray-900 dark:text-white\">Data Analytics</h3>\n                  <p className=\"text-sm text-gray-600 dark:text-gray-400\">Help us improve by sharing anonymous usage data</p>\n                </div>\n                <label className=\"relative inline-flex items-center cursor-pointer\">\n                  <input \n                    type=\"checkbox\" \n                    className=\"sr-only peer\" \n                    checked={dataAnalytics}\n                    onChange={(e) => {\n                      setDataAnalytics(e.target.checked)\n                      trackSettingChange('dataAnalytics', e.target.checked)\n                    }}\n                  />\n                  <div className=\"w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-helfi-green/20 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-helfi-green\"></div>\n                </label>\n              </div>\n            </div>\n          </div>\n\n          {/* Account Actions */}\n          <div className=\"bg-white dark:bg-gray-800 rounded-lg shadow-sm p-6\">\n            <h2 className=\"text-xl font-bold text-gray-900 dark:text-white mb-6\">Account Actions</h2>\n            \n            <div className=\"space-y-4\">\n              <Link href=\"/account\" className=\"flex items-center p-3 border border-gray-200 dark:border-gray-700 rounded-lg hover:border-helfi-green transition-colors\">\n                <div className=\"flex-1\">\n                  <h3 className=\"font-medium text-gray-900 dark:text-white\">Account Settings</h3>\n                  <p className=\"text-sm text-gray-600 dark:text-gray-400\">Manage your account information</p>\n                </div>\n                <svg className=\"w-5 h-5 text-gray-400\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M9 5l7 7-7 7\" />\n                </svg>\n              </Link>\n              \n              <Link href=\"/billing\" className=\"flex items-center p-3 border border-gray-200 dark:border-gray-700 rounded-lg hover:border-helfi-green transition-colors\">\n                <div className=\"flex-1\">\n                  <h3 className=\"font-medium text-gray-900 dark:text-white\">Subscription & Billing</h3>\n                  <p className=\"text-sm text-gray-600 dark:text-gray-400\">Manage your subscription</p>\n                </div>\n                <svg className=\"w-5 h-5 text-gray-400\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M9 5l7 7-7 7\" />\n                </svg>\n              </Link>\n              \n              <Link href=\"/help\" className=\"flex items-center p-3 border border-gray-200 dark:border-gray-700 rounded-lg hover:border-helfi-green transition-colors\">\n                <div className=\"flex-1\">\n                  <h3 className=\"font-medium text-gray-900 dark:text-white\">Help & Support</h3>\n                  <p className=\"text-sm text-gray-600 dark:text-gray-400\">Get help and contact support</p>\n                </div>\n                <svg className=\"w-5 h-5 text-gray-400\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M9 5l7 7-7 7\" />\n                </svg>\n              </Link>\n            </div>\n          </div>\n\n\n        </div>\n\n        {/* Reminder Times */}\n        <div className=\"bg-white dark:bg-gray-800 rounded-lg shadow-sm p-6\">\n          <div className=\"flex items-center justify-between mb-6\">\n            <h2 className=\"text-xl font-bold text-gray-900 dark:text-white\">Reminder Times</h2>\n            <Link href=\"/check-in\" className=\"text-sm text-helfi-green hover:underline font-medium\">\n              Go to Check-In ‚Üí\n            </Link>\n          </div>\n          <p className=\"text-sm text-gray-600 dark:text-gray-400 mb-4\">\n            Set up to 3 daily reminders. You can check in multiple times per day to track your health throughout the day.\n          </p>\n          \n          {loadingSettings ? (\n            <div className=\"flex items-center justify-center py-4\">\n              <div className=\"animate-spin rounded-full h-6 w-6 border-b-2 border-helfi-green\"></div>\n            </div>\n          ) : (\n            <>\n              <div className=\"space-y-4 mb-4\">\n                <div>\n                  <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2\">\n                    Number of reminders per day\n                  </label>\n                  <select\n                    value={frequency}\n                    onChange={(e) => setFrequency(parseInt(e.target.value, 10))}\n                    className=\"w-full border border-gray-300 dark:border-gray-600 rounded-lg px-3 py-2 bg-white dark:bg-gray-700 text-gray-900 dark:text-white\"\n                  >\n                    <option value={1}>1 reminder</option>\n                    <option value={2}>2 reminders</option>\n                    <option value={3}>3 reminders</option>\n                  </select>\n                </div>\n\n                {frequency >= 1 && (\n                  <div>\n                    <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1\">\n                      Reminder 1\n                    </label>\n                    <input\n                      type=\"time\"\n                      value={time1}\n                      onChange={(e) => setTime1(e.target.value)}\n                      className=\"w-full border border-gray-300 dark:border-gray-600 rounded-lg px-3 py-2 bg-white dark:bg-gray-700 text-gray-900 dark:text-white\"\n                    />\n                  </div>\n                )}\n\n                {frequency >= 2 && (\n                  <div>\n                    <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1\">\n                      Reminder 2\n                    </label>\n                    <input\n                      type=\"time\"\n                      value={time2}\n                      onChange={(e) => setTime2(e.target.value)}\n                      className=\"w-full border border-gray-300 dark:border-gray-600 rounded-lg px-3 py-2 bg-white dark:bg-gray-700 text-gray-900 dark:text-white\"\n                    />\n                  </div>\n                )}\n\n                {frequency >= 3 && (\n                  <div>\n                    <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1\">\n                      Reminder 3\n                    </label>\n                    <input\n                      type=\"time\"\n                      value={time3}\n                      onChange={(e) => setTime3(e.target.value)}\n                      className=\"w-full border border-gray-300 dark:border-gray-600 rounded-lg px-3 py-2 bg-white dark:bg-gray-700 text-gray-900 dark:text-white\"\n                    />\n                  </div>\n                )}\n\n                <div>\n                  <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1\">\n                    Timezone\n                  </label>\n                  <select\n                    value={tz}\n                    onChange={(e) => setTz(e.target.value)}\n                    className=\"w-full border border-gray-300 dark:border-gray-600 rounded-lg px-3 py-2 bg-white dark:bg-gray-700 text-gray-900 dark:text-white\"\n                  >\n                    {baseTimezones.map((tzOption) => (\n                      <option key={tzOption} value={tzOption}>\n                        {tzOption}\n                      </option>\n                    ))}\n                  </select>\n                </div>\n              </div>\n\n              <button\n                onClick={async () => {\n                  setSavingTimes(true)\n                  try {\n                    const res = await fetch('/api/checkins/settings', {\n                      method: 'POST',\n                      headers: { 'Content-Type': 'application/json' },\n                      body: JSON.stringify({ time1, time2, time3, timezone: tz, frequency })\n                    })\n                    if (res.ok) {\n                      alert('Reminder times saved successfully!')\n                    } else {\n                      const data = await res.json().catch(() => ({}))\n                      alert(`Failed to save: ${data.error || 'Unknown error'}`)\n                    }\n                  } catch (e) {\n                    alert('Failed to save reminder times. Please try again.')\n                  } finally {\n                    setSavingTimes(false)\n                  }\n                }}\n                disabled={savingTimes}\n                className=\"w-full bg-helfi-green text-white px-4 py-2 rounded-lg hover:bg-helfi-green/90 disabled:opacity-60 disabled:cursor-not-allowed font-medium\"\n              >\n                {savingTimes ? 'Saving...' : 'Save Reminder Times'}\n              </button>\n            </>\n          )}\n        </div>\n      </div>\n\n      {/* Mobile Bottom Navigation - with pressed, ripple and active states */}\n      <nav className=\"md:hidden fixed bottom-0 left-0 right-0 bg-white dark:bg-gray-800 border-t border-gray-200 dark:border-gray-700 px-4 py-2 z-40\">\n        <div className=\"flex items-center justify-around\">\n          \n          {/* Dashboard */}\n          <Link href=\"/dashboard\" className=\"pressable ripple flex flex-col items-center py-2 px-1 min-w-0 flex-1\" onClick={() => { try { const reduced = window.matchMedia('(prefers-reduced-motion: reduce)')?.matches; const pref = localStorage.getItem('hapticsEnabled'); const enabled = pref === null ? true : pref === 'true'; if (enabled && !reduced && 'vibrate' in navigator) navigator.vibrate(10) } catch {} }}>\n            <div className={`icon ${pathname === '/dashboard' ? 'text-helfi-green' : 'text-gray-400'}`}>\n              <svg className=\"w-6 h-6\" fill=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path d=\"M3 13h8V3H3v10zm0 8h8v-6H3v6zm10 0h8V11h-8v10zm0-18v6h8V3h-8z\"/>\n              </svg>\n            </div>\n            <span className={`label text-xs mt-1 truncate ${pathname === '/dashboard' ? 'text-helfi-green font-bold' : 'text-gray-400 font-medium'}`}>Dashboard</span>\n          </Link>\n\n          {/* Insights */}\n          <Link href=\"/insights\" className=\"pressable ripple flex flex-col items-center py-2 px-1 min-w-0 flex-1\" onClick={() => { try { const reduced = window.matchMedia('(prefers-reduced-motion: reduce)')?.matches; const pref = localStorage.getItem('hapticsEnabled'); const enabled = pref === null ? true : pref === 'true'; if (enabled && !reduced && 'vibrate' in navigator) navigator.vibrate(10) } catch {} }}>\n            <div className={`icon ${pathname === '/insights' ? 'text-helfi-green' : 'text-gray-400'}`}>\n              <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z\" />\n              </svg>\n            </div>\n            <span className={`label text-xs mt-1 truncate ${pathname === '/insights' ? 'text-helfi-green font-bold' : 'text-gray-400 font-medium'}`}>Insights</span>\n          </Link>\n\n          {/* Food */}\n          <Link href=\"/food\" className=\"pressable ripple flex flex-col items-center py-2 px-1 min-w-0 flex-1\" onClick={() => { try { const reduced = window.matchMedia('(prefers-reduced-motion: reduce)')?.matches; const pref = localStorage.getItem('hapticsEnabled'); const enabled = pref === null ? true : pref === 'true'; if (enabled && !reduced && 'vibrate' in navigator) navigator.vibrate(10) } catch {} }}>\n            <div className={`icon ${pathname === '/food' ? 'text-helfi-green' : 'text-gray-400'}`}>\n              <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10\" />\n              </svg>\n            </div>\n            <span className={`label text-xs mt-1 truncate ${pathname === '/food' ? 'text-helfi-green font-bold' : 'text-gray-400 font-medium'}`}>Food</span>\n          </Link>\n\n          {/* Intake (Onboarding) */}\n          <MobileMoreMenu />\n\n          {/* Settings (Active) */}\n          <Link href=\"/settings\" className=\"pressable ripple flex flex-col items-center py-2 px-1 min-w-0 flex-1\" onClick={() => { try { const reduced = window.matchMedia('(prefers-reduced-motion: reduce)')?.matches; const pref = localStorage.getItem('hapticsEnabled'); const enabled = pref === null ? true : pref === 'true'; if (enabled && !reduced && 'vibrate' in navigator) navigator.vibrate(10) } catch {} }}>\n            <div className={`icon ${pathname === '/settings' ? 'text-helfi-green' : 'text-gray-400'}`}>\n              <Cog6ToothIcon className=\"w-6 h-6 flex-shrink-0\" style={{ minWidth: '24px', minHeight: '24px' }} />\n            </div>\n            <span className={`label text-xs mt-1 truncate ${pathname === '/settings' ? 'text-helfi-green font-bold' : 'text-gray-400 font-medium'}`}>Settings</span>\n          </Link>\n\n        </div>\n      </nav>\n\n      {/* In-app PDF viewer with back button (mobile safe) */}\n      {showPdf && (\n        <div className=\"fixed inset-0 bg-white z-[999] flex flex-col\">\n          <div className=\"p-3 border-b flex items-center justify-between\">\n            <button onClick={()=>{ setShowPdf(false); if (pdfUrl) { URL.revokeObjectURL(pdfUrl); setPdfUrl('') } }} className=\"px-3 py-2 rounded-md bg-gray-200 text-gray-800 text-sm font-medium\">Back</button>\n            <a href={pdfUrl} download=\"helfi-health-summary.pdf\" className=\"px-3 py-2 rounded-md bg-helfi-green text-white text-sm font-medium\">Download</a>\n          </div>\n          <div className=\"flex-1 overflow-hidden\">\n            <iframe src={pdfUrl} className=\"w-full h-full\" title=\"Helfi PDF\" />\n          </div>\n        </div>\n      )}\n    </div>\n  )\n} ","truncated":false,"size":54143},{"path":"app/support/page.tsx","content":"'use client'\n\nimport React, { useState, useEffect, useCallback, useRef } from 'react'\nimport { useSession } from 'next-auth/react'\nimport Image from 'next/image'\nimport Link from 'next/link'\n\ntype SupportAttachment = {\n  id?: string\n  name: string\n  url: string\n  type?: string\n  size?: number\n}\n\nconst SUPPORT_AGENT_NAME = 'Maya'\nconst SUPPORT_AGENT_ROLE = 'Helfi Support'\nconst SUPPORT_AGENT_AVATAR = '/support/maya.jpg'\nconst ATTACHMENTS_MARKER = '[[ATTACHMENTS]]'\n\nexport default function SupportPage() {\n  const { data: session } = useSession()\n  const [isSubmitting, setIsSubmitting] = useState(false)\n  const [submitStatus, setSubmitStatus] = useState<'idle' | 'success' | 'error'>('idle')\n  const [activeTicket, setActiveTicket] = useState<any | null>(null)\n  const [isLoadingTicket, setIsLoadingTicket] = useState(false)\n  const [chatMessage, setChatMessage] = useState('')\n  const [isSendingChat, setIsSendingChat] = useState(false)\n  const [chatAttachments, setChatAttachments] = useState<SupportAttachment[]>([])\n  const [formAttachments, setFormAttachments] = useState<SupportAttachment[]>([])\n  const [isUploadingChatAttachment, setIsUploadingChatAttachment] = useState(false)\n  const [isUploadingFormAttachment, setIsUploadingFormAttachment] = useState(false)\n  const [attachmentError, setAttachmentError] = useState('')\n  const [feedbackRating, setFeedbackRating] = useState(0)\n  const [feedbackComment, setFeedbackComment] = useState('')\n  const [isSubmittingFeedback, setIsSubmittingFeedback] = useState(false)\n  const [feedbackSubmitted, setFeedbackSubmitted] = useState(false)\n  const [showChatComposer, setShowChatComposer] = useState(false)\n  const [optimisticMessages, setOptimisticMessages] = useState<Array<{\n    id: string\n    message: string\n    attachments: SupportAttachment[]\n    isAdminResponse: boolean\n    createdAt: string\n  }>>([])\n  const chatEndRef = useRef<HTMLDivElement | null>(null)\n  \n  const [formData, setFormData] = useState({\n    name: '',\n    email: session?.user?.email || '',\n    inquiryType: '',\n    registeredEmail: '',\n    subject: '',\n    message: '',\n    isRegisteredUser: false\n  })\n\n  // Update email when session loads\n  useEffect(() => {\n    if (session?.user?.email) {\n      setFormData(prev => ({\n        ...prev,\n        email: session.user?.email || '',\n        name: session.user?.name || '',\n        isRegisteredUser: true\n      }))\n    }\n  }, [session])\n\n  const loadActiveTicket = useCallback(async () => {\n    if (!session?.user?.email) return\n    setIsLoadingTicket(true)\n    try {\n      const response = await fetch('/api/support/tickets?activeOnly=1')\n      if (response.ok) {\n        const result = await response.json()\n        const clearedTicketId = typeof window !== 'undefined' ? window.localStorage.getItem('helfi:support:cleared-ticket') || '' : ''\n        const isClearedClosed =\n          clearedTicketId &&\n          result.ticket?.id === clearedTicketId &&\n          ['RESOLVED', 'CLOSED'].includes(result.ticket?.status)\n        setActiveTicket(isClearedClosed ? null : (result.ticket || null))\n        setFeedbackSubmitted(Boolean(result.ticket?.responses?.some((res: any) => String(res.message || '').startsWith('[FEEDBACK]'))))\n      }\n    } catch (error) {\n      console.error('Error loading support ticket:', error)\n    }\n    setIsLoadingTicket(false)\n  }, [session?.user?.email])\n\n  useEffect(() => {\n    if (session?.user?.email) {\n      loadActiveTicket()\n    }\n  }, [session, loadActiveTicket])\n\n  useEffect(() => {\n    if (typeof window === 'undefined') return\n    if (activeTicket && session?.user?.email) {\n      window.localStorage.setItem('helfi:support:widget:open', 'true')\n    }\n  }, [activeTicket, session?.user?.email])\n\n  useEffect(() => {\n    if (!activeTicket) return\n    const timer = window.setTimeout(() => {\n      chatEndRef.current?.scrollIntoView({ behavior: 'smooth', block: 'end' })\n    }, 0)\n    return () => window.clearTimeout(timer)\n  }, [activeTicket?.id, activeTicket?.responses?.length, optimisticMessages.length])\n\n  const splitMessageAttachments = (message: string) => {\n    const markerIndex = message.indexOf(ATTACHMENTS_MARKER)\n    if (markerIndex === -1) {\n      return { text: message, attachments: [] as SupportAttachment[] }\n    }\n    const text = message.slice(0, markerIndex).trim()\n    const raw = message.slice(markerIndex + ATTACHMENTS_MARKER.length).trim()\n    if (!raw) {\n      return { text, attachments: [] as SupportAttachment[] }\n    }\n    try {\n      const parsed = JSON.parse(raw)\n      const attachments = Array.isArray(parsed)\n        ? parsed\n            .map((item) => ({\n              id: item?.id ? String(item.id) : undefined,\n              name: String(item?.name || ''),\n              url: String(item?.url || ''),\n              type: item?.type ? String(item.type) : undefined,\n              size: typeof item?.size === 'number' ? item.size : undefined\n            }))\n            .filter((item) => item.name && item.url)\n        : []\n      return { text, attachments }\n    } catch {\n      return { text: message, attachments: [] as SupportAttachment[] }\n    }\n  }\n\n  const serializeMessageWithAttachments = (text: string, attachments: SupportAttachment[]) => {\n    if (!attachments.length) return text\n    const payload = attachments.map((att) => ({\n      id: att.id,\n      name: att.name,\n      url: att.url,\n      type: att.type,\n      size: att.size\n    }))\n    return `${text}\\n\\n${ATTACHMENTS_MARKER}\\n${JSON.stringify(payload)}`\n  }\n\n  const uploadSupportFile = async (file: File) => {\n    const formData = new FormData()\n    formData.append('file', file)\n    const response = await fetch('/api/support/uploads', {\n      method: 'POST',\n      body: formData\n    })\n    if (!response.ok) {\n      const error = await response.json().catch(() => ({}))\n      throw new Error(error?.error || 'Upload failed')\n    }\n    return response.json()\n  }\n\n  const handleUploadFiles = async (\n    files: File[],\n    setAttachments: React.Dispatch<React.SetStateAction<SupportAttachment[]>>,\n    setUploading: React.Dispatch<React.SetStateAction<boolean>>\n  ) => {\n    if (!files.length) return\n    setAttachmentError('')\n    setUploading(true)\n    try {\n      const uploads = await Promise.all(\n        files.map(async (file) => {\n          const result = await uploadSupportFile(file)\n          return {\n            id: result.fileId,\n            name: result.name,\n            url: result.url,\n            type: result.type,\n            size: result.size\n          } as SupportAttachment\n        })\n      )\n      setAttachments((prev) => [...prev, ...uploads])\n    } catch (error: any) {\n      setAttachmentError(error?.message || 'Failed to upload file')\n    } finally {\n      setUploading(false)\n    }\n  }\n\n  const handlePasteUpload = async (\n    event: React.ClipboardEvent<HTMLTextAreaElement>,\n    setAttachments: React.Dispatch<React.SetStateAction<SupportAttachment[]>>,\n    setUploading: React.Dispatch<React.SetStateAction<boolean>>\n  ) => {\n    const items = Array.from(event.clipboardData?.items || [])\n    const imageFiles: File[] = []\n    for (const item of items) {\n      if (item.kind === 'file' && item.type.startsWith('image/')) {\n        const file = item.getAsFile()\n        if (file) imageFiles.push(file)\n      }\n    }\n    if (imageFiles.length > 0) {\n      await handleUploadFiles(imageFiles, setAttachments, setUploading)\n    }\n  }\n\n  const inquiryTypes = [\n    { value: 'account', label: 'Account/Login Issue' },\n    { value: 'billing', label: 'Billing Question' },\n    { value: 'technical', label: 'Technical Support' },\n    { value: 'general', label: 'General Inquiry' },\n    { value: 'feedback', label: 'Feedback / Suggestion' }\n  ]\n\n  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {\n    const { name, value, type } = e.target\n    const checked = type === 'checkbox' ? (e.target as HTMLInputElement).checked : false\n    \n    setFormData(prev => ({\n      ...prev,\n      [name]: type === 'checkbox' ? checked : value\n    }))\n  }\n\n  const handleSubmit = async (e: React.FormEvent) => {\n    e.preventDefault()\n    setIsSubmitting(true)\n    setSubmitStatus('idle')\n\n    try {\n      const messageWithAttachments = serializeMessageWithAttachments(formData.message, formAttachments)\n      const endpoint = session ? '/api/support/tickets' : '/api/admin/tickets'\n      const payload = session\n        ? {\n            action: 'create',\n            subject: formData.subject || `${formData.inquiryType} - ${inquiryTypes.find(t => t.value === formData.inquiryType)?.label}`,\n            message: messageWithAttachments,\n            category: formData.inquiryType.toUpperCase(),\n            priority: formData.inquiryType === 'account' || formData.inquiryType === 'billing' ? 'HIGH' : 'MEDIUM'\n          }\n        : {\n            action: 'create',\n            subject: formData.subject || `${formData.inquiryType} - ${inquiryTypes.find(t => t.value === formData.inquiryType)?.label}`,\n            message: messageWithAttachments,\n            userEmail: formData.inquiryType === 'account' ? formData.registeredEmail : formData.email,\n            userName: formData.name,\n            category: formData.inquiryType.toUpperCase(),\n            priority: formData.inquiryType === 'account' || formData.inquiryType === 'billing' ? 'HIGH' : 'MEDIUM'\n          }\n\n      // Create support ticket via API\n      const response = await fetch(endpoint, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(payload)\n      })\n\n      if (response.ok) {\n        setSubmitStatus('success')\n        if (session) {\n          await loadActiveTicket()\n        }\n        setFormAttachments([])\n        // Reset form\n        setFormData({\n          name: session?.user?.name || '',\n          email: session?.user?.email || '',\n          inquiryType: '',\n          registeredEmail: '',\n          subject: '',\n          message: '',\n          isRegisteredUser: !!session\n        })\n      } else {\n        setSubmitStatus('error')\n      }\n    } catch (error) {\n      console.error('Error submitting support ticket:', error)\n      setSubmitStatus('error')\n    }\n\n    setIsSubmitting(false)\n  }\n\n  const sendChatMessage = async () => {\n    if (!chatMessage.trim() && chatAttachments.length === 0) return\n    if (isChatClosed) return\n    const trimmedMessage = chatMessage.trim()\n    const outgoingAttachments = chatAttachments\n    const optimisticId = `local-${Date.now()}-${Math.random().toString(16).slice(2)}`\n    setOptimisticMessages((prev) => [\n      ...prev,\n      {\n        id: optimisticId,\n        message: trimmedMessage,\n        attachments: outgoingAttachments,\n        isAdminResponse: false,\n        createdAt: new Date().toISOString()\n      }\n    ])\n    setChatMessage('')\n    setChatAttachments([])\n    setIsSendingChat(true)\n    try {\n      const messageWithAttachments = serializeMessageWithAttachments(trimmedMessage, outgoingAttachments)\n      const payload = activeTicket\n        ? { action: 'add_response', ticketId: activeTicket.id, message: messageWithAttachments }\n        : { action: 'create', subject: 'Support chat', message: messageWithAttachments, category: 'TECHNICAL', priority: 'MEDIUM' }\n      const response = await fetch('/api/support/tickets', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(payload)\n      })\n\n      if (response.ok) {\n        const result = await response.json()\n        setActiveTicket(result.ticket || null)\n        if (result.ticket) {\n          setShowChatComposer(true)\n        }\n        setOptimisticMessages((prev) => prev.filter((item) => item.id !== optimisticId))\n      }\n      if (!response.ok) {\n        setOptimisticMessages((prev) => prev.filter((item) => item.id !== optimisticId))\n      }\n    } catch (error) {\n      console.error('Error sending support message:', error)\n      setOptimisticMessages((prev) => prev.filter((item) => item.id !== optimisticId))\n    }\n    setIsSendingChat(false)\n  }\n\n  const handleChatKeyDown = (event: React.KeyboardEvent<HTMLTextAreaElement>) => {\n    if (event.key !== 'Enter' || event.shiftKey || event.nativeEvent.isComposing) return\n    event.preventDefault()\n    if (!isChatClosed && !isSendingChat) {\n      sendChatMessage()\n    }\n  }\n\n  const startNewTicket = () => {\n    setActiveTicket(null)\n    setSubmitStatus('idle')\n    setChatAttachments([])\n    setFormAttachments([])\n    setOptimisticMessages([])\n    setFeedbackRating(0)\n    setFeedbackComment('')\n    setFeedbackSubmitted(false)\n    setAttachmentError('')\n    setShowChatComposer(true)\n    if (typeof window !== 'undefined') {\n      window.localStorage.removeItem('helfi:support:cleared-ticket')\n    }\n  }\n\n  const clearChat = () => {\n    if (typeof window !== 'undefined' && activeTicket?.id) {\n      window.localStorage.setItem('helfi:support:cleared-ticket', activeTicket.id)\n    }\n    setActiveTicket(null)\n    setChatMessage('')\n    setChatAttachments([])\n    setOptimisticMessages([])\n    setFeedbackRating(0)\n    setFeedbackComment('')\n    setFeedbackSubmitted(false)\n    setShowChatComposer(false)\n  }\n\n  const endChat = async () => {\n    if (!activeTicket) return\n    setIsSendingChat(true)\n    try {\n      const response = await fetch('/api/support/tickets', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          action: 'end_chat',\n          ticketId: activeTicket.id\n        })\n      })\n      if (response.ok) {\n        const result = await response.json()\n        setActiveTicket(result.ticket || null)\n      }\n    } catch (error) {\n      console.error('Error ending support chat:', error)\n    }\n    setIsSendingChat(false)\n  }\n\n  const submitFeedback = async () => {\n    if (!activeTicket || feedbackRating < 1) return\n    setIsSubmittingFeedback(true)\n    try {\n      const response = await fetch('/api/support/tickets', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          action: 'submit_feedback',\n          ticketId: activeTicket.id,\n          rating: feedbackRating,\n          comment: feedbackComment.trim()\n        })\n      })\n      if (response.ok) {\n        const result = await response.json()\n        setActiveTicket(result.ticket || null)\n        setFeedbackSubmitted(true)\n      }\n    } catch (error) {\n      console.error('Error submitting feedback:', error)\n    }\n    setIsSubmittingFeedback(false)\n  }\n\n  const shouldShowRegisteredEmail = formData.inquiryType === 'account' && !session\n  const isChatClosed = activeTicket && ['RESOLVED', 'CLOSED'].includes(activeTicket.status)\n  const hasFeedback = feedbackSubmitted || Boolean(activeTicket?.responses?.some((res: any) => String(res.message || '').startsWith('[FEEDBACK]')))\n  const conversationItems = activeTicket\n    ? [\n        (() => {\n          const parsed = splitMessageAttachments(String(activeTicket.message || ''))\n          return {\n            id: `ticket-${activeTicket.id}`,\n            message: parsed.text,\n            attachments: parsed.attachments,\n            isAdminResponse: false,\n            createdAt: activeTicket.createdAt\n          }\n        })(),\n        ...(activeTicket.responses || [])\n          .filter((response: any) => {\n            const msg = String(response.message || '')\n            return !msg.startsWith('[SYSTEM]') && !msg.startsWith('[FEEDBACK]')\n          })\n          .map((response: any) => {\n            const parsed = splitMessageAttachments(String(response.message || ''))\n            return {\n              id: response.id,\n              message: parsed.text,\n              attachments: parsed.attachments,\n              isAdminResponse: response.isAdminResponse,\n              createdAt: response.createdAt\n            }\n          })\n      ]\n    : []\n  const combinedConversationItems = [...conversationItems, ...optimisticMessages]\n\n  return (\n    <div className=\"min-h-screen bg-gray-50\">\n      {/* Navigation Header */}\n      <nav className=\"bg-white border-b border-gray-200 px-4 py-3\">\n        <div className=\"max-w-7xl mx-auto flex justify-between items-center\">\n          {/* Logo on the left */}\n          <div className=\"flex items-center\">\n            <Link href=\"/\" className=\"w-16 h-16 md:w-20 md:h-20 cursor-pointer hover:opacity-80 transition-opacity\">\n              <Image\n                src=\"/mobile-assets/LOGOS/helfi-01-01.png\"\n                alt=\"Helfi Logo\"\n                width={80}\n                height={80}\n                className=\"w-full h-full object-contain\"\n                priority\n              />\n            </Link>\n          </div>\n          \n          {/* Navigation Links */}\n          <div className=\"flex items-center space-x-4\">\n            {session ? (\n              <Link \n                href=\"/dashboard\" \n                className=\"bg-helfi-green text-white px-4 py-2 rounded-lg hover:bg-helfi-green/90 transition-colors font-medium\"\n              >\n                Back to Dashboard\n              </Link>\n            ) : (\n              <Link \n                href=\"/\" \n                className=\"bg-helfi-green text-white px-4 py-2 rounded-lg hover:bg-helfi-green/90 transition-colors font-medium\"\n              >\n                Back to Home\n              </Link>\n            )}\n          </div>\n        </div>\n      </nav>\n\n      {/* Page Title */}\n      <div className=\"bg-white border-b border-gray-200 px-4 py-4\">\n        <div className=\"max-w-7xl mx-auto text-center\">\n          <h1 className=\"text-lg md:text-xl font-semibold text-gray-900\">Get Support</h1>\n          <p className=\"text-sm text-gray-500 hidden sm:block\">We're here to help you with any questions or issues</p>\n        </div>\n      </div>\n\n      {/* Main Content */}\n      <div className=\"max-w-6xl mx-auto px-6 md:px-10 py-8\">\n        {session && !activeTicket && !showChatComposer && (\n          <div className=\"mb-6 flex flex-col gap-4 md:flex-row md:items-center md:justify-between\">\n            <div>\n              <h2 className=\"text-xl font-semibold text-gray-900\">Need help right now?</h2>\n              <p className=\"text-sm text-gray-600\">Start a support chat and we‚Äôll assist you straight away.</p>\n            </div>\n            <button\n              type=\"button\"\n              onClick={() => setShowChatComposer(true)}\n              className=\"inline-flex items-center justify-center px-5 py-2 bg-helfi-green text-white rounded-lg hover:bg-helfi-green/90 transition-colors\"\n            >\n              Start support chat\n            </button>\n          </div>\n        )}\n\n        {session && (activeTicket || showChatComposer) && (\n          <div className=\"mb-10\">\n            <div className=\"text-center mb-6\">\n              <h2 className=\"text-2xl font-bold text-gray-900 mb-2\">Support Chat</h2>\n              <p className=\"text-gray-600\">Chat with our support assistant. Replies appear here right away.</p>\n              <div className=\"mt-4 flex items-center justify-center gap-3 text-sm text-gray-600\">\n                <Image\n                  src={SUPPORT_AGENT_AVATAR}\n                  alt={`${SUPPORT_AGENT_NAME} avatar`}\n                  width={36}\n                  height={36}\n                  className=\"rounded-full object-cover\"\n                />\n                <span>{SUPPORT_AGENT_NAME} from {SUPPORT_AGENT_ROLE}</span>\n              </div>\n            </div>\n\n            {isLoadingTicket && (\n              <div className=\"text-center text-sm text-gray-500\">Loading your conversation...</div>\n            )}\n\n            {!isLoadingTicket && (\n              <div className=\"space-y-4\">\n                {isChatClosed && (\n                  <div className=\"text-sm text-amber-700 bg-amber-50 border border-amber-200 rounded-lg p-3\">\n                    This chat is closed. If you need more help, start a new ticket below.\n                  </div>\n                )}\n                {combinedConversationItems.length === 0 && (\n                  <div className=\"text-sm text-gray-500 text-center\">No messages yet.</div>\n                )}\n                {combinedConversationItems.map((item) => (\n                  <div\n                    key={item.id}\n                    className={`rounded-lg p-4 ${item.isAdminResponse ? 'bg-emerald-50 border-l-4 border-emerald-500' : 'bg-gray-50 border-l-4 border-gray-300'}`}\n                  >\n                    <div className=\"flex items-center justify-between mb-2 text-xs text-gray-500\">\n                      <span className=\"flex items-center gap-2\">\n                        {item.isAdminResponse ? (\n                          <>\n                            <Image\n                              src={SUPPORT_AGENT_AVATAR}\n                              alt={`${SUPPORT_AGENT_NAME} avatar`}\n                              width={20}\n                              height={20}\n                              className=\"rounded-full object-cover\"\n                            />\n                            {SUPPORT_AGENT_NAME}\n                          </>\n                        ) : (\n                          'You'\n                        )}\n                      </span>\n                      <span>{item.createdAt ? new Date(item.createdAt).toLocaleString() : ''}</span>\n                    </div>\n                    <p className=\"text-gray-700 whitespace-pre-wrap\">{item.message}</p>\n                    {item.attachments?.length > 0 && (\n                      <div className=\"mt-3 grid grid-cols-1 sm:grid-cols-2 gap-3\">\n                        {item.attachments.map((att: SupportAttachment) => (\n                          <a\n                            key={`${item.id}-${att.url}`}\n                            href={att.url}\n                            target=\"_blank\"\n                            rel=\"noreferrer\"\n                            className=\"border border-gray-200 rounded-lg p-2 bg-white hover:bg-gray-50 transition-colors\"\n                          >\n                            {att.type?.startsWith('image/') ? (\n                              <div className=\"space-y-2\">\n                                <div className=\"relative w-full h-32\">\n                                  <Image\n                                    src={att.url}\n                                    alt={att.name}\n                                    fill\n                                    className=\"object-cover rounded-md\"\n                                  />\n                                </div>\n                                <div className=\"text-xs text-gray-600 truncate\">{att.name}</div>\n                              </div>\n                            ) : (\n                              <div className=\"text-sm text-gray-700\">\n                                <div className=\"font-medium\">{att.name}</div>\n                                <div className=\"text-xs text-gray-500\">{att.type || 'Document'}</div>\n                              </div>\n                            )}\n                          </a>\n                        ))}\n                      </div>\n                    )}\n                  </div>\n                ))}\n                <div ref={chatEndRef} />\n              </div>\n            )}\n\n            <div className=\"mt-6\">\n              <label htmlFor=\"chatMessage\" className=\"block text-sm font-medium text-gray-700 mb-2\">\n                Send a message\n              </label>\n              <textarea\n                id=\"chatMessage\"\n                name=\"chatMessage\"\n                rows={4}\n                value={chatMessage}\n                onChange={(e) => setChatMessage(e.target.value)}\n                onPaste={(e) => handlePasteUpload(e, setChatAttachments, setIsUploadingChatAttachment)}\n                onKeyDown={handleChatKeyDown}\n                className=\"w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-helfi-green focus:border-helfi-green\"\n                placeholder=\"Describe the issue or add more details...\"\n                disabled={isChatClosed}\n              />\n              {attachmentError && (\n                <p className=\"mt-2 text-sm text-red-600\">{attachmentError}</p>\n              )}\n              {chatAttachments.length > 0 && (\n                <div className=\"mt-3 flex flex-wrap gap-2\">\n                  {chatAttachments.map((att) => (\n                    <div key={att.url} className=\"flex items-center gap-2 bg-gray-100 px-3 py-1 rounded-full text-xs\">\n                      <span className=\"truncate max-w-[160px]\">{att.name}</span>\n                      <button\n                        type=\"button\"\n                        onClick={() => setChatAttachments((prev) => prev.filter((item) => item.url !== att.url))}\n                        className=\"text-gray-500 hover:text-gray-700\"\n                        aria-label={`Remove ${att.name}`}\n                      >\n                        ‚úï\n                      </button>\n                    </div>\n                  ))}\n                </div>\n              )}\n              <div className=\"flex items-center justify-between mt-4\">\n                <div className=\"flex items-center gap-2\">\n                  <label className={`px-3 py-2 border border-gray-300 text-gray-700 rounded-lg hover:bg-gray-50 transition-colors cursor-pointer ${isChatClosed ? 'opacity-50 pointer-events-none' : ''}`}>\n                    Attach files\n                    <input\n                      type=\"file\"\n                      multiple\n                      accept=\"image/*,application/pdf,application/msword,application/vnd.openxmlformats-officedocument.wordprocessingml.document\"\n                      className=\"hidden\"\n                      onChange={(e) => handleUploadFiles(Array.from(e.target.files || []), setChatAttachments, setIsUploadingChatAttachment)}\n                      disabled={isChatClosed}\n                    />\n                  </label>\n                  <button\n                    type=\"button\"\n                    onClick={startNewTicket}\n                    className=\"px-4 py-2 border border-gray-300 text-gray-700 rounded-lg hover:bg-gray-50 transition-colors\"\n                  >\n                    Start a new ticket\n                  </button>\n                  <button\n                    type=\"button\"\n                    onClick={endChat}\n                    disabled={isChatClosed || isSendingChat}\n                    className=\"px-4 py-2 border border-emerald-500 text-emerald-700 rounded-lg hover:bg-emerald-50 transition-colors disabled:opacity-50 disabled:cursor-not-allowed\"\n                  >\n                    End chat\n                  </button>\n                  {isChatClosed && (\n                    <button\n                      type=\"button\"\n                      onClick={clearChat}\n                      className=\"px-4 py-2 border border-gray-300 text-gray-700 rounded-lg hover:bg-gray-50 transition-colors\"\n                    >\n                      Clear chat\n                    </button>\n                  )}\n                </div>\n                <button\n                  type=\"button\"\n                  onClick={sendChatMessage}\n                  disabled={isChatClosed || isUploadingChatAttachment || (!chatMessage.trim() && chatAttachments.length === 0) || isSendingChat}\n                  className=\"inline-flex items-center justify-center w-11 h-11 bg-helfi-green text-white rounded-full hover:bg-helfi-green/90 transition-colors disabled:opacity-50 disabled:cursor-not-allowed\"\n                  aria-label=\"Send message\"\n                  title=\"Send\"\n                >\n                  {isSendingChat || isUploadingChatAttachment ? (\n                    <span className=\"text-xs\">...</span>\n                  ) : (\n                    <svg viewBox=\"0 0 24 24\" className=\"w-5 h-5\" fill=\"currentColor\" aria-hidden=\"true\">\n                      <path d=\"M2.01 21L23 12 2.01 3 2 10l15 2-15 2z\" />\n                    </svg>\n                  )}\n                </button>\n              </div>\n            </div>\n\n            {isChatClosed && (\n              <div className=\"mt-8 border-t border-gray-200 pt-6\">\n                <h3 className=\"text-lg font-semibold text-gray-900 mb-2\">How was your support experience?</h3>\n                <p className=\"text-sm text-gray-600 mb-4\">A quick rating helps us improve.</p>\n                {hasFeedback ? (\n                  <div className=\"text-sm text-emerald-700 bg-emerald-50 border border-emerald-200 rounded-lg p-3\">\n                    Thanks for the feedback ‚Äî we really appreciate it.\n                  </div>\n                ) : (\n                  <>\n                    <div className=\"flex gap-2 mb-4\">\n                      {[1, 2, 3, 4, 5].map((rating) => (\n                        <button\n                          key={rating}\n                          type=\"button\"\n                          onClick={() => setFeedbackRating(rating)}\n                          className={`px-3 py-2 rounded-lg border text-sm ${feedbackRating === rating ? 'bg-emerald-500 text-white border-emerald-500' : 'border-gray-300 text-gray-700 hover:bg-gray-50'}`}\n                        >\n                          {rating}\n                        </button>\n                      ))}\n                    </div>\n                    <textarea\n                      rows={3}\n                      value={feedbackComment}\n                      onChange={(e) => setFeedbackComment(e.target.value)}\n                      className=\"w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-helfi-green focus:border-helfi-green\"\n                      placeholder=\"Optional comment...\"\n                    />\n                    <div className=\"flex justify-end mt-4\">\n                      <button\n                        type=\"button\"\n                        onClick={submitFeedback}\n                        disabled={feedbackRating < 1 || isSubmittingFeedback}\n                        className=\"px-4 py-2 bg-helfi-green text-white rounded-lg hover:bg-helfi-green/90 transition-colors disabled:opacity-50 disabled:cursor-not-allowed\"\n                      >\n                        {isSubmittingFeedback ? 'Submitting...' : 'Submit Feedback'}\n                      </button>\n                    </div>\n                  </>\n                )}\n              </div>\n            )}\n          </div>\n        )}\n\n        {(!session || (!activeTicket && !showChatComposer)) && (\n          <div className=\"mt-6\">\n          <div className=\"text-center mb-8\">\n            <h2 className=\"text-2xl font-bold text-gray-900 mb-2\">Contact Support</h2>\n            <p className=\"text-gray-600\">\n              Have a question or need help? Send us a message and we'll get back to you as soon as possible.\n            </p>\n          </div>\n\n          {/* Success Message */}\n          {submitStatus === 'success' && (\n            <div className=\"mb-6 bg-green-50 border border-green-200 rounded-lg p-4\">\n              <div className=\"flex items-center\">\n                <svg className=\"w-5 h-5 text-green-600 mr-3\" fill=\"currentColor\" viewBox=\"0 0 20 20\">\n                  <path fillRule=\"evenodd\" d=\"M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z\" clipRule=\"evenodd\" />\n                </svg>\n                <div>\n                  <h3 className=\"text-green-800 font-medium\">Support ticket submitted successfully!</h3>\n                  <p className=\"text-green-700 text-sm\">You will receive a reply by email shortly.</p>\n                </div>\n              </div>\n            </div>\n          )}\n\n          {/* Error Message */}\n          {submitStatus === 'error' && (\n            <div className=\"mb-6 bg-red-50 border border-red-200 rounded-lg p-4\">\n              <div className=\"flex items-center\">\n                <svg className=\"w-5 h-5 text-red-600 mr-3\" fill=\"currentColor\" viewBox=\"0 0 20 20\">\n                  <path fillRule=\"evenodd\" d=\"M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z\" clipRule=\"evenodd\" />\n                </svg>\n                <div>\n                  <h3 className=\"text-red-800 font-medium\">Error submitting ticket</h3>\n                  <p className=\"text-red-700 text-sm\">Please try again or email us directly at support@helfi.ai</p>\n                </div>\n              </div>\n            </div>\n          )}\n\n          <form onSubmit={handleSubmit} className=\"space-y-6\">\n            {/* Registered User Toggle */}\n            {!session && (\n              <div className=\"flex items-center\">\n                <input\n                  type=\"checkbox\"\n                  id=\"isRegisteredUser\"\n                  name=\"isRegisteredUser\"\n                  checked={formData.isRegisteredUser}\n                  onChange={handleInputChange}\n                  className=\"h-4 w-4 text-helfi-green focus:ring-helfi-green border-gray-300 rounded\"\n                />\n                <label htmlFor=\"isRegisteredUser\" className=\"ml-2 text-sm text-gray-700\">\n                  I am a registered Helfi user\n                </label>\n              </div>\n            )}\n\n            {/* Basic Information */}\n            <div className=\"grid grid-cols-1 md:grid-cols-2 gap-6\">\n              <div>\n                <label htmlFor=\"name\" className=\"block text-sm font-medium text-gray-700 mb-2\">\n                  Your Name *\n                </label>\n                <input\n                  type=\"text\"\n                  id=\"name\"\n                  name=\"name\"\n                  required\n                  value={formData.name}\n                  onChange={handleInputChange}\n                  className=\"w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-helfi-green focus:border-helfi-green\"\n                  placeholder=\"John Doe\"\n                />\n              </div>\n              \n              <div>\n                <label htmlFor=\"email\" className=\"block text-sm font-medium text-gray-700 mb-2\">\n                  Email Address *\n                </label>\n                <input\n                  type=\"email\"\n                  id=\"email\"\n                  name=\"email\"\n                  required\n                  value={formData.email}\n                  onChange={handleInputChange}\n                  className=\"w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-helfi-green focus:border-helfi-green\"\n                  placeholder=\"your@email.com\"\n                />\n              </div>\n            </div>\n\n            {/* Inquiry Type */}\n            <div>\n              <label htmlFor=\"inquiryType\" className=\"block text-sm font-medium text-gray-700 mb-2\">\n                What can we help you with? *\n              </label>\n              <select\n                id=\"inquiryType\"\n                name=\"inquiryType\"\n                required\n                value={formData.inquiryType}\n                onChange={handleInputChange}\n                className=\"w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-helfi-green focus:border-helfi-green\"\n              >\n                <option value=\"\">Select an option...</option>\n                {inquiryTypes.map(type => (\n                  <option key={type.value} value={type.value}>\n                    {type.label}\n                  </option>\n                ))}\n              </select>\n            </div>\n\n            {/* Conditional Field for Account Issues */}\n            {shouldShowRegisteredEmail && (\n              <div>\n                <label htmlFor=\"registeredEmail\" className=\"block text-sm font-medium text-gray-700 mb-2\">\n                  Registered Email Address *\n                </label>\n                <input\n                  type=\"email\"\n                  id=\"registeredEmail\"\n                  name=\"registeredEmail\"\n                  required\n                  value={formData.registeredEmail}\n                  onChange={handleInputChange}\n                  className=\"w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-helfi-green focus:border-helfi-green\"\n                  placeholder=\"The email address associated with your Helfi account\"\n                />\n              </div>\n            )}\n\n            {/* Subject Line */}\n            <div>\n              <label htmlFor=\"subject\" className=\"block text-sm font-medium text-gray-700 mb-2\">\n                Subject\n              </label>\n              <input\n                type=\"text\"\n                id=\"subject\"\n                name=\"subject\"\n                value={formData.subject}\n                onChange={handleInputChange}\n                className=\"w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-helfi-green focus:border-helfi-green\"\n                placeholder=\"Brief description of your issue\"\n              />\n            </div>\n\n            {/* Message */}\n            <div>\n              <label htmlFor=\"message\" className=\"block text-sm font-medium text-gray-700 mb-2\">\n                Message *\n              </label>\n              <textarea\n                id=\"message\"\n                name=\"message\"\n                required\n                rows={6}\n                value={formData.message}\n                onChange={handleInputChange}\n                onPaste={(e) => {\n                  if (session) handlePasteUpload(e, setFormAttachments, setIsUploadingFormAttachment)\n                }}\n                className=\"w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-helfi-green focus:border-helfi-green\"\n                placeholder=\"Please provide as much detail as possible about your issue or question...\"\n              />\n              {session && (\n                <div className=\"mt-3 flex flex-wrap items-center gap-3\">\n                  <label className=\"px-3 py-2 border border-gray-300 text-gray-700 rounded-lg hover:bg-gray-50 transition-colors cursor-pointer text-sm\">\n                    Attach files\n                    <input\n                      type=\"file\"\n                      multiple\n                      accept=\"image/*,application/pdf,application/msword,application/vnd.openxmlformats-officedocument.wordprocessingml.document\"\n                      className=\"hidden\"\n                      onChange={(e) => handleUploadFiles(Array.from(e.target.files || []), setFormAttachments, setIsUploadingFormAttachment)}\n                    />\n                  </label>\n                  {isUploadingFormAttachment && <span className=\"text-xs text-gray-500\">Uploading...</span>}\n                </div>\n              )}\n              {formAttachments.length > 0 && (\n                <div className=\"mt-3 flex flex-wrap gap-2\">\n                  {formAttachments.map((att) => (\n                    <div key={att.url} className=\"flex items-center gap-2 bg-gray-100 px-3 py-1 rounded-full text-xs\">\n                      <span className=\"truncate max-w-[160px]\">{att.name}</span>\n                      <button\n                        type=\"button\"\n                        onClick={() => setFormAttachments((prev) => prev.filter((item) => item.url !== att.url))}\n                        className=\"text-gray-500 hover:text-gray-700\"\n                        aria-label={`Remove ${att.name}`}\n                      >\n                        ‚úï\n                      </button>\n                    </div>\n                  ))}\n                </div>\n              )}\n              {attachmentError && (\n                <p className=\"mt-2 text-sm text-red-600\">{attachmentError}</p>\n              )}\n            </div>\n\n            {/* Submit Button */}\n            <div>\n              <button\n                type=\"submit\"\n                disabled={isSubmitting || isUploadingFormAttachment}\n                className=\"w-full bg-helfi-green text-white px-6 py-3 rounded-lg font-medium hover:bg-helfi-green/90 transition-colors disabled:opacity-50 disabled:cursor-not-allowed\"\n              >\n                {isSubmitting || isUploadingFormAttachment ? 'Submitting...' : 'Send Message'}\n              </button>\n            </div>\n          </form>\n\n          {/* Additional Contact Info */}\n          <div className=\"mt-8 pt-8 border-t border-gray-200\">\n            <div className=\"text-center\">\n              <h3 className=\"text-lg font-medium text-gray-900 mb-4\">Other Ways to Reach Us</h3>\n              <div className=\"space-y-2 text-sm text-gray-600\">\n                <p>\n                  üìß Email: <a href=\"mailto:support@helfi.ai\" className=\"text-helfi-green hover:text-helfi-green/80 font-medium\">support@helfi.ai</a>\n                </p>\n                <p>‚è∞ Response Time: Usually within a few minutes</p>\n                <p>üïí Business Hours: Monday - Friday, 9 AM - 5 PM (AEST)</p>\n              </div>\n            </div>\n          </div>\n        </div>\n        )}\n      </div>\n    </div>\n  )\n} \n","truncated":false,"size":41201},{"path":"app/symptoms/history/page.tsx","content":"'use client'\n\nimport { useCallback, useEffect, useState } from 'react'\nimport Link from 'next/link'\nimport { usePathname } from 'next/navigation'\nimport PageHeader from '@/components/PageHeader'\n\ntype SymptomHistoryItem = {\n  id: string\n  symptoms: any\n  duration?: string | null\n  notes?: string | null\n  summary?: string | null\n  analysisText?: string | null\n  analysisData?: {\n    possibleCauses?: Array<{ name: string; whyLikely?: string; confidence?: string }>\n    redFlags?: string[]\n    nextSteps?: string[]\n  } | null\n  createdAt: string\n}\n\nexport default function SymptomHistoryPage() {\n  const pathname = usePathname()\n  const [historyItems, setHistoryItems] = useState<SymptomHistoryItem[]>([])\n  const [historyLoading, setHistoryLoading] = useState(false)\n  const [historyError, setHistoryError] = useState<string | null>(null)\n  const [historyDeletingId, setHistoryDeletingId] = useState<string | null>(null)\n  const [historyClearing, setHistoryClearing] = useState(false)\n  const [expandedHistoryId, setExpandedHistoryId] = useState<string | null>(null)\n\n  const loadHistory = useCallback(async () => {\n    try {\n      setHistoryLoading(true)\n      setHistoryError(null)\n      const res = await fetch('/api/symptoms/history', { cache: 'no-store' as any })\n      if (!res.ok) {\n        throw new Error('Failed to load history')\n      }\n      const data = await res.json()\n      const nextHistory = Array.isArray(data?.history) ? data.history : []\n      setHistoryItems(nextHistory)\n    } catch (err) {\n      setHistoryError((err as Error).message || 'Failed to load history')\n    } finally {\n      setHistoryLoading(false)\n    }\n  }, [])\n\n  useEffect(() => {\n    loadHistory()\n  }, [loadHistory])\n\n  const handleDeleteHistoryItem = async (id: string) => {\n    if (!window.confirm('Delete this symptom analysis? This cannot be undone.')) return\n    try {\n      setHistoryDeletingId(id)\n      setHistoryError(null)\n      const res = await fetch(`/api/symptoms/history/${id}`, { method: 'DELETE' })\n      if (!res.ok) {\n        throw new Error('Failed to delete analysis')\n      }\n      setHistoryItems((prev) => prev.filter((item) => item.id !== id))\n      setExpandedHistoryId((prev) => (prev === id ? null : prev))\n    } catch (err) {\n      setHistoryError((err as Error).message || 'Failed to delete analysis')\n    } finally {\n      setHistoryDeletingId(null)\n    }\n  }\n\n  const handleClearHistory = async () => {\n    if (!window.confirm('Clear all symptom analyses? This cannot be undone.')) return\n    try {\n      setHistoryClearing(true)\n      setHistoryError(null)\n      const res = await fetch('/api/symptoms/history', { method: 'DELETE' })\n      if (!res.ok) {\n        throw new Error('Failed to clear history')\n      }\n      setHistoryItems([])\n      setExpandedHistoryId(null)\n    } catch (err) {\n      setHistoryError((err as Error).message || 'Failed to clear history')\n    } finally {\n      setHistoryClearing(false)\n    }\n  }\n\n  return (\n    <div className=\"min-h-screen bg-gray-50 flex flex-col\">\n      <PageHeader title=\"Symptom Analysis\" />\n\n      <div className=\"max-w-7xl mx-auto w-full px-4 pt-4\">\n        <div className=\"bg-white rounded-t-xl border-b border-gray-200\">\n          <div className=\"flex\">\n            <Link\n              href=\"/symptoms\"\n              style={{ width: '100%' }}\n              className={`flex-1 px-4 py-3 text-center font-medium transition-colors ${\n                pathname !== '/symptoms/history'\n                  ? 'text-helfi-green border-b-2 border-helfi-green'\n                  : 'text-gray-600 hover:text-gray-900'\n              }`}\n            >\n              Symptom Analysis\n            </Link>\n            <Link\n              href=\"/symptoms/history\"\n              style={{ width: '100%' }}\n              className={`flex-1 px-4 py-3 text-center font-medium transition-colors ${\n                pathname === '/symptoms/history'\n                  ? 'text-helfi-green border-b-2 border-helfi-green'\n                  : 'text-gray-600 hover:text-gray-900'\n              }`}\n            >\n              History\n            </Link>\n          </div>\n        </div>\n      </div>\n\n      <main className=\"flex-1\">\n        <div className=\"max-w-7xl mx-auto px-4 py-6\">\n          <div className=\"bg-white rounded-b-2xl shadow-sm border border-gray-200 p-6\">\n            <div className=\"flex items-center justify-between gap-2 mb-4\">\n              <div>\n                <h1 className=\"text-2xl font-bold text-gray-900\">Symptom History</h1>\n                <p className=\"text-xs text-gray-500 mt-1\">\n                  Review your previous symptom analyses. You can delete any entry at any time.\n                </p>\n              </div>\n              <div className=\"flex items-center gap-3 text-xs\">\n                {historyItems.length > 0 && (\n                  <button\n                    onClick={handleClearHistory}\n                    className=\"text-red-600 hover:text-red-700 disabled:opacity-60\"\n                    type=\"button\"\n                    disabled={historyClearing}\n                  >\n                    {historyClearing ? 'Clearing...' : 'Clear all'}\n                  </button>\n                )}\n                <button\n                  onClick={loadHistory}\n                  className=\"text-gray-600 hover:text-gray-900 disabled:opacity-60\"\n                  type=\"button\"\n                  disabled={historyLoading}\n                >\n                  Refresh\n                </button>\n              </div>\n            </div>\n\n            {historyLoading && <div className=\"text-sm text-gray-500\">Loading history...</div>}\n            {historyError && <div className=\"text-sm text-red-700\">{historyError}</div>}\n            {!historyLoading && !historyError && historyItems.length === 0 && (\n              <div className=\"text-sm text-gray-500\">No saved analyses yet.</div>\n            )}\n\n            <div className=\"mt-4 space-y-4\">\n              {historyItems.map((item) => {\n                const symptoms = Array.isArray(item.symptoms) ? item.symptoms : []\n                const analysisData = item.analysisData || null\n                const possibleCauses = Array.isArray(analysisData?.possibleCauses)\n                  ? analysisData?.possibleCauses\n                  : []\n                const redFlags = Array.isArray(analysisData?.redFlags) ? analysisData?.redFlags : []\n                const nextSteps = Array.isArray(analysisData?.nextSteps) ? analysisData?.nextSteps : []\n                const isExpanded = expandedHistoryId === item.id\n                const createdAtLabel = item.createdAt\n                  ? new Date(item.createdAt).toLocaleString()\n                  : 'Unknown date'\n\n                return (\n                  <div key={item.id} className=\"border border-gray-200 rounded-lg p-4 bg-white\">\n                    <div className=\"flex items-center justify-between gap-2\">\n                      <div className=\"text-xs text-gray-500\">{createdAtLabel}</div>\n                      <div className=\"flex items-center gap-3 text-xs\">\n                        <button\n                          type=\"button\"\n                          onClick={() => setExpandedHistoryId(isExpanded ? null : item.id)}\n                          className=\"text-helfi-green hover:text-helfi-green/80\"\n                        >\n                          {isExpanded ? 'Hide details' : 'View details'}\n                        </button>\n                        <button\n                          type=\"button\"\n                          onClick={() => handleDeleteHistoryItem(item.id)}\n                          className=\"text-red-600 hover:text-red-700 disabled:opacity-60\"\n                          disabled={historyDeletingId === item.id || historyClearing}\n                        >\n                          {historyDeletingId === item.id ? 'Deleting...' : 'Delete'}\n                        </button>\n                      </div>\n                    </div>\n\n                    <div className=\"mt-3 space-y-2\">\n                      {symptoms.length > 0 && (\n                        <div className=\"text-sm text-gray-900\">\n                          <span className=\"font-medium\">Symptoms:</span> {symptoms.join(', ')}\n                        </div>\n                      )}\n                      {item.duration && (\n                        <div className=\"text-sm text-gray-700\">\n                          <span className=\"font-medium\">Duration:</span> {item.duration}\n                        </div>\n                      )}\n                      {item.summary && (\n                        <p className=\"text-sm text-gray-800\">{item.summary}</p>\n                      )}\n                    </div>\n\n                    {isExpanded && (\n                      <div className=\"pt-3 space-y-3 text-sm text-gray-700\">\n                        {item.notes && (\n                          <div>\n                            <div className=\"font-medium text-gray-900 mb-1\">Notes</div>\n                            <p className=\"whitespace-pre-line\">{item.notes}</p>\n                          </div>\n                        )}\n                        {possibleCauses.length > 0 && (\n                          <div>\n                            <div className=\"font-medium text-gray-900 mb-1\">Likely causes</div>\n                            <ul className=\"space-y-1\">\n                              {possibleCauses.map((cause: any, idx: number) => (\n                                <li key={`${cause.name}-${idx}`} className=\"flex items-center gap-2\">\n                                  <span className=\"text-gray-900\">{cause.name}</span>\n                                  {cause.confidence && (\n                                    <span className=\"text-xs text-gray-500\">({cause.confidence})</span>\n                                  )}\n                                </li>\n                              ))}\n                            </ul>\n                          </div>\n                        )}\n                        {redFlags.length > 0 && (\n                          <div>\n                            <div className=\"font-medium text-red-700 mb-1\">Red-flag signs</div>\n                            <ul className=\"list-disc list-inside space-y-1 text-red-800\">\n                              {redFlags.map((flag: string, idx: number) => (\n                                <li key={idx}>{flag}</li>\n                              ))}\n                            </ul>\n                          </div>\n                        )}\n                        {nextSteps.length > 0 && (\n                          <div>\n                            <div className=\"font-medium text-gray-900 mb-1\">Next steps</div>\n                            <ul className=\"list-disc list-inside space-y-1\">\n                              {nextSteps.map((step: string, idx: number) => (\n                                <li key={idx}>{step}</li>\n                              ))}\n                            </ul>\n                          </div>\n                        )}\n                        {item.analysisText && (\n                          <div>\n                            <div className=\"font-medium text-gray-900 mb-1\">Full notes</div>\n                            <p className=\"whitespace-pre-line\">{item.analysisText}</p>\n                          </div>\n                        )}\n                      </div>\n                    )}\n                  </div>\n                )\n              })}\n            </div>\n          </div>\n        </div>\n      </main>\n    </div>\n  )\n}\n","truncated":false,"size":11545},{"path":"app/symptoms/page.tsx","content":"'use client'\nimport { Cog6ToothIcon } from '@heroicons/react/24/outline'\n\nimport { useEffect, useMemo, useRef, useState } from 'react'\nimport Link from 'next/link'\nimport { usePathname } from 'next/navigation'\nimport CreditPurchaseModal from '@/components/CreditPurchaseModal'\nimport MobileMoreMenu from '@/components/MobileMoreMenu'\nimport SymptomChat from './SymptomChat'\nimport UsageMeter from '@/components/UsageMeter'\nimport FeatureUsageDisplay from '@/components/FeatureUsageDisplay'\nimport PageHeader from '@/components/PageHeader'\n\ntype AnalysisResult = {\n  success: boolean\n  analysisText?: string\n  summary?: string | null\n  possibleCauses?: Array<{ name: string; whyLikely: string; confidence: 'low' | 'medium' | 'high' }>\n  redFlags?: string[]\n  nextSteps?: string[]\n  disclaimer?: string\n  error?: string\n}\n\nexport default function SymptomAnalysisPage() {\n  const pathname = usePathname()\n  const [symptomInput, setSymptomInput] = useState<string>('')\n  const [selectedSymptoms, setSelectedSymptoms] = useState<string[]>([])\n  const [duration, setDuration] = useState<string>('')\n  const [notes, setNotes] = useState<string>('')\n\n  const [isAnalyzing, setIsAnalyzing] = useState<boolean>(false)\n  const [phase, setPhase] = useState<number>(0)\n  const [progress, setProgress] = useState<number>(0)\n  const [result, setResult] = useState<AnalysisResult | null>(null)\n  const [error, setError] = useState<string>('')\n\n  const [showCreditsModal, setShowCreditsModal] = useState<boolean>(false)\n  const [creditInfo, setCreditInfo] = useState<any>({ dailyUsed: 0, dailyLimit: 0, additionalCredits: 0, plan: 'FREE', creditCost: 1 })\n  const [tagsExpanded, setTagsExpanded] = useState<boolean>(false)\n  const [usageMeterRefresh, setUsageMeterRefresh] = useState<number>(0) // Trigger for UsageMeter refresh\n  const resultRef = useRef<HTMLDivElement | null>(null)\n  const [hasPaidAccess, setHasPaidAccess] = useState<boolean>(false)\n  const [creditRefreshTick, setCreditRefreshTick] = useState<number>(0)\n\n  // Progress phases shown while analyzing\n  const phases = useMemo(() => [\n    'Gathering context',\n    'Checking differentials',\n    'Flagging red flags',\n    'Drafting next steps'\n  ], [])\n\n  useEffect(() => {\n    if (!isAnalyzing) return\n    setPhase(0)\n    setProgress(0)\n    let pct = 0\n    // Cap progress at 85% during simulation, will jump to 100% when API completes\n    const timer = setInterval(() => {\n      pct = Math.min(85, pct + Math.random() * 7 + 3)\n      setProgress(pct)\n      // advance phase roughly every ~25%\n      if (pct > 75) setPhase(3)\n      else if (pct > 50) setPhase(2)\n      else if (pct > 25) setPhase(1)\n      else setPhase(0)\n    }, 350)\n    return () => clearInterval(timer)\n  }, [isAnalyzing])\n\n  useEffect(() => {\n    const handler = () => setCreditRefreshTick((v) => v + 1)\n    try {\n      window.addEventListener('credits:refresh', handler)\n      return () => window.removeEventListener('credits:refresh', handler)\n    } catch {\n      return () => {}\n    }\n  }, [])\n\n  useEffect(() => {\n    const fetchCreditStatus = async () => {\n      try {\n        const res = await fetch(`/api/credit/status`, { cache: 'no-store' })\n        if (!res.ok) return\n        const data = await res.json()\n        const isPremium = data?.plan === 'PREMIUM'\n        const hasWalletCredits =\n          typeof data?.totalAvailableCents === 'number' && data.totalAvailableCents > 0\n        const hasLegacyCredits =\n          typeof data?.credits?.total === 'number' && data.credits.total > 0\n\n        setHasPaidAccess(Boolean(isPremium || hasWalletCredits || hasLegacyCredits))\n      } catch {\n        // ignore failures ‚Äì fall back to showing free banner\n      }\n    }\n    fetchCreditStatus()\n  }, [creditRefreshTick])\n\n  const quickTags = [\n    'Fever','Headache','Cough','Sore throat','Runny nose','Nasal congestion','Sneezing','Fatigue','Body aches','Chills','Night sweats',\n    'Shortness of breath','Chest pain','Palpitations','Dizziness','Lightheadedness','Confusion','Anxiety','Depressed mood','Insomnia',\n    'Nausea','Vomiting','Diarrhea','Constipation','Abdominal pain','Bloating','Heartburn','Indigestion','Loss of appetite',\n    'Back pain','Joint pain','Muscle pain','Swollen joints','Rash','Itchy skin','Hives','Head pressure','Loss of taste','Loss of smell',\n    'Ear pain','Tooth pain','Sore gums','Swollen glands','Frequent urination','Burning urination','Blood in urine','Blood in stool'\n  ]\n\n  const handleAddTag = (tag: string) => {\n    setSelectedSymptoms((prev) => (prev.includes(tag) ? prev : [...prev, tag]))\n  }\n\n  const handleAddSymptom = () => {\n    const s = symptomInput.trim()\n    if (!s) return\n    setSelectedSymptoms((prev) => (prev.includes(s) ? prev : [...prev, s]))\n    setSymptomInput('')\n  }\n\n  const handleRemoveSymptom = (symptom: string) => {\n    setSelectedSymptoms((prev) => prev.filter((s) => s !== symptom))\n  }\n\n  const handleAnalyze = async () => {\n    setError('')\n    setResult(null)\n    const hasAny = selectedSymptoms.length > 0\n    if (!hasAny) {\n      setError('Please enter at least one symptom.')\n      return\n    }\n    setIsAnalyzing(true)\n    try {\n      const res = await fetch('/api/analyze-symptoms', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ symptoms: selectedSymptoms, duration, notes })\n      })\n\n      if (res.status === 402) {\n        const data = await res.json()\n        setCreditInfo({\n          dailyUsed: 0,\n          dailyLimit: 0,\n          additionalCredits: data.additionalCredits ?? 0,\n          plan: data.plan ?? 'FREE',\n          creditCost: data.creditCost ?? 1,\n          dailyLimits: data.dailyLimits,\n          featureUsageToday: data.featureUsageToday,\n        })\n        setShowCreditsModal(true)\n        return\n      }\n\n      if (!res.ok) {\n        const data = await res.json().catch(() => ({}))\n        throw new Error(data?.error || 'Failed to analyze symptoms')\n      }\n\n      const data: AnalysisResult = await res.json()\n      setResult(data)\n      // Trigger usage meter refresh after successful analysis\n      try { window.dispatchEvent(new Event('credits:refresh')); } catch {}\n    } catch (e: any) {\n      setError(e?.message || 'Something went wrong')\n    } finally {\n      setIsAnalyzing(false)\n      setProgress(100)\n    }\n  }\n\n  useEffect(() => {\n    if (!result) return\n    const el = resultRef.current\n    if (!el) return\n    requestAnimationFrame(() => {\n      el.scrollIntoView({ behavior: 'smooth', block: 'start' })\n    })\n  }, [result])\n\n  return (\n    <div className=\"min-h-screen bg-gray-50 flex flex-col\">\n      <PageHeader title=\"Symptom Analysis\" />\n\n      {/* Tabs */}\n      <div className=\"max-w-7xl mx-auto w-full px-4 pt-4\">\n        <div className=\"bg-white rounded-t-xl border-b border-gray-200\">\n          <div className=\"flex\">\n            <Link\n              href=\"/symptoms\"\n              style={{ width: '100%' }}\n              className={`flex-1 px-4 py-3 text-center font-medium transition-colors ${\n                pathname !== '/symptoms/history'\n                  ? 'text-helfi-green border-b-2 border-helfi-green'\n                  : 'text-gray-600 hover:text-gray-900'\n              }`}\n            >\n              Symptom Analysis\n            </Link>\n            <Link\n              href=\"/symptoms/history\"\n              style={{ width: '100%' }}\n              className={`flex-1 px-4 py-3 text-center font-medium transition-colors ${\n                pathname === '/symptoms/history'\n                  ? 'text-helfi-green border-b-2 border-helfi-green'\n                  : 'text-gray-600 hover:text-gray-900'\n              }`}\n            >\n              History\n            </Link>\n          </div>\n        </div>\n      </div>\n\n      {/* Content */}\n      <main className=\"flex-1\">\n        <div className=\"mx-auto w-full px-0 sm:px-4 md:max-w-3xl md:px-4 py-6\">\n          <div className=\"bg-white rounded-lg shadow-sm border border-gray-200 p-4 md:p-6\">\n            <h1 className=\"text-xl font-semibold text-gray-900 mb-1\">Describe your symptoms</h1>\n            <p className=\"text-sm text-gray-600 mb-4\">List symptoms separated by commas (e.g., Headache, Fever). Add duration and any notes.</p>\n\n            <div className=\"mb-3\">\n               <label className=\"block text-sm font-medium text-gray-700 mb-1\">Symptoms</label>\n              <div className=\"flex gap-2\">\n                <input\n                  type=\"text\"\n                  value={symptomInput}\n                  onChange={(e) => setSymptomInput(e.target.value)}\n                  onKeyDown={(e) => { if (e.key === 'Enter') { e.preventDefault(); handleAddSymptom() } }}\n                  className=\"flex-1 border border-gray-300 rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-helfi-green/30 focus:border-helfi-green\"\n                  placeholder=\"e.g., Headache\"\n                />\n                <button onClick={handleAddSymptom} className=\"px-3 py-2 bg-helfi-green text-white rounded-lg hover:bg-helfi-green/90\">+ Add</button>\n              </div>\n\n              {/* Selected symptoms */}\n              {selectedSymptoms.length > 0 && (\n                <div className=\"flex flex-wrap gap-2 mt-2\">\n                  {selectedSymptoms.map((s) => (\n                    <span key={s} className=\"inline-flex items-center gap-1 px-2 py-1 text-xs bg-emerald-50 border border-emerald-200 text-emerald-800 rounded-full\">\n                      {s}\n                      <button aria-label={`Remove ${s}`} onClick={() => handleRemoveSymptom(s)} className=\"ml-1 text-emerald-800 hover:text-emerald-900\">√ó</button>\n                    </span>\n                  ))}\n                </div>\n              )}\n\n              {/* Quick tags */}\n              <div className=\"mt-3\">\n                <div className=\"flex flex-wrap gap-2\">\n                  {(tagsExpanded ? quickTags : quickTags.slice(0, 12)).map((t) => {\n                    const selected = selectedSymptoms.includes(t)\n                    return (\n                      <button\n                        key={t}\n                        onClick={() => handleAddTag(t)}\n                        className={`${selected ? 'bg-emerald-100 text-emerald-800 border-emerald-200' : 'bg-gray-100 text-gray-700 border-gray-200 hover:bg-gray-200'} px-2 py-1 text-xs border rounded-full`}\n                      >\n                        {t}\n                      </button>\n                    )\n                  })}\n                </div>\n                {quickTags.length > 12 && (\n                  <button\n                    onClick={() => setTagsExpanded(!tagsExpanded)}\n                    className=\"mt-2 text-sm text-helfi-green hover:text-helfi-green/80 font-medium\"\n                  >\n                    {tagsExpanded ? 'Show less' : `Show ${quickTags.length - 12} more`}\n                  </button>\n                )}\n              </div>\n            </div>\n\n            <div className=\"grid md:grid-cols-2 gap-3 mb-3\">\n              <div>\n                <label className=\"block text-sm font-medium text-gray-700 mb-1\">Duration</label>\n                <input\n                  type=\"text\"\n                  value={duration}\n                  onChange={(e) => setDuration(e.target.value)}\n                  className=\"w-full border border-gray-300 rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-helfi-green/30 focus:border-helfi-green\"\n                  placeholder=\"e.g., 2 days, 1 week\"\n                />\n              </div>\n            </div>\n            <div className=\"mb-3\">\n              <label className=\"block text-sm font-medium text-gray-700 mb-1\">Notes (optional)</label>\n              <textarea\n                value={notes}\n                onChange={(e) => setNotes(e.target.value)}\n                rows={4}\n                className=\"w-full border border-gray-300 rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-helfi-green/30 focus:border-helfi-green\"\n                placeholder=\"e.g., started after travel, any triggers, patterns, etc.\"\n              />\n            </div>\n\n            {error && (\n              <div className=\"bg-red-50 border border-red-200 text-red-800 rounded-lg p-3 mb-3 text-sm\">{error}</div>\n            )}\n\n            <button\n              onClick={handleAnalyze}\n              disabled={isAnalyzing}\n              className={`inline-flex items-center px-4 py-2 rounded-lg font-medium text-white transition-colors ${isAnalyzing ? 'bg-helfi-green/60' : 'bg-helfi-green hover:bg-helfi-green/90'}`}\n            >\n              {isAnalyzing ? 'Analyzing‚Ä¶' : 'Analyze symptoms'}\n            </button>\n            <div className=\"mt-2\">\n              <p className=\"text-xs text-gray-500 mb-2\">Cost: 6 credits per analysis</p>\n              {!hasPaidAccess && (\n                <div className=\"text-[11px] text-blue-800 bg-blue-50 border border-blue-200 rounded px-2 py-1 mb-2\">\n                  Free accounts can try this AI feature once. After your free analysis, upgrade or buy credits to continue.\n                </div>\n              )}\n              <UsageMeter inline={true} refreshTrigger={usageMeterRefresh} feature=\"symptomAnalysis\" />\n              <FeatureUsageDisplay featureName=\"symptomAnalysis\" featureLabel=\"Symptom Analysis\" refreshTrigger={usageMeterRefresh} />\n              <p className=\"text-xs text-gray-600 mt-1\">Cost: 6 credits per symptom analysis.</p>\n            </div>\n\n            {/* Progress Bar */}\n            {isAnalyzing && (\n              <div className=\"mt-4\">\n                <div className=\"flex items-center justify-between mb-1 text-sm text-gray-600\">\n                  <span>{phases[phase]}</span>\n                  <span>{Math.round(progress)}%</span>\n                </div>\n                <div className=\"h-2 bg-gray-200 rounded-full overflow-hidden\">\n                  <div className=\"h-2 bg-helfi-green transition-all\" style={{ width: `${progress}%` }} />\n                </div>\n              </div>\n            )}\n          </div>\n\n          {/* Results */}\n          {result && (\n            <div\n              ref={resultRef}\n              className=\"mt-6 bg-white rounded-lg shadow-sm border border-gray-200 p-4 md:p-6\"\n            >\n              <h2 className=\"text-lg font-semibold text-gray-900 mb-2\">Your analysis</h2>\n\n              {result.summary && (\n                <div className=\"mb-4\">\n                  <h3 className=\"font-medium text-gray-900 mb-1\">Summary</h3>\n                  <p className=\"text-gray-700 text-sm whitespace-pre-line\">{result.summary}</p>\n                </div>\n              )}\n\n              {Array.isArray(result.possibleCauses) && result.possibleCauses.length > 0 && (\n                <div className=\"mb-4\">\n                  <h3 className=\"font-medium text-gray-900 mb-2\">Likely causes</h3>\n                  <ul className=\"space-y-2\">\n                    {result.possibleCauses.map((c, idx) => (\n                      <li key={idx} className=\"p-3 border border-gray-200 rounded-lg\">\n                        <div className=\"flex items-center justify-between\">\n                          <div className=\"font-medium text-gray-900\">{c.name}</div>\n                          <span className=\"text-xs px-2 py-0.5 rounded-full bg-gray-100 text-gray-700\">{c.confidence}</span>\n                        </div>\n                        <div className=\"mt-1 text-sm text-gray-700\">{c.whyLikely}</div>\n                      </li>\n                    ))}\n                  </ul>\n                </div>\n              )}\n\n              {Array.isArray(result.redFlags) && result.redFlags.length > 0 && (\n                <div className=\"mb-4\">\n                  <h3 className=\"font-medium text-red-700 mb-2 flex items-center\">Red flags</h3>\n                  <ul className=\"list-disc list-inside text-sm text-red-800 space-y-1\">\n                    {result.redFlags.map((rf, idx) => (\n                      <li key={idx}>{rf}</li>\n                    ))}\n                  </ul>\n                </div>\n              )}\n\n              {Array.isArray(result.nextSteps) && result.nextSteps.length > 0 && (\n                <div className=\"mb-4\">\n                  <h3 className=\"font-medium text-gray-900 mb-2\">What to do next</h3>\n                  <ul className=\"list-disc list-inside text-sm text-gray-700 space-y-1\">\n                    {result.nextSteps.map((step, idx) => (\n                      <li key={idx}>{step}</li>\n                    ))}\n                  </ul>\n                </div>\n              )}\n\n              <div className=\"text-xs text-gray-500 bg-gray-50 border border-gray-200 rounded-lg p-3\">\n                {result.disclaimer || 'This is not medical advice. If you have concerning or worsening symptoms, contact a licensed medical professional or emergency services.'}\n              </div>\n            </div>\n          )}\n\n          {/* AI Chat */}\n          {result && (\n            <SymptomChat\n              analysisResult={result}\n              symptoms={selectedSymptoms}\n              duration={duration}\n              notes={notes}\n            />\n          )}\n        </div>\n      </main>\n\n      {/* Mobile Bottom Spacing */}\n      <div className=\"h-20 md:h-0\" />\n\n      {/* Credit Modal */}\n      <CreditPurchaseModal\n        isOpen={showCreditsModal}\n        onClose={() => setShowCreditsModal(false)}\n        creditInfo={creditInfo}\n      />\n\n      {/* Mobile Bottom Navigation (placeholder, will be updated globally in a later step) */}\n      <nav className=\"md:hidden fixed bottom-0 left-0 right-0 bg-white border-t border-gray-200 px-4 py-2 z-40\">\n        <div className=\"flex items-center justify-around\">\n          <Link href=\"/dashboard\" className=\"pressable ripple flex flex-col items-center py-2 px-1 min-w-0 flex-1\">\n            <div className=\"icon text-gray-400\">\n              <svg className=\"w-6 h-6\" fill=\"currentColor\" viewBox=\"0 0 24 24\"><path d=\"M3 13h8V3H3v10zm0 8h8v-6H3v6zm10 0h8V11h-8v10zm0-18v6h8V3h-8z\"/></svg>\n            </div>\n            <span className=\"label text-xs mt-1 truncate text-gray-400 font-medium\">Dashboard</span>\n          </Link>\n          <Link href=\"/insights\" className=\"pressable ripple flex flex-col items-center py-2 px-1 min-w-0 flex-1\">\n            <div className=\"icon text-gray-400\">\n              <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\"><path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z\"/></svg>\n            </div>\n            <span className=\"label text-xs mt-1 truncate text-gray-400 font-medium\">Insights</span>\n          </Link>\n          <Link href=\"/food\" className=\"pressable ripple flex flex-col items-center py-2 px-1 min-w-0 flex-1\">\n            <div className=\"icon text-gray-400\">\n              <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\"><path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10\"/></svg>\n            </div>\n            <span className=\"label text-xs mt-1 truncate text-gray-400 font-medium\">Food</span>\n          </Link>\n          <MobileMoreMenu />\n          <Link href=\"/settings\" className=\"pressable ripple flex flex-col items-center py-2 px-1 min-w-0 flex-1\">\n            <div className=\"icon text-gray-400\">\n              <Cog6ToothIcon className=\"w-6 h-6 flex-shrink-0\" style={{ minWidth: '24px', minHeight: '24px' }} />\n            </div>\n            <span className=\"label text-xs mt-1 truncate text-gray-400 font-medium\">Settings</span>\n          </Link>\n        </div>\n      </nav>\n    </div>\n  )\n}\n","truncated":false,"size":19912},{"path":"app/symptoms/SymptomChat.tsx","content":"'use client'\n\nimport { FormEvent, KeyboardEvent, useEffect, useLayoutEffect, useMemo, useRef, useState, useCallback } from 'react'\nimport { createPortal } from 'react-dom'\nimport { ArrowsPointingOutIcon, ArrowsPointingInIcon } from '@heroicons/react/24/outline'\nimport { formatChatContent } from '@/lib/chatFormatting'\n\ninterface SymptomChatProps {\n  analysisResult: {\n    summary?: string | null\n    possibleCauses?: Array<{ name: string; whyLikely: string; confidence: string }>\n    redFlags?: string[]\n    nextSteps?: string[]\n    analysisText?: string\n  }\n  symptoms: string[]\n  duration?: string\n  notes?: string\n}\n\ntype ChatMessage = { role: 'user' | 'assistant'; content: string }\n\nexport default function SymptomChat({ analysisResult, symptoms, duration, notes }: SymptomChatProps) {\n  const storageKey = useMemo(() => `helfi:symptoms:chat`, [])\n  const [messages, setMessages] = useState<ChatMessage[]>([])\n  const [input, setInput] = useState('')\n  const [loading, setLoading] = useState(false)\n  const [error, setError] = useState<string | null>(null)\n  const [isListening, setIsListening] = useState(false)\n  const [expanded, setExpanded] = useState(false)\n  const [showExpandControl, setShowExpandControl] = useState(false)\n  const scrollPositionRef = useRef<number>(0)\n  const endRef = useRef<HTMLDivElement | null>(null)\n  const containerRef = useRef<HTMLDivElement | null>(null)\n  const textareaRef = useRef<HTMLTextAreaElement | null>(null)\n  const recognitionRef = useRef<any>(null)\n  const resizeRafRef = useRef<number | null>(null)\n  const [isClient, setIsClient] = useState(false)\n\n  // Smooth, single-frame resize to avoid jumpiness when text grows/shrinks rapidly (typing or voice)\n  const resizeTextarea = useCallback(() => {\n    if (resizeRafRef.current) cancelAnimationFrame(resizeRafRef.current)\n    resizeRafRef.current = requestAnimationFrame(() => {\n      const textarea = textareaRef.current\n      if (!textarea) return\n      const minHeight = 52\n      const maxHeight = 200\n      textarea.style.height = 'auto'\n      const desired = Math.min(Math.max(textarea.scrollHeight, minHeight), maxHeight)\n      if (textarea.style.height !== `${desired}px`) {\n        textarea.style.height = `${desired}px`\n      }\n      textarea.style.overflowY = textarea.scrollHeight > maxHeight ? 'auto' : 'hidden'\n\n      // Show expand control when textarea height exceeds ~3-4 lines (around 156px for 3 lines)\n      // Using scrollHeight which reflects actual content height\n      const shouldShow = textarea.scrollHeight > 140 || (textarea.value.match(/\\n/g) || []).length >= 2\n      setShowExpandControl(shouldShow)\n    })\n  }, [])\n\n  // Initialize speech recognition\n  useEffect(() => {\n    if (typeof window === 'undefined') return\n    const SpeechRecognition = (window as any).SpeechRecognition || (window as any).webkitSpeechRecognition\n    if (!SpeechRecognition) return\n\n    const recognition = new SpeechRecognition()\n    recognition.continuous = true\n    recognition.interimResults = true\n    recognition.lang = 'en-US'\n\n    let finalTranscript = ''\n\n    recognition.onstart = () => {\n      setIsListening(true)\n      finalTranscript = ''\n    }\n\n    recognition.onresult = (event: any) => {\n      let interimTranscript = ''\n      \n      for (let i = event.resultIndex; i < event.results.length; i++) {\n        const transcript = event.results[i][0].transcript\n        if (event.results[i].isFinal) {\n          finalTranscript += transcript + ' '\n        } else {\n          interimTranscript += transcript\n        }\n      }\n      \n      setInput(finalTranscript + interimTranscript)\n    }\n\n    recognition.onerror = (event: any) => {\n      setIsListening(false)\n      if (event.error !== 'no-speech') {\n        setError('Speech recognition error. Please try again.')\n      }\n    }\n\n    recognition.onend = () => {\n      setIsListening(false)\n      if (finalTranscript.trim()) {\n        setInput(finalTranscript.trim())\n      }\n    }\n\n    recognitionRef.current = recognition\n    return () => {\n      if (recognitionRef.current) recognitionRef.current.stop()\n    }\n  }, [])\n\n  // Track client-side mount so we can safely use portals\n  useEffect(() => {\n    setIsClient(true)\n  }, [])\n\n  function startListening() {\n    if (!recognitionRef.current || isListening) return\n    try {\n      recognitionRef.current.start()\n    } catch (err) {\n      setError('Failed to start voice recognition')\n    }\n  }\n\n  function stopListening() {\n    if (recognitionRef.current && isListening) {\n      recognitionRef.current.stop()\n      setIsListening(false)\n    }\n  }\n\n  // Load from localStorage on mount\n  useEffect(() => {\n    try {\n      const saved = localStorage.getItem(storageKey)\n      if (saved) {\n        const parsed = JSON.parse(saved)\n        if (Array.isArray(parsed)) {\n          setMessages(parsed.filter((m) => m && typeof m.content === 'string' && (m.role === 'user' || m.role === 'assistant')).slice(-24))\n        }\n      }\n    } catch {}\n  }, [storageKey])\n\n  // Persist messages locally\n  useEffect(() => {\n    try {\n      localStorage.setItem(storageKey, JSON.stringify(messages))\n    } catch {}\n  }, [messages, storageKey])\n\n  useEffect(() => {\n    const container = containerRef.current\n    if (!container) return\n    // Scroll inside the chat container only, avoid scrolling the whole page\n    container.scrollTop = container.scrollHeight\n\n    return () => {\n      if (resizeRafRef.current) cancelAnimationFrame(resizeRafRef.current)\n    }\n  }, [messages, loading])\n\n  useEffect(() => {\n    return () => {\n      if (resizeRafRef.current) cancelAnimationFrame(resizeRafRef.current)\n    }\n  }, [])\n\n  // Auto-resize textarea pre-paint to reduce visible flicker\n  useLayoutEffect(() => {\n    resizeTextarea()\n  }, [input, resizeTextarea])\n\n  // NOTE: We intentionally do NOT manipulate page scroll here.\n  // The expanded chat is rendered in a fullscreen portal overlay,\n  // so closing it just removes the overlay and leaves the page\n  // exactly where it was.\n\n  function onComposerKeyDown(event: KeyboardEvent<HTMLTextAreaElement>) {\n    if (event.key === 'Enter' && !event.shiftKey) {\n      event.preventDefault()\n      const form = (event.target as HTMLTextAreaElement).closest('form') as HTMLFormElement | null\n      form?.requestSubmit()\n    }\n  }\n\n  async function handleClear() {\n    try {\n      setLoading(true)\n      setError(null)\n      setMessages([])\n      try { localStorage.removeItem(storageKey) } catch {}\n    } catch (err) {\n      setError((err as Error).message)\n    } finally {\n      setLoading(false)\n    }\n  }\n\n  async function handleSubmit(event: FormEvent<HTMLFormElement>) {\n    event.preventDefault()\n    const text = input.trim()\n    if (!text) {\n      setError('Enter a question to ask the AI.')\n      return\n    }\n    try {\n      setLoading(true)\n      setError(null)\n      stopListening()\n      const nextMessages: ChatMessage[] = [...messages, { role: 'user', content: text }]\n      setMessages(nextMessages)\n      setInput('')\n\n      const url = `/api/analyze-symptoms/chat`\n      const res = await fetch(url, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json', Accept: 'text/event-stream' },\n        body: JSON.stringify({\n          message: text,\n          symptoms,\n          duration,\n          notes,\n          analysisResult,\n        }),\n      })\n\n      if (res.ok && (res.headers.get('content-type') || '').includes('text/event-stream') && res.body) {\n        const reader = res.body.getReader()\n        const decoder = new TextDecoder()\n        let buffer = ''\n        let hasAssistant = false\n        while (true) {\n          const { value, done } = await reader.read()\n          if (done) break\n          buffer += decoder.decode(value, { stream: true })\n          const parts = buffer.split('\\n\\n')\n          buffer = parts.pop() || ''\n          for (const chunk of parts) {\n            if (chunk.startsWith('data: ')) {\n              const token = chunk.slice(6)\n              if (!hasAssistant) {\n                setMessages((prev) => [...prev, { role: 'assistant', content: token }])\n                hasAssistant = true\n              } else {\n                setMessages((prev) => {\n                  const copy = prev.slice()\n                  copy[copy.length - 1] = { role: 'assistant', content: (copy[copy.length - 1] as any).content + token }\n                  return copy\n                })\n              }\n            }\n          }\n        }\n      } else {\n        const data = await res.json().catch(() => null)\n        const textOut = data?.assistant as string | undefined\n        if (textOut) setMessages((prev) => [...prev, { role: 'assistant', content: textOut }])\n      }\n    } catch (err) {\n      setError((err as Error).message)\n    } finally {\n      setLoading(false)\n    }\n  }\n\n  const sectionClass = expanded\n    ? 'fixed inset-0 z-[9999] bg-white flex flex-col h-[100dvh]'\n    : 'bg-white mt-6 overflow-hidden md:rounded-2xl md:border md:shadow-sm relative flex flex-col h-[calc(100vh-140px)] md:h-auto'\n\n  const chatUI = (\n    <section\n      className={sectionClass}\n      style={\n        expanded\n          ? {\n              paddingTop: 'calc(env(safe-area-inset-top, 16px))',\n              paddingBottom: 'env(safe-area-inset-bottom, 0px)',\n            }\n          : undefined\n      }\n    >\n      <header className=\"flex items-center justify-between px-4 py-3 border-b border-gray-200 w-full max-w-3xl mx-auto\">\n        <div>\n          <h3 className=\"text-sm font-semibold text-gray-900\">Chat about your symptom analysis</h3>\n          <p className=\"text-xs text-gray-500\">Ask follow-up questions ‚Äì history saved locally</p>\n        </div>\n        <div className=\"flex items-center gap-2\">\n          <button\n            onClick={handleClear}\n            disabled={loading}\n            className=\"text-xs rounded-md border border-gray-300 px-2 py-1 text-gray-600 hover:bg-gray-50 disabled:opacity-60\"\n          >\n            Reset\n          </button>\n        </div>\n      </header>\n\n      <div\n        ref={containerRef}\n        className={`px-4 py-6 overflow-y-auto overflow-x-hidden space-y-6 min-w-0 w-full max-w-3xl mx-auto ${expanded ? 'flex-1 min-h-0' : 'min-h-[220px]'}`}\n        aria-live=\"polite\"\n        style={{\n          maxWidth: '100%',\n          wordWrap: 'break-word',\n          paddingBottom: expanded ? 'calc(env(safe-area-inset-bottom, 0px) + 96px)' : 'calc(env(safe-area-inset-bottom, 0px) + 96px)',\n        }}\n      >\n        {messages.length === 0 && !loading && (\n          <div className=\"text-sm text-gray-400\">\n            Ask follow‚Äëups like:\n            <div className=\"mt-3 flex flex-wrap gap-2\">\n              {[\n                'What should I do about these red flags?',\n                'Can you explain these likely causes in more detail?',\n                'When should I see a doctor?',\n                'What lifestyle changes can help?',\n              ].map((q) => (\n                <button\n                  key={q}\n                  onClick={() => setInput(q)}\n                  className=\"text-left px-4 py-3 bg-gray-50 hover:bg-gray-100 rounded-xl text-sm text-gray-700 transition-colors\"\n                  type=\"button\"\n                >\n                  {q}\n                </button>\n              ))}\n            </div>\n          </div>\n        )}\n        {messages.map((m, idx) => (\n          <div key={idx} className={`flex gap-4 ${m.role === 'user' ? 'flex-row-reverse' : ''}`}>\n            <div className=\"flex-shrink-0 w-8 h-8 rounded-full bg-gray-200 flex items-center justify-center\">\n              {m.role === 'user' ? (\n                <svg className=\"w-5 h-5 text-gray-600\" fill=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path d=\"M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z\"/>\n                </svg>\n              ) : (\n                <svg className=\"w-5 h-5 text-gray-600\" fill=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path d=\"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z\"/>\n                </svg>\n              )}\n            </div>\n            <div className={`flex-1 min-w-0 ${m.role === 'user' ? 'text-right' : ''}`}>\n              <div className={`inline-block max-w-full px-4 py-2.5 rounded-2xl ${\n                m.role === 'user' \n                  ? 'bg-gray-900 text-white' \n                  : 'bg-gray-100 text-gray-900'\n              }`} style={{ wordWrap: 'break-word', overflowWrap: 'break-word' }}>\n                <div className=\"text-lg leading-relaxed break-words\" style={{ whiteSpace: 'pre-wrap' }}>\n                  {formatChatContent(m.content).split('\\n').map((line, idx) => {\n                    const trimmed = line.trim()\n                    if (!trimmed) {\n                      return <div key={idx} className=\"h-3\" />\n                    }\n                    \n                    if (trimmed.startsWith('**') && trimmed.endsWith('**') && trimmed.length > 4) {\n                      return (\n                        <div key={idx} className=\"font-bold text-gray-900 mb-2 mt-3 first:mt-0\">\n                          {trimmed.slice(2, -2)}\n                        </div>\n                      )\n                    }\n                    \n                    const numberedMatch = trimmed.match(/^(\\d+)\\.\\s+(.+)$/)\n                    if (numberedMatch) {\n                      return (\n                        <div key={idx} className=\"ml-4 mb-1.5\">\n                          <span className=\"font-medium\">{numberedMatch[1]}.</span> {numberedMatch[2]}\n                        </div>\n                      )\n                    }\n                    \n                    const bulletMatch = trimmed.match(/^[-‚Ä¢*]\\s+(.+)$/)\n                    if (bulletMatch) {\n                      return (\n                        <div key={idx} className=\"ml-4 mb-1.5\">\n                          <span className=\"mr-2\">‚Ä¢</span> {bulletMatch[1]}\n                        </div>\n                      )\n                    }\n                    \n                    const parts = trimmed.split(/(\\*\\*.*?\\*\\*)/g)\n                    return (\n                      <div key={idx} className=\"mb-2\">\n                        {parts.map((part, j) => {\n                          if (part.startsWith('**') && part.endsWith('**')) {\n                            return <strong key={j} className=\"font-semibold\">{part.slice(2, -2)}</strong>\n                          }\n                          return <span key={j}>{part}</span>\n                        })}\n                      </div>\n                    )\n                  })}\n                </div>\n              </div>\n            </div>\n          </div>\n        ))}\n        {loading && (\n          <div className=\"flex gap-4\">\n            <div className=\"flex-shrink-0 w-8 h-8 rounded-full bg-gray-200 flex items-center justify-center\">\n              <svg className=\"w-5 h-5 text-gray-600\" fill=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path d=\"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z\"/>\n              </svg>\n            </div>\n            <div className=\"flex-1\">\n              <div className=\"inline-block px-4 py-2.5 rounded-2xl bg-gray-100\">\n                <div className=\"flex gap-1\">\n                  <span className=\"w-2 h-2 bg-gray-400 rounded-full animate-bounce\" style={{ animationDelay: '0ms' }}></span>\n                  <span className=\"w-2 h-2 bg-gray-400 rounded-full animate-bounce\" style={{ animationDelay: '150ms' }}></span>\n                  <span className=\"w-2 h-2 bg-gray-400 rounded-full animate-bounce\" style={{ animationDelay: '300ms' }}></span>\n                </div>\n              </div>\n            </div>\n          </div>\n        )}\n        <div ref={endRef} />\n      </div>\n\n      <form\n        className=\"sticky bottom-0 left-0 right-0 border-t border-gray-200 px-4 py-3 bg-white z-40 shadow-[0_-6px_18px_rgba(0,0,0,0.08)] flex-shrink-0\"\n        onSubmit={handleSubmit}\n        style={{ paddingBottom: 'calc(env(safe-area-inset-bottom, 0px) + 12px)' }}\n      >\n        <div className=\"flex items-center gap-2 w-full max-w-3xl mx-auto\">\n          {recognitionRef.current && (\n            <button\n              type=\"button\"\n              onClick={isListening ? stopListening : startListening}\n              disabled={loading}\n              className={`flex-shrink-0 w-10 h-10 rounded-full flex items-center justify-center transition-colors ${\n                isListening\n                  ? 'bg-red-500 text-white'\n                  : 'bg-gray-100 text-gray-600 hover:bg-gray-200'\n              } disabled:opacity-50 disabled:cursor-not-allowed`}\n              aria-label={isListening ? 'Stop listening' : 'Start voice input'}\n            >\n              {isListening ? (\n                <svg className=\"w-5 h-5\" fill=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path d=\"M12 14c1.66 0 2.99-1.34 2.99-3L15 5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.3-3c0 3-2.54 5.1-5.3 5.1S6.7 14 6.7 11H5c0 3.41 2.72 6.23 6 6.72V21h2v-3.28c3.28-.48 6-3.3 6-6.72h-1.7z\"/>\n                </svg>\n              ) : (\n                <svg className=\"w-5 h-5\" fill=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path d=\"M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z\"/>\n                  <path d=\"M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z\"/>\n                </svg>\n              )}\n            </button>\n          )}\n          <div className=\"flex-1 relative flex items-center\">\n            <textarea\n              ref={textareaRef}\n              value={input}\n              onChange={(event) => {\n                setInput(event.target.value)\n                resizeTextarea()\n              }}\n              onKeyDown={onComposerKeyDown}\n              placeholder={recognitionRef.current ? \"Type or use voice input...\" : \"Message AI about your symptom analysis\"}\n              rows={1}\n              className=\"w-full rounded-2xl border-0 bg-gray-100 px-4 py-3 pr-14 text-[16px] leading-6 text-gray-900 placeholder-gray-500 focus:outline-none focus:ring-0 resize-none transition-all duration-200 min-h-[52px] max-h-[200px]\"\n            />\n            {false && (\n              <button\n                type=\"button\"\n                onClick={(e) => {\n                  e.preventDefault()\n                  e.stopPropagation()\n                  setExpanded((v) => !v)\n                }}\n                className=\"absolute right-14 top-2.5 w-5 h-5 flex items-center justify-center text-gray-500 hover:text-gray-700 transition-colors z-10\"\n                aria-label={expanded ? 'Exit expanded chat view' : 'Expand chat area'}\n              >\n                {expanded ? (\n                  <ArrowsPointingInIcon className=\"w-4 h-4\" />\n                ) : (\n                  <ArrowsPointingOutIcon className=\"w-4 h-4\" />\n                )}\n              </button>\n            )}\n            <button\n              type=\"submit\"\n              disabled={loading || !input.trim() || isListening}\n              className=\"absolute right-2 bottom-2 w-9 h-9 rounded-full bg-gray-900 text-white flex items-center justify-center hover:bg-gray-800 disabled:opacity-50 disabled:cursor-not-allowed transition-colors\"\n              aria-label=\"Send message\"\n            >\n              <svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M12 19l9 2-9-18-9 18 9-2zm0 0v-8\" />\n              </svg>\n            </button>\n          </div>\n        </div>\n        {error && <div className=\"mt-2 text-xs text-red-600\">{error}</div>}\n      </form>\n    </section>\n  )\n\n  // When expanded, render the chat as a true fullscreen overlay\n  // using a portal so it is independent of the page layout.\n  if (expanded && isClient && typeof document !== 'undefined') {\n    return createPortal(chatUI, document.body)\n  }\n\n  return chatUI\n}\n","truncated":false,"size":20144},{"path":"app/terms/page.tsx","content":"'use client'\n\nimport React from 'react';\nimport Image from 'next/image';\nimport Link from 'next/link';\n\nexport default function TermsPage() {\n  return (\n    <div className=\"min-h-screen bg-gray-50\">\n      {/* Navigation Header */}\n      <nav className=\"bg-white border-b border-gray-200 px-4 py-3\">\n        <div className=\"max-w-7xl mx-auto flex justify-between items-center\">\n          {/* Logo on the left */}\n          <div className=\"flex items-center\">\n            <Link href=\"/\" className=\"w-16 h-16 md:w-20 md:h-20 cursor-pointer hover:opacity-80 transition-opacity\">\n              <Image\n                src=\"/mobile-assets/LOGOS/helfi-01-01.png\"\n                alt=\"Helfi Logo\"\n                width={80}\n                height={80}\n                className=\"w-full h-full object-contain\"\n                priority\n              />\n            </Link>\n          </div>\n          \n          {/* Back to Home button on the right */}\n          <div>\n            <Link \n              href=\"/\" \n              className=\"bg-helfi-green text-white px-4 py-2 rounded-lg hover:bg-helfi-green/90 transition-colors font-medium\"\n            >\n              Back to Home\n            </Link>\n          </div>\n        </div>\n      </nav>\n\n      {/* Page Title */}\n      <div className=\"bg-white border-b border-gray-200 px-4 py-4\">\n        <div className=\"max-w-7xl mx-auto text-center\">\n          <h1 className=\"text-lg md:text-xl font-semibold text-gray-900\">Terms of Use</h1>\n          <p className=\"text-sm text-gray-500 hidden sm:block\">Legal terms and conditions for using Helfi</p>\n        </div>\n      </div>\n\n      {/* Main Content */}\n      <div className=\"max-w-4xl mx-auto p-8 bg-white mt-8 rounded-lg shadow-sm\">\n        <div className=\"prose prose-lg max-w-none\">\n          <h1 className=\"text-4xl font-bold text-center mb-2 text-gray-900\">Helfi Terms of Use</h1>\n          <p className=\"text-center text-gray-600 mb-8 text-lg\">Effective Date: [Insert Launch Date]</p>\n          \n          <div className=\"bg-blue-50 border border-blue-200 rounded-lg p-6 mb-8\">\n            <p className=\"text-gray-700 leading-relaxed\">\n              By accessing or using the Helfi app and related services (\"Helfi\", \"we\", \"us\", or \"our\"), you (\"user\", \"you\") agree to be bound by these Terms of Use and our Privacy Policy. Please read them carefully before using the app.\n            </p>\n          </div>\n\n          <div className=\"space-y-8\">\n            <section>\n              <h2 className=\"text-2xl font-bold text-gray-900 mb-4 border-b-2 border-green-500 pb-2\">1. Medical Disclaimer</h2>\n              <p className=\"text-gray-700 leading-relaxed\">\n                Helfi is not a licensed medical provider and does not provide medical advice, diagnosis, or treatment. All content, including AI-generated responses, health reports, symptom analyses, supplement suggestions, and any other information provided by Helfi is for informational purposes only. It should not be relied upon for medical decisions. You must consult a qualified healthcare professional for any medical concerns. Use of Helfi does not create a doctor-patient relationship.\n              </p>\n            </section>\n\n            <section>\n              <h2 className=\"text-2xl font-bold text-gray-900 mb-4 border-b-2 border-green-500 pb-2\">2. User Responsibilities</h2>\n              <ul className=\"text-gray-700 leading-relaxed space-y-2 list-disc pl-6\">\n                <li>You must be at least 18 years of age to use Helfi.</li>\n                <li>You agree to provide accurate, complete, and up-to-date information about yourself and your health.</li>\n                <li>You are solely responsible for any decisions or actions you take based on information provided by Helfi.</li>\n                <li>You understand that supplement-medication contradictions, AI-based symptom guesses, and lifestyle advice are not substitutes for clinical evaluation.</li>\n                <li>Helfi is available internationally. It is your responsibility to ensure that your use of Helfi complies with the laws, regulations, and rules of the country or jurisdiction in which you reside.</li>\n              </ul>\n            </section>\n\n            <section>\n              <h2 className=\"text-2xl font-bold text-gray-900 mb-4 border-b-2 border-green-500 pb-2\">3. Subscription and Payment</h2>\n              <ul className=\"text-gray-700 leading-relaxed space-y-2 list-disc pl-6\">\n                <li>Helfi offers both free and paid subscription plans.</li>\n                <li>Paid features (e.g., AI health reports, symptom analyzer, wearable sync, unlimited goals, AI chatbot) require an active subscription.</li>\n                <li>All payments are billed in AUD and are non-refundable, except as required by law.</li>\n                <li>Subscriptions renew automatically unless canceled.</li>\n              </ul>\n            </section>\n\n            <section>\n              <h2 className=\"text-2xl font-bold text-gray-900 mb-4 border-b-2 border-green-500 pb-2\">4. Content & Data Usage</h2>\n              <ul className=\"text-gray-700 leading-relaxed space-y-2 list-disc pl-6\">\n                <li>By uploading information, images, or descriptions (e.g., supplement bottles, symptoms), you grant us a non-exclusive, royalty-free, worldwide license to use that data for the purpose of providing and improving our services.</li>\n                <li>Helfi uses machine learning and artificial intelligence. Uploaded data may be used anonymously to enhance algorithm performance.</li>\n                <li>We do not sell personal data to third parties. For full data handling terms, refer to our Privacy Policy.</li>\n              </ul>\n            </section>\n\n            <section>\n              <h2 className=\"text-2xl font-bold text-gray-900 mb-4 border-b-2 border-green-500 pb-2\">4a. Laboratory Report PDFs</h2>\n              <p className=\"text-gray-700 leading-relaxed mb-3\">\n                By uploading a laboratory report in PDF format, you represent that you are permitted to provide the report to Helfi for the sole purpose of extracting and analyzing laboratory test results for your personal use.\n              </p>\n              <ul className=\"text-gray-700 leading-relaxed space-y-2 list-disc pl-6\">\n                <li>If your PDF is password-protected and you choose to supply the password, you expressly authorize Helfi to use that password once to decrypt and process the file. We do not store your password.</li>\n                <li>You may choose whether Helfi retains an encrypted copy of your original PDF; by default, we delete the original file after extraction.</li>\n                <li>We may refuse processing of unreadable or corrupted files.</li>\n                <li>Structured lab data (analyte names, values, units, reference ranges, collection dates, accession numbers, and laboratory names) is extracted and encrypted at rest using industry-standard encryption.</li>\n              </ul>\n            </section>\n\n            <section>\n              <h2 className=\"text-2xl font-bold text-gray-900 mb-4 border-b-2 border-green-500 pb-2\">5. Security & Encryption</h2>\n              <p className=\"text-gray-700 leading-relaxed mb-3\">\n                Helfi uses industry-standard encryption to protect sensitive information in transit and at rest. Structured data is encrypted using per-record keys, and retained originals are encrypted with managed key services. If a breach occurs that may cause harm, Helfi will notify affected users and authorities per applicable law.\n              </p>\n            </section>\n\n            <section>\n              <h2 className=\"text-2xl font-bold text-gray-900 mb-4 border-b-2 border-green-500 pb-2\">6. AI Limitations and Liability</h2>\n              <ul className=\"text-gray-700 leading-relaxed space-y-2 list-disc pl-6\">\n                <li>AI suggestions are based on pattern recognition and probability, not clinical assessment.</li>\n                <li>Helfi may occasionally provide incorrect or incomplete information.</li>\n                <li>You agree that Helfi is not liable for any harm, injury, delay, loss, or damage arising from reliance on any content, feature, or AI output.</li>\n                <li>All features are used at your own risk.</li>\n              </ul>\n            </section>\n\n            <section>\n              <h2 className=\"text-2xl font-bold text-gray-900 mb-4 border-b-2 border-green-500 pb-2\">7. Intellectual Property</h2>\n              <ul className=\"text-gray-700 leading-relaxed space-y-2 list-disc pl-6\">\n                <li>All content, design, software, and functionality of the app are owned by Helfi or its licensors.</li>\n                <li>You may not reproduce, distribute, reverse-engineer, or exploit any part of the app without our prior written consent.</li>\n              </ul>\n            </section>\n\n            <section>\n              <h2 className=\"text-2xl font-bold text-gray-900 mb-4 border-b-2 border-green-500 pb-2\">8. Account Termination</h2>\n              <ul className=\"text-gray-700 leading-relaxed space-y-2 list-disc pl-6\">\n                <li>We reserve the right to suspend or terminate accounts that violate these terms, misuse the platform, or engage in unlawful activity.</li>\n                <li>You may cancel your account at any time via your profile settings.</li>\n              </ul>\n            </section>\n\n            <section>\n              <h2 className=\"text-2xl font-bold text-gray-900 mb-4 border-b-2 border-green-500 pb-2\">9. Indemnification</h2>\n              <p className=\"text-gray-700 leading-relaxed\">\n                You agree to defend, indemnify, and hold harmless Helfi, its owners, officers, employees, agents, partners, and affiliates from and against any claims, liabilities, damages, losses, or expenses (including legal fees) arising out of or related to:\n              </p>\n              <ul className=\"text-gray-700 leading-relaxed space-y-2 list-disc pl-6 mt-3\">\n                <li>Your use of the app</li>\n                <li>Any data or content submitted by you</li>\n                <li>Violation of these Terms or applicable laws</li>\n              </ul>\n            </section>\n\n            <section>\n              <h2 className=\"text-2xl font-bold text-gray-900 mb-4 border-b-2 border-green-500 pb-2\">10. Dispute Resolution and Governing Law</h2>\n              <ul className=\"text-gray-700 leading-relaxed space-y-2 list-disc pl-6\">\n                <li>These Terms are governed by the laws of Victoria, Australia, regardless of conflict-of-law principles.</li>\n                <li>Any disputes, claims, or legal proceedings arising from your use of the app shall be resolved exclusively through arbitration or courts located in Melbourne, Victoria, Australia.</li>\n                <li>You expressly waive any right to bring claims in another jurisdiction or to participate in class action proceedings.</li>\n              </ul>\n            </section>\n\n            <section>\n              <h2 className=\"text-2xl font-bold text-gray-900 mb-4 border-b-2 border-green-500 pb-2\">11. Modifications</h2>\n              <p className=\"text-gray-700 leading-relaxed\">\n                We may update these Terms of Use at any time. Continued use of the app after changes are posted constitutes your acceptance.\n              </p>\n            </section>\n\n            <section>\n              <h2 className=\"text-2xl font-bold text-gray-900 mb-4 border-b-2 border-green-500 pb-2\">12. No Emergency Services Clause</h2>\n              <p className=\"text-gray-700 leading-relaxed\">\n                Helfi is not intended for use in emergency situations. Do not use the app to seek or provide help in emergencies. If you are experiencing a medical emergency, call your local emergency number immediately.\n              </p>\n            </section>\n\n            <section>\n              <h2 className=\"text-2xl font-bold text-gray-900 mb-4 border-b-2 border-green-500 pb-2\">13. Limitation of Liability (Expanded)</h2>\n              <p className=\"text-gray-700 leading-relaxed mb-3\">\n                To the fullest extent permitted by applicable law, Helfi and its affiliates shall not be liable for any indirect, incidental, special, consequential, or punitive damages, or for loss of profits, data, use, goodwill, or other intangible losses resulting from:\n              </p>\n              <ul className=\"text-gray-700 leading-relaxed space-y-2 list-disc pl-6\">\n                <li>Your access to or use of or inability to access or use the app;</li>\n                <li>Any conduct or content of any third party on the app;</li>\n                <li>Any content obtained from the app;</li>\n                <li>Unauthorized access, use, or alteration of your transmissions or content.</li>\n              </ul>\n            </section>\n\n            <section>\n              <h2 className=\"text-2xl font-bold text-gray-900 mb-4 border-b-2 border-green-500 pb-2\">14. Force Majeure</h2>\n              <p className=\"text-gray-700 leading-relaxed\">\n                Helfi shall not be held liable for any failure or delay in performance caused by circumstances beyond its reasonable control, including but not limited to acts of God, natural disasters, war, terrorism, labor conditions, power failures, internet disturbances, cyberattacks, or government actions.\n              </p>\n            </section>\n\n            <section>\n              <h2 className=\"text-2xl font-bold text-gray-900 mb-4 border-b-2 border-green-500 pb-2\">15. Severability</h2>\n              <p className=\"text-gray-700 leading-relaxed\">\n                If any provision of these Terms is found to be unlawful, void, or unenforceable for any reason, that provision shall be deemed severable and shall not affect the validity or enforceability of the remaining provisions.\n              </p>\n            </section>\n\n            <section>\n              <h2 className=\"text-2xl font-bold text-gray-900 mb-4 border-b-2 border-green-500 pb-2\">16. Export Control</h2>\n              <p className=\"text-gray-700 leading-relaxed\">\n                You agree not to use, export, or re-export the app except as authorized by the laws of Australia and the laws of the jurisdiction in which the app was obtained. You represent and warrant that you are not located in any country subject to Australian government embargo or listed on any government list of prohibited or restricted parties.\n              </p>\n            </section>\n\n            <section>\n              <h2 className=\"text-2xl font-bold text-gray-900 mb-4 border-b-2 border-green-500 pb-2\">17. Assignment</h2>\n              <p className=\"text-gray-700 leading-relaxed\">\n                You may not assign or transfer your rights or obligations under these Terms without our prior written consent. We may freely assign or transfer these Terms without restriction.\n              </p>\n            </section>\n          </div>\n\n          <div className=\"bg-green-50 border border-green-200 rounded-lg p-6 mt-12\">\n            <p className=\"text-gray-700 leading-relaxed font-medium\">\n              By checking the box \"I agree to the Terms of Use\" during registration, you confirm you have read, understood, and agreed to all provisions above. If you do not agree, do not use the app.\n            </p>\n          </div>\n\n          <div className=\"text-center mt-8 pt-8 border-t border-gray-200\">\n            <p className=\"text-gray-600\">\n              For questions or legal inquiries, please contact us at: <a href=\"mailto:support@helfi.ai\" className=\"text-green-600 hover:text-green-800 font-medium\">support@helfi.ai</a>\n            </p>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n} ","truncated":false,"size":15715},{"path":"app/test-interactions/page.tsx","content":"'use client';\n\nimport InteractionAnalysis from '../../components/InteractionAnalysis';\n\nconst sampleAnalysis = {\n  overallRisk: 'low' as const,\n  interactions: [\n    {\n      substance1: 'Lisinopril',\n      substance2: 'Omega-3 Fish Oil',\n      severity: 'low' as const,\n      description: 'Omega-3 fatty acids can potentially lower blood pressure, which might enhance the blood pressure lowering effect of Lisinopril. However, this interaction is generally considered minor and may even be beneficial.',\n      recommendation: 'Monitor your blood pressure regularly. If you experience symptoms like dizziness, lightheadedness, fainting, and/or changes in pulse or heart rate, contact your healthcare provider.',\n      timingAdjustment: 'No adjustment needed'\n    },\n    {\n      substance1: 'Metformin',\n      substance2: 'Vitamin D3',\n      severity: 'low' as const,\n      description: 'Vitamin D3 does not directly interact with Metformin. However, Vitamin D deficiency has been associated with insulin resistance, which Metformin is used to treat.',\n      recommendation: 'Maintain a consistent intake of Vitamin D3. If you have concerns about your Vitamin D levels, discuss with your healthcare provider.',\n      timingAdjustment: 'No adjustment needed'\n    }\n  ],\n  timingOptimization: {\n    morning: ['Vitamin D3', 'Omega-3 Fish Oil', 'Lisinopril', 'Metformin'],\n    afternoon: [],\n    evening: ['Metformin'],\n    beforeBed: []\n  },\n  generalRecommendations: [\n    'Continue taking your medications and supplements as prescribed. Regular monitoring of your health and blood pressure is recommended. Always inform your healthcare provider about all the medications and supplements you are taking.'\n  ],\n  disclaimer: 'This analysis is based on current scientific research and should not replace professional medical advice. Always consult with your healthcare provider before making any changes to your medication or supplement regimen.',\n  analysisDate: new Date().toISOString(),\n  supplementCount: 2,\n  medicationCount: 2\n};\n\nexport default function TestInteractionsPage() {\n  return (\n    <div className=\"min-h-screen bg-gray-50 py-8\">\n      <div className=\"max-w-6xl mx-auto px-4\">\n        <div className=\"mb-8\">\n          <h1 className=\"text-3xl font-bold text-gray-900 mb-2\">\n            Interaction Analysis Test Page\n          </h1>\n          <p className=\"text-gray-600\">\n            Testing the interaction analysis component with sample data\n          </p>\n        </div>\n        \n        <InteractionAnalysis \n          analysis={sampleAnalysis}\n          onContinue={() => alert('Continue clicked!')}\n          onBack={() => alert('Back clicked!')}\n        />\n      </div>\n    </div>\n  );\n} ","truncated":false,"size":2707},{"path":"components/ConfirmationModal.tsx","content":"import React from 'react'\n\ninterface ConfirmationModalProps {\n  isOpen: boolean\n  onClose: () => void\n  onConfirm: () => void\n  title: string\n  message: string\n  confirmText?: string\n  cancelText?: string\n  confirmButtonClass?: string\n  isLoading?: boolean\n}\n\nconst ConfirmationModal: React.FC<ConfirmationModalProps> = ({\n  isOpen,\n  onClose,\n  onConfirm,\n  title,\n  message,\n  confirmText = 'Confirm',\n  cancelText = 'Cancel',\n  confirmButtonClass = 'bg-red-500 hover:bg-red-600',\n  isLoading = false\n}) => {\n  if (!isOpen) return null\n\n  return (\n    <div className=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4\">\n      <div className=\"bg-white rounded-lg shadow-xl max-w-md w-full mx-4\">\n        <div className=\"p-6\">\n          <h2 className=\"text-xl font-bold text-gray-900 mb-4\">{title}</h2>\n          <p className=\"text-gray-600 mb-6\">{message}</p>\n          <div className=\"flex justify-end space-x-3\">\n            <button\n              onClick={onClose}\n              disabled={isLoading}\n              className=\"px-4 py-2 text-gray-700 bg-gray-100 rounded-lg hover:bg-gray-200 transition-colors disabled:opacity-50 disabled:cursor-not-allowed\"\n            >\n              {cancelText}\n            </button>\n            <button\n              onClick={onConfirm}\n              disabled={isLoading}\n              className={`px-4 py-2 text-white rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed ${confirmButtonClass}`}\n            >\n              {isLoading ? 'Processing...' : confirmText}\n            </button>\n          </div>\n        </div>\n      </div>\n    </div>\n  )\n}\n\nexport default ConfirmationModal\n\n\n","truncated":false,"size":1681},{"path":"components/CreditPurchaseModal.tsx","content":"import React from 'react';\n\ninterface CreditInfo {\n  dailyUsed: number;\n  dailyLimit: number;\n  additionalCredits: number;\n  plan: string;\n  creditCost?: number;\n  featureUsageToday?: {\n    foodAnalysis: number;\n    interactionAnalysis: number;\n  };\n  dailyLimits?: {\n    total: number;\n    foodAnalysis: number;\n    interactionAnalysis: number;\n  };\n}\n\ninterface CreditPurchaseModalProps {\n  isOpen: boolean;\n  onClose: () => void;\n  creditInfo: CreditInfo;\n}\n\nconst CreditPurchaseModal: React.FC<CreditPurchaseModalProps> = ({ \n  isOpen, \n  onClose, \n  creditInfo \n}) => {\n  if (!isOpen) return null;\n\n  const handlePurchase = (creditPackage: string) => {\n    // For now, redirect to billing page\n    // In a real implementation, this would integrate with payment processor\n    window.location.href = '/billing';\n  };\n\n  return (\n    <div className=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50\">\n      <div className=\"bg-white rounded-lg p-6 max-w-md w-full mx-4\">\n        <div className=\"flex justify-between items-center mb-4\">\n          <h2 className=\"text-xl font-bold text-gray-900\">\n            Analysis Quota Exceeded\n          </h2>\n          <button\n            onClick={onClose}\n            className=\"text-gray-400 hover:text-gray-600\"\n          >\n            ‚úï\n          </button>\n        </div>\n\n        <div className=\"mb-6\">\n          {/* Free account notice */}\n          {creditInfo.plan !== 'PREMIUM' && (\n            <div className=\"bg-blue-50 border border-blue-200 rounded-lg p-4 mb-4\">\n              <p className=\"text-sm text-blue-800\">\n                With a free account, you can try each AI feature once. If you've already\n                used the free analysis for this feature, please upgrade to Premium or buy\n                credits to continue.\n              </p>\n            </div>\n          )}\n\n          <div className=\"bg-yellow-50 border border-yellow-200 rounded-lg p-4 mb-4\">\n            <div className=\"flex items-center\">\n              <div className=\"flex-shrink-0\">\n                <svg className=\"h-5 w-5 text-yellow-400\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n                  <path fillRule=\"evenodd\" d=\"M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z\" clipRule=\"evenodd\" />\n                </svg>\n              </div>\n              <div className=\"ml-3\">\n                <h3 className=\"text-sm font-medium text-yellow-800\">\n                  Insufficient Credits\n                </h3>\n                <p className=\"text-sm text-yellow-700 mt-1\">\n                  You need {creditInfo.creditCost || 1} credits for this analysis.\n                  You've used {creditInfo.dailyUsed} of {creditInfo.dailyLimit} daily credits.\n                  {creditInfo.additionalCredits > 0 \n                    ? ` You have ${creditInfo.additionalCredits} additional credits remaining.`\n                    : ' You have no additional credits remaining.'\n                  }\n                </p>\n              </div>\n            </div>\n          </div>\n\n          <div className=\"text-sm text-gray-600 mb-4\">\n            <strong>Current Plan:</strong> {creditInfo.plan}\n          </div>\n\n          {/* Feature-specific usage breakdown */}\n          {creditInfo.featureUsageToday && (\n            <div className=\"bg-gray-50 border border-gray-200 rounded-lg p-4 mb-4\">\n              <h4 className=\"font-medium text-gray-900 mb-2\">Today's Feature Usage</h4>\n              <div className=\"space-y-2 text-sm\">\n                <div className=\"flex justify-between\">\n                  <span className=\"text-gray-700\">Food Analysis (1 credit each):</span>\n                  <span className=\"font-medium text-gray-900\">{creditInfo.featureUsageToday.foodAnalysis}</span>\n                </div>\n                <div className=\"flex justify-between\">\n                  <span className=\"text-gray-700\">Interaction Analysis (3 credits each):</span>\n                  <span className=\"font-medium text-gray-900\">{creditInfo.featureUsageToday.interactionAnalysis}</span>\n                </div>\n              </div>\n            </div>\n          )}\n\n          {/* Show upgrade option for non-subscribed users */}\n          {creditInfo.plan !== 'PREMIUM' && (\n            <div className=\"bg-blue-50 border border-blue-200 rounded-lg p-4 mb-4\">\n              <h4 className=\"font-medium text-blue-900 mb-2\">\n                Upgrade to Premium\n              </h4>\n              <p className=\"text-sm text-blue-800 mb-3\">\n                Get monthly credits plus unlimited additional credits. Perfect for both food analysis and interaction analysis.\n              </p>\n              <button\n                onClick={() => handlePurchase('premium')}\n                className=\"w-full bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700 transition-colors\"\n              >\n                View Premium Plans\n              </button>\n            </div>\n          )}\n\n          <div className=\"space-y-3\">\n            <h4 className=\"font-medium text-gray-900\">\n              Purchase Additional Credits\n            </h4>\n            \n            <div className=\"grid grid-cols-1 gap-3\">\n              <button\n                onClick={() => handlePurchase('credits-100')}\n                className=\"flex justify-between items-center p-3 border border-gray-200 rounded-lg hover:bg-gray-50 transition-colors\"\n              >\n                <div>\n                  <div className=\"font-medium text-gray-900\">100 Credits</div>\n                  <div className=\"text-sm text-gray-500\">Never expire</div>\n                </div>\n                <div className=\"text-lg font-bold text-green-600\">$5</div>\n              </button>\n              \n              <button\n                onClick={() => handlePurchase('credits-150')}\n                className=\"flex justify-between items-center p-3 border border-gray-200 rounded-lg hover:bg-gray-50 transition-colors\"\n              >\n                <div>\n                  <div className=\"font-medium text-gray-900\">150 Credits</div>\n                  <div className=\"text-sm text-gray-500\">Never expire ‚Ä¢ Best Value</div>\n                </div>\n                <div className=\"text-lg font-bold text-green-600\">$10</div>\n              </button>\n            </div>\n          </div>\n        </div>\n\n        <div className=\"flex justify-end space-x-3\">\n          <button\n            onClick={onClose}\n            className=\"px-4 py-2 text-gray-600 hover:text-gray-800 transition-colors\"\n          >\n            Cancel\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default CreditPurchaseModal; ","truncated":false,"size":6773},{"path":"components/devices/FitbitCharts.tsx","content":"'use client'\n\nimport React, { useEffect, useMemo, useState } from 'react'\nimport {\n  Chart as ChartJS,\n  CategoryScale,\n  LinearScale,\n  PointElement,\n  LineElement,\n  Tooltip,\n  Legend,\n  TimeScale,\n} from 'chart.js'\nimport 'chartjs-adapter-date-fns'\nimport { Line } from 'react-chartjs-2'\n\nChartJS.register(CategoryScale, LinearScale, PointElement, LineElement, Tooltip, Legend, TimeScale)\n\ntype SeriesResponse = {\n  success: boolean\n  range: { start: string; end: string }\n  series: {\n    steps: Array<{ date: string; steps?: number }>\n    heartrate: Array<{ date: string; restingHeartRate?: number }>\n    sleep: Array<{ date: string; minutes?: number }>\n    weight: Array<{ date: string; weightKg?: number }>\n  }\n}\n\nfunction toDataset(\n  xs: string[],\n  ys: (number | undefined)[],\n  color: string,\n  label: string\n) {\n  return {\n    labels: xs,\n    datasets: [\n      {\n        label,\n        data: ys.map((v) => (typeof v === 'number' ? v : null)),\n        fill: false,\n        borderColor: color,\n        backgroundColor: color,\n        tension: 0.25,\n        spanGaps: true,\n      },\n    ],\n  }\n}\n\nconst baseOptions = {\n  responsive: true,\n  maintainAspectRatio: false,\n  interaction: { mode: 'index' as const, intersect: false },\n  plugins: { legend: { display: false } },\n  scales: {\n    x: { type: 'time' as const, time: { unit: 'day' as const } },\n    y: { beginAtZero: true },\n  },\n}\n\nexport default function FitbitCharts({ rangeDays = 30 }: { rangeDays?: number }) {\n  const [data, setData] = useState<SeriesResponse | null>(null)\n  const [loading, setLoading] = useState(false)\n  const [error, setError] = useState<string | null>(null)\n\n  useEffect(() => {\n    const fetchData = async () => {\n      setLoading(true)\n      setError(null)\n      try {\n        const end = new Date()\n        const start = new Date()\n        start.setDate(end.getDate() - (rangeDays - 1))\n        const startStr = start.toISOString().slice(0, 10)\n        const endStr = end.toISOString().slice(0, 10)\n        const res = await fetch(`/api/fitbit/data?start=${startStr}&end=${endStr}`)\n        if (!res.ok) throw new Error('Failed to load Fitbit data')\n        setData((await res.json()) as SeriesResponse)\n      } catch (e: any) {\n        setError(e?.message || 'Failed to load data')\n      } finally {\n        setLoading(false)\n      }\n    }\n    fetchData()\n  }, [rangeDays])\n\n  const xs = useMemo(() => (data ? data.series.steps.map((s) => s.date) : []), [data])\n  const steps = useMemo(() => (data ? data.series.steps.map((s) => s.steps ?? undefined) : []), [data])\n  const rhr = useMemo(\n    () => (data ? data.series.heartrate.map((s) => s.restingHeartRate ?? undefined) : []),\n    [data]\n  )\n  const sleepMin = useMemo(\n    () => (data ? data.series.sleep.map((s) => s.minutes ?? undefined) : []),\n    [data]\n  )\n  const weightKg = useMemo(\n    () => (data ? data.series.weight.map((s) => s.weightKg ?? undefined) : []),\n    [data]\n  )\n\n  if (loading) {\n    return <div className=\"h-64 rounded-xl border bg-white animate-pulse\" />\n  }\n  if (error) {\n    return (\n      <div className=\"p-4 rounded-xl border bg-red-50 border-red-200 text-red-700 text-sm\">\n        {error}\n      </div>\n    )\n  }\n  if (!data) return null\n\n  // Check if we have any data at all\n  const hasData = data.series.steps.some(s => s.steps != null) ||\n                  data.series.heartrate.some(h => h.restingHeartRate != null) ||\n                  data.series.sleep.some(s => s.minutes != null) ||\n                  data.series.weight.some(w => w.weightKg != null)\n\n  if (!hasData) {\n    return (\n      <div className=\"p-4 rounded-xl border bg-gray-50 border-gray-200 text-gray-600 text-sm\">\n        No Fitbit data available yet. Connect your Fitbit and sync data, or load demo data to see charts.\n      </div>\n    )\n  }\n\n  return (\n    <div className=\"grid grid-cols-1 lg:grid-cols-2 gap-6\">\n      <div className=\"p-4 rounded-xl border bg-white h-72\">\n        <div className=\"text-sm text-gray-600 mb-2\">Steps per day</div>\n        <Line data={toDataset(xs, steps, '#10b981', 'Steps')} options={baseOptions as any} />\n      </div>\n\n      <div className=\"p-4 rounded-xl border bg-white h-72\">\n        <div className=\"text-sm text-gray-600 mb-2\">Resting heart rate</div>\n        <Line data={toDataset(xs, rhr, '#3b82f6', 'Resting HR')} options={baseOptions as any} />\n      </div>\n\n      <div className=\"p-4 rounded-xl border bg-white h-72\">\n        <div className=\"text-sm text-gray-600 mb-2\">Sleep minutes</div>\n        <Line data={toDataset(xs, sleepMin, '#a855f7', 'Sleep (min)')} options={baseOptions as any} />\n      </div>\n\n      <div className=\"p-4 rounded-xl border bg-white h-72\">\n        <div className=\"text-sm text-gray-600 mb-2\">Weight (kg)</div>\n        <Line data={toDataset(xs, weightKg, '#f59e0b', 'Weight')} options={baseOptions as any} />\n      </div>\n    </div>\n  )\n}\n\n\n","truncated":false,"size":4864},{"path":"components/devices/FitbitCorrelations.tsx","content":"'use client'\n\nimport React, { useEffect, useMemo, useState } from 'react'\n\ntype FitbitSeries = {\n  success: boolean\n  range: { start: string; end: string }\n  series: {\n    steps: Array<{ date: string; steps?: number }>\n    sleep: Array<{ date: string; minutes?: number }>\n  }\n}\n\ntype CheckinRow = { date: string; issueId: string; name: string; polarity: 'positive' | 'negative'; value: number | null; note?: string }\ntype CheckinHistory = { history: CheckinRow[] }\ntype MoodEntry = { localDate: string; mood: number }\ntype MoodHistory = { entries: MoodEntry[] }\n\nfunction pearson(x: number[], y: number[]): number | null {\n  const n = Math.min(x.length, y.length)\n  if (n < 3) return null\n  let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0, sumYY = 0, k = 0\n  for (let i = 0; i < n; i++) {\n    const xi = x[i]\n    const yi = y[i]\n    if (xi == null || yi == null || isNaN(xi) || isNaN(yi)) continue\n    k++\n    sumX += xi\n    sumY += yi\n    sumXY += xi * yi\n    sumXX += xi * xi\n    sumYY += yi * yi\n  }\n  if (k < 3) return null\n  const cov = sumXY - (sumX * sumY) / k\n  const varX = sumXX - (sumX * sumX) / k\n  const varY = sumYY - (sumY * sumY) / k\n  if (varX <= 0 || varY <= 0) return null\n  return cov / Math.sqrt(varX * varY)\n}\n\nfunction strengthLabel(r: number | null): string {\n  if (r == null) return 'No correlation'\n  const a = Math.abs(r)\n  if (a >= 0.7) return `Strong (${r.toFixed(2)})`\n  if (a >= 0.4) return `Moderate (${r.toFixed(2)})`\n  if (a >= 0.2) return `Weak (${r.toFixed(2)})`\n  return `Very weak (${r.toFixed(2)})`\n}\n\nexport default function FitbitCorrelations({ rangeDays = 30 }: { rangeDays?: number }) {\n  const [fitbit, setFitbit] = useState<FitbitSeries | null>(null)\n  const [checkins, setCheckins] = useState<CheckinHistory | null>(null)\n  const [mood, setMood] = useState<MoodHistory | null>(null)\n  const [loading, setLoading] = useState(false)\n  const [error, setError] = useState<string | null>(null)\n\n  useEffect(() => {\n    const load = async () => {\n      setLoading(true)\n      setError(null)\n      try {\n        // Fitbit\n        const end = new Date()\n        const start = new Date()\n        start.setDate(end.getDate() - (rangeDays - 1))\n        const startStr = start.toISOString().slice(0, 10)\n        const endStr = end.toISOString().slice(0, 10)\n        const fbRes = await fetch(`/api/fitbit/data?start=${startStr}&end=${endStr}&dataTypes=steps,sleep`)\n        if (!fbRes.ok) throw new Error('Failed to load Fitbit data')\n        setFitbit((await fbRes.json()) as FitbitSeries)\n        // Mood (preferred)\n        const moodRes = await fetch(`/api/mood/entries?start=${startStr}&end=${endStr}`)\n        if (moodRes.ok) setMood((await moodRes.json()) as MoodHistory)\n        // Checkins\n        const ciRes = await fetch(`/api/checkins/history?start=${startStr}&end=${endStr}`)\n        if (!ciRes.ok) throw new Error('Failed to load check-ins')\n        setCheckins((await ciRes.json()) as CheckinHistory)\n      } catch (e: any) {\n        setError(e?.message || 'Failed to load correlations')\n      } finally {\n        setLoading(false)\n      }\n    }\n    load()\n  }, [rangeDays])\n\n  const dailyMood = useMemo(() => {\n    const map = new Map<string, number[]>()\n    const moodEntries = (mood as any)?.entries\n    if (Array.isArray(moodEntries) && moodEntries.length > 0) {\n      for (const row of moodEntries as MoodEntry[]) {\n        const d = String(row.localDate || '').slice(0, 10)\n        const v = Number(row.mood)\n        if (!d || !Number.isFinite(v)) continue\n        // Align to 0..6 range used elsewhere.\n        const scaled = Math.max(0, Math.min(6, v - 1))\n        if (!map.has(d)) map.set(d, [])\n        map.get(d)!.push(scaled)\n      }\n    } else if (checkins?.history) {\n      for (const row of checkins.history) {\n        const d = row.date.slice(0, 10)\n        const v = row.value ?? 0\n        if (!map.has(d)) map.set(d, [])\n        map.get(d)!.push(v)\n      }\n    }\n    const avg = new Map<string, number>()\n    map.forEach((arr, d) => {\n      const mean = arr.length ? arr.reduce((a, b) => a + b, 0) / arr.length : 0\n      avg.set(d, mean)\n    })\n    return avg\n  }, [checkins, mood])\n\n  const series = useMemo(() => {\n    if (!fitbit) return null\n    const steps = fitbit.series.steps.map((s) => s.steps ?? 0)\n    const sleepHrs = fitbit.series.sleep.map((s) => (s.minutes ?? 0) / 60)\n    const xs = fitbit.series.steps.map((s) => s.date)\n    const mood = xs.map((d) => dailyMood.get(d) ?? null)\n    const stepsMood = pearson(steps, mood.map((v) => (v == null ? NaN : v)) as number[])\n    const sleepMood = pearson(sleepHrs, mood.map((v) => (v == null ? NaN : v)) as number[])\n\n    // Find low-sleep + low-mood days\n    const flagged: Array<{ date: string; sleepHrs: number; mood: number | null }> = []\n    xs.forEach((d, i) => {\n      const sh = sleepHrs[i]\n      const m = mood[i]\n      if (sh > 0 && sh < 6 && (m == null || m < 3)) {\n        flagged.push({ date: d, sleepHrs: sh, mood: m })\n      }\n    })\n\n    return {\n      stepsMood,\n      sleepMood,\n      flagged: flagged.slice(0, 5),\n    }\n  }, [fitbit, dailyMood])\n\n  if (loading) {\n    return <div className=\"rounded-xl border bg-white p-4 animate-pulse h-40\" />\n  }\n  if (error) {\n    return (\n      <div className=\"p-4 rounded-xl border bg-red-50 border-red-200 text-red-700 text-sm\">\n        {error}\n      </div>\n    )\n  }\n  if (!fitbit || !series) return null\n\n  // Check if we have any Fitbit data\n  const hasFitbitData = fitbit.series.steps.some(s => s.steps != null) ||\n                        fitbit.series.sleep.some(s => s.minutes != null)\n  \n  if (!hasFitbitData) {\n    return (\n      <div className=\"p-4 rounded-xl border bg-gray-50 border-gray-200 text-gray-600 text-sm\">\n        No Fitbit data available yet. Connect your Fitbit and sync data, or load demo data to see correlations.\n      </div>\n    )\n  }\n\n  return (\n    <div className=\"rounded-xl border bg-white p-4\">\n      <div className=\"flex flex-col md:flex-row md:items-center md:justify-between gap-3\">\n        <div>\n          <div className=\"text-sm text-gray-500\">Correlations (last {rangeDays} days)</div>\n          <div className=\"text-lg font-semibold text-gray-900\">How your activity and sleep relate to mood</div>\n        </div>\n      </div>\n\n      <div className=\"grid grid-cols-1 sm:grid-cols-2 gap-4 mt-4\">\n        <div className=\"p-4 rounded-lg border\">\n          <div className=\"text-sm text-gray-500\">Steps ‚ÜîÔ∏é Mood</div>\n          <div className=\"text-xl font-semibold mt-1\">{strengthLabel(series.stepsMood)}</div>\n          <p className=\"text-xs text-gray-500 mt-1\">Correlation uses daily steps and your daily mood check-ins (or check-in ratings if mood is empty).</p>\n        </div>\n        <div className=\"p-4 rounded-lg border\">\n          <div className=\"text-sm text-gray-500\">Sleep ‚ÜîÔ∏é Mood</div>\n          <div className=\"text-xl font-semibold mt-1\">{strengthLabel(series.sleepMood)}</div>\n          <p className=\"text-xs text-gray-500 mt-1\">Correlation uses total sleep hours per night vs. your daily mood check-ins.</p>\n        </div>\n      </div>\n\n      {series.flagged.length > 0 && (\n        <div className=\"mt-4\">\n          <div className=\"text-sm text-gray-600 mb-2\">Recent low sleep + low mood days</div>\n          <div className=\"rounded-lg border overflow-hidden\">\n            <table className=\"min-w-full text-sm\">\n              <thead className=\"bg-gray-50\">\n                <tr>\n                  <th className=\"px-3 py-2 text-left text-gray-600 font-medium\">Date</th>\n                  <th className=\"px-3 py-2 text-left text-gray-600 font-medium\">Sleep</th>\n                  <th className=\"px-3 py-2 text-left text-gray-600 font-medium\">Avg Mood</th>\n                </tr>\n              </thead>\n              <tbody>\n                {series.flagged.map((row) => (\n                  <tr key={row.date} className=\"border-t\">\n                    <td className=\"px-3 py-2\">{row.date}</td>\n                    <td className=\"px-3 py-2\">{row.sleepHrs.toFixed(1)} h</td>\n                    <td className=\"px-3 py-2\">{row.mood == null ? 'N/A' : row.mood.toFixed(2)}</td>\n                  </tr>\n                ))}\n              </tbody>\n            </table>\n          </div>\n        </div>\n      )}\n    </div>\n  )\n}\n","truncated":false,"size":8252},{"path":"components/devices/FitbitSummary.tsx","content":"'use client'\n\nimport React, { useEffect, useMemo, useState } from 'react'\n\ntype SeriesResponse = {\n  success: boolean\n  range: { start: string; end: string }\n  series: {\n    steps: Array<{ date: string; steps?: number; calories?: number; distanceKm?: number }>\n    heartrate: Array<{ date: string; restingHeartRate?: number }>\n    sleep: Array<{ date: string; minutes?: number; efficiency?: number }>\n    weight: Array<{ date: string; weightKg?: number }>\n  }\n}\n\nexport default function FitbitSummary({ rangeDays = 7 }: { rangeDays?: number }) {\n  const [data, setData] = useState<SeriesResponse | null>(null)\n  const [loading, setLoading] = useState(false)\n  const [error, setError] = useState<string | null>(null)\n\n  useEffect(() => {\n    const fetchData = async () => {\n      setLoading(true)\n      setError(null)\n      try {\n        const end = new Date()\n        const start = new Date()\n        start.setDate(end.getDate() - (rangeDays - 1))\n        const startStr = start.toISOString().slice(0, 10)\n        const endStr = end.toISOString().slice(0, 10)\n        const res = await fetch(`/api/fitbit/data?start=${startStr}&end=${endStr}`)\n        if (!res.ok) throw new Error('Failed to load Fitbit data')\n        const json = (await res.json()) as SeriesResponse\n        setData(json)\n      } catch (e: any) {\n        setError(e?.message || 'Failed to load data')\n      } finally {\n        setLoading(false)\n      }\n    }\n    fetchData()\n  }, [rangeDays])\n\n  const today = useMemo(() => {\n    if (!data) return null\n    const lastIdx = data.series.steps.length - 1\n    return {\n      steps: data.series.steps[lastIdx]?.steps,\n      calories: data.series.steps[lastIdx]?.calories,\n      distanceKm: data.series.steps[lastIdx]?.distanceKm,\n      rhr: data.series.heartrate[data.series.heartrate.length - 1]?.restingHeartRate,\n      sleepMin: data.series.sleep[data.series.sleep.length - 1]?.minutes,\n      weightKg: data.series.weight[data.series.weight.length - 1]?.weightKg,\n    }\n  }, [data])\n\n  if (loading) {\n    return (\n      <div className=\"grid grid-cols-1 md:grid-cols-3 gap-4\">\n        <div className=\"p-4 rounded-xl border bg-white\">\n          <div className=\"animate-pulse h-6 w-24 bg-gray-200 rounded mb-2\" />\n          <div className=\"animate-pulse h-8 w-32 bg-gray-200 rounded\" />\n        </div>\n        <div className=\"p-4 rounded-xl border bg-white\">\n          <div className=\"animate-pulse h-6 w-24 bg-gray-200 rounded mb-2\" />\n          <div className=\"animate-pulse h-8 w-32 bg-gray-200 rounded\" />\n        </div>\n        <div className=\"p-4 rounded-xl border bg-white\">\n          <div className=\"animate-pulse h-6 w-24 bg-gray-200 rounded mb-2\" />\n          <div className=\"animate-pulse h-8 w-32 bg-gray-200 rounded\" />\n        </div>\n      </div>\n    )\n  }\n\n  if (error) {\n    return (\n      <div className=\"p-4 rounded-xl border bg-red-50 border-red-200 text-red-700 text-sm\">\n        {error}\n      </div>\n    )\n  }\n\n  if (!data) return null\n\n  // Check if we have any data at all\n  const hasData = data.series.steps.some(s => s.steps != null) ||\n                  data.series.heartrate.some(h => h.restingHeartRate != null) ||\n                  data.series.sleep.some(s => s.minutes != null) ||\n                  data.series.weight.some(w => w.weightKg != null)\n\n  if (!hasData) {\n    return (\n      <div className=\"p-4 rounded-xl border bg-gray-50 border-gray-200 text-gray-600 text-sm\">\n        No Fitbit data available yet. Connect your Fitbit and sync data, or load demo data to see how it looks.\n      </div>\n    )\n  }\n\n  const km = today?.distanceKm != null ? today.distanceKm.toFixed(2) : '‚Äî'\n  const steps = today?.steps != null ? today.steps.toLocaleString() : '‚Äî'\n  const rhr = today?.rhr != null ? `${today.rhr} bpm` : '‚Äî'\n  const sleepHrs = today?.sleepMin != null ? (today.sleepMin / 60).toFixed(1) + ' h' : '‚Äî'\n  const weight = today?.weightKg != null ? `${today.weightKg.toFixed(1)} kg` : '‚Äî'\n\n  return (\n    <div className=\"grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4\">\n      <div className=\"p-4 rounded-xl border bg-white\">\n        <div className=\"text-sm text-gray-500\">Steps Today</div>\n        <div className=\"text-2xl font-semibold mt-1\">{steps}</div>\n        <div className=\"text-xs text-gray-500 mt-1\">Distance: {km}</div>\n      </div>\n      <div className=\"p-4 rounded-xl border bg-white\">\n        <div className=\"text-sm text-gray-500\">Resting Heart Rate</div>\n        <div className=\"text-2xl font-semibold mt-1\">{rhr}</div>\n      </div>\n      <div className=\"p-4 rounded-xl border bg-white\">\n        <div className=\"text-sm text-gray-500\">Sleep (last night)</div>\n        <div className=\"text-2xl font-semibold mt-1\">{sleepHrs}</div>\n      </div>\n      <div className=\"p-4 rounded-xl border bg-white\">\n        <div className=\"text-sm text-gray-500\">Weight (latest)</div>\n        <div className=\"text-2xl font-semibold mt-1\">{weight}</div>\n      </div>\n    </div>\n  )\n}\n\n\n","truncated":false,"size":4947},{"path":"components/devices/GarminCharts.tsx","content":"'use client'\n\nimport React, { useEffect, useMemo, useState } from 'react'\nimport {\n  Chart as ChartJS,\n  CategoryScale,\n  LinearScale,\n  PointElement,\n  LineElement,\n  Tooltip,\n  Legend,\n  TimeScale,\n} from 'chart.js'\nimport 'chartjs-adapter-date-fns'\nimport { Line } from 'react-chartjs-2'\n\nChartJS.register(CategoryScale, LinearScale, PointElement, LineElement, Tooltip, Legend, TimeScale)\n\ntype SeriesResponse = {\n  success: boolean\n  range: { start: string; end: string }\n  series: {\n    steps: Array<{ date: string; steps?: number }>\n    heartrate: Array<{ date: string; restingHeartRate?: number }>\n    sleep: Array<{ date: string; minutes?: number }>\n    weight: Array<{ date: string; weightKg?: number }>\n  }\n}\n\nfunction toDataset(xs: string[], ys: (number | undefined)[], color: string, label: string) {\n  return {\n    labels: xs,\n    datasets: [\n      {\n        label,\n        data: ys.map((v) => (typeof v === 'number' ? v : null)),\n        fill: false,\n        borderColor: color,\n        backgroundColor: color,\n        tension: 0.25,\n        spanGaps: true,\n      },\n    ],\n  }\n}\n\nconst baseOptions = {\n  responsive: true,\n  maintainAspectRatio: false,\n  interaction: { mode: 'index' as const, intersect: false },\n  plugins: { legend: { display: false } },\n  scales: {\n    x: { type: 'time' as const, time: { unit: 'day' as const } },\n    y: { beginAtZero: true },\n  },\n}\n\nexport default function GarminCharts({ rangeDays = 30 }: { rangeDays?: number }) {\n  const [data, setData] = useState<SeriesResponse | null>(null)\n  const [loading, setLoading] = useState(false)\n  const [error, setError] = useState<string | null>(null)\n\n  useEffect(() => {\n    const fetchData = async () => {\n      setLoading(true)\n      setError(null)\n      try {\n        const end = new Date()\n        const start = new Date()\n        start.setDate(end.getDate() - (rangeDays - 1))\n        const startStr = start.toISOString().slice(0, 10)\n        const endStr = end.toISOString().slice(0, 10)\n        const res = await fetch(`/api/garmin/data?start=${startStr}&end=${endStr}`)\n        if (!res.ok) throw new Error('Failed to load Garmin data')\n        setData((await res.json()) as SeriesResponse)\n      } catch (e: any) {\n        setError(e?.message || 'Failed to load data')\n      } finally {\n        setLoading(false)\n      }\n    }\n    fetchData()\n  }, [rangeDays])\n\n  const xs = useMemo(() => (data ? data.series.steps.map((s) => s.date) : []), [data])\n  const steps = useMemo(() => (data ? data.series.steps.map((s) => s.steps ?? undefined) : []), [data])\n  const rhr = useMemo(() => (data ? data.series.heartrate.map((s) => s.restingHeartRate ?? undefined) : []), [data])\n  const sleepMin = useMemo(() => (data ? data.series.sleep.map((s) => s.minutes ?? undefined) : []), [data])\n  const weightKg = useMemo(() => (data ? data.series.weight.map((s) => s.weightKg ?? undefined) : []), [data])\n\n  if (loading) return <div className=\"h-64 rounded-xl border bg-white animate-pulse\" />\n  if (error) {\n    return (\n      <div className=\"p-4 rounded-xl border bg-red-50 border-red-200 text-red-700 text-sm\">\n        {error}\n      </div>\n    )\n  }\n  if (!data) return null\n\n  const hasData =\n    data.series.steps.some((s) => s.steps != null) ||\n    data.series.heartrate.some((h) => h.restingHeartRate != null) ||\n    data.series.sleep.some((s) => s.minutes != null) ||\n    data.series.weight.some((w) => w.weightKg != null)\n\n  if (!hasData) {\n    return (\n      <div className=\"p-4 rounded-xl border bg-gray-50 border-gray-200 text-gray-600 text-sm\">\n        No Garmin data available yet. Sync in Garmin Connect, then refresh.\n      </div>\n    )\n  }\n\n  return (\n    <div className=\"grid grid-cols-1 lg:grid-cols-2 gap-6\">\n      <div className=\"p-4 rounded-xl border bg-white h-72\">\n        <div className=\"text-sm text-gray-600 mb-2\">Steps per day</div>\n        <Line data={toDataset(xs, steps, '#10b981', 'Steps')} options={baseOptions as any} />\n      </div>\n\n      <div className=\"p-4 rounded-xl border bg-white h-72\">\n        <div className=\"text-sm text-gray-600 mb-2\">Resting heart rate</div>\n        <Line data={toDataset(xs, rhr, '#3b82f6', 'Resting HR')} options={baseOptions as any} />\n      </div>\n\n      <div className=\"p-4 rounded-xl border bg-white h-72\">\n        <div className=\"text-sm text-gray-600 mb-2\">Sleep minutes</div>\n        <Line data={toDataset(xs, sleepMin, '#a855f7', 'Sleep (min)')} options={baseOptions as any} />\n      </div>\n\n      <div className=\"p-4 rounded-xl border bg-white h-72\">\n        <div className=\"text-sm text-gray-600 mb-2\">Weight (kg)</div>\n        <Line data={toDataset(xs, weightKg, '#f59e0b', 'Weight')} options={baseOptions as any} />\n      </div>\n    </div>\n  )\n}\n\n","truncated":false,"size":4709},{"path":"components/devices/GarminSummary.tsx","content":"'use client'\n\nimport React, { useEffect, useMemo, useState } from 'react'\n\ntype SeriesResponse = {\n  success: boolean\n  range: { start: string; end: string }\n  series: {\n    steps: Array<{ date: string; steps?: number; calories?: number; distanceKm?: number }>\n    heartrate: Array<{ date: string; restingHeartRate?: number }>\n    sleep: Array<{ date: string; minutes?: number }>\n    weight: Array<{ date: string; weightKg?: number }>\n  }\n}\n\nexport default function GarminSummary({ rangeDays = 7 }: { rangeDays?: number }) {\n  const [data, setData] = useState<SeriesResponse | null>(null)\n  const [loading, setLoading] = useState(false)\n  const [error, setError] = useState<string | null>(null)\n\n  useEffect(() => {\n    const fetchData = async () => {\n      setLoading(true)\n      setError(null)\n      try {\n        const end = new Date()\n        const start = new Date()\n        start.setDate(end.getDate() - (rangeDays - 1))\n        const startStr = start.toISOString().slice(0, 10)\n        const endStr = end.toISOString().slice(0, 10)\n        const res = await fetch(`/api/garmin/data?start=${startStr}&end=${endStr}`)\n        if (!res.ok) throw new Error('Failed to load Garmin data')\n        const json = (await res.json()) as SeriesResponse\n        setData(json)\n      } catch (e: any) {\n        setError(e?.message || 'Failed to load data')\n      } finally {\n        setLoading(false)\n      }\n    }\n    fetchData()\n  }, [rangeDays])\n\n  const today = useMemo(() => {\n    if (!data) return null\n    const lastIdx = data.series.steps.length - 1\n    return {\n      steps: data.series.steps[lastIdx]?.steps,\n      calories: data.series.steps[lastIdx]?.calories,\n      distanceKm: data.series.steps[lastIdx]?.distanceKm,\n      rhr: data.series.heartrate[data.series.heartrate.length - 1]?.restingHeartRate,\n      sleepMin: data.series.sleep[data.series.sleep.length - 1]?.minutes,\n      weightKg: data.series.weight[data.series.weight.length - 1]?.weightKg,\n    }\n  }, [data])\n\n  if (loading) {\n    return (\n      <div className=\"grid grid-cols-1 md:grid-cols-3 gap-4\">\n        <div className=\"p-4 rounded-xl border bg-white\">\n          <div className=\"animate-pulse h-6 w-24 bg-gray-200 rounded mb-2\" />\n          <div className=\"animate-pulse h-8 w-32 bg-gray-200 rounded\" />\n        </div>\n        <div className=\"p-4 rounded-xl border bg-white\">\n          <div className=\"animate-pulse h-6 w-24 bg-gray-200 rounded mb-2\" />\n          <div className=\"animate-pulse h-8 w-32 bg-gray-200 rounded\" />\n        </div>\n        <div className=\"p-4 rounded-xl border bg-white\">\n          <div className=\"animate-pulse h-6 w-24 bg-gray-200 rounded mb-2\" />\n          <div className=\"animate-pulse h-8 w-32 bg-gray-200 rounded\" />\n        </div>\n      </div>\n    )\n  }\n\n  if (error) {\n    return (\n      <div className=\"p-4 rounded-xl border bg-red-50 border-red-200 text-red-700 text-sm\">\n        {error}\n      </div>\n    )\n  }\n\n  if (!data) return null\n\n  const hasData =\n    data.series.steps.some((s) => s.steps != null) ||\n    data.series.heartrate.some((h) => h.restingHeartRate != null) ||\n    data.series.sleep.some((s) => s.minutes != null) ||\n    data.series.weight.some((w) => w.weightKg != null)\n\n  if (!hasData) {\n    return (\n      <div className=\"p-4 rounded-xl border bg-gray-50 border-gray-200 text-gray-600 text-sm\">\n        No Garmin data has arrived yet. Open the Garmin Connect app on the phone and sync the watch, then refresh.\n      </div>\n    )\n  }\n\n  const km = today?.distanceKm != null ? today.distanceKm.toFixed(2) : '‚Äî'\n  const steps = today?.steps != null ? today.steps.toLocaleString() : '‚Äî'\n  const rhr = today?.rhr != null ? `${today.rhr} bpm` : '‚Äî'\n  const sleepHrs = today?.sleepMin != null ? (today.sleepMin / 60).toFixed(1) + ' h' : '‚Äî'\n  const weight = today?.weightKg != null ? `${today.weightKg.toFixed(1)} kg` : '‚Äî'\n\n  return (\n    <div className=\"grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4\">\n      <div className=\"p-4 rounded-xl border bg-white\">\n        <div className=\"text-sm text-gray-500\">Steps Today</div>\n        <div className=\"text-2xl font-semibold mt-1\">{steps}</div>\n        <div className=\"text-xs text-gray-500 mt-1\">Distance: {km}</div>\n      </div>\n      <div className=\"p-4 rounded-xl border bg-white\">\n        <div className=\"text-sm text-gray-500\">Resting Heart Rate</div>\n        <div className=\"text-2xl font-semibold mt-1\">{rhr}</div>\n      </div>\n      <div className=\"p-4 rounded-xl border bg-white\">\n        <div className=\"text-sm text-gray-500\">Sleep (last night)</div>\n        <div className=\"text-2xl font-semibold mt-1\">{sleepHrs}</div>\n      </div>\n      <div className=\"p-4 rounded-xl border bg-white\">\n        <div className=\"text-sm text-gray-500\">Weight (latest)</div>\n        <div className=\"text-2xl font-semibold mt-1\">{weight}</div>\n      </div>\n    </div>\n  )\n}\n\n","truncated":false,"size":4860},{"path":"components/DietIcon.tsx","content":"'use client'\n\nimport React from 'react'\n\ntype DietIconProps = {\n  dietId: string\n  size?: number\n}\n\nconst pickPalette = (dietId: string) => {\n  const id = (dietId || '').toLowerCase()\n  if (id.includes('vegan') || id.includes('plant') || id.includes('vegetarian') || id.includes('wfpb')) {\n    return { bg: '#E8F7EE', stroke: '#19A463', fg: '#0B6B42' }\n  }\n  if (id.includes('keto') || id.includes('low-carb') || id.includes('atkins') || id.includes('zero-carb')) {\n    return { bg: '#F1EDFF', stroke: '#6D4CFF', fg: '#3B2AA8' }\n  }\n  if (id.includes('gluten') || id.includes('grain') || id.includes('wheat')) {\n    return { bg: '#FFF3E6', stroke: '#FF8A00', fg: '#B85E00' }\n  }\n  if (id.includes('fast') || id.includes('omad') || id.includes('time')) {\n    return { bg: '#E9F4FF', stroke: '#2E7CF6', fg: '#1A4EA6' }\n  }\n  if (id.includes('medical') || id.includes('renal') || id.includes('gerd') || id.includes('diabetic') || id.includes('histamine')) {\n    return { bg: '#FFE8EE', stroke: '#E63973', fg: '#8E1D44' }\n  }\n  if (id.includes('halal') || id.includes('kosher') || id.includes('jain') || id.includes('buddhist')) {\n    return { bg: '#EAF3FF', stroke: '#3366FF', fg: '#1F3FA6' }\n  }\n  if (id.includes('carnivore') || id.includes('lion') || id.includes('paleo') || id.includes('primal')) {\n    return { bg: '#FFEFEA', stroke: '#FF5A1F', fg: '#A82E07' }\n  }\n  return { bg: '#F3F4F6', stroke: '#6B7280', fg: '#374151' }\n}\n\nconst initialsForDiet = (dietId: string) => {\n  const id = (dietId || '').toString().trim()\n  if (!id) return '?'\n  const parts = id\n    .replace(/[^a-z0-9]+/gi, ' ')\n    .trim()\n    .split(/\\s+/)\n    .filter(Boolean)\n  const initials = parts.slice(0, 2).map((p) => p[0]?.toUpperCase() || '')\n  return (initials.join('') || id.slice(0, 2).toUpperCase()).slice(0, 2)\n}\n\nconst pickGlyph = (dietId: string) => {\n  const id = (dietId || '').toLowerCase()\n  if (id.includes('vegan') || id.includes('plant') || id.includes('vegetarian') || id.includes('wfpb')) return 'leaf'\n  if (id.includes('carnivore') || id.includes('lion') || id.includes('paleo') || id.includes('primal')) return 'steak'\n  if (id.includes('keto') || id.includes('low-carb') || id.includes('atkins') || id.includes('zero-carb')) return 'bolt'\n  if (id.includes('gluten') || id.includes('wheat') || id.includes('grain')) return 'wheat'\n  if (id.includes('fast') || id.includes('omad') || id.includes('time')) return 'clock'\n  if (id.includes('halal') || id.includes('kosher') || id.includes('jain') || id.includes('buddhist')) return 'star'\n  if (id.includes('renal') || id.includes('diabetic') || id.includes('gerd') || id.includes('histamine') || id.includes('oxalate') || id.includes('purine')) return 'shield'\n  if (id.includes('mediterranean') || id.includes('nordic')) return 'fish'\n  return 'plate'\n}\n\nexport default function DietIcon({ dietId, size = 44 }: DietIconProps) {\n  const palette = pickPalette(dietId)\n  const glyph = pickGlyph(dietId)\n  const initials = initialsForDiet(dietId)\n  const s = Math.max(28, size)\n  const strokeWidth = 2\n\n  const common = {\n    fill: 'none',\n    stroke: palette.fg,\n    strokeWidth,\n    strokeLinecap: 'round' as const,\n    strokeLinejoin: 'round' as const,\n  }\n\n  return (\n    <svg width={s} height={s} viewBox=\"0 0 64 64\" role=\"img\" aria-label=\"\" className=\"select-none\">\n      <rect x=\"4\" y=\"4\" width=\"56\" height=\"56\" rx=\"16\" fill={palette.bg} stroke={palette.stroke} strokeWidth={2.5} />\n\n      {glyph === 'leaf' && (\n        <>\n          <path {...common} d=\"M40 20c-10 2-18 10-20 20c10-2 18-10 20-20Z\" />\n          <path {...common} d=\"M22 40c6-4 12-8 18-12\" />\n        </>\n      )}\n      {glyph === 'steak' && (\n        <>\n          <path\n            {...common}\n            d=\"M21 26c4-6 14-8 21-3c7 5 6 16-2 20c-8 4-18 1-21-6c-2-4-1-8 2-11Z\"\n          />\n          <circle cx=\"38\" cy=\"34\" r=\"4\" fill={palette.fg} opacity=\"0.15\" />\n        </>\n      )}\n      {glyph === 'bolt' && <path {...common} d=\"M34 18l-10 18h10l-4 10l14-20H34l4-8Z\" />}\n      {glyph === 'wheat' && (\n        <>\n          <path {...common} d=\"M32 18v28\" />\n          <path {...common} d=\"M32 22c-5 2-8 6-8 10c5-2 8-6 8-10Z\" />\n          <path {...common} d=\"M32 22c5 2 8 6 8 10c-5-2-8-6-8-10Z\" />\n          <path {...common} d=\"M32 32c-5 2-8 6-8 10c5-2 8-6 8-10Z\" />\n          <path {...common} d=\"M32 32c5 2 8 6 8 10c-5-2-8-6-8-10Z\" />\n        </>\n      )}\n      {glyph === 'clock' && (\n        <>\n          <circle cx=\"32\" cy=\"32\" r=\"14\" fill=\"none\" stroke={palette.fg} strokeWidth={strokeWidth} />\n          <path {...common} d=\"M32 24v9l6 4\" />\n        </>\n      )}\n      {glyph === 'star' && (\n        <path\n          {...common}\n          d=\"M32 20l3 7l8 1l-6 5l2 8l-7-4l-7 4l2-8l-6-5l8-1l3-7Z\"\n        />\n      )}\n      {glyph === 'shield' && (\n        <>\n          <path {...common} d=\"M32 18l12 6v10c0 10-6 16-12 18c-6-2-12-8-12-18V24l12-6Z\" />\n          <path {...common} d=\"M28 34l3 3l6-8\" />\n        </>\n      )}\n      {glyph === 'fish' && (\n        <>\n          <path {...common} d=\"M22 34c6-8 14-10 22-6c2 1 4 3 6 6c-2 3-4 5-6 6c-8 4-16 2-22-6Z\" />\n          <circle cx=\"40\" cy=\"33\" r=\"1.5\" fill={palette.fg} />\n          <path {...common} d=\"M22 34l-6-4v8l6-4Z\" />\n        </>\n      )}\n      {glyph === 'plate' && (\n        <>\n          <circle cx=\"32\" cy=\"32\" r=\"14\" fill=\"none\" stroke={palette.fg} strokeWidth={strokeWidth} />\n          <circle cx=\"32\" cy=\"32\" r=\"6\" fill={palette.fg} opacity=\"0.08\" />\n        </>\n      )}\n\n      <g>\n        <rect x=\"12\" y=\"44\" width=\"40\" height=\"12\" rx=\"6\" fill=\"white\" opacity=\"0.85\" />\n        <text x=\"32\" y=\"53\" textAnchor=\"middle\" fontSize=\"9.5\" fontWeight=\"700\" fill={palette.fg} style={{ letterSpacing: 1 }}>\n          {initials}\n        </text>\n      </g>\n    </svg>\n  )\n}\n\n","truncated":false,"size":5759},{"path":"components/FeatureUsageDisplay.tsx","content":"'use client'\nimport { useEffect, useState } from 'react'\n\ninterface FeatureUsage {\n  count: number\n  costPerUse: number\n  label?: 'monthly' | 'total'\n  // Optional explicit total credits used for this feature (for dynamic-cost features like Health Tips)\n  totalCredits?: number\n}\n\ninterface FeatureUsageData {\n  featureUsage: {\n    symptomAnalysis: FeatureUsage\n    foodAnalysis: FeatureUsage\n    interactionAnalysis: FeatureUsage\n    medicalImageAnalysis: FeatureUsage\n    insightsGeneration: FeatureUsage\n    healthTips?: FeatureUsage\n  }\n  hasSubscription: boolean\n  actualCreditsUsed: number\n}\n\ntype FeatureKey = keyof FeatureUsageData['featureUsage']\n\ninterface FeatureUsageDisplayProps {\n  featureName: FeatureKey\n  featureLabel: string\n  refreshTrigger?: number // Trigger refresh when this changes\n}\n\ntype UsageCacheEntry = {\n  data?: FeatureUsageData\n  inFlight?: Promise<FeatureUsageData | null>\n  fetchedAt?: number\n}\n\nconst usageCache: Record<string, UsageCacheEntry> = {}\nconst USAGE_CACHE_TTL_MS = 2000\n\nasync function fetchFeatureUsage(featureName: FeatureKey, forceRefresh: boolean): Promise<FeatureUsageData | null> {\n  const key = String(featureName)\n  const now = Date.now()\n  const cached = usageCache[key]\n  if (!forceRefresh && cached?.data && cached.fetchedAt && now - cached.fetchedAt < USAGE_CACHE_TTL_MS) {\n    return cached.data\n  }\n  if (cached?.inFlight) {\n    return cached.inFlight\n  }\n\n  const request = fetch(`/api/credit/feature-usage?feature=${encodeURIComponent(featureName)}`, { cache: 'no-store' })\n    .then(async (res) => {\n      if (!res.ok) return null\n      return (await res.json()) as FeatureUsageData\n    })\n    .catch(() => null)\n\n  usageCache[key] = { ...cached, inFlight: request }\n  const data = await request\n  usageCache[key] = { data: data ?? cached?.data, fetchedAt: Date.now() }\n  return data\n}\n\nexport default function FeatureUsageDisplay({ featureName, featureLabel, refreshTrigger }: FeatureUsageDisplayProps) {\n  const [usage, setUsage] = useState<FeatureUsage | null>(null)\n  const [hasSubscription, setHasSubscription] = useState(false)\n  const [loading, setLoading] = useState(true)\n  const [eventTick, setEventTick] = useState(0)\n\n  useEffect(() => {\n    const handler = () => setEventTick((v) => v + 1)\n    try {\n      window.addEventListener('credits:refresh', handler)\n      return () => window.removeEventListener('credits:refresh', handler)\n    } catch {\n      return () => {}\n    }\n  }, [])\n\n  useEffect(() => {\n    const fetchUsage = async () => {\n      setLoading(true)\n      try {\n        const forceRefresh = Boolean((refreshTrigger || 0) > 0 || eventTick > 0)\n        const data = await fetchFeatureUsage(featureName, forceRefresh)\n        if (data) {\n          const value = data.featureUsage[featureName]\n          setUsage(value ?? null)\n          setHasSubscription(data.hasSubscription)\n        }\n      } catch (err) {\n        console.error('Failed to fetch feature usage:', err)\n      } finally {\n        setLoading(false)\n      }\n    }\n    fetchUsage()\n  }, [featureName, refreshTrigger, eventTick])\n\n  if (loading || !usage) {\n    return null\n  }\n\n  if (usage.count === 0) {\n    return null\n  }\n\n  // Calculate total credits used for this feature\n  const creditsUsed =\n    typeof usage.totalCredits === 'number'\n      ? usage.totalCredits\n      : usage.count * usage.costPerUse\n  \n  // Determine label and suffix based on API-provided label (monthly vs total)\n  const isMonthly = usage.label === 'monthly'\n  const timeLabel = isMonthly ? 'This month' : 'Total'\n  const suffix = isMonthly ? ' for this month' : ''\n\n  return (\n    <div className=\"mt-2 text-xs text-gray-600\">\n      <span className=\"text-gray-500\">{timeLabel}: </span>\n      <span className=\"font-medium\">\n        This AI feature has been used {usage.count} {usage.count === 1 ? 'time' : 'times'} at a cost of {creditsUsed} {creditsUsed === 1 ? 'credit' : 'credits'}{suffix}\n      </span>\n    </div>\n  )\n}\n","truncated":false,"size":3952},{"path":"components/food/DailyMacroSummary.tsx","content":"'use client'\n\nimport { useMemo, useState } from 'react'\n\ntype MacroTotals = {\n  calories: number | null\n  protein_g: number | null\n  carbs_g: number | null\n  fat_g: number | null\n  fiber_g: number | null\n  sugar_g: number | null\n}\n\nconst safeNumber = (value: any) => {\n  const num = Number(value)\n  return Number.isFinite(num) ? num : 0\n}\n\nconst kcalToKj = (kcal: number) => kcal * 4.184\n\nexport default function DailyMacroSummary({ targets, used }: { targets: MacroTotals; used: MacroTotals }) {\n  const [energyUnit, setEnergyUnit] = useState<'kcal' | 'kJ'>('kcal')\n\n  const rows = useMemo(() => {\n    const macroRows = [\n      { key: 'protein', label: 'Protein', consumed: safeNumber(used.protein_g), target: safeNumber(targets.protein_g), unit: 'g', color: '#ef4444', cap: false },\n      { key: 'carbs', label: 'Carbs', consumed: safeNumber(used.carbs_g), target: safeNumber(targets.carbs_g), unit: 'g', color: '#22c55e', cap: false },\n      { key: 'fat', label: 'Fat', consumed: safeNumber(used.fat_g), target: safeNumber(targets.fat_g), unit: 'g', color: '#6366f1', cap: false },\n      { key: 'fibre', label: 'Fibre', consumed: safeNumber(used.fiber_g), target: safeNumber(targets.fiber_g), unit: 'g', color: '#12adc9', cap: false },\n      { key: 'sugar', label: 'Sugar (max)', consumed: safeNumber(used.sugar_g), target: safeNumber(targets.sugar_g), unit: 'g', color: '#f97316', cap: true },\n    ].filter((row) => row.target > 0)\n\n    return macroRows\n  }, [targets, used])\n\n  const energy = useMemo(() => {\n    const consumedKcal = safeNumber(used.calories)\n    const targetKcal = safeNumber(targets.calories)\n    if (targetKcal <= 0) return null\n    const consumed = energyUnit === 'kJ' ? kcalToKj(consumedKcal) : consumedKcal\n    const target = energyUnit === 'kJ' ? kcalToKj(targetKcal) : targetKcal\n    const remaining = Math.max(0, target - consumed)\n    const pctRaw = target > 0 ? consumed / target : 0\n    const percentDisplay = target > 0 ? Math.round(pctRaw * 100) : 0\n    const over = percentDisplay > 100\n    return {\n      label: 'Calories',\n      consumed,\n      target,\n      remaining,\n      percentDisplay,\n      over,\n      unit: energyUnit,\n      color: '#10b981',\n    }\n  }, [energyUnit, targets.calories, used.calories])\n\n  return (\n    <div className=\"bg-white border border-gray-200 rounded-2xl shadow-sm p-4\">\n      <div className=\"flex items-center justify-between mb-3\">\n        <div className=\"text-sm font-semibold text-gray-900\">Today‚Äôs macro summary</div>\n        <div className=\"inline-flex items-center text-[11px] sm:text-xs bg-gray-100 rounded-full p-0.5 border border-gray-200\">\n          <button\n            type=\"button\"\n            onClick={() => setEnergyUnit('kcal')}\n            className={`px-2 py-0.5 rounded-full ${energyUnit === 'kcal' ? 'bg-white text-gray-900 shadow-sm' : 'text-gray-500'}`}\n          >\n            kcal\n          </button>\n          <button\n            type=\"button\"\n            onClick={() => setEnergyUnit('kJ')}\n            className={`px-2 py-0.5 rounded-full ${energyUnit === 'kJ' ? 'bg-white text-gray-900 shadow-sm' : 'text-gray-500'}`}\n          >\n            kJ\n          </button>\n        </div>\n      </div>\n\n      <div className=\"space-y-3\">\n        {energy && (\n          <div className=\"space-y-1\">\n            <div className=\"flex items-center justify-between text-sm\">\n              <div className=\"text-gray-900 font-semibold flex items-center gap-2\">\n                <span>{energy.label}</span>\n                <span className=\"text-gray-700 font-normal\">\n                  {Math.round(energy.consumed)} / {Math.round(energy.target)} {energy.unit}\n                </span>\n                <span className=\"font-semibold\" style={{ color: energy.over ? '#ef4444' : energy.color }}>\n                  {Math.round(energy.remaining)} {energy.unit} left\n                </span>\n              </div>\n              <div className={`text-xs font-semibold ${energy.over ? 'text-red-600' : 'text-gray-900'}`}>\n                {energy.percentDisplay > 0 ? `${energy.percentDisplay}%` : '0%'}\n              </div>\n            </div>\n            <div className=\"h-2 w-full bg-gray-200 rounded-full overflow-hidden\">\n              <div\n                className=\"h-2 rounded-full transition-all\"\n                style={{ width: `${Math.min(100, Math.max(0, energy.target > 0 ? (energy.consumed / energy.target) * 100 : 0))}%`, backgroundColor: energy.over ? '#ef4444' : energy.color }}\n              />\n            </div>\n          </div>\n        )}\n\n        {rows.map((row) => {\n          const pctRaw = row.target > 0 ? row.consumed / row.target : 0\n          const pct = Math.max(0, pctRaw)\n          const percentDisplay = row.target > 0 ? Math.round(pctRaw * 100) : 0\n          const over = percentDisplay > 100\n          const remaining = Math.max(0, row.target - row.consumed)\n          return (\n            <div key={row.key} className=\"space-y-1\">\n              <div className=\"flex items-center justify-between text-sm\">\n                <div className=\"text-gray-900 font-semibold flex items-center gap-2\">\n                  <span>{row.label}</span>\n                  <span className=\"text-gray-700 font-normal\">\n                    {Math.round(row.consumed)} / {Math.round(row.target)} {row.unit}\n                    {row.cap ? ' cap' : ''}\n                  </span>\n                  <span className=\"font-semibold\" style={{ color: over ? '#ef4444' : row.color }}>\n                    {Math.round(remaining)} {row.unit} left\n                  </span>\n                </div>\n                <div className={`text-xs font-semibold ${over ? 'text-red-600' : 'text-gray-900'}`}>\n                  {percentDisplay > 0 ? `${percentDisplay}%` : '0%'}\n                </div>\n              </div>\n              <div className=\"h-2 w-full bg-gray-200 rounded-full overflow-hidden\">\n                <div\n                  className=\"h-2 rounded-full transition-all\"\n                  style={{ width: `${Math.min(100, pct * 100)}%`, backgroundColor: over ? '#ef4444' : row.color }}\n                />\n              </div>\n            </div>\n          )\n        })}\n\n        {rows.length === 0 && (\n          <div className=\"text-xs text-gray-500\">Set daily targets in Health Setup to see macro progress.</div>\n        )}\n      </div>\n    </div>\n  )\n}\n\n","truncated":false,"size":6328},{"path":"components/food/RecommendedIngredientCard.tsx","content":"'use client'\n\nimport { useMemo } from 'react'\n\ntype RecommendedItem = {\n  name: string\n  serving_size?: string | null\n  calories?: number | null\n  protein_g?: number | null\n  carbs_g?: number | null\n  fat_g?: number | null\n  fiber_g?: number | null\n  sugar_g?: number | null\n  servings: number\n}\n\nconst clamp = (n: number, min: number, max: number) => Math.min(max, Math.max(min, n))\n\nconst formatNumber = (value: number | null | undefined, decimals = 0) => {\n  if (typeof value !== 'number' || !Number.isFinite(value)) return '‚Äî'\n  return decimals > 0 ? value.toFixed(decimals) : String(Math.round(value))\n}\n\nconst macroOrZero = (v: any) => (typeof v === 'number' && Number.isFinite(v) ? v : 0)\n\nconst formatServingsDisplay = (value: number) => {\n  if (!Number.isFinite(value) || value <= 0) return '0'\n  const normalized = Math.round(value * 1000) / 1000\n  const rounded = Math.round(normalized * 100) / 100\n  if (Number.isInteger(rounded)) return String(rounded)\n  return rounded.toFixed(2).replace(/\\.0+$/, '').replace(/(\\.[1-9])0$/, '$1')\n}\n\nconst iconKeyForIngredient = (name: string) => {\n  const n = String(name || '').toLowerCase()\n  const has = (re: RegExp) => re.test(n)\n  if (has(/\\b(cod|salmon|tuna|sardine|mackerel|fish|prawn|shrimp)\\b/)) return 'fish'\n  if (has(/\\b(chicken|beef|pork|lamb|turkey|steak|bacon|ham)\\b/)) return 'meat'\n  if (has(/\\b(egg|eggs)\\b/)) return 'egg'\n  if (has(/\\b(milk|cheese|yogurt|yoghurt|whey|casein|kefir)\\b/)) return 'dairy'\n  if (has(/\\b(oat|oats|rice|bread|pasta|quinoa|barley|cereal|granola)\\b/)) return 'grain'\n  if (has(/\\b(lentil|lentils|bean|beans|chickpea|chickpeas|tofu|tempeh|edamame)\\b/)) return 'legume'\n  if (has(/\\b(lemon|lime|orange|apple|banana|berry|berries|mango|pineapple|grape)\\b/)) return 'fruit'\n  if (has(/\\b(garlic|ginger|turmeric|cumin|paprika|chili|chilli|pepper|salt|spice|herb|parsley|basil|oregano|coriander|cilantro)\\b/))\n    return 'spice'\n  if (has(/\\b(oil|olive|butter|ghee)\\b/)) return 'oil'\n  if (has(/\\b(broccoli|spinach|kale|lettuce|carrot|tomato|cucumber|zucchini|capsicum|pepper|onion|mushroom)\\b/))\n    return 'veg'\n  return 'bowl'\n}\n\nconst Icon = ({ name }: { name: string }) => {\n  const key = iconKeyForIngredient(name)\n  const { bg, fg, svg } = (() => {\n    switch (key) {\n      case 'fish':\n        return {\n          bg: 'bg-sky-50 border-sky-100',\n          fg: 'text-sky-700',\n          svg: (\n            <path\n              d=\"M7 12c2.2-2.3 4.8-3.5 7.8-3.5 2 0 3.8.5 5.4 1.5l2.3-1.8v7.6L20.2 14c-1.6 1-3.4 1.5-5.4 1.5C11.8 15.5 9.2 14.3 7 12Zm7.8-2c-1.9 0-3.6.7-5.1 2 1.5 1.3 3.2 2 5.1 2 1.3 0 2.5-.3 3.6-.9l.3-.2-.3-.2c-1.1-.6-2.3-.9-3.6-.9Zm4.9 2.1a.8.8 0 1 0 0-1.6.8.8 0 0 0 0 1.6Z\"\n              fill=\"currentColor\"\n            />\n          ),\n        }\n      case 'meat':\n        return {\n          bg: 'bg-rose-50 border-rose-100',\n          fg: 'text-rose-700',\n          svg: (\n            <path\n              d=\"M9.5 7.2c2-2 5.2-2 7.2 0 2.7 2.7 1.8 6.2-.6 8.6-2.4 2.4-5.9 3.3-8.6.6-2-2-2-5.2 0-7.2l.7-.7c.3-.3.8-.3 1.1 0l.2.2ZM8.8 10a3.2 3.2 0 0 0 0 4.5c1.9 1.9 4.6 1.1 6.4-.7 1.8-1.8 2.6-4.5.7-6.4a3.2 3.2 0 0 0-4.5 0L8.8 10Zm-1.9 8.6a1.5 1.5 0 0 1 2.1 0l.3.3a1.5 1.5 0 1 1-2.1 2.1l-.3-.3a1.5 1.5 0 0 1 0-2.1Z\"\n              fill=\"currentColor\"\n            />\n          ),\n        }\n      case 'egg':\n        return {\n          bg: 'bg-amber-50 border-amber-100',\n          fg: 'text-amber-700',\n          svg: <path d=\"M12 3c3.1 0 6 5.2 6 9.5S15.1 21 12 21s-6-4.2-6-8.5S8.9 3 12 3Z\" fill=\"currentColor\" />,\n        }\n      case 'dairy':\n        return {\n          bg: 'bg-indigo-50 border-indigo-100',\n          fg: 'text-indigo-700',\n          svg: <path d=\"M9 2h6l1 3v16a2 2 0 0 1-2 2h-4a2 2 0 0 1-2-2V5l1-3Zm1.7 5L10 9h4l-.7-2H10.7Z\" fill=\"currentColor\" />,\n        }\n      case 'grain':\n        return {\n          bg: 'bg-yellow-50 border-yellow-100',\n          fg: 'text-yellow-700',\n          svg: <path d=\"M12 3c3 2 5 5 5 8 0 4-2.2 7-5 10-2.8-3-5-6-5-10 0-3 2-6 5-8Z\" fill=\"currentColor\" />,\n        }\n      case 'legume':\n        return {\n          bg: 'bg-emerald-50 border-emerald-100',\n          fg: 'text-emerald-700',\n          svg: (\n            <path\n              d=\"M10.3 4.2c3.1-.8 6.3 1.1 7.1 4.2.8 3.1-1.1 6.3-4.2 7.1-1.6.4-3 .2-4.3-.5l-2.2 2.2a2 2 0 1 1-2.8-2.8l2.2-2.2c-.7-1.3-.9-2.8-.5-4.3.8-3.1 4-5 7-4.2Zm-.1 3.1a3.5 3.5 0 1 0 1.7 6.8 3.5 3.5 0 0 0-1.7-6.8Z\"\n              fill=\"currentColor\"\n            />\n          ),\n        }\n      case 'fruit':\n        return {\n          bg: 'bg-pink-50 border-pink-100',\n          fg: 'text-pink-700',\n          svg: (\n            <path\n              d=\"M13 4c1.5 0 2.8.6 3.8 1.6l.7-.7a1 1 0 0 1 1.4 1.4l-.8.8c.6 1 .9 2.1.9 3.4 0 4.7-3.8 8.5-8.5 8.5S2 15.2 2 10.5 5.8 2 10.5 2c.9 0 1.8.1 2.5.4V4Z\"\n              fill=\"currentColor\"\n            />\n          ),\n        }\n      case 'spice':\n        return {\n          bg: 'bg-violet-50 border-violet-100',\n          fg: 'text-violet-700',\n          svg: (\n            <path\n              d=\"M12 2l1.2 3.6L17 7l-3.8 1.4L12 12l-1.2-3.6L7 7l3.8-1.4L12 2Zm7 10l.7 2.1L22 15l-2.3.9L19 18l-.7-2.1L16 15l2.3-.9L19 12ZM5 12l.7 2.1L8 15l-2.3.9L5 18l-.7-2.1L2 15l2.3-.9L5 12Z\"\n              fill=\"currentColor\"\n            />\n          ),\n        }\n      case 'oil':\n        return {\n          bg: 'bg-lime-50 border-lime-100',\n          fg: 'text-lime-700',\n          svg: <path d=\"M12 2c2.5 3 5 6.2 5 9a5 5 0 1 1-10 0c0-2.8 2.5-6 5-9Z\" fill=\"currentColor\" />,\n        }\n      case 'veg':\n        return {\n          bg: 'bg-green-50 border-green-100',\n          fg: 'text-green-700',\n          svg: (\n            <path\n              d=\"M12 3c4 0 7 3 7 7 0 6-5 11-7 11S5 16 5 10c0-4 3-7 7-7Zm0 3c-2.2 0-4 1.8-4 4 0 4.1 3.2 7.9 4 8.9.8-1 4-4.8 4-8.9 0-2.2-1.8-4-4-4Z\"\n              fill=\"currentColor\"\n            />\n          ),\n        }\n      default:\n        return {\n          bg: 'bg-gray-50 border-gray-100',\n          fg: 'text-gray-700',\n          svg: <path d=\"M7 6h10a2 2 0 0 1 2 2v2c0 4.4-3.6 8-8 8H7V6Zm2 2v8h2a6 6 0 0 0 6-6V8H9Z\" fill=\"currentColor\" />,\n        }\n    }\n  })()\n\n  return (\n    <div className={`h-9 w-9 rounded-xl border ${bg} flex items-center justify-center ${fg} shrink-0`}>\n      <svg width=\"22\" height=\"22\" viewBox=\"0 0 24 24\" aria-hidden>\n        {svg}\n      </svg>\n    </div>\n  )\n}\n\nexport default function RecommendedIngredientCard({\n  item,\n  index,\n  onServingsChange,\n}: {\n  item: RecommendedItem\n  index: number\n  onServingsChange: (index: number, next: number) => void\n}) {\n  const servings = useMemo(() => {\n    const raw = Number(item?.servings ?? 1)\n    return Number.isFinite(raw) ? clamp(raw, 0, 20) : 1\n  }, [item?.servings])\n\n  const totals = useMemo(() => {\n    return {\n      calories: Math.round(macroOrZero(item.calories) * servings),\n      protein_g: Math.round(macroOrZero(item.protein_g) * servings * 10) / 10,\n      carbs_g: Math.round(macroOrZero(item.carbs_g) * servings * 10) / 10,\n      fat_g: Math.round(macroOrZero(item.fat_g) * servings * 10) / 10,\n      fiber_g: Math.round(macroOrZero(item.fiber_g) * servings * 10) / 10,\n      sugar_g: Math.round(macroOrZero(item.sugar_g) * servings * 10) / 10,\n    }\n  }, [item.calories, item.protein_g, item.carbs_g, item.fat_g, item.fiber_g, item.sugar_g, servings])\n\n  const perServingCalories = Math.round(macroOrZero(item.calories))\n  const servingSizeLabel = item.serving_size ? String(item.serving_size).trim() : '1 serving'\n  const totalsLabel = `${formatServingsDisplay(servings)} serving${Math.abs(servings - 1) < 0.001 ? '' : 's'}`\n\n  return (\n    <div className=\"bg-white rounded-xl border border-gray-200 shadow-sm p-4\">\n      <div className=\"flex items-start justify-between gap-3\">\n        <div className=\"flex items-start gap-3 min-w-0\">\n          <Icon name={item.name} />\n          <div className=\"min-w-0\">\n            <div className=\"font-semibold text-gray-900 text-base truncate\">{item.name}</div>\n            <div className=\"text-sm text-gray-500 mt-1 truncate\">\n              Serving size: {servingSizeLabel} ‚Ä¢ {perServingCalories} kcal per serving\n            </div>\n          </div>\n        </div>\n\n        <div className=\"flex items-center gap-2\">\n          <span className=\"text-xs text-gray-500\">Servings</span>\n          <input\n            value={String(servings)}\n            onChange={(e) => onServingsChange(index, Number(e.target.value))}\n            inputMode=\"decimal\"\n            className=\"w-20 px-2 py-1.5 rounded-lg border border-gray-200 text-sm text-gray-900\"\n            aria-label={`Servings for ${item.name}`}\n          />\n        </div>\n      </div>\n\n      <div className=\"mt-3 space-y-2\">\n        <div className=\"text-xs font-medium text-gray-500 uppercase tracking-wide\">Totals for {totalsLabel}</div>\n        <div className=\"flex flex-wrap gap-2\">\n          <div className=\"px-3 py-1 rounded-full bg-gray-100 border border-gray-200 text-[11px] font-medium text-gray-700 flex items-center gap-1\">\n            <span className=\"font-semibold text-orange-600\">{formatNumber(totals.calories)}</span>\n            <span className=\"uppercase text-gray-500\">Calories</span>\n          </div>\n          <div className=\"px-3 py-1 rounded-full bg-gray-100 border border-gray-200 text-[11px] font-medium text-gray-700 flex items-center gap-1\">\n            <span className=\"font-semibold text-blue-600\">{formatNumber(totals.protein_g, 1)}g</span>\n            <span className=\"uppercase text-gray-500\">Protein</span>\n          </div>\n          <div className=\"px-3 py-1 rounded-full bg-gray-100 border border-gray-200 text-[11px] font-medium text-gray-700 flex items-center gap-1\">\n            <span className=\"font-semibold text-green-600\">{formatNumber(totals.carbs_g, 1)}g</span>\n            <span className=\"uppercase text-gray-500\">Carbs</span>\n          </div>\n          <div className=\"px-3 py-1 rounded-full bg-gray-100 border border-gray-200 text-[11px] font-medium text-gray-700 flex items-center gap-1\">\n            <span className=\"font-semibold text-purple-600\">{formatNumber(totals.fat_g, 1)}g</span>\n            <span className=\"uppercase text-gray-500\">Fat</span>\n          </div>\n          <div className=\"px-3 py-1 rounded-full bg-gray-100 border border-gray-200 text-[11px] font-medium text-gray-700 flex items-center gap-1\">\n            <span className=\"font-semibold text-amber-600\">{formatNumber(totals.fiber_g, 1)}g</span>\n            <span className=\"uppercase text-gray-500\">Fiber</span>\n          </div>\n          <div className=\"px-3 py-1 rounded-full bg-gray-100 border border-gray-200 text-[11px] font-medium text-gray-700 flex items-center gap-1\">\n            <span className=\"font-semibold text-pink-600\">{formatNumber(totals.sugar_g, 1)}g</span>\n            <span className=\"uppercase text-gray-500\">Sugar</span>\n          </div>\n        </div>\n      </div>\n    </div>\n  )\n}\n","truncated":false,"size":10855},{"path":"components/HeroCarousel.tsx","content":"'use client'\n\nimport React, { useCallback, useEffect, useMemo, useRef, useState } from 'react'\nimport Image from 'next/image'\n\n// Optimal order for maximum impact - tells a story from onboarding to advanced features\nconst screenshots = [\n  'DASHBOARD.png',                    // 1. Start with main overview\n  \"LET'S GET STARTED.png\",           // 2. Show onboarding experience\n  'FOOD ANALYSIS.png',                // 3. Core feature - food tracking\n  'INSIGHTS.png',                     // 4. Core feature - AI insights\n  'HEALTH ISSUES.png',                // 5. Health tracking\n  'TODAYS CHECK IN.png',              // 6. Daily engagement\n  'SYMPTOM ANALYZER.png',             // 7. Problem-solving feature\n  'SUPPLEMENT INTERACTIONS.png',      // 8. Safety feature\n  'INSIGHTS ENERGY.png',              // 9. Specific insight example\n  'UPLOAD BLOOD RESULTS.png',         // 10. Advanced feature\n  'ASK AI.png',                       // 11. AI chat capability\n  'MORE MENU.png',                    // 12. Navigation/completeness\n]\n\nexport default function HeroCarousel() {\n  const scrollContainerRef = useRef<HTMLDivElement>(null)\n  const [isPaused, setIsPaused] = useState(false)\n  const scrollPositionRef = useRef(0)\n  const [isMobile, setIsMobile] = useState(false)\n  const [hasMounted, setHasMounted] = useState(false)\n  const mobileSlideIndexRef = useRef(0)\n  const autoScrollTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null)\n  const resumeTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null)\n  const scrollAnimationFrameRef = useRef<number | null>(null)\n  const isAutoScrollingRef = useRef(false)\n  const isPausedRef = useRef(isPaused)\n\n  useEffect(() => {\n    setHasMounted(true)\n  }, [])\n\n  useEffect(() => {\n    isPausedRef.current = isPaused\n  }, [isPaused])\n\n  // Detect mobile on mount and resize\n  useEffect(() => {\n    const checkMobile = () => {\n      setIsMobile(window.innerWidth < 768)\n    }\n    checkMobile()\n    window.addEventListener('resize', checkMobile)\n    return () => window.removeEventListener('resize', checkMobile)\n  }, [])\n\n  const getScrollAmount = useCallback(() => {\n    const container = scrollContainerRef.current\n    if (!container || typeof window === 'undefined') return 0\n\n    const firstSlide = container.querySelector<HTMLElement>('[data-carousel-slide]')\n    if (!firstSlide) return 0\n\n    const computedStyles = window.getComputedStyle(container)\n    const gapValue =\n      parseFloat(computedStyles.columnGap || computedStyles.gap || '0') || 0\n\n    return firstSlide.offsetWidth + gapValue\n  }, [])\n\n  const slidesToRender = useMemo(() => {\n    if (!hasMounted) {\n      return screenshots\n    }\n    return isMobile ? screenshots : [...screenshots, ...screenshots]\n  }, [isMobile, hasMounted])\n\n  const scrollLeft = () => {\n    const container = scrollContainerRef.current\n    if (!container) return\n    \n    // Calculate scroll amount - scroll by 1 image width\n    const fallbackWidth = isMobile ? 336 : 276\n    const imageWidth = getScrollAmount() || fallbackWidth\n    const newScrollLeft = Math.max(0, container.scrollLeft - imageWidth)\n    \n    container.scrollTo({ left: newScrollLeft, behavior: 'smooth' })\n    scrollPositionRef.current = newScrollLeft\n    setIsPaused(true) // Pause auto-scroll when manually scrolling\n    \n    // Resume auto-scroll after a delay\n    setTimeout(() => setIsPaused(false), 3000)\n  }\n\n  const scrollRight = () => {\n    const container = scrollContainerRef.current\n    if (!container) return\n    \n    // Calculate scroll amount - scroll by 1 image width\n    const fallbackWidth = isMobile ? 336 : 276\n    const imageWidth = getScrollAmount() || fallbackWidth\n    const maxScroll = container.scrollWidth - container.clientWidth\n    const newScrollLeft = Math.min(maxScroll, container.scrollLeft + imageWidth)\n    \n    container.scrollTo({ left: newScrollLeft, behavior: 'smooth' })\n    scrollPositionRef.current = newScrollLeft\n    setIsPaused(true) // Pause auto-scroll when manually scrolling\n    \n    // Resume auto-scroll after a delay\n    setTimeout(() => setIsPaused(false), 3000)\n  }\n\n  // Mobile: auto-play carousel with smooth transitions\n  useEffect(() => {\n    if (!isMobile || !hasMounted) {\n      if (autoScrollTimeoutRef.current) {\n        clearTimeout(autoScrollTimeoutRef.current)\n        autoScrollTimeoutRef.current = null\n      }\n      if (resumeTimeoutRef.current) {\n        clearTimeout(resumeTimeoutRef.current)\n        resumeTimeoutRef.current = null\n      }\n      if (scrollAnimationFrameRef.current) {\n        cancelAnimationFrame(scrollAnimationFrameRef.current)\n        scrollAnimationFrameRef.current = null\n      }\n      isAutoScrollingRef.current = false\n      mobileSlideIndexRef.current = 0\n      scrollPositionRef.current = 0\n      return\n    }\n\n    const container = scrollContainerRef.current\n    if (!container) return\n\n    let isUserInteracting = false\n    const totalSlides = screenshots.length\n    const fallbackSlideWidth = 336\n\n    const getSlideWidth = () => {\n      const width = getScrollAmount()\n      return width > 0 ? width : fallbackSlideWidth\n    }\n\n    const cancelAnimation = () => {\n      if (scrollAnimationFrameRef.current) {\n        cancelAnimationFrame(scrollAnimationFrameRef.current)\n        scrollAnimationFrameRef.current = null\n      }\n      isAutoScrollingRef.current = false\n    }\n\n    const scheduleAdvance = (delay = 5000) => {\n      if (autoScrollTimeoutRef.current) {\n        clearTimeout(autoScrollTimeoutRef.current)\n      }\n      autoScrollTimeoutRef.current = setTimeout(() => {\n        advanceSlide()\n      }, delay)\n    }\n\n    const advanceSlide = () => {\n      if (isUserInteracting || isPausedRef.current) {\n        scheduleAdvance(500)\n        return\n      }\n\n      const slideWidth = getSlideWidth()\n      const nextIndex = (mobileSlideIndexRef.current + 1) % totalSlides\n      const targetPosition = nextIndex * slideWidth\n      const startPosition = container.scrollLeft\n      const distance = targetPosition - startPosition\n\n      if (Math.abs(distance) < 1) {\n        container.scrollLeft = targetPosition\n        mobileSlideIndexRef.current = nextIndex\n        scheduleAdvance(5000)\n        return\n      }\n\n      const duration = 1400\n      let animationStart: number | null = null\n      isAutoScrollingRef.current = true\n\n      const animate = (timestamp: number) => {\n        if (animationStart === null) animationStart = timestamp\n        const elapsed = timestamp - animationStart\n        const progress = Math.min(elapsed / duration, 1)\n        const eased = 1 - Math.pow(1 - progress, 3)\n        container.scrollLeft = startPosition + distance * eased\n\n        if (progress < 1) {\n          scrollAnimationFrameRef.current = requestAnimationFrame(animate)\n        } else {\n          container.scrollLeft = targetPosition\n          mobileSlideIndexRef.current = nextIndex\n          cancelAnimation()\n          scheduleAdvance(5000)\n        }\n      }\n\n      scrollAnimationFrameRef.current = requestAnimationFrame(animate)\n    }\n\n    const restartResumeTimer = () => {\n      if (resumeTimeoutRef.current) {\n        clearTimeout(resumeTimeoutRef.current)\n      }\n      resumeTimeoutRef.current = setTimeout(() => {\n        const width = getSlideWidth()\n        const approxIndex = Math.round(container.scrollLeft / width)\n        mobileSlideIndexRef.current = Math.max(0, Math.min(approxIndex, totalSlides - 1))\n        isUserInteracting = false\n        scheduleAdvance(5000)\n      }, 1500)\n    }\n\n    const handleInteractionStart = () => {\n      isUserInteracting = true\n      if (autoScrollTimeoutRef.current) {\n        clearTimeout(autoScrollTimeoutRef.current)\n        autoScrollTimeoutRef.current = null\n      }\n      cancelAnimation()\n    }\n\n    const handleInteractionEnd = () => {\n      restartResumeTimer()\n    }\n\n    const handleScroll = () => {\n      if (isAutoScrollingRef.current) return\n      const width = getSlideWidth()\n      if (width <= 0) return\n      const approxIndex = Math.round(container.scrollLeft / width)\n      mobileSlideIndexRef.current = Math.max(0, Math.min(approxIndex, totalSlides - 1))\n      if (isUserInteracting) {\n        restartResumeTimer()\n      }\n    }\n\n    const handleVisibilityChange = () => {\n      if (document.hidden) {\n        handleInteractionStart()\n      } else {\n        restartResumeTimer()\n      }\n    }\n\n    container.addEventListener('touchstart', handleInteractionStart, { passive: true })\n    container.addEventListener('touchmove', handleInteractionStart, { passive: true })\n    container.addEventListener('touchend', handleInteractionEnd, { passive: true })\n    container.addEventListener('touchcancel', handleInteractionEnd, { passive: true })\n    container.addEventListener('pointerdown', handleInteractionStart)\n    container.addEventListener('pointerup', handleInteractionEnd)\n    container.addEventListener('pointercancel', handleInteractionEnd)\n    container.addEventListener('wheel', handleInteractionStart, { passive: true })\n    container.addEventListener('scroll', handleScroll, { passive: true })\n    document.addEventListener('visibilitychange', handleVisibilityChange)\n\n    const initialWidth = getSlideWidth()\n    container.scrollLeft = mobileSlideIndexRef.current * initialWidth\n\n    scheduleAdvance(5000)\n\n    return () => {\n      if (autoScrollTimeoutRef.current) {\n        clearTimeout(autoScrollTimeoutRef.current)\n        autoScrollTimeoutRef.current = null\n      }\n      if (resumeTimeoutRef.current) {\n        clearTimeout(resumeTimeoutRef.current)\n        resumeTimeoutRef.current = null\n      }\n      cancelAnimation()\n      container.removeEventListener('touchstart', handleInteractionStart)\n      container.removeEventListener('touchmove', handleInteractionStart)\n      container.removeEventListener('touchend', handleInteractionEnd)\n      container.removeEventListener('touchcancel', handleInteractionEnd)\n      container.removeEventListener('pointerdown', handleInteractionStart)\n      container.removeEventListener('pointerup', handleInteractionEnd)\n      container.removeEventListener('pointercancel', handleInteractionEnd)\n      container.removeEventListener('wheel', handleInteractionStart)\n      container.removeEventListener('scroll', handleScroll)\n      document.removeEventListener('visibilitychange', handleVisibilityChange)\n    }\n  }, [isMobile, hasMounted, getScrollAmount])\n\n  // Desktop: Continuous smooth scroll\n  useEffect(() => {\n    if (isMobile) return\n\n    const container = scrollContainerRef.current\n    if (!container) return\n\n    let animationFrameId: number\n    const scrollSpeed = 0.5\n\n    const scroll = () => {\n      if (!isPaused) {\n        scrollPositionRef.current += scrollSpeed\n        const maxScroll = container.scrollWidth - container.clientWidth\n        \n        if (scrollPositionRef.current >= maxScroll) {\n          scrollPositionRef.current = 0 // Reset to start for seamless loop\n        }\n        \n        container.scrollLeft = scrollPositionRef.current\n      }\n      animationFrameId = requestAnimationFrame(scroll)\n    }\n\n    animationFrameId = requestAnimationFrame(scroll)\n\n    return () => {\n      if (animationFrameId) {\n        cancelAnimationFrame(animationFrameId)\n      }\n    }\n  }, [isMobile, isPaused])\n\n  return (\n    <div \n      className=\"relative w-full px-2 sm:px-4 lg:px-8\"\n      style={{ paddingTop: '2rem', paddingBottom: '2rem' }}\n      onMouseEnter={() => setIsPaused(true)}\n      onMouseLeave={() => setIsPaused(false)}\n    >\n      {/* Left Scroll Button - Hidden on mobile */}\n      <button\n        onClick={scrollLeft}\n        className=\"hidden md:block absolute left-0 top-1/2 -translate-y-1/2 z-50 bg-black/20 hover:bg-black/30 backdrop-blur-sm rounded-full p-2 md:p-3 transition-all duration-200 opacity-60 hover:opacity-100\"\n        aria-label=\"Scroll left\"\n      >\n        <svg \n          className=\"w-5 h-5 md:w-6 md:h-6 text-white\" \n          fill=\"none\" \n          stroke=\"currentColor\" \n          viewBox=\"0 0 24 24\"\n          strokeWidth={1.5}\n        >\n          <path strokeLinecap=\"round\" strokeLinejoin=\"round\" d=\"M15.75 19.5L8.25 12l7.5-7.5\" />\n        </svg>\n      </button>\n\n      {/* Right Scroll Button - Hidden on mobile */}\n      <button\n        onClick={scrollRight}\n        className=\"hidden md:block absolute right-0 top-1/2 -translate-y-1/2 z-50 bg-black/20 hover:bg-black/30 backdrop-blur-sm rounded-full p-2 md:p-3 transition-all duration-200 opacity-60 hover:opacity-100\"\n        aria-label=\"Scroll right\"\n      >\n        <svg \n          className=\"w-5 h-5 md:w-6 md:h-6 text-white\" \n          fill=\"none\" \n          stroke=\"currentColor\" \n          viewBox=\"0 0 24 24\"\n          strokeWidth={1.5}\n        >\n          <path strokeLinecap=\"round\" strokeLinejoin=\"round\" d=\"M8.25 4.5l7.5 7.5-7.5 7.5\" />\n        </svg>\n      </button>\n\n      {/* Horizontal Scrolling Container */}\n      <div\n        ref={scrollContainerRef}\n        className=\"flex gap-4 overflow-x-auto items-center scrollbar-hide\"\n        style={{ \n          scrollBehavior: 'auto',\n          width: '100%',\n          maxWidth: '100%',\n          paddingLeft: isMobile ? '2.75rem' : '5.5rem',\n          paddingRight: isMobile ? '2.75rem' : '5.5rem',\n          scrollSnapType: isMobile ? 'x mandatory' : 'none',\n        }}\n      >\n        {/* Render slides (desktop duplicates for seamless loop) */}\n        {slidesToRender.map((screenshot, index) => (\n          <div\n            key={`${screenshot}-${index}`}\n            data-carousel-slide\n            className={`flex-shrink-0 relative ${isMobile ? 'w-[320px]' : 'w-[260px]'} h-auto`}\n            style={{\n              scrollSnapAlign: isMobile ? 'center' : 'none'\n            }}\n          >\n            <div className=\"relative aspect-[9/16] rounded-2xl overflow-hidden shadow-xl\">\n              <Image\n                src={`/screenshots/hero/${screenshot}`}\n                alt={`Helfi ${screenshot.replace('.png', '').replace(/_/g, ' ')}`}\n                fill\n                className=\"object-contain\"\n                priority={index < 2}\n                loading={index < 3 ? 'eager' : 'lazy'}\n                sizes={isMobile ? '320px' : '260px'}\n              />\n            </div>\n          </div>\n        ))}\n      </div>\n    </div>\n  )\n}\n","truncated":false,"size":14248},{"path":"components/InsightsProgressBar.tsx","content":"'use client'\n\nimport React from 'react'\n\ninterface InsightsProgressBarProps {\n  isGenerating: boolean\n  message?: string\n}\n\n// Indeterminate shimmer bar to avoid misleading ‚Äústuck‚Äù percentages\nexport default function InsightsProgressBar({ isGenerating, message }: InsightsProgressBarProps) {\n  if (!isGenerating) return null\n\n  return (\n    <div className=\"w-full space-y-2\">\n      <div className=\"flex items-center justify-between text-sm\">\n        <p className=\"text-gray-700 font-medium\">\n          {message || 'Generating insights‚Ä¶'}\n        </p>\n        <p className=\"text-gray-500 text-xs\">\n          This may take up to a minute\n        </p>\n      </div>\n      <div className=\"w-full bg-gray-200 rounded-full h-2 overflow-hidden relative\">\n        <div className=\"absolute inset-0 bg-gradient-to-r from-helfi-green/30 via-helfi-green to-helfi-green/30 animate-pulse\" />\n      </div>\n    </div>\n  )\n}\n","truncated":false,"size":913},{"path":"components/InteractionAnalysis.tsx","content":"'use client';\n\nimport React, { useState } from 'react';\n\ninterface Interaction {\n  substance1: string;\n  substance2: string;\n  severity: 'low' | 'medium' | 'high';\n  description: string;\n  recommendation: string;\n  timingAdjustment: string;\n}\n\ninterface TimingOptimization {\n  morning: string[];\n  afternoon: string[];\n  evening: string[];\n  beforeBed: string[];\n}\n\ninterface AnalysisResult {\n  overallRisk: 'low' | 'medium' | 'high';\n  interactions: Interaction[];\n  timingOptimization: TimingOptimization;\n  generalRecommendations: string[];\n  disclaimer: string;\n  analysisDate: string;\n  supplementCount: number;\n  medicationCount: number;\n}\n\ninterface InteractionAnalysisProps {\n  analysis: AnalysisResult;\n  onContinue?: () => void;\n  onBack?: () => void;\n}\n\nconst InteractionAnalysis: React.FC<InteractionAnalysisProps> = ({ \n  analysis, \n  onContinue, \n  onBack \n}) => {\n  const [expandedInteraction, setExpandedInteraction] = useState<number | null>(null);\n\n  const getRiskColor = (risk: 'low' | 'medium' | 'high') => {\n    switch (risk) {\n      case 'low': return 'text-green-600 bg-green-50 border-green-200';\n      case 'medium': return 'text-orange-600 bg-orange-50 border-orange-200';\n      case 'high': return 'text-red-600 bg-red-50 border-red-200';\n      default: return 'text-gray-600 bg-gray-50 border-gray-200';\n    }\n  };\n\n  const getRiskIcon = (risk: 'low' | 'medium' | 'high') => {\n    switch (risk) {\n      case 'low': return 'üü¢';\n      case 'medium': return 'üü†';\n      case 'high': return 'üî¥';\n      default: return '‚ö™';\n    }\n  };\n\n  const getRiskText = (risk: 'low' | 'medium' | 'high') => {\n    switch (risk) {\n      case 'low': return 'Low Risk';\n      case 'medium': return 'Medium Risk';\n      case 'high': return 'High Risk';\n      default: return 'Unknown Risk';\n    }\n  };\n\n  const getTimingIcon = (timing: string) => {\n    switch (timing.toLowerCase()) {\n      case 'morning': return 'üåÖ';\n      case 'afternoon': return '‚òÄÔ∏è';\n      case 'evening': return 'üåÜ';\n      case 'beforebed': return 'üåô';\n      default: return '‚è∞';\n    }\n  };\n\n  return (\n    <div className=\"max-w-4xl mx-auto p-6 bg-white rounded-lg shadow-sm\">\n      {/* Header */}\n      <div className=\"mb-8\">\n        <h2 className=\"text-2xl font-bold text-gray-900 mb-2\">\n          Interaction Analysis Results\n        </h2>\n        <p className=\"text-gray-600\">\n          Analysis of {analysis.supplementCount} supplements and {analysis.medicationCount} medications\n        </p>\n      </div>\n\n      {/* Overall Risk Assessment */}\n      <div className={`mb-8 p-4 rounded-lg border-2 ${getRiskColor(analysis.overallRisk)}`}>\n        <div className=\"flex items-center gap-3\">\n          <span className=\"text-2xl\">{getRiskIcon(analysis.overallRisk)}</span>\n          <div>\n            <h3 className=\"text-lg font-semibold\">\n              Overall Risk: {getRiskText(analysis.overallRisk)}\n            </h3>\n            <p className=\"text-sm opacity-80\">\n              Based on analysis of all supplement and medication combinations\n            </p>\n          </div>\n        </div>\n      </div>\n\n      {/* Interactions Section */}\n      <div className=\"mb-8\">\n        <h3 className=\"text-xl font-semibold mb-4\">Potential Interactions</h3>\n        {analysis.interactions.length === 0 ? (\n          <div className=\"bg-green-50 border border-green-200 rounded-lg p-4\">\n            <div className=\"flex items-center gap-2\">\n              <span className=\"text-green-600\">‚úÖ</span>\n              <span className=\"text-green-800 font-medium\">No significant interactions detected</span>\n            </div>\n          </div>\n        ) : (\n          <div className=\"space-y-4\">\n            {analysis.interactions.map((interaction, index) => (\n              <div \n                key={index}\n                className={`border-2 rounded-lg ${getRiskColor(interaction.severity)}`}\n              >\n                <div \n                  className=\"p-4 cursor-pointer\"\n                  onClick={() => setExpandedInteraction(expandedInteraction === index ? null : index)}\n                >\n                  <div className=\"flex items-center justify-between\">\n                    <div className=\"flex items-center gap-3\">\n                      <span className=\"text-xl\">{getRiskIcon(interaction.severity)}</span>\n                      <div>\n                        <h4 className=\"font-semibold\">\n                          {interaction.substance1} + {interaction.substance2}\n                        </h4>\n                        <p className=\"text-sm opacity-80\">\n                          {getRiskText(interaction.severity)} - Click to expand\n                        </p>\n                      </div>\n                    </div>\n                    <svg \n                      className={`w-5 h-5 transform transition-transform ${\n                        expandedInteraction === index ? 'rotate-180' : ''\n                      }`}\n                      fill=\"none\" \n                      stroke=\"currentColor\" \n                      viewBox=\"0 0 24 24\"\n                    >\n                      <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M19 9l-7 7-7-7\" />\n                    </svg>\n                  </div>\n                </div>\n                \n                {expandedInteraction === index && (\n                  <div className=\"px-4 pb-4 border-t border-current border-opacity-20\">\n                    <div className=\"mt-4 space-y-3\">\n                      <div>\n                        <h5 className=\"font-medium text-sm uppercase tracking-wide opacity-80\">Description</h5>\n                        <p className=\"text-sm mt-1\">{interaction.description}</p>\n                      </div>\n                      <div>\n                        <h5 className=\"font-medium text-sm uppercase tracking-wide opacity-80\">Recommendation</h5>\n                        <p className=\"text-sm mt-1\">{interaction.recommendation}</p>\n                      </div>\n                      {interaction.timingAdjustment && interaction.timingAdjustment !== 'No adjustment needed' && (\n                        <div>\n                          <h5 className=\"font-medium text-sm uppercase tracking-wide opacity-80\">Timing Adjustment</h5>\n                          <p className=\"text-sm mt-1\">{interaction.timingAdjustment}</p>\n                        </div>\n                      )}\n                    </div>\n                  </div>\n                )}\n              </div>\n            ))}\n          </div>\n        )}\n      </div>\n\n      {/* Timing Optimization */}\n      <div className=\"mb-8\">\n        <h3 className=\"text-xl font-semibold mb-4\">Optimal Timing Schedule</h3>\n        <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4\">\n          {Object.entries(analysis.timingOptimization).map(([timing, substances]) => (\n            <div key={timing} className=\"bg-gray-50 rounded-lg p-4\">\n              <div className=\"flex items-center gap-2 mb-3\">\n                <span className=\"text-xl\">{getTimingIcon(timing)}</span>\n                <h4 className=\"font-semibold capitalize\">\n                  {timing === 'beforeBed' ? 'Before Bed' : timing}\n                </h4>\n              </div>\n              {substances.length === 0 ? (\n                <p className=\"text-sm text-gray-500\">None recommended</p>\n              ) : (\n                <ul className=\"space-y-1\">\n                  {substances.map((substance: string, index: number) => (\n                    <li key={index} className=\"text-sm text-gray-700\">\n                      ‚Ä¢ {substance}\n                    </li>\n                  ))}\n                </ul>\n              )}\n            </div>\n          ))}\n        </div>\n      </div>\n\n      {/* General Recommendations */}\n      {analysis.generalRecommendations.length > 0 && (\n        <div className=\"mb-8\">\n          <h3 className=\"text-xl font-semibold mb-4\">General Recommendations</h3>\n          <div className=\"bg-blue-50 border border-blue-200 rounded-lg p-4\">\n            <ul className=\"space-y-2\">\n              {analysis.generalRecommendations.map((recommendation, index) => (\n                <li key={index} className=\"flex items-start gap-2 text-blue-800\">\n                  <span className=\"text-blue-600 mt-1\">üí°</span>\n                  <span className=\"text-sm\">{recommendation}</span>\n                </li>\n              ))}\n            </ul>\n          </div>\n        </div>\n      )}\n\n      {/* Medical Disclaimer */}\n      <div className=\"mb-8\">\n        <div className=\"bg-yellow-50 border border-yellow-200 rounded-lg p-4\">\n          <div className=\"flex items-start gap-2\">\n            <span className=\"text-yellow-600 text-xl\">‚ö†Ô∏è</span>\n            <div>\n              <h4 className=\"font-semibold text-yellow-800 mb-1\">Important Medical Disclaimer</h4>\n              <p className=\"text-sm text-yellow-700\">{analysis.disclaimer}</p>\n            </div>\n          </div>\n        </div>\n      </div>\n\n      {/* Navigation Buttons */}\n      <div className=\"flex justify-between pt-4\">\n        {onBack && (\n          <button \n            onClick={onBack}\n            className=\"border border-green-600 text-green-600 px-6 py-3 rounded-lg hover:bg-green-600 hover:text-white transition-colors\"\n          >\n            Back\n          </button>\n        )}\n        {onContinue && (\n          <button \n            onClick={onContinue}\n            className=\"bg-green-600 text-white px-6 py-3 rounded-lg hover:bg-green-700 transition-colors ml-auto\"\n          >\n            Continue\n          </button>\n        )}\n      </div>\n\n      {/* Analysis Metadata */}\n      <div className=\"mt-4 pt-4 border-t border-gray-200\">\n        <p className=\"text-xs text-gray-500\">\n          Analysis completed on {new Date(analysis.analysisDate).toLocaleDateString()} at{' '}\n          {new Date(analysis.analysisDate).toLocaleTimeString()}\n        </p>\n      </div>\n    </div>\n  );\n};\n\nexport default InteractionAnalysis; ","truncated":false,"size":9975},{"path":"components/LayoutWrapper.tsx","content":"'use client'\nimport { Cog6ToothIcon } from '@heroicons/react/24/outline'\n\nimport { usePathname, useRouter } from 'next/navigation'\nimport { useSession } from 'next-auth/react'\nimport { MouseEvent, ReactNode, useEffect, useState } from 'react'\nimport UsageMeter from '@/components/UsageMeter'\nimport SupportChatWidget from '@/components/support/SupportChatWidget'\n\n// Desktop Sidebar Navigation Component  \nfunction DesktopSidebar({\n  pathname,\n  onNavigate,\n}: {\n  pathname: string\n  onNavigate: (href: string, e: MouseEvent<HTMLAnchorElement>) => void\n}) {\n  return (\n    <aside className=\"hidden md:fixed md:inset-y-0 md:left-0 md:z-40 md:w-64 md:flex md:flex-col\">\n      <div className=\"flex flex-col flex-grow bg-[#1f2937] text-white border-r border-gray-800 pt-5 pb-4 overflow-y-auto\">\n        {/* Logo */}\n        <div className=\"flex items-center flex-shrink-0 px-4\">\n          <img\n            className=\"h-12 w-auto\"\n            src=\"/mobile-assets/LOGOS/helfi-01-06.png\"\n            alt=\"Helfi\"\n          />\n        </div>\n        \n        {/* Usage Meter */}\n        <div className=\"px-4 pt-4 border-b border-gray-700 pb-4\">\n          <UsageMeter showResetDate={true} />\n        </div>\n        \n        {/* Navigation */}\n        <nav className=\"mt-8 flex-1 px-4 space-y-1\">\n          <a\n            href=\"/dashboard\"\n            onClick={(e) => onNavigate('/dashboard', e)}\n            className=\"text-gray-100 hover:text-white hover:bg-gray-700/80 group flex items-center px-2 py-2 text-base font-medium rounded-md\"\n          >\n            <svg className=\"text-gray-300 group-hover:text-white mr-3 h-6 w-6\" fill=\"currentColor\" viewBox=\"0 0 24 24\">\n              <path d=\"M3 13h8V3H3v10zm0 8h8v-6H3v6zm10 0h8V11h-8v10zm0-18v6h8V3h-8z\"/>\n            </svg>\n            Dashboard\n          </a>\n          \n          <a\n            href=\"/insights\"\n            onClick={(e) => onNavigate('/insights', e)}\n            className=\"text-gray-100 hover:text-white hover:bg-gray-700/80 group flex items-center px-2 py-2 text-base font-medium rounded-md\"\n          >\n            <svg className=\"text-gray-300 group-hover:text-white mr-3 h-6 w-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z\" />\n            </svg>\n            Insights\n          </a>\n          \n          <a\n            href=\"/health-tips\"\n            onClick={(e) => onNavigate('/health-tips', e)}\n            className=\"text-gray-100 hover:text-white hover:bg-gray-700/80 group flex items-center px-2 py-2 text-base font-medium rounded-md\"\n          >\n            <svg className=\"text-gray-300 group-hover:text-white mr-3 h-6 w-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M13 7H7m0 0V5a2 2 0 012-2h6m-8 4v6m0 0h6m-6 0H5a2 2 0 01-2-2V7m10-4h2a2 2 0 012 2v8a2 2 0 01-2 2h-2m0 0H9m4 0v2a2 2 0 01-2 2H9\" />\n            </svg>\n            Health Tips\n          </a>\n          \n          <a\n            href=\"/food\"\n            onClick={(e) => onNavigate('/food', e)}\n            className=\"text-gray-100 hover:text-white hover:bg-gray-700/80 group flex items-center px-2 py-2 text-base font-medium rounded-md\"\n          >\n            <svg className=\"text-gray-300 group-hover:text-white mr-3 h-6 w-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10\" />\n            </svg>\n            Food Diary\n          </a>\n          \n          <a\n            href=\"/symptoms\"\n            onClick={(e) => onNavigate('/symptoms', e)}\n            className=\"text-gray-100 hover:text-white hover:bg-gray-700/80 group flex items-center px-2 py-2 text-base font-medium rounded-md\"\n          >\n            <svg className=\"text-gray-300 group-hover:text-white mr-3 h-6 w-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M9 12h6m-3-3v6m9 0a9 9 0 11-18 0 9 9 0 0118 0z\" />\n            </svg>\n            Symptom Analysis\n          </a>\n\n          <a\n            href=\"/medical-images\"\n            onClick={(e) => onNavigate('/medical-images', e)}\n            className=\"text-gray-100 hover:text-white hover:bg-gray-700/80 group flex items-center px-2 py-2 text-base font-medium rounded-md\"\n          >\n            <svg className=\"text-gray-300 group-hover:text-white mr-3 h-6 w-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z\" />\n            </svg>\n            Medical Image Analyzer\n          </a>\n\n          <a\n            href=\"/health-tracking\"\n            onClick={(e) => onNavigate('/health-tracking', e)}\n            className=\"text-gray-100 hover:text-white hover:bg-gray-700/80 group flex items-center px-2 py-2 text-base font-medium rounded-md\"\n          >\n            <svg className=\"text-gray-300 group-hover:text-white mr-3 h-6 w-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z\" />\n            </svg>\n            Health Tracking\n          </a>\n          \n          <a\n            href=\"/devices\"\n            onClick={(e) => onNavigate('/devices', e)}\n            className=\"text-gray-100 hover:text-white hover:bg-gray-700/80 group flex items-center px-2 py-2 text-base font-medium rounded-md\"\n          >\n            <svg className=\"text-gray-300 group-hover:text-white mr-3 h-6 w-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M7 7h10a2 2 0 012 2v6a2 2 0 01-2 2H7a2 2 0 01-2-2V9a2 2 0 012-2z\" />\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M7 7V5a2 2 0 012-2h6a2 2 0 012 2v2\" />\n            </svg>\n            Devices\n          </a>\n          \n          <a\n            href=\"/onboarding?step=1\"\n            onClick={(e) => onNavigate('/onboarding?step=1', e)}\n            className=\"text-gray-100 hover:text-white hover:bg-gray-700/80 group flex items-center px-2 py-2 text-base font-medium rounded-md\"\n          >\n            <svg className=\"text-gray-300 group-hover:text-white mr-3 h-6 w-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z\" />\n            </svg>\n            Health Setup\n          </a>\n          \n          <div className=\"border-t border-gray-700 mt-6 pt-6\">\n          <a\n            href=\"/check-in\"\n            onClick={(e) => onNavigate('/check-in', e)}\n            className=\"text-gray-100 hover:text-white hover:bg-gray-700/80 group flex items-center px-2 py-2 text-base font-medium rounded-md\"\n          >\n              <svg className=\"text-gray-300 group-hover:text-white mr-3 h-6 w-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z\" />\n              </svg>\n              Today's Check-in\n            </a>\n          <a\n            href=\"/check-in/history\"\n            onClick={(e) => onNavigate('/check-in/history', e)}\n            className=\"text-gray-100 hover:text-white hover:bg-gray-700/80 group flex items-center px-2 py-2 text-base font-medium rounded-md\"\n          >\n              <svg className=\"text-gray-300 group-hover:text-white mr-3 h-6 w-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M8 7V3m8 4V3M5 11h14M5 19h14M7 11v8m10-8v8\" />\n              </svg>\n              Rating History\n            </a>\n          <a\n            href=\"/mood\"\n            onClick={(e) => onNavigate('/mood', e)}\n            className=\"text-gray-100 hover:text-white hover:bg-gray-700/80 group flex items-center px-2 py-2 text-base font-medium rounded-md\"\n          >\n              <svg className=\"text-gray-300 group-hover:text-white mr-3 h-6 w-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M12 21a9 9 0 110-18 9 9 0 010 18z\" />\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M8.5 10.5h.01M15.5 10.5h.01\" />\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M9 15c1 1 2.2 1.5 3 1.5s2-.5 3-1.5\" />\n              </svg>\n              Mood Tracker\n            </a>\n          <a\n            href=\"/mood/quick\"\n            onClick={(e) => onNavigate('/mood/quick', e)}\n            className=\"text-gray-100 hover:text-white hover:bg-gray-700/80 group flex items-center px-2 py-2 text-base font-medium rounded-md\"\n          >\n              <svg className=\"text-gray-300 group-hover:text-white mr-3 h-6 w-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M12 6v6l4 2\" />\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M21 12a9 9 0 11-18 0 9 9 0 0118 0z\" />\n              </svg>\n              Quick Mood Check‚ÄëIn\n            </a>\n          <a\n            href=\"/settings\"\n            onClick={(e) => onNavigate('/settings', e)}\n            className=\"text-gray-100 hover:text-white hover:bg-gray-700/80 group flex items-center px-2 py-2 text-base font-medium rounded-md\"\n          >\n              <Cog6ToothIcon className=\"text-gray-300 group-hover:text-white mr-3 h-6 w-6 flex-shrink-0\" style={{ minWidth: '24px', minHeight: '24px' }} />\n              Settings\n            </a>\n            \n          <a\n            href=\"/reports\"\n            onClick={(e) => onNavigate('/reports', e)}\n            className=\"text-gray-100 hover:text-white hover:bg-gray-700/80 group flex items-center px-2 py-2 text-base font-medium rounded-md\"\n          >\n              <svg className=\"text-gray-300 group-hover:text-white mr-3 h-6 w-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z\" />\n              </svg>\n              Reports\n            </a>\n          </div>\n        </nav>\n      </div>\n    </aside>\n  )\n}\n\ninterface LayoutWrapperProps {\n  children: ReactNode\n}\n\nexport default function LayoutWrapper({ children }: LayoutWrapperProps) {\n  const pathname = usePathname()\n  const router = useRouter()\n  const { data: session, status } = useSession()\n  const [showHealthSetupReminder, setShowHealthSetupReminder] = useState(false)\n  \n  // Pages that should ALWAYS be public (no sidebar regardless of auth status)\n  const publicPages = [\n    '/',\n    '/healthapp',\n    '/auth/signin',\n    '/auth/verify',\n    '/auth/check-email',\n    '/auth/forgot-password',\n    '/auth/reset-password',\n    '/onboarding',\n    '/privacy',\n    '/terms',\n    '/help',\n    '/faq',\n    '/affiliate/terms',\n  ]\n  \n  // Admin panel paths should never show user sidebar\n  const isAdminPanelPath =\n    pathname.startsWith('/admin-panel') || pathname.startsWith('/main-admin')\n\n  // Dark mode is only allowed inside the signed-in app.\n  // Keep public/auth pages in light mode even if the user enabled dark mode previously.\n  const isOnboardingPath = pathname.startsWith('/onboarding')\n  const themeAllowed =\n    status === 'authenticated' &&\n    !isAdminPanelPath &&\n    (!publicPages.includes(pathname) || isOnboardingPath)\n\n  useEffect(() => {\n    if (typeof document === 'undefined') return\n\n    if (!themeAllowed) {\n      document.documentElement.classList.remove('dark')\n      return\n    }\n\n    try {\n      const enabled = localStorage.getItem('darkMode') === 'true'\n      document.documentElement.classList.toggle('dark', enabled)\n    } catch {\n      // Ignore storage errors\n    }\n  }, [themeAllowed])\n\n  // ‚ö†Ô∏è HEALTH SETUP GUARD RAIL\n  // The 5-minute global Health Setup reminder must:\n  // - Only appear for authenticated users on non-public, non-admin pages.\n  // - Use GET /api/health-setup-status to respect account-wide \"Don't ask me again\".\n  // - Show at most once per browser session via sessionStorage.helfiHealthSetupReminderShownThisSession.\n  // Do NOT convert this into a hard block or change the timing/behaviour without\n  // reading HEALTH_SETUP_PROTECTION.md and obtaining explicit user approval.\n\n  // One-time per-session reminder: if a user has been using the app\n  // for more than ~5 minutes without completing Health Setup, gently prompt\n  // them to finish it. Users can permanently opt out of this reminder for\n  // their account by choosing \"Don't ask me again\".\n  useEffect(() => {\n    if (status !== 'authenticated') return\n    if (publicPages.includes(pathname) || isAdminPanelPath) return\n    if ((session as any)?.user?.needsVerification) return\n\n    try {\n      if (sessionStorage.getItem('helfiHealthSetupReminderShownThisSession') === '1') {\n        return\n      }\n    } catch {\n      // Ignore storage errors\n    }\n\n    const timer = setTimeout(async () => {\n      try {\n        const res = await fetch('/api/health-setup-status', { method: 'GET' })\n        if (!res.ok) return\n        const data = await res.json()\n        const complete = !!data.complete\n        const reminderDisabled = !!data.reminderDisabled\n\n        if (!complete && !reminderDisabled) {\n          setShowHealthSetupReminder(true)\n          try {\n            sessionStorage.setItem('helfiHealthSetupReminderShownThisSession', '1')\n          } catch {\n            // Ignore\n          }\n        }\n      } catch {\n        // Non-blocking; ignore failures\n      }\n    }, 5 * 60 * 1000)\n\n    return () => clearTimeout(timer)\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [status, pathname, isAdminPanelPath, publicPages, session])\n\n  // Track the last in-app page the user visited (for ‚Äúresume where I left off‚Äù).\n  // We only store non-public, non-admin paths so onboarding / auth pages are excluded.\n  useEffect(() => {\n    if (status !== 'authenticated') return\n    if (publicPages.includes(pathname) || isAdminPanelPath) return\n    if (typeof window === 'undefined') return\n    try {\n      const fullPath = window.location.pathname + window.location.search\n      localStorage.setItem('helfi:lastPath', fullPath)\n      // Mirror the last path into a simple cookie so the server can redirect\n      const encoded = encodeURIComponent(fullPath)\n      const maxAgeSeconds = 5 * 365 * 24 * 60 * 60 // ~5 years\n      document.cookie = `helfi-last-path=${encoded}; path=/; max-age=${maxAgeSeconds}; samesite=lax`\n    } catch {\n      // Ignore storage errors\n    }\n  }, [status, pathname, isAdminPanelPath, publicPages])\n\n  // Don't show sidebar while session is loading to prevent flickering\n  if (status === 'loading') {\n    return (\n      <div className=\"min-h-screen\">\n        {children}\n      </div>\n    )\n  }\n  \n  // Check if authenticated user needs email verification\n  if (status === 'authenticated' && session?.user?.needsVerification && !publicPages.includes(pathname) && !isAdminPanelPath) {\n    return (\n      <div className=\"min-h-screen flex items-center justify-center bg-gradient-to-b from-white to-helfi-green-light/10 p-4\">\n        <div className=\"max-w-md w-full bg-white rounded-lg shadow-lg p-6 text-center\">\n          <div className=\"mb-4\">\n            <div className=\"mx-auto w-16 h-16 bg-yellow-100 rounded-full flex items-center justify-center\">\n              <svg className=\"w-8 h-8 text-yellow-600\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L4.082 16.5c-.77.833.192 2.5 1.732 2.5z\" />\n              </svg>\n            </div>\n          </div>\n          <h2 className=\"text-xl font-semibold text-gray-900 mb-2\">Email Verification Required</h2>\n          <p className=\"text-gray-600 mb-4\">\n            Please check your email for a verification link. You must verify your email address before accessing your account.\n          </p>\n          <div className=\"bg-blue-50 border border-blue-200 rounded-lg p-3 mb-4\">\n            <p className=\"text-blue-700 text-sm\">\n              üìß Verification email sent to: <strong>{session?.user?.email}</strong>\n            </p>\n          </div>\n          <div className=\"space-y-3\">\n            <button\n              onClick={async () => {\n                try {\n                  const response = await fetch('/api/auth/resend-verification', {\n                    method: 'POST',\n                    headers: { 'Content-Type': 'application/json' },\n                    body: JSON.stringify({ email: session?.user?.email })\n                  })\n                  \n                  if (response.ok) {\n                    alert('‚úÖ Verification email sent! Please check your inbox.')\n                  } else {\n                    const error = await response.json()\n                    alert(`‚ùå Failed to send email: ${error.error}`)\n                  }\n                } catch (error) {\n                  alert('‚ùå Failed to send verification email. Please try again.')\n                }\n              }}\n              className=\"w-full bg-blue-500 text-white px-4 py-2 rounded-lg hover:bg-blue-600 transition-colors font-medium\"\n            >\n              üìß Resend Verification Email\n            </button>\n            <button\n              onClick={() => window.location.href = '/auth/signin'}\n              className=\"w-full bg-gray-500 text-white px-4 py-2 rounded-lg hover:bg-gray-600 transition-colors font-medium\"\n            >\n              Back to Sign In\n            </button>\n          </div>\n        </div>\n      </div>\n    )\n  }\n  \n  if (status === 'unauthenticated' && !publicPages.includes(pathname) && !isAdminPanelPath) {\n    if (typeof window !== 'undefined') {\n      window.location.href = '/auth/signin'\n    }\n    return (\n      <div className=\"min-h-screen flex items-center justify-center\">\n        <div className=\"text-center\">\n          <p className=\"text-gray-600\">Redirecting...</p>\n        </div>\n      </div>\n    )\n  }\n  \n  // Show sidebar only if:\n  // 1. User is authenticated (status === 'authenticated') AND\n  // 2. Current page is not in publicPages list AND\n  // 3. Current page is not an admin panel path\n  const shouldShowSidebar =\n    status === 'authenticated' &&\n    !isAdminPanelPath &&\n    (!publicPages.includes(pathname) || isOnboardingPath)\n\n  const handleSidebarNavigate = (href: string, e: MouseEvent<HTMLAnchorElement>) => {\n    e.preventDefault()\n    if (typeof href !== 'string' || !href) return\n\n    // Health Setup / Onboarding: if there are unsaved changes, ask the user once\n    // before leaving the section (the onboarding page owns the popup).\n    if (isOnboardingPath) {\n      try {\n        const hasUnsaved =\n          !!(window as any).__helfiOnboardingPhysicalHasUnsavedChanges ||\n          !!(window as any).__helfiOnboardingHasUnsavedChanges\n        if (hasUnsaved) {\n          window.postMessage({ type: 'OPEN_ONBOARDING_UPDATE_POPUP', navigateTo: href }, '*')\n          return\n        }\n      } catch {\n        // fall through\n      }\n    }\n\n    try {\n      router.push(href)\n    } catch {\n      window.location.assign(href)\n    }\n  }\n\n  if (shouldShowSidebar) {\n    return (\n      <div className=\"flex min-h-screen bg-gray-50\">\n        {/* Desktop Sidebar - Only for authenticated users on app pages */}\n        <DesktopSidebar pathname={pathname} onNavigate={handleSidebarNavigate} />\n        \n        {/* Main Content */}\n        <div className=\"md:pl-64 flex flex-col flex-1 overflow-y-auto relative\">\n          {showHealthSetupReminder && (\n            <div className=\"fixed bottom-4 right-4 z-50 max-w-sm w-full mx-4 md:mx-0\">\n              <div className=\"bg-white border border-helfi-green/30 shadow-xl rounded-lg p-4\">\n                <h2 className=\"text-sm font-semibold text-helfi-black dark:text-white mb-1\">\n                  Complete your Health Setup for accurate insights\n                </h2>\n                <p className=\"text-xs text-gray-600 mb-3\">\n                  Helfi can only give you precise health guidance when your Health Setup is finished.\n                </p>\n                <div className=\"flex flex-col sm:flex-row gap-2\">\n                  <button\n                    type=\"button\"\n                    onClick={() => {\n                      setShowHealthSetupReminder(false)\n                      router.push('/onboarding?step=1')\n                    }}\n                    className=\"flex-1 bg-helfi-green text-white text-sm px-3 py-2 rounded-md hover:bg-helfi-green-dark transition-colors\"\n                  >\n                    Complete Health Setup\n                  </button>\n                  <button\n                    type=\"button\"\n                    onClick={async () => {\n                      setShowHealthSetupReminder(false)\n                      try {\n                        await fetch('/api/health-setup-status', {\n                          method: 'POST',\n                          headers: { 'Content-Type': 'application/json' },\n                          body: JSON.stringify({ disableReminder: true }),\n                        })\n                      } catch {\n                        // Non-blocking; if this fails we may remind again in a future session\n                      }\n                    }}\n                    className=\"flex-1 bg-gray-100 text-gray-700 text-sm px-3 py-2 rounded-md hover:bg-gray-200 transition-colors\"\n                  >\n                    Don&apos;t ask me again\n                  </button>\n                </div>\n              </div>\n            </div>\n          )}\n          {children}\n          <SupportChatWidget />\n        </div>\n      </div>\n    )\n  }\n\n  // Public pages or unauthenticated users - no sidebar\n  return (\n    <div className=\"min-h-screen\">\n      {children}\n      <SupportChatWidget />\n    </div>\n  )\n} \n","truncated":false,"size":23112},{"path":"components/LowCreditsModal.tsx","content":"'use client'\n\nimport { useState, useEffect } from 'react'\nimport Link from 'next/link'\n\ninterface LowCreditsModalProps {\n  isOpen: boolean\n  onClose: () => void\n  creditsRemaining?: number\n  featureName?: string\n}\n\nexport default function LowCreditsModal({ \n  isOpen, \n  onClose, \n  creditsRemaining = 0,\n  featureName = 'AI features'\n}: LowCreditsModalProps) {\n  const [isClosing, setIsClosing] = useState(false)\n\n  useEffect(() => {\n    if (isOpen) {\n      setIsClosing(false)\n      // Prevent body scroll when modal is open\n      document.body.style.overflow = 'hidden'\n    } else {\n      document.body.style.overflow = ''\n    }\n    return () => {\n      document.body.style.overflow = ''\n    }\n  }, [isOpen])\n\n  const handleClose = () => {\n    setIsClosing(true)\n    setTimeout(() => {\n      onClose()\n      setIsClosing(false)\n    }, 200)\n  }\n\n  if (!isOpen) return null\n\n  return (\n    <div \n      className={`fixed inset-0 z-50 flex items-center justify-center p-4 transition-opacity duration-200 ${\n        isClosing ? 'opacity-0' : 'opacity-100'\n      }`}\n      onClick={handleClose}\n    >\n      {/* Backdrop */}\n      <div className=\"absolute inset-0 bg-black/60 backdrop-blur-sm\" />\n      \n      {/* Modal */}\n      <div \n        className={`relative bg-white rounded-2xl shadow-2xl max-w-md w-full transform transition-all duration-200 ${\n          isClosing ? 'scale-95 opacity-0' : 'scale-100 opacity-100'\n        }`}\n        onClick={(e) => e.stopPropagation()}\n      >\n        {/* Close button */}\n        <button\n          onClick={handleClose}\n          className=\"absolute top-4 right-4 p-2 text-gray-400 hover:text-gray-600 transition-colors rounded-full hover:bg-gray-100\"\n          aria-label=\"Close\"\n        >\n          <svg\n            className=\"w-5 h-5\"\n            viewBox=\"0 0 24 24\"\n            fill=\"none\"\n            stroke=\"currentColor\"\n            strokeWidth=\"2\"\n            strokeLinecap=\"round\"\n            strokeLinejoin=\"round\"\n            aria-hidden=\"true\"\n          >\n            <path d=\"M18 6L6 18\" />\n            <path d=\"M6 6l12 12\" />\n          </svg>\n        </button>\n\n        {/* Content */}\n        <div className=\"p-8\">\n          {/* Icon */}\n          <div className=\"flex justify-center mb-6\">\n            <div className=\"w-20 h-20 bg-gradient-to-br from-red-100 to-orange-100 rounded-full flex items-center justify-center\">\n              <svg \n                className=\"w-10 h-10 text-red-500\" \n                fill=\"none\" \n                stroke=\"currentColor\" \n                viewBox=\"0 0 24 24\"\n              >\n                <path \n                  strokeLinecap=\"round\" \n                  strokeLinejoin=\"round\" \n                  strokeWidth={2} \n                  d=\"M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16c-.77.833.192 2.5 1.732 2.5z\" \n                />\n              </svg>\n            </div>\n          </div>\n\n          {/* Title */}\n          <h2 className=\"text-2xl font-bold text-gray-900 text-center mb-3\">\n            Low Credits Warning\n          </h2>\n\n          {/* Message */}\n          <p className=\"text-gray-600 text-center mb-2\">\n            You're running low on credits\n            {creditsRemaining > 0 && (\n              <span className=\"font-semibold text-red-600\"> ({creditsRemaining} remaining)</span>\n            )}\n            .\n          </p>\n          <p className=\"text-gray-600 text-center mb-8\">\n            Purchase more credits or upgrade your subscription to continue using {featureName}.\n          </p>\n\n          {/* Action buttons */}\n          <div className=\"flex flex-col sm:flex-row gap-3\">\n            <Link\n              href=\"/billing\"\n              onClick={handleClose}\n              className=\"flex-1 px-6 py-3 bg-white border-2 border-gray-300 text-gray-800 font-semibold rounded-xl hover:bg-gray-50 hover:border-gray-400 transition-all duration-200 text-center\"\n            >\n              Upgrade Plan\n            </Link>\n            <Link\n              href=\"/billing\"\n              onClick={handleClose}\n              className=\"flex-1 px-6 py-3 bg-gradient-to-r from-red-600 to-red-500 text-white font-semibold rounded-xl hover:from-red-700 hover:to-red-600 transition-all duration-200 shadow-lg hover:shadow-xl text-center\"\n            >\n              Buy Credits\n            </Link>\n          </div>\n\n          {/* Additional info */}\n          <p className=\"text-xs text-gray-500 text-center mt-6\">\n            Credits refresh monthly with your subscription plan\n          </p>\n        </div>\n      </div>\n    </div>\n  )\n}\n","truncated":false,"size":4612},{"path":"components/MaterialSymbol.tsx","content":"'use client'\n\nimport React from 'react'\n\ntype MaterialSymbolProps = {\n  name: string\n  className?: string\n}\n\nexport default function MaterialSymbol({ name, className }: MaterialSymbolProps) {\n  return <span className={`material-symbols-outlined ${className || ''}`.trim()}>{name}</span>\n}\n\n","truncated":false,"size":290},{"path":"components/MessageModal.tsx","content":"import React from 'react'\n\ninterface MessageModalProps {\n  isOpen: boolean\n  onClose: () => void\n  title: string\n  message: string\n  type?: 'success' | 'error' | 'info'\n  buttonText?: string\n}\n\nconst MessageModal: React.FC<MessageModalProps> = ({\n  isOpen,\n  onClose,\n  title,\n  message,\n  type = 'info',\n  buttonText = 'OK'\n}) => {\n  if (!isOpen) return null\n\n  const typeStyles = {\n    success: {\n      icon: '‚úì',\n      iconBg: 'bg-green-100',\n      iconColor: 'text-green-600',\n      button: 'bg-helfi-green hover:bg-helfi-green-dark'\n    },\n    error: {\n      icon: '‚úï',\n      iconBg: 'bg-red-100',\n      iconColor: 'text-red-600',\n      button: 'bg-red-500 hover:bg-red-600'\n    },\n    info: {\n      icon: '‚Ñπ',\n      iconBg: 'bg-blue-100',\n      iconColor: 'text-blue-600',\n      button: 'bg-blue-600 hover:bg-blue-700'\n    }\n  }\n\n  const styles = typeStyles[type]\n\n  return (\n    <div className=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4\">\n      <div className=\"bg-white rounded-lg shadow-xl max-w-md w-full mx-4\">\n        <div className=\"p-6\">\n          <div className=\"flex items-start mb-4\">\n            <div className={`flex-shrink-0 ${styles.iconBg} rounded-full p-2 mr-4`}>\n              <span className={`text-xl font-bold ${styles.iconColor}`}>{styles.icon}</span>\n            </div>\n            <div className=\"flex-1\">\n              <h2 className=\"text-xl font-bold text-gray-900 mb-2\">{title}</h2>\n              <p className=\"text-gray-600 whitespace-pre-line\">{message}</p>\n            </div>\n          </div>\n          <div className=\"flex justify-end\">\n            <button\n              onClick={onClose}\n              className={`px-6 py-2 text-white rounded-lg transition-colors ${styles.button}`}\n            >\n              {buttonText}\n            </button>\n          </div>\n        </div>\n      </div>\n    </div>\n  )\n}\n\nexport default MessageModal\n\n","truncated":false,"size":1918},{"path":"components/MobileMoreMenu.tsx","content":"'use client'\n\nimport Link from 'next/link'\nimport { usePathname } from 'next/navigation'\n\nfunction triggerHaptic() {\n  try {\n    const reduced = window.matchMedia('(prefers-reduced-motion: reduce)')?.matches\n    const pref = typeof window !== 'undefined' ? localStorage.getItem('hapticsEnabled') : null\n    const enabled = pref === null ? true : pref === 'true'\n    if (!reduced && enabled && typeof navigator !== 'undefined' && 'vibrate' in navigator) {\n      navigator.vibrate(10)\n    }\n  } catch {}\n}\n\nexport default function MobileMoreMenu() {\n  const pathname = usePathname()\n  const isActive = pathname === '/more'\n\n  return (\n    <Link\n      href=\"/more\"\n      className=\"pressable ripple flex flex-col items-center py-2 px-1 min-w-0 flex-1\"\n      onClick={triggerHaptic}\n    >\n      <div className={`icon ${isActive ? 'text-helfi-green' : 'text-gray-400'}`}>\n        <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n          <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M12 6.75a1.5 1.5 0 110-3 1.5 1.5 0 010 3zm0 6a1.5 1.5 0 110-3 1.5 1.5 0 010 3zm0 6a1.5 1.5 0 110-3 1.5 1.5 0 010 3z\"/>\n        </svg>\n      </div>\n      <span className={`label text-xs mt-1 truncate ${isActive ? 'text-helfi-green font-bold' : 'text-gray-400 font-medium'}`}>More</span>\n    </Link>\n  )\n}\n\n\n","truncated":false,"size":1341},{"path":"components/mood/ExpandableContextRow.tsx","content":"'use client'\n\nimport React from 'react'\n\nexport default function ExpandableContextRow({\n  icon,\n  label,\n  value,\n  children,\n}: {\n  icon: React.ReactNode\n  label: string\n  value?: string\n  children: React.ReactNode\n}) {\n  return (\n    <details className=\"group rounded-xl border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800\">\n      <summary className=\"list-none cursor-pointer select-none px-4 py-3 flex items-center gap-3 touch-manipulation\">\n        <div className=\"w-9 h-9 rounded-lg bg-gray-50 dark:bg-gray-700 flex items-center justify-center text-gray-600 dark:text-gray-200\">\n          {icon}\n        </div>\n        <div className=\"flex-1 min-w-0\">\n          <div className=\"text-sm font-medium text-gray-900 dark:text-white\">{label}</div>\n          <div className=\"text-xs text-gray-500 dark:text-gray-400 truncate\">{value || 'Optional'}</div>\n        </div>\n        <svg\n          className=\"w-5 h-5 text-gray-400 transition-transform group-open:rotate-180\"\n          fill=\"none\"\n          stroke=\"currentColor\"\n          viewBox=\"0 0 24 24\"\n          aria-hidden=\"true\"\n        >\n          <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M19 9l-7 7-7-7\" />\n        </svg>\n      </summary>\n      <div className=\"px-4 pb-4 pt-1\">\n        {children}\n      </div>\n    </details>\n  )\n}\n\n","truncated":false,"size":1333},{"path":"components/mood/FivePointScale.tsx","content":"'use client'\n\nimport React from 'react'\n\nconst LEVELS = [\n  { value: 1, label: 'Low' },\n  { value: 2, label: 'Low‚Äëmid' },\n  { value: 3, label: 'Medium' },\n  { value: 4, label: 'High‚Äëmid' },\n  { value: 5, label: 'High' },\n] as const\n\nexport default function FivePointScale({\n  label,\n  value,\n  onChange,\n}: {\n  label: string\n  value: number | null\n  onChange: (next: number | null) => void\n}) {\n  return (\n    <div>\n      <div className=\"text-sm font-medium text-gray-800 dark:text-gray-200\">{label}</div>\n      <div className=\"mt-2 grid grid-cols-5 gap-2\">\n        {LEVELS.map((l) => {\n          const isSelected = l.value === value\n          return (\n            <button\n              key={l.value}\n              type=\"button\"\n              onClick={() => onChange(isSelected ? null : l.value)}\n              className={[\n                'rounded-lg border px-2 py-2 text-xs font-medium touch-manipulation',\n                isSelected\n                  ? 'bg-helfi-green/10 border-helfi-green/30 text-helfi-green-dark dark:text-helfi-green-light'\n                  : 'bg-white dark:bg-gray-800 border-gray-200 dark:border-gray-700 text-gray-700 dark:text-gray-200 hover:bg-gray-50 dark:hover:bg-gray-700/50',\n              ].join(' ')}\n              aria-pressed={isSelected}\n            >\n              {l.value}\n            </button>\n          )\n        })}\n      </div>\n      <div className=\"mt-2 text-xs text-gray-500 dark:text-gray-400\">\n        {value ? LEVELS.find((l) => l.value === value)?.label : 'Optional'}\n      </div>\n    </div>\n  )\n}\n\n","truncated":false,"size":1556},{"path":"components/mood/InfluenceChips.tsx","content":"'use client'\n\nimport React, { useEffect, useMemo, useState } from 'react'\n\ntype CustomIcon = {\n  type: 'badge' | 'image'\n  value: string\n  color?: string\n}\n\ntype Tile = {\n  id: string\n  label: string\n  imageUrl?: string\n  badgeMark?: string\n  badgeColor?: string\n  fallbackIcon?: string\n  isCustom?: boolean\n}\n\nconst CUSTOM_ICON_KEY = 'moodCustomIconsV1'\n\nconst BADGE_COLORS = [\n  '#E8F5E9',\n  '#E3F2FD',\n  '#FCE4EC',\n  '#FFF3E0',\n  '#E8EAF6',\n  '#E0F7FA',\n  '#F3E5F5',\n  '#F1F8E9',\n] as const\n\nconst ICON_URLS = {\n  work: 'https://bvconuycpdvgzbvbkijl.supabase.co/storage/v1/object/public/sizes/5f20be-computer/dynamic/200/color.webp',\n  family: 'https://bvconuycpdvgzbvbkijl.supabase.co/storage/v1/object/public/sizes/1acc3d-heart/dynamic/200/color.webp',\n  sleep: 'https://bvconuycpdvgzbvbkijl.supabase.co/storage/v1/object/public/sizes/a63030-moon/dynamic/200/color.webp',\n  food: 'https://bvconuycpdvgzbvbkijl.supabase.co/storage/v1/object/public/sizes/7fb19c-cup/dynamic/200/color.webp',\n  weather: 'https://bvconuycpdvgzbvbkijl.supabase.co/storage/v1/object/public/sizes/801da3-sun/dynamic/200/color.webp',\n  exercise: 'https://bvconuycpdvgzbvbkijl.supabase.co/storage/v1/object/public/sizes/10c35a-gym/dynamic/200/color.webp',\n  travel: 'https://bvconuycpdvgzbvbkijl.supabase.co/storage/v1/object/public/sizes/fa6099-travel/dynamic/200/color.webp',\n  social: 'https://bvconuycpdvgzbvbkijl.supabase.co/storage/v1/object/public/sizes/eec43d-chat-bubble/dynamic/200/color.webp',\n  music: 'https://bvconuycpdvgzbvbkijl.supabase.co/storage/v1/object/public/sizes/331e9c-music/dynamic/200/color.webp',\n  movies: 'https://bvconuycpdvgzbvbkijl.supabase.co/storage/v1/object/public/sizes/b1dccf-video-cam/dynamic/200/color.webp',\n  gaming: 'https://bvconuycpdvgzbvbkijl.supabase.co/storage/v1/object/public/sizes/a68576-puzzle/dynamic/200/color.webp',\n  reading: 'https://bvconuycpdvgzbvbkijl.supabase.co/storage/v1/object/public/sizes/628100-notebook/dynamic/200/color.webp',\n  shopping: 'https://bvconuycpdvgzbvbkijl.supabase.co/storage/v1/object/public/sizes/f71a3e-bag/dynamic/200/color.webp',\n  cleaning: 'https://bvconuycpdvgzbvbkijl.supabase.co/storage/v1/object/public/sizes/368c50-broom/dynamic/200/color.webp',\n  cooking: 'https://bvconuycpdvgzbvbkijl.supabase.co/storage/v1/object/public/sizes/544d0d-cauldron/dynamic/200/color.webp',\n  tea: 'https://bvconuycpdvgzbvbkijl.supabase.co/storage/v1/object/public/sizes/845bf0-tea-cup/dynamic/200/color.webp',\n  photography: 'https://bvconuycpdvgzbvbkijl.supabase.co/storage/v1/object/public/sizes/5656e5-camera/dynamic/200/color.webp',\n  art: 'https://bvconuycpdvgzbvbkijl.supabase.co/storage/v1/object/public/sizes/fcbbf1-painting-kit/dynamic/200/color.webp',\n  nature: 'https://bvconuycpdvgzbvbkijl.supabase.co/storage/v1/object/public/sizes/2c84d9-leaf/dynamic/200/color.webp',\n  pets: 'https://bvconuycpdvgzbvbkijl.supabase.co/storage/v1/object/public/sizes/1dec68-bone/dynamic/200/color.webp',\n  money: 'https://bvconuycpdvgzbvbkijl.supabase.co/storage/v1/object/public/sizes/7d956f-wallet/dynamic/200/color.webp',\n  goals: 'https://bvconuycpdvgzbvbkijl.supabase.co/storage/v1/object/public/sizes/49b6f4-target/dynamic/200/color.webp',\n  calendar: 'https://bvconuycpdvgzbvbkijl.supabase.co/storage/v1/object/public/sizes/f32794-calendar/dynamic/200/color.webp',\n  walk: 'https://bvconuycpdvgzbvbkijl.supabase.co/storage/v1/object/public/sizes/1858b9-map-pin/dynamic/200/color.webp',\n  study: 'https://bvconuycpdvgzbvbkijl.supabase.co/storage/v1/object/public/sizes/66b0f8-pencil/dynamic/200/color.webp',\n  relax: 'https://bvconuycpdvgzbvbkijl.supabase.co/storage/v1/object/public/sizes/6e6a21-candle/dynamic/200/color.webp',\n  calls: 'https://bvconuycpdvgzbvbkijl.supabase.co/storage/v1/object/public/sizes/87c2c5-call-out/dynamic/200/color.webp',\n  sports: 'https://bvconuycpdvgzbvbkijl.supabase.co/storage/v1/object/public/sizes/7db5bc-ball/dynamic/200/color.webp',\n  diy: 'https://bvconuycpdvgzbvbkijl.supabase.co/storage/v1/object/public/sizes/ff5be0-tools/dynamic/200/color.webp',\n  chores: 'https://bvconuycpdvgzbvbkijl.supabase.co/storage/v1/object/public/sizes/add2ea-trash-can/dynamic/200/color.webp',\n  rainy: 'https://bvconuycpdvgzbvbkijl.supabase.co/storage/v1/object/public/sizes/3f82a3-umbrella/dynamic/200/color.webp',\n  audio: 'https://bvconuycpdvgzbvbkijl.supabase.co/storage/v1/object/public/sizes/b81ead-headphone/dynamic/200/color.webp',\n  achievement: 'https://bvconuycpdvgzbvbkijl.supabase.co/storage/v1/object/public/sizes/39121b-medal/dynamic/200/color.webp',\n  motivation: 'https://bvconuycpdvgzbvbkijl.supabase.co/storage/v1/object/public/sizes/744cc0-rocket/dynamic/200/color.webp',\n  time: 'https://bvconuycpdvgzbvbkijl.supabase.co/storage/v1/object/public/sizes/8ef1fa-clock/dynamic/200/color.webp',\n} as const\n\nconst ICON_CHOICES = [\n  { id: 'work', label: 'Work', imageUrl: ICON_URLS.work },\n  { id: 'family', label: 'Family', imageUrl: ICON_URLS.family },\n  { id: 'sleep', label: 'Sleep', imageUrl: ICON_URLS.sleep },\n  { id: 'food', label: 'Food & Drink', imageUrl: ICON_URLS.food },\n  { id: 'weather', label: 'Weather', imageUrl: ICON_URLS.weather },\n  { id: 'exercise', label: 'Exercise', imageUrl: ICON_URLS.exercise },\n  { id: 'travel', label: 'Travel', imageUrl: ICON_URLS.travel },\n  { id: 'social', label: 'Social', imageUrl: ICON_URLS.social },\n  { id: 'music', label: 'Music', imageUrl: ICON_URLS.music },\n  { id: 'movies', label: 'Movies', imageUrl: ICON_URLS.movies },\n  { id: 'gaming', label: 'Gaming', imageUrl: ICON_URLS.gaming },\n  { id: 'reading', label: 'Reading', imageUrl: ICON_URLS.reading },\n  { id: 'shopping', label: 'Shopping', imageUrl: ICON_URLS.shopping },\n  { id: 'cleaning', label: 'Cleaning', imageUrl: ICON_URLS.cleaning },\n  { id: 'cooking', label: 'Cooking', imageUrl: ICON_URLS.cooking },\n  { id: 'tea', label: 'Tea/Coffee', imageUrl: ICON_URLS.tea },\n  { id: 'photography', label: 'Photography', imageUrl: ICON_URLS.photography },\n  { id: 'art', label: 'Art', imageUrl: ICON_URLS.art },\n  { id: 'nature', label: 'Nature', imageUrl: ICON_URLS.nature },\n  { id: 'pets', label: 'Pets', imageUrl: ICON_URLS.pets },\n  { id: 'money', label: 'Money', imageUrl: ICON_URLS.money },\n  { id: 'goals', label: 'Goals', imageUrl: ICON_URLS.goals },\n  { id: 'calendar', label: 'Schedule', imageUrl: ICON_URLS.calendar },\n  { id: 'walk', label: 'Walk', imageUrl: ICON_URLS.walk },\n  { id: 'study', label: 'Study', imageUrl: ICON_URLS.study },\n  { id: 'relax', label: 'Relax', imageUrl: ICON_URLS.relax },\n  { id: 'calls', label: 'Calls', imageUrl: ICON_URLS.calls },\n  { id: 'sports', label: 'Sports', imageUrl: ICON_URLS.sports },\n  { id: 'diy', label: 'DIY', imageUrl: ICON_URLS.diy },\n  { id: 'chores', label: 'Chores', imageUrl: ICON_URLS.chores },\n  { id: 'rainy', label: 'Rainy day', imageUrl: ICON_URLS.rainy },\n  { id: 'audio', label: 'Podcasts', imageUrl: ICON_URLS.audio },\n  { id: 'achievement', label: 'Achievement', imageUrl: ICON_URLS.achievement },\n  { id: 'motivation', label: 'Motivation', imageUrl: ICON_URLS.motivation },\n  { id: 'time', label: 'Time', imageUrl: ICON_URLS.time },\n] as const\n\nfunction normalize(tag: string) {\n  return tag.trim().replace(/\\s+/g, ' ').slice(0, 24)\n}\n\nfunction colorForLabel(label: string) {\n  let hash = 0\n  for (let i = 0; i < label.length; i++) {\n    hash = (hash * 31 + label.charCodeAt(i)) % 997\n  }\n  return BADGE_COLORS[hash % BADGE_COLORS.length]\n}\n\nfunction firstMark(label: string): string {\n  const s = label.trim()\n  if (!s) return '‚Ä¢'\n  try {\n    const Seg = (Intl as any)?.Segmenter\n    if (Seg) {\n      const seg = new Seg(undefined, { granularity: 'grapheme' })\n      const it = seg.segment(s)[Symbol.iterator]()\n      const first = it.next()?.value\n      const val = first?.segment\n      if (val) return String(val)\n    }\n  } catch {}\n  return Array.from(s)[0] || '‚Ä¢'\n}\n\nfunction defaultBadge(label: string): CustomIcon {\n  return {\n    type: 'badge',\n    value: firstMark(label),\n    color: colorForLabel(label),\n  }\n}\n\nexport default function InfluenceChips({\n  value,\n  onChange,\n}: {\n  value: string[]\n  onChange: (next: string[]) => void\n}) {\n  const [adding, setAdding] = useState(false)\n  const [custom, setCustom] = useState('')\n  const [expanded, setExpanded] = useState(false)\n  const [customIcons, setCustomIcons] = useState<Record<string, CustomIcon>>({})\n  const [iconPickerOpen, setIconPickerOpen] = useState(false)\n  const [iconPickerLabel, setIconPickerLabel] = useState<string | null>(null)\n  const [pendingIcon, setPendingIcon] = useState<CustomIcon | null>(null)\n\n  useEffect(() => {\n    try {\n      const flag = sessionStorage.getItem('moodInfluencesExpanded')\n      if (flag === '1') {\n        setExpanded(true)\n        sessionStorage.removeItem('moodInfluencesExpanded')\n      }\n    } catch {}\n  }, [])\n\n  useEffect(() => {\n    try {\n      const raw = localStorage.getItem(CUSTOM_ICON_KEY)\n      if (!raw) return\n      const parsed = JSON.parse(raw)\n      if (parsed && typeof parsed === 'object') setCustomIcons(parsed)\n    } catch {}\n  }, [])\n\n  useEffect(() => {\n    try {\n      localStorage.setItem(CUSTOM_ICON_KEY, JSON.stringify(customIcons))\n    } catch {}\n  }, [customIcons])\n\n  const selected = useMemo(() => new Set(value.map((t) => normalize(t)).filter(Boolean)), [value])\n\n  const toggle = (tag: string) => {\n    const t = normalize(tag)\n    if (!t) return\n    const next = new Set(selected)\n    if (next.has(t)) next.delete(t)\n    else next.add(t)\n    onChange(Array.from(next))\n  }\n\n  const openPicker = (label: string | null) => {\n    setIconPickerLabel(label)\n    setIconPickerOpen(true)\n  }\n\n  const closePicker = () => {\n    setIconPickerOpen(false)\n    setIconPickerLabel(null)\n  }\n\n  const applyIcon = (label: string, icon: CustomIcon) => {\n    const key = normalize(label)\n    setCustomIcons((prev) => ({ ...prev, [key]: icon }))\n  }\n\n  const addCustom = () => {\n    const t = normalize(custom)\n    if (!t) return\n    const next = new Set(selected)\n    next.add(t)\n    onChange(Array.from(next))\n    const icon = pendingIcon || defaultBadge(t)\n    applyIcon(t, icon)\n    setCustom('')\n    setAdding(false)\n    setPendingIcon(null)\n    setExpanded(true)\n  }\n\n  const getCustomIcon = (label: string) => {\n    const key = normalize(label)\n    return customIcons[key] || defaultBadge(label)\n  }\n\n  const tiles = useMemo((): Tile[] => {\n    const main: Tile[] = [\n      { id: 'work', label: 'Work', imageUrl: ICON_URLS.work, fallbackIcon: 'work' },\n      { id: 'family', label: 'Family', imageUrl: ICON_URLS.family, fallbackIcon: 'family_restroom' },\n      { id: 'sleep', label: 'Sleep', imageUrl: ICON_URLS.sleep, fallbackIcon: 'bedtime' },\n      { id: 'food', label: 'Food & Drink', imageUrl: ICON_URLS.food, fallbackIcon: 'restaurant' },\n      { id: 'weather', label: 'Weather', imageUrl: ICON_URLS.weather, fallbackIcon: 'sunny' },\n      { id: 'exercise', label: 'Exercise', imageUrl: ICON_URLS.exercise, fallbackIcon: 'fitness_center' },\n    ]\n\n    const more: Tile[] = [\n      { id: 'travel', label: 'Travel', imageUrl: ICON_URLS.travel },\n      { id: 'social', label: 'Social', imageUrl: ICON_URLS.social },\n      { id: 'music', label: 'Music', imageUrl: ICON_URLS.music },\n      { id: 'movies', label: 'Movies', imageUrl: ICON_URLS.movies },\n      { id: 'gaming', label: 'Gaming', imageUrl: ICON_URLS.gaming },\n      { id: 'reading', label: 'Reading', imageUrl: ICON_URLS.reading },\n      { id: 'shopping', label: 'Shopping', imageUrl: ICON_URLS.shopping },\n      { id: 'cleaning', label: 'Cleaning', imageUrl: ICON_URLS.cleaning },\n      { id: 'cooking', label: 'Cooking', imageUrl: ICON_URLS.cooking },\n      { id: 'tea', label: 'Tea/Coffee', imageUrl: ICON_URLS.tea },\n      { id: 'photography', label: 'Photography', imageUrl: ICON_URLS.photography },\n      { id: 'art', label: 'Art', imageUrl: ICON_URLS.art },\n      { id: 'nature', label: 'Nature', imageUrl: ICON_URLS.nature },\n      { id: 'pets', label: 'Pets', imageUrl: ICON_URLS.pets },\n      { id: 'money', label: 'Money', imageUrl: ICON_URLS.money },\n      { id: 'goals', label: 'Goals', imageUrl: ICON_URLS.goals },\n      { id: 'calendar', label: 'Schedule', imageUrl: ICON_URLS.calendar },\n      { id: 'walk', label: 'Walk', imageUrl: ICON_URLS.walk },\n      { id: 'study', label: 'Study', imageUrl: ICON_URLS.study },\n      { id: 'relax', label: 'Relax', imageUrl: ICON_URLS.relax },\n      { id: 'calls', label: 'Calls', imageUrl: ICON_URLS.calls },\n      { id: 'sports', label: 'Sports', imageUrl: ICON_URLS.sports },\n      { id: 'diy', label: 'DIY', imageUrl: ICON_URLS.diy },\n      { id: 'chores', label: 'Chores', imageUrl: ICON_URLS.chores },\n      { id: 'rainy', label: 'Rainy day', imageUrl: ICON_URLS.rainy },\n      { id: 'audio', label: 'Podcasts', imageUrl: ICON_URLS.audio },\n      { id: 'achievement', label: 'Achievement', imageUrl: ICON_URLS.achievement },\n      { id: 'motivation', label: 'Motivation', imageUrl: ICON_URLS.motivation },\n      { id: 'time', label: 'Time', imageUrl: ICON_URLS.time },\n    ]\n\n    const known = new Set<string>([...main, ...more].map((t) => normalize(t.label)))\n    const customTiles: Tile[] = Array.from(selected)\n      .filter((t) => !known.has(normalize(t)))\n      .map((t) => {\n        const icon = getCustomIcon(t)\n        return {\n          id: `custom-${t}`,\n          label: t,\n          isCustom: true,\n          imageUrl: icon.type === 'image' ? icon.value : undefined,\n          badgeMark: icon.type === 'badge' ? icon.value : undefined,\n          badgeColor: icon.type === 'badge' ? icon.color : undefined,\n          fallbackIcon: 'sell',\n        }\n      })\n\n    const selectedMore = more.filter((t) => selected.has(normalize(t.label)))\n\n    const dedupe = (arr: Tile[]) => {\n      const seen = new Set<string>()\n      const out: Tile[] = []\n      for (const item of arr) {\n        const key = normalize(item.label)\n        if (seen.has(key)) continue\n        seen.add(key)\n        out.push(item)\n      }\n      return out\n    }\n\n    const base = expanded ? dedupe([...main, ...more]) : dedupe([...main, ...selectedMore])\n    return [...base, ...customTiles]\n  }, [selected, expanded, customIcons])\n\n  const pendingPreview = useMemo(() => {\n    if (pendingIcon) return pendingIcon\n    if (!custom.trim()) return defaultBadge('New')\n    return defaultBadge(custom)\n  }, [pendingIcon, custom])\n\n  return (\n    <div className=\"w-full\">\n      <div className=\"flex items-center justify-between mb-4 px-1\">\n        <h3 className=\"text-base font-bold text-slate-800 dark:text-white\">What‚Äôs affecting you?</h3>\n        <button\n          type=\"button\"\n          onClick={() => setExpanded((v) => !v)}\n          className=\"inline-flex items-center gap-1 rounded-full border border-slate-200 dark:border-gray-700 bg-white dark:bg-gray-800 px-3 py-2 text-sm font-bold text-helfi-green hover:bg-slate-50 dark:hover:bg-gray-700/50\"\n        >\n          <span className=\"material-symbols-outlined text-[18px]\">{expanded ? 'expand_less' : 'expand_more'}</span>\n          {expanded ? 'Show less' : 'More options'}\n        </button>\n      </div>\n\n      <div className=\"grid grid-cols-3 gap-y-6 gap-x-4 px-1 pb-2\">\n        {tiles.map((item) => {\n          const isSelected = selected.has(normalize(item.label))\n          return (\n            <button\n              key={item.id}\n              type=\"button\"\n              onClick={() => toggle(item.label)}\n              className=\"flex flex-col items-center gap-2 group\"\n              aria-pressed={isSelected}\n            >\n              <div\n                className={[\n                  'relative p-1 rounded-full transition-all duration-200',\n                  isSelected\n                    ? 'ring-2 ring-helfi-green ring-offset-2 ring-offset-[#f8f9fa] dark:ring-offset-gray-900'\n                    : 'hover:bg-black/5 dark:hover:bg-white/5',\n                ].join(' ')}\n              >\n                {item.imageUrl ? (\n                  <img\n                    src={item.imageUrl}\n                    alt={item.label}\n                    loading=\"lazy\"\n                    className=\"w-16 h-16 sm:w-20 sm:h-20 rounded-full bg-white dark:bg-gray-800 object-contain p-2\"\n                  />\n                ) : (\n                  <div\n                    className=\"w-16 h-16 sm:w-20 sm:h-20 rounded-full border border-slate-200 dark:border-gray-700 flex items-center justify-center\"\n                    style={{ backgroundColor: item.badgeColor || '#ffffff' }}\n                  >\n                    {item.badgeMark ? (\n                      <span className=\"text-3xl leading-none text-slate-700\">{item.badgeMark}</span>\n                    ) : (\n                      <span className=\"material-symbols-outlined text-[34px] text-slate-400 dark:text-gray-400\">\n                        {item.fallbackIcon || 'sell'}\n                      </span>\n                    )}\n                  </div>\n                )}\n\n                {item.isCustom && (\n                  <button\n                    type=\"button\"\n                    onClick={(e) => {\n                      e.stopPropagation()\n                      openPicker(item.label)\n                    }}\n                    className=\"absolute -top-1 -right-1 bg-white dark:bg-gray-800 border border-slate-200 dark:border-gray-700 rounded-full p-1 shadow-sm\"\n                    aria-label={`Change icon for ${item.label}`}\n                  >\n                    <span className=\"material-symbols-outlined text-[14px] text-slate-500\">edit</span>\n                  </button>\n                )}\n\n                {isSelected && (\n                  <div className=\"absolute -bottom-1 -right-1 bg-helfi-green text-[#0b2b10] rounded-full p-0.5 border-2 border-[#f8f9fa] dark:border-gray-900\">\n                    <span className=\"material-symbols-outlined\" style={{ fontSize: 16, fontWeight: 700, display: 'block' }}>\n                      check\n                    </span>\n                  </div>\n                )}\n              </div>\n              <p\n                className={\n                  isSelected\n                    ? 'text-slate-900 dark:text-white text-sm font-semibold leading-normal text-center'\n                    : 'text-slate-500 dark:text-gray-400 text-sm font-medium leading-normal text-center group-hover:text-helfi-green transition-colors'\n                }\n              >\n                {item.label}\n              </p>\n            </button>\n          )\n        })}\n\n        <button\n          type=\"button\"\n          onClick={() => setAdding((v) => !v)}\n          className=\"flex flex-col items-center gap-2 group\"\n          aria-label=\"Add your own\"\n        >\n          <div className=\"relative p-1 rounded-full transition-all duration-200 hover:bg-black/5 dark:hover:bg-white/5\">\n            <div className=\"w-16 h-16 sm:w-20 sm:h-20 rounded-full bg-slate-50 dark:bg-gray-800 border border-dashed border-slate-300 dark:border-gray-600 flex items-center justify-center\">\n              <span className=\"material-symbols-outlined text-[34px] text-slate-400\">add</span>\n            </div>\n          </div>\n          <p className=\"text-slate-400 dark:text-gray-500 text-sm font-medium leading-normal text-center\">Add</p>\n        </button>\n      </div>\n\n      {adding && (\n        <div className=\"mt-4 flex flex-col gap-3\">\n          <div className=\"flex gap-2 items-center\">\n            <div\n              className=\"w-12 h-12 rounded-full border border-slate-200 dark:border-gray-700 flex items-center justify-center\"\n              style={{ backgroundColor: pendingPreview.color || '#ffffff' }}\n            >\n              {pendingPreview.type === 'image' ? (\n                <img\n                  src={pendingPreview.value}\n                  alt=\"Selected icon\"\n                  className=\"w-12 h-12 rounded-full bg-white dark:bg-gray-800 object-contain p-1\"\n                />\n              ) : (\n                <span className=\"text-2xl text-slate-700\">{pendingPreview.value}</span>\n              )}\n            </div>\n            <button\n              type=\"button\"\n              onClick={() => openPicker('__new__')}\n              className=\"rounded-full border border-slate-200 dark:border-gray-700 bg-white dark:bg-gray-800 px-3 py-2 text-sm font-bold text-helfi-green hover:bg-slate-50 dark:hover:bg-gray-700/50\"\n            >\n              Change icon\n            </button>\n          </div>\n          <div className=\"flex gap-2\">\n            <input\n              value={custom}\n              onChange={(e) => setCustom(e.target.value)}\n              placeholder=\"Type it (emoji first if you want one)\"\n              className=\"flex-1 min-w-0 rounded-full border border-slate-200 dark:border-gray-700 bg-white dark:bg-gray-900 px-4 py-3 text-base text-slate-900 dark:text-white\"\n              maxLength={24}\n            />\n            <button\n              type=\"button\"\n              onClick={addCustom}\n              disabled={!normalize(custom)}\n              className=\"rounded-full bg-helfi-green px-5 py-3 text-sm font-bold text-white disabled:opacity-50\"\n            >\n              Add\n            </button>\n          </div>\n        </div>\n      )}\n\n      {iconPickerOpen && (\n        <div className=\"fixed inset-0 z-50 flex items-center justify-center bg-black/40 px-4\">\n          <div className=\"w-full max-w-sm rounded-2xl bg-white dark:bg-gray-900 border border-slate-200 dark:border-gray-700 p-4\">\n            <div className=\"text-base font-bold text-slate-800 dark:text-white\">Choose an icon</div>\n            <div className=\"mt-3 grid grid-cols-4 gap-3\">\n              {ICON_CHOICES.map((icon) => (\n                <button\n                  key={icon.id}\n                  type=\"button\"\n                  onClick={() => {\n                    if (iconPickerLabel === '__new__') {\n                      setPendingIcon({ type: 'image', value: icon.imageUrl })\n                    } else if (iconPickerLabel) {\n                      applyIcon(iconPickerLabel, { type: 'image', value: icon.imageUrl })\n                    }\n                    closePicker()\n                  }}\n                  className=\"rounded-full border border-slate-200 dark:border-gray-700 p-1 hover:border-helfi-green\"\n                >\n                  <img\n                    src={icon.imageUrl}\n                    alt={icon.label}\n                    className=\"w-14 h-14 rounded-full bg-white dark:bg-gray-800 object-contain p-2\"\n                  />\n                </button>\n              ))}\n            </div>\n            <div className=\"mt-4 flex gap-2\">\n              <button\n                type=\"button\"\n                onClick={() => {\n                  if (iconPickerLabel === '__new__') {\n                    setPendingIcon(null)\n                  } else if (iconPickerLabel) {\n                    applyIcon(iconPickerLabel, defaultBadge(iconPickerLabel))\n                  }\n                  closePicker()\n                }}\n                className=\"flex-1 rounded-full border border-slate-200 dark:border-gray-700 bg-white dark:bg-gray-800 px-4 py-2 text-sm font-bold text-slate-700 dark:text-gray-200\"\n              >\n                Use letter badge\n              </button>\n              <button\n                type=\"button\"\n                onClick={closePicker}\n                className=\"flex-1 rounded-full bg-helfi-green px-4 py-2 text-sm font-bold text-white\"\n              >\n                Done\n              </button>\n            </div>\n          </div>\n        </div>\n      )}\n    </div>\n  )\n}\n","truncated":false,"size":23502},{"path":"components/mood/InsightCard.tsx","content":"'use client'\n\nimport React from 'react'\n\nexport type InsightCardData = {\n  title: string\n  detail: string\n  confidence: 'low' | 'medium' | 'high'\n}\n\nfunction confidenceLabel(confidence: InsightCardData['confidence']) {\n  if (confidence === 'high') return 'High confidence'\n  if (confidence === 'medium') return 'Medium confidence'\n  return 'Low confidence'\n}\n\nfunction confidenceClasses(confidence: InsightCardData['confidence']) {\n  if (confidence === 'high') return 'bg-helfi-green/10 text-helfi-green-dark border-helfi-green/20'\n  if (confidence === 'medium') return 'bg-yellow-50 text-yellow-800 border-yellow-200 dark:bg-yellow-900/20 dark:text-yellow-200 dark:border-yellow-800/40'\n  return 'bg-gray-50 text-gray-700 border-gray-200 dark:bg-gray-800/60 dark:text-gray-300 dark:border-gray-700'\n}\n\nexport default function InsightCard({ title, detail, confidence }: InsightCardData) {\n  return (\n    <div className=\"rounded-2xl border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 p-4 shadow-sm\">\n      <div className=\"flex items-start justify-between gap-3\">\n        <div className=\"text-base font-semibold text-gray-900 dark:text-white\">{title}</div>\n        <div className={`shrink-0 rounded-full border px-2 py-1 text-xs ${confidenceClasses(confidence)}`}>\n          {confidenceLabel(confidence)}\n        </div>\n      </div>\n      <div className=\"mt-2 text-sm text-gray-600 dark:text-gray-300 leading-relaxed\">\n        {detail}\n      </div>\n    </div>\n  )\n}\n\n","truncated":false,"size":1484},{"path":"components/mood/IntensitySlider.tsx","content":"'use client'\n\nimport React, { useMemo } from 'react'\n\nfunction clampInt(value: number, min: number, max: number) {\n  return Math.max(min, Math.min(max, Math.round(value)))\n}\n\nexport default function IntensitySlider({\n  value,\n  onChange,\n}: {\n  value: number\n  onChange: (next: number) => void\n}) {\n  const pct = useMemo(() => clampInt(value, 0, 100), [value])\n\n  return (\n    <div className=\"rounded-2xl p-5 shadow-sm border border-slate-100 bg-slate-50 dark:bg-gray-800/60 dark:border-gray-700\">\n      <div className=\"flex justify-between items-center mb-4\">\n        <div className=\"flex items-center gap-2\">\n          <div className=\"w-9 h-9 rounded-full bg-helfi-green/10 text-helfi-green flex items-center justify-center\">\n            <span className=\"material-symbols-outlined text-[20px]\">bolt</span>\n          </div>\n          <p className=\"text-base font-bold text-slate-700 dark:text-gray-100\">Intensity</p>\n        </div>\n        <p className=\"text-2xl font-bold text-helfi-green\">{pct}%</p>\n      </div>\n\n      <div className=\"relative w-full\">\n        <div className=\"w-full h-3 rounded-full bg-slate-200 dark:bg-gray-700 overflow-hidden\">\n          <div\n            className=\"h-full rounded-full bg-gradient-to-r from-green-300 to-helfi-green\"\n            style={{ width: `${pct}%` }}\n          />\n        </div>\n\n        <input\n          type=\"range\"\n          min={0}\n          max={100}\n          step={1}\n          value={pct}\n          onChange={(e) => onChange(clampInt(Number(e.target.value), 0, 100))}\n          className=\"absolute inset-0 w-full h-8 -top-2 opacity-0 cursor-pointer\"\n          aria-label=\"Intensity\"\n        />\n\n        <div\n          className=\"absolute top-1/2 -translate-y-1/2 w-7 h-7 bg-white dark:bg-gray-200 border-4 border-helfi-green rounded-full shadow-md transition-transform pointer-events-none\"\n          style={{ left: `${pct}%`, transform: `translate(-50%, -50%)` }}\n        />\n      </div>\n\n      <div className=\"flex justify-between mt-3 px-1\">\n        <span className=\"text-xs font-semibold text-slate-400 dark:text-gray-400 uppercase tracking-wider\">Low</span>\n        <span className=\"text-xs font-semibold text-slate-400 dark:text-gray-400 uppercase tracking-wider\">High</span>\n      </div>\n    </div>\n  )\n}\n\n","truncated":false,"size":2269},{"path":"components/mood/MoodFaceIcon.tsx","content":"'use client'\n\nimport React from 'react'\n\nfunction mouthPath(level: number) {\n  // 1..7 where 1 is very low and 7 is very high\n  if (level <= 2) return 'M10 19c2.5-2 5.5-2 8 0' // frown\n  if (level === 3) return 'M10 18c2-1.2 6-1.2 8 0' // slight frown\n  if (level === 4) return 'M10 17.5h8' // neutral\n  if (level === 5) return 'M10 17c2 1.2 6 1.2 8 0' // slight smile\n  return 'M10 16c2.5 2 5.5 2 8 0' // smile\n}\n\nexport default function MoodFaceIcon({\n  level,\n  selected,\n}: {\n  level: number\n  selected?: boolean\n}) {\n  return (\n    <svg\n      viewBox=\"0 0 32 32\"\n      className=\"w-9 h-9\"\n      aria-hidden=\"true\"\n    >\n      <circle\n        cx=\"16\"\n        cy=\"16\"\n        r=\"13\"\n        fill=\"currentColor\"\n        opacity={selected ? 0.18 : 0.12}\n      />\n      <circle cx=\"12.5\" cy=\"13.5\" r=\"1.2\" fill=\"currentColor\" opacity={selected ? 0.9 : 0.7} />\n      <circle cx=\"19.5\" cy=\"13.5\" r=\"1.2\" fill=\"currentColor\" opacity={selected ? 0.9 : 0.7} />\n      <path\n        d={mouthPath(level)}\n        fill=\"none\"\n        stroke=\"currentColor\"\n        strokeWidth=\"1.8\"\n        strokeLinecap=\"round\"\n        opacity={selected ? 0.95 : 0.8}\n      />\n    </svg>\n  )\n}\n\n","truncated":false,"size":1170},{"path":"components/mood/MoodPicker.tsx","content":"'use client'\n\nimport React, { useMemo } from 'react'\nimport { MOOD_FACE_OPTIONS } from '@/components/mood/moodScale'\n\nfunction triggerHaptic() {\n  try {\n    const reduced = window.matchMedia('(prefers-reduced-motion: reduce)')?.matches\n    const pref = typeof window !== 'undefined' ? localStorage.getItem('hapticsEnabled') : null\n    const enabled = pref === null ? true : pref === 'true'\n    if (!reduced && enabled && typeof navigator !== 'undefined' && 'vibrate' in navigator) {\n      navigator.vibrate(12)\n    }\n  } catch {}\n}\n\nexport default function MoodPicker({\n  value,\n  onChange,\n}: {\n  value: number | null\n  onChange: (next: number) => void\n}) {\n  const selected = useMemo(() => MOOD_FACE_OPTIONS.find((o) => o.value === value) ?? null, [value])\n\n  return (\n    <div className=\"w-full\">\n      <div className=\"flex items-center justify-between px-1\">\n        <div className=\"text-sm font-semibold text-gray-700 dark:text-gray-200\">Pick your mood</div>\n        <div className=\"text-sm font-semibold text-gray-500 dark:text-gray-400\">\n          {selected ? selected.label : 'Tap a face'}\n        </div>\n      </div>\n\n      <div className=\"mt-4 w-full overflow-x-auto no-scrollbar\">\n        <div className=\"flex items-end gap-4 min-w-max px-1 pb-2\">\n          {MOOD_FACE_OPTIONS.map((o) => {\n            const isSelected = o.value === value\n            return (\n              <button\n                key={o.value}\n                type=\"button\"\n                onClick={() => {\n                  onChange(o.value)\n                  triggerHaptic()\n                }}\n                className={[\n                  'group flex flex-col items-center gap-3 select-none touch-manipulation',\n                  'transition-transform active:scale-95',\n                  isSelected ? 'scale-110' : '',\n                ].join(' ')}\n                aria-pressed={isSelected}\n                aria-label={o.label}\n              >\n                <div\n                  className={[\n                    'relative overflow-hidden rounded-full bg-transparent',\n                    'border-2 border-transparent',\n                    'flex items-center justify-center',\n                    isSelected\n                      ? 'w-[96px] h-[96px] border-helfi-green/0 ring-4 ring-helfi-green/25 shadow-[0_0_20px_rgba(77,175,80,0.25)]'\n                      : 'w-[80px] h-[80px] group-hover:ring-2 group-hover:ring-helfi-green/15',\n                  ].join(' ')}\n                >\n                  <span\n                    className={[\n                      isSelected ? 'text-6xl' : 'text-5xl',\n                      'leading-none',\n                      isSelected ? '' : 'opacity-80 group-hover:opacity-100',\n                      'transition-all',\n                    ].join(' ')}\n                  >\n                    {o.emoji}\n                  </span>\n                </div>\n                <span\n                  className={[\n                    'text-sm font-semibold transition-colors',\n                    isSelected ? 'text-helfi-green' : 'text-slate-500 dark:text-gray-300 group-hover:text-helfi-green',\n                  ].join(' ')}\n                >\n                  {o.label}\n                </span>\n              </button>\n            )\n          })}\n        </div>\n      </div>\n    </div>\n  )\n}\n","truncated":false,"size":3307},{"path":"components/mood/MoodPieChart.tsx","content":"'use client'\n\nimport React, { useMemo } from 'react'\nimport { Pie } from 'react-chartjs-2'\nimport { Chart as ChartJS, ArcElement, Tooltip, Legend } from 'chart.js'\nimport type { ChartData, ChartOptions } from 'chart.js'\nimport { emojiForMoodValue, moodColorForValue, MOOD_FACE_OPTIONS } from '@/components/mood/moodScale'\n\nChartJS.register(ArcElement, Tooltip, Legend)\n\ntype MoodEntry = {\n  mood: number\n  timestamp?: string | null\n}\n\nexport default function MoodPieChart({ entries }: { entries: MoodEntry[] }) {\n  const { slices, timeMap } = useMemo(() => {\n    const counts = new Map<number, number>()\n    const times = new Map<number, string[]>()\n\n    for (const entry of entries) {\n      const value = Number(entry.mood)\n      if (!Number.isFinite(value)) continue\n      counts.set(value, (counts.get(value) || 0) + 1)\n\n      if (entry.timestamp) {\n        const d = new Date(entry.timestamp)\n        if (!Number.isNaN(d.getTime())) {\n          const label = d.toLocaleTimeString(undefined, { hour: 'numeric', minute: '2-digit' })\n          const list = times.get(value) ?? []\n          list.push(label)\n          times.set(value, list)\n        }\n      }\n    }\n\n    const result = MOOD_FACE_OPTIONS\n      .map((opt) => ({ value: opt.value, label: opt.label, count: counts.get(opt.value) || 0 }))\n      .filter((slice) => slice.count > 0)\n\n    return { slices: result, timeMap: times }\n  }, [entries])\n\n  const emojiSize = useMemo(() => {\n    const totalEntries = slices.reduce((sum, slice) => sum + slice.count, 0)\n    const weight = Math.max(slices.length, Math.ceil(totalEntries / 2))\n    const size = 72 - weight * 8\n    return Math.max(22, Math.min(64, size))\n  }, [slices])\n\n  const emojiPlugin = useMemo(() => ({\n    id: 'emojiLabels',\n    afterDatasetsDraw: (chart: any) => {\n      const meta = chart.getDatasetMeta(0)\n      if (!meta?.data?.length) return\n      const { ctx } = chart\n      const fontSize = emojiSize\n      ctx.save()\n      ctx.font = `${fontSize}px \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Noto Color Emoji\", sans-serif`\n      ctx.textAlign = 'center'\n      ctx.textBaseline = 'middle'\n      if (slices.length === 1) {\n        const { left, right, top, bottom } = chart.chartArea\n        const centerX = (left + right) / 2\n        const centerY = (top + bottom) / 2\n        ctx.fillText(emojiForMoodValue(slices[0].value), centerX, centerY)\n      } else {\n        meta.data.forEach((arc: any, index: number) => {\n          const slice = slices[index]\n          if (!slice) return\n          const center = arc.getCenterPoint()\n          ctx.fillText(emojiForMoodValue(slice.value), center.x, center.y)\n        })\n      }\n      ctx.restore()\n    },\n  }), [slices, emojiSize])\n\n  const data: ChartData<'pie', number[], string> = useMemo(() => {\n    return {\n      labels: slices.map((slice) => slice.label),\n      datasets: [\n        {\n          data: slices.map((slice) => slice.count),\n          backgroundColor: slices.map((slice) => moodColorForValue(slice.value)),\n          borderWidth: 0,\n        },\n      ],\n    }\n  }, [slices])\n\n  const options: ChartOptions<'pie'> = useMemo(() => ({\n    responsive: true,\n    maintainAspectRatio: false,\n    events: ['click'],\n    plugins: {\n      legend: { display: false },\n      tooltip: {\n        enabled: false,\n        external: (context) => {\n          const { chart, tooltip } = context\n          const parent = chart.canvas.parentNode as HTMLElement | null\n          if (!parent) return\n\n          let tooltipEl = parent.querySelector<HTMLDivElement>('#mood-pie-tooltip')\n          if (!tooltipEl) {\n            tooltipEl = document.createElement('div')\n            tooltipEl.id = 'mood-pie-tooltip'\n            tooltipEl.style.position = 'absolute'\n            tooltipEl.style.pointerEvents = 'none'\n            tooltipEl.style.opacity = '0'\n            tooltipEl.style.transform = 'translate(-50%, -110%)'\n            tooltipEl.style.transition = 'opacity 0.1s ease'\n            tooltipEl.style.background = 'rgba(17, 24, 39, 0.9)'\n            tooltipEl.style.borderRadius = '12px'\n            tooltipEl.style.padding = '12px 14px'\n            tooltipEl.style.color = '#fff'\n            tooltipEl.style.textAlign = 'center'\n            tooltipEl.style.fontFamily = 'inherit'\n            tooltipEl.style.minWidth = '140px'\n            tooltipEl.style.maxWidth = '220px'\n            tooltipEl.style.boxShadow = '0 8px 20px rgba(0,0,0,0.2)'\n            parent.appendChild(tooltipEl)\n          }\n\n          if (tooltip.opacity === 0) {\n            tooltipEl.style.opacity = '0'\n            return\n          }\n\n          const dataIndex = tooltip.dataPoints?.[0]?.dataIndex ?? 0\n          const slice = slices[dataIndex]\n          const label = slice?.label || 'Mood'\n          const count = slice?.count ?? 0\n          const color = slice ? moodColorForValue(slice.value) : '#bbf7d0'\n          const times = slice ? (timeMap.get(slice.value) ?? []) : []\n          const maxItems = 4\n          const shown = times.slice(0, maxItems)\n          const suffix = times.length > maxItems ? ` +${times.length - maxItems} more` : ''\n          const timeLabel = times.length\n            ? `${times.length > 1 ? 'Times' : 'Time'}: ${shown.join(', ')}${suffix}`\n            : 'Time: ‚Äî'\n\n          tooltipEl.innerHTML = ''\n\n          const titleEl = document.createElement('div')\n          titleEl.style.fontSize = '16px'\n          titleEl.style.fontWeight = '600'\n          titleEl.style.marginBottom = '6px'\n          titleEl.textContent = label\n\n          const lineEl = document.createElement('div')\n          lineEl.style.display = 'flex'\n          lineEl.style.alignItems = 'center'\n          lineEl.style.justifyContent = 'center'\n          lineEl.style.gap = '8px'\n          lineEl.style.fontSize = '14px'\n          lineEl.style.fontWeight = '500'\n          lineEl.style.marginBottom = '4px'\n          lineEl.style.width = '100%'\n\n          const swatch = document.createElement('span')\n          swatch.style.width = '12px'\n          swatch.style.height = '12px'\n          swatch.style.borderRadius = '3px'\n          swatch.style.background = color\n          swatch.style.display = 'inline-block'\n\n          const text = document.createElement('span')\n          text.textContent = `${label}: ${count}`\n\n          lineEl.appendChild(swatch)\n          lineEl.appendChild(text)\n\n          const timeEl = document.createElement('div')\n          timeEl.style.fontSize = '14px'\n          timeEl.style.fontWeight = '500'\n          timeEl.style.textAlign = 'center'\n          timeEl.style.width = '100%'\n          timeEl.textContent = timeLabel\n\n          tooltipEl.appendChild(titleEl)\n          tooltipEl.appendChild(lineEl)\n          tooltipEl.appendChild(timeEl)\n\n          const { offsetLeft, offsetTop } = chart.canvas\n          tooltipEl.style.left = `${offsetLeft + tooltip.caretX}px`\n          tooltipEl.style.top = `${offsetTop + tooltip.caretY}px`\n          const aboveTop = tooltip.caretY - tooltipEl.offsetHeight - 12\n          tooltipEl.style.transform = aboveTop < 0 ? 'translate(-50%, 12px)' : 'translate(-50%, -110%)'\n          tooltipEl.style.opacity = '1'\n        },\n      },\n    },\n  }), [slices, timeMap])\n\n  if (!slices.length) {\n    return (\n      <div className=\"flex h-full items-center justify-center text-sm text-gray-500 dark:text-gray-400\">\n        No mood entries yet.\n      </div>\n    )\n  }\n\n  return (\n    <div className=\"relative h-48 w-full\">\n      <Pie data={data} options={options} plugins={[emojiPlugin]} />\n    </div>\n  )\n}\n","truncated":false,"size":7528},{"path":"components/mood/moodScale.ts","content":"export const MOOD_LEVELS = [\n  { value: 1, label: 'Very low', color: '#ef4444' },\n  { value: 2, label: 'Low', color: '#f97316' },\n  { value: 3, label: 'A bit low', color: '#f59e0b' },\n  { value: 4, label: 'Neutral', color: '#eab308' },\n  { value: 5, label: 'A bit high', color: '#84cc16' },\n  { value: 6, label: 'High', color: '#22c55e' },\n  { value: 7, label: 'Very high', color: '#16a34a' },\n] as const\n\nexport type MoodValue = (typeof MOOD_LEVELS)[number]['value']\n\nexport const MOOD_FACE_OPTIONS = [\n  { value: 1, label: 'Terrible', emoji: 'üò°' },\n  { value: 2, label: 'Bad', emoji: 'üòû' },\n  { value: 3, label: 'Meh', emoji: 'üòï' },\n  { value: 4, label: 'Okay', emoji: 'üòê' },\n  { value: 5, label: 'Good', emoji: 'üôÇ' },\n  { value: 6, label: 'Great', emoji: 'üòÑ' },\n  { value: 7, label: 'Amazing', emoji: 'ü§©' },\n] as const\n\nexport type MoodFaceOption = (typeof MOOD_FACE_OPTIONS)[number]\n\nexport function emojiForMoodValue(value: number) {\n  return MOOD_FACE_OPTIONS.find((o) => o.value === value)?.emoji ?? 'üôÇ'\n}\n\nexport function moodColorForValue(value: number) {\n  const palette: Record<number, string> = {\n    1: '#ef4444',\n    2: '#f87171',\n    3: '#fb923c',\n    4: '#facc15',\n    5: '#bbf7d0',\n    6: '#4ade80',\n    7: '#22c55e',\n  }\n  return palette[value] ?? '#bbf7d0'\n}\n\nexport const DEFAULT_MOOD_TAGS = [\n  { label: 'Calm', emoji: 'üòå' },\n  { label: 'Focused', emoji: 'ü§ì' },\n  { label: 'Motivated', emoji: 'üò§' },\n  { label: 'Anxious', emoji: 'üò∞' },\n  { label: 'Stressed', emoji: 'üò´' },\n  { label: 'Sad', emoji: 'üò¢' },\n  { label: 'Lonely', emoji: 'ü•∫' },\n  { label: 'Tired', emoji: 'üò¥' },\n  { label: 'Restless', emoji: 'üò¨' },\n  { label: 'Content', emoji: 'üòä' },\n  { label: 'Confident', emoji: 'üòé' },\n  { label: 'Grateful', emoji: 'üòá' },\n  { label: 'Hopeful', emoji: 'üôÇ' },\n  { label: 'Irritable', emoji: 'üò†' },\n  { label: 'Energised', emoji: 'üòÅ' },\n  { label: 'Flat', emoji: 'üò∂' },\n  { label: 'Social', emoji: 'ü•≥' },\n  { label: 'Overwhelmed', emoji: 'üòµ‚Äçüí´' },\n] as const\n","truncated":false,"size":2059},{"path":"components/mood/MoodSlider.tsx","content":"'use client'\n\nimport React, { useMemo } from 'react'\nimport MoodFaceIcon from '@/components/mood/MoodFaceIcon'\nimport { MOOD_LEVELS, type MoodValue } from '@/components/mood/moodScale'\n\nfunction triggerHaptic() {\n  try {\n    const reduced = window.matchMedia('(prefers-reduced-motion: reduce)')?.matches\n    const pref = typeof window !== 'undefined' ? localStorage.getItem('hapticsEnabled') : null\n    const enabled = pref === null ? true : pref === 'true'\n    if (!reduced && enabled && typeof navigator !== 'undefined' && 'vibrate' in navigator) {\n      navigator.vibrate(10)\n    }\n  } catch {}\n}\n\nexport default function MoodSlider({\n  value,\n  onChange,\n}: {\n  value: MoodValue | null\n  onChange: (next: MoodValue) => void\n}) {\n  const selected = useMemo(() => MOOD_LEVELS.find((m) => m.value === value) ?? null, [value])\n\n  return (\n    <div className=\"w-full\">\n      <div className=\"mb-2 flex items-center justify-between\">\n        <div className=\"text-sm font-medium text-gray-700 dark:text-gray-200\">Mood</div>\n        <div className=\"text-sm text-gray-600 dark:text-gray-400\">\n          {selected ? selected.label : 'Select'}\n        </div>\n      </div>\n\n      <div className=\"rounded-2xl border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 p-3\">\n        <div className=\"rounded-xl bg-gradient-to-r from-red-400 via-yellow-300 to-green-500 p-[2px]\">\n          <div className=\"rounded-[10px] bg-white/80 dark:bg-gray-900/70 backdrop-blur px-2 py-3\">\n            <div className=\"grid grid-cols-7 gap-1\">\n              {MOOD_LEVELS.map((m) => {\n                const isSelected = m.value === value\n                return (\n                  <button\n                    key={m.value}\n                    type=\"button\"\n                    onClick={() => {\n                      onChange(m.value)\n                      triggerHaptic()\n                    }}\n                    className={[\n                      'touch-manipulation select-none rounded-xl py-2 flex flex-col items-center justify-center',\n                      'transition-colors focus:outline-none focus-visible:ring-2 focus-visible:ring-helfi-green focus-visible:ring-offset-2 focus-visible:ring-offset-white dark:focus-visible:ring-offset-gray-900',\n                      isSelected ? 'bg-white dark:bg-gray-800 shadow-sm' : 'bg-transparent hover:bg-white/50 dark:hover:bg-white/5',\n                    ].join(' ')}\n                    aria-pressed={isSelected}\n                    aria-label={m.label}\n                  >\n                    <div style={{ color: m.color }} className=\"leading-none\">\n                      <MoodFaceIcon level={m.value} selected={isSelected} />\n                    </div>\n                    <div className=\"mt-1 text-[10px] leading-tight text-gray-700 dark:text-gray-200\">\n                      {m.value}\n                    </div>\n                  </button>\n                )\n              })}\n            </div>\n          </div>\n        </div>\n\n        <div className=\"mt-3\">\n          <input\n            type=\"range\"\n            min={MOOD_LEVELS[0].value}\n            max={MOOD_LEVELS[MOOD_LEVELS.length - 1].value}\n            step={1}\n            value={value ?? 4}\n            onChange={(e) => {\n              const next = Number(e.target.value) as MoodValue\n              onChange(next)\n              triggerHaptic()\n            }}\n            className=\"w-full accent-helfi-green\"\n            aria-label=\"Mood slider\"\n          />\n          <div className=\"mt-1 flex justify-between text-xs text-gray-500 dark:text-gray-400\">\n            <span>{MOOD_LEVELS[0].label}</span>\n            <span>{MOOD_LEVELS[MOOD_LEVELS.length - 1].label}</span>\n          </div>\n        </div>\n      </div>\n    </div>\n  )\n}\n\n","truncated":false,"size":3740},{"path":"components/mood/MoodTabs.tsx","content":"'use client'\n\nimport React from 'react'\nimport Link from 'next/link'\nimport { usePathname } from 'next/navigation'\n\nexport default function MoodTabs() {\n  const pathname = usePathname()\n  const isCheckIn = pathname === '/mood'\n  const isHistory = pathname === '/mood/history'\n  const isJournal = pathname === '/mood/journal'\n  const isInsights = pathname === '/mood/insights'\n  const isPrefs = pathname === '/mood/preferences'\n\n  return (\n    <div className=\"max-w-3xl mx-auto px-4 pt-4\">\n      <div className=\"bg-white dark:bg-gray-800 rounded-t-xl border-b border-gray-200 dark:border-gray-700\">\n        <div className=\"flex items-center justify-end px-2 pt-2\">\n          <Link\n            href=\"/mood/preferences\"\n            className={`px-3 py-1 rounded-full border text-xs font-semibold transition-colors ${\n              isPrefs\n                ? 'border-helfi-green text-helfi-green'\n                : 'border-gray-200 dark:border-gray-700 text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-gray-100'\n            }`}\n            aria-label=\"Preferences\"\n          >\n            <span className=\"material-symbols-outlined align-middle text-[18px]\">settings</span>\n          </Link>\n        </div>\n        <div className=\"px-1 pb-1\">\n          <div className=\"flex items-center gap-1 overflow-x-auto no-scrollbar\">\n            <Link\n              href=\"/mood\"\n              className={`flex-shrink-0 px-4 py-3 text-center font-medium whitespace-nowrap transition-colors ${\n                isCheckIn\n                  ? 'text-helfi-green border-b-2 border-helfi-green'\n                  : 'text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-200'\n              }`}\n            >\n              Check‚Äëin\n            </Link>\n            <Link\n              href=\"/mood/history\"\n              className={`flex-shrink-0 px-4 py-3 text-center font-medium whitespace-nowrap transition-colors ${\n                isHistory\n                  ? 'text-helfi-green border-b-2 border-helfi-green'\n                  : 'text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-200'\n              }`}\n            >\n              History\n            </Link>\n            <Link\n              href=\"/mood/journal\"\n              className={`flex-shrink-0 px-4 py-3 text-center font-medium whitespace-nowrap transition-colors ${\n                isJournal\n                  ? 'text-helfi-green border-b-2 border-helfi-green'\n                  : 'text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-200'\n              }`}\n            >\n              Journal\n            </Link>\n            <Link\n              href=\"/mood/insights\"\n              className={`flex-shrink-0 px-4 py-3 text-center font-medium whitespace-nowrap transition-colors ${\n                isInsights\n                  ? 'text-helfi-green border-b-2 border-helfi-green'\n                  : 'text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-200'\n              }`}\n            >\n              Insights\n            </Link>\n          </div>\n        </div>\n      </div>\n    </div>\n  )\n}\n","truncated":false,"size":3139},{"path":"components/mood/MoodTagChips.tsx","content":"'use client'\n\nimport React, { useMemo, useState } from 'react'\nimport { DEFAULT_MOOD_TAGS } from '@/components/mood/moodScale'\n\nfunction normalizeTag(tag: string) {\n  return tag.trim().replace(/\\s+/g, ' ').slice(0, 24)\n}\n\nconst DEFAULT_TAG_LABELS = DEFAULT_MOOD_TAGS.map((tag) => tag.label)\nconst DEFAULT_TAG_EMOJI = new Map<string, string>(\n  DEFAULT_MOOD_TAGS.map((tag) => [normalizeTag(tag.label), tag.emoji]),\n)\n\nfunction extractEmoji(tag: string) {\n  const trimmed = tag.trim()\n  if (!trimmed) return ''\n  const first = Array.from(trimmed)[0] ?? ''\n  const code = first.codePointAt(0) ?? 0\n  const isEmoji =\n    (code >= 0x1f300 && code <= 0x1fbff) ||\n    (code >= 0x2600 && code <= 0x27bf)\n  return isEmoji ? first : ''\n}\n\nexport default function MoodTagChips({\n  value,\n  onChange,\n  title = 'Mood tags',\n}: {\n  value: string[]\n  onChange: (next: string[]) => void\n  title?: string\n}) {\n  const [adding, setAdding] = useState(false)\n  const [custom, setCustom] = useState('')\n\n  const selected = useMemo(() => new Set(value.map((t) => normalizeTag(t)).filter(Boolean)), [value])\n\n  const toggle = (tag: string) => {\n    const t = normalizeTag(tag)\n    if (!t) return\n    const next = new Set(selected)\n    if (next.has(t)) next.delete(t)\n    else next.add(t)\n    onChange(Array.from(next))\n  }\n\n  const addCustom = () => {\n    const t = normalizeTag(custom)\n    if (!t) return\n    const next = new Set(selected)\n    next.add(t)\n    onChange(Array.from(next))\n    setCustom('')\n    setAdding(false)\n  }\n\n  const allTags = useMemo(() => {\n    const merged = new Set<string>(DEFAULT_TAG_LABELS)\n    selected.forEach((t) => merged.add(t))\n    return Array.from(merged)\n  }, [selected])\n\n  return (\n    <div className=\"w-full\">\n      <div className=\"mb-2 flex items-center justify-between\">\n        <div className=\"text-sm font-medium text-gray-700 dark:text-gray-200\">{title}</div>\n        {value.length > 0 && (\n          <button\n            type=\"button\"\n            onClick={() => onChange([])}\n            className=\"text-xs font-semibold text-helfi-green hover:text-helfi-green-dark dark:text-helfi-green-light\"\n          >\n            Clear all\n          </button>\n        )}\n      </div>\n\n      <div className=\"flex flex-wrap gap-2\">\n        {allTags.map((tag) => {\n          const normalized = normalizeTag(tag)\n          const isSelected = selected.has(normalized)\n          const defaultEmoji = DEFAULT_TAG_EMOJI.get(normalized)\n          let emoji = defaultEmoji ?? ''\n          let label = tag\n\n          if (!emoji) {\n            const fromTag = extractEmoji(tag)\n            if (fromTag) {\n              emoji = fromTag\n              label = tag.replace(fromTag, '').trim()\n            } else {\n              emoji = 'üôÇ'\n            }\n          }\n\n          if (!label) label = tag\n          return (\n            <button\n              key={tag}\n              type=\"button\"\n              onClick={() => toggle(tag)}\n              className={[\n                'inline-flex items-center gap-1.5 px-3 py-1.5 rounded-full border text-sm touch-manipulation',\n                'transition-colors focus:outline-none focus-visible:ring-2 focus-visible:ring-helfi-green focus-visible:ring-offset-2 focus-visible:ring-offset-white dark:focus-visible:ring-offset-gray-900',\n                isSelected\n                  ? 'bg-helfi-green/10 border-helfi-green/30 text-helfi-green-dark dark:text-helfi-green-light'\n                  : 'bg-white dark:bg-gray-800 border-gray-200 dark:border-gray-700 text-gray-700 dark:text-gray-200 hover:bg-gray-50 dark:hover:bg-gray-700/50',\n              ].join(' ')}\n              aria-pressed={isSelected}\n            >\n              <span className=\"text-base leading-none\" aria-hidden>\n                {emoji}\n              </span>\n              <span>{label}</span>\n              {isSelected && (\n                <span className=\"text-sm leading-none text-helfi-green-dark dark:text-helfi-green-light\">√ó</span>\n              )}\n            </button>\n          )\n        })}\n\n        <button\n          type=\"button\"\n          onClick={() => setAdding((v) => !v)}\n          className=\"px-3 py-1.5 rounded-full border border-dashed border-gray-300 dark:border-gray-600 text-sm text-gray-600 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-700/50 touch-manipulation\"\n        >\n          + Add tag\n        </button>\n      </div>\n\n      {adding && (\n        <div className=\"mt-3 flex gap-2\">\n          <input\n            value={custom}\n            onChange={(e) => setCustom(e.target.value)}\n            placeholder=\"Custom tag\"\n            className=\"flex-1 rounded-lg border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 px-3 py-2 text-sm text-gray-900 dark:text-white\"\n            maxLength={24}\n          />\n          <button\n            type=\"button\"\n            onClick={addCustom}\n            className=\"rounded-lg bg-helfi-green px-4 py-2 text-sm font-medium text-white disabled:opacity-50\"\n            disabled={!normalizeTag(custom)}\n          >\n            Add\n          </button>\n        </div>\n      )}\n    </div>\n  )\n}\n","truncated":false,"size":5098},{"path":"components/mood/MoodTrendGraph.tsx","content":"'use client'\n\nimport React, { useMemo } from 'react'\nimport { Line } from 'react-chartjs-2'\nimport {\n  Chart as ChartJS,\n  CategoryScale,\n  LinearScale,\n  TimeScale,\n  PointElement,\n  LineElement,\n  Tooltip,\n  Filler,\n} from 'chart.js'\nimport type { ChartData, ChartOptions } from 'chart.js'\nimport 'chartjs-adapter-date-fns'\nimport { MOOD_LEVELS, emojiForMoodValue } from '@/components/mood/moodScale'\n\nChartJS.register(\n  CategoryScale,\n  LinearScale,\n  TimeScale,\n  PointElement,\n  LineElement,\n  Tooltip,\n  Filler,\n)\n\nexport type MoodPoint = { timestamp: string; mood: number | null; label?: string }\n\nexport default function MoodTrendGraph({\n  points,\n  showTimeAxis = false,\n  fillArea = true,\n  spanGaps = false,\n}: {\n  points: MoodPoint[]\n  showTimeAxis?: boolean\n  fillArea?: boolean\n  spanGaps?: boolean\n}) {\n  const chartPoints = useMemo(() => {\n    if (points.length !== 1) {\n      return points.map((p, index) => ({ x: p.timestamp, y: p.mood, sourceIndex: index }))\n    }\n\n    const base = points[0]\n    if (!Number.isFinite(Number(base?.mood))) {\n      return []\n    }\n    const baseDate = new Date(base.timestamp)\n    if (Number.isNaN(baseDate.getTime())) {\n      return [{ x: new Date().toISOString(), y: base.mood }]\n    }\n\n    const start = new Date(baseDate)\n    start.setHours(0, 0, 0, 0)\n    const end = new Date(baseDate)\n    end.setHours(23, 59, 59, 999)\n\n    return [\n      { x: start.toISOString(), y: base.mood, synthetic: true, sourceIndex: -1 },\n      { x: baseDate.toISOString(), y: base.mood, sourceIndex: 0 },\n      { x: end.toISOString(), y: base.mood, synthetic: true, sourceIndex: -1 },\n    ]\n  }, [points])\n\n  const emojiPlugin = useMemo(() => ({\n    id: 'emojiPoints',\n    afterDatasetsDraw: (chart: any) => {\n      const meta = chart.getDatasetMeta(0)\n      if (!meta?.data?.length) return\n      const dataset = chart.data.datasets?.[0]\n      if (!dataset) return\n      const { ctx, chartArea } = chart\n      const fontSize = 28\n      ctx.save()\n      ctx.font = `${fontSize}px \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Noto Color Emoji\", sans-serif`\n      ctx.textAlign = 'center'\n      ctx.textBaseline = 'middle'\n      meta.data.forEach((point: any, index: number) => {\n        const raw = (dataset.data as any[])?.[index]\n        if (raw?.synthetic) return\n        const moodValue = Number(raw?.y)\n        if (!Number.isFinite(moodValue)) return\n        const emoji = emojiForMoodValue(moodValue)\n        const y = Math.max(point.y - (fontSize * 0.9), chartArea.top + fontSize * 0.6)\n        ctx.fillText(emoji, point.x, y)\n      })\n      ctx.restore()\n    },\n  }), [])\n\n  const formatTime = (ts: string) => {\n    try {\n      const d = new Date(ts)\n      if (Number.isNaN(d.getTime())) return ''\n      return d.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' })\n    } catch {\n      return ''\n    }\n  }\n\n  const formatDay = (ts: string) => {\n    try {\n      const d = new Date(ts)\n      if (Number.isNaN(d.getTime())) return ''\n      return d.toLocaleDateString(undefined, { month: 'short', day: 'numeric' })\n    } catch {\n      return ''\n    }\n  }\n\n  const data: ChartData<'line', { x: string; y: number | null }[]> = useMemo(() => {\n    return {\n      labels: [],\n      datasets: [\n        {\n          label: 'Mood',\n          data: chartPoints,\n          borderColor: 'rgb(34, 197, 94)',\n          backgroundColor: 'rgba(34, 197, 94, 0.12)',\n          tension: 0.35,\n          fill: fillArea,\n          spanGaps,\n          pointRadius: (ctx) => ((ctx.raw as any)?.synthetic ? 0 : 3),\n          pointHoverRadius: (ctx) => ((ctx.raw as any)?.synthetic ? 0 : 5),\n          pointHitRadius: (ctx) => ((ctx.raw as any)?.synthetic ? 0 : 18),\n          pointBackgroundColor: 'rgb(34, 197, 94)',\n        },\n      ],\n    }\n  }, [chartPoints])\n\n  const options: ChartOptions<'line'> = useMemo(() => ({\n    responsive: true,\n    maintainAspectRatio: false,\n    events: ['click'],\n    plugins: {\n      legend: { display: false },\n      tooltip: {\n        enabled: false,\n        external: (context) => {\n          const { chart, tooltip } = context\n          const parent = chart.canvas.parentNode as HTMLElement | null\n          if (!parent) return\n\n          let tooltipEl = parent.querySelector<HTMLDivElement>('#mood-line-tooltip')\n          if (!tooltipEl) {\n            tooltipEl = document.createElement('div')\n            tooltipEl.id = 'mood-line-tooltip'\n            tooltipEl.style.position = 'absolute'\n            tooltipEl.style.pointerEvents = 'none'\n            tooltipEl.style.opacity = '0'\n            tooltipEl.style.transform = 'translate(-50%, -110%)'\n            tooltipEl.style.transition = 'opacity 0.1s ease'\n            tooltipEl.style.background = 'rgba(17, 24, 39, 0.9)'\n            tooltipEl.style.borderRadius = '12px'\n            tooltipEl.style.padding = '12px 14px'\n            tooltipEl.style.color = '#fff'\n            tooltipEl.style.textAlign = 'center'\n            tooltipEl.style.fontFamily = 'inherit'\n            tooltipEl.style.minWidth = '140px'\n            tooltipEl.style.maxWidth = '220px'\n            tooltipEl.style.boxShadow = '0 8px 20px rgba(0,0,0,0.2)'\n            parent.appendChild(tooltipEl)\n          }\n\n          if (tooltip.opacity === 0) {\n            tooltipEl.style.opacity = '0'\n            return\n          }\n\n          const dataIndex = tooltip.dataPoints?.[0]?.dataIndex ?? 0\n          const raw = (chart.data.datasets?.[0]?.data as any[])?.[dataIndex]\n          const sourceIndex = typeof raw?.sourceIndex === 'number' ? raw.sourceIndex : dataIndex\n          const point = sourceIndex >= 0 ? points[sourceIndex] : null\n          const moodValue = Number(point?.mood ?? tooltip.dataPoints?.[0]?.parsed?.y)\n          if (!Number.isFinite(moodValue)) {\n            tooltipEl.style.opacity = '0'\n            return\n          }\n\n          const moodLabel = MOOD_LEVELS.find((m) => m.value === moodValue)?.label ?? `Mood ${moodValue}`\n          const detail = showTimeAxis\n            ? `Time: ${formatTime(point?.timestamp || '') || '‚Äî'}`\n            : point?.label\n              ? point.label\n              : `Day: ${formatDay(point?.timestamp || '') || '‚Äî'}`\n\n          tooltipEl.innerHTML = ''\n\n          const titleEl = document.createElement('div')\n          titleEl.style.fontSize = '16px'\n          titleEl.style.fontWeight = '600'\n          titleEl.style.marginBottom = '6px'\n          titleEl.style.textAlign = 'center'\n          titleEl.textContent = moodLabel\n\n          const detailEl = document.createElement('div')\n          detailEl.style.fontSize = '14px'\n          detailEl.style.fontWeight = '500'\n          detailEl.style.textAlign = 'center'\n          detailEl.style.width = '100%'\n          detailEl.textContent = detail\n\n          tooltipEl.appendChild(titleEl)\n          tooltipEl.appendChild(detailEl)\n\n          const { offsetLeft, offsetTop } = chart.canvas\n          tooltipEl.style.left = `${offsetLeft + tooltip.caretX}px`\n          tooltipEl.style.top = `${offsetTop + tooltip.caretY}px`\n          const aboveTop = tooltip.caretY - tooltipEl.offsetHeight - 12\n          tooltipEl.style.transform = aboveTop < 0 ? 'translate(-50%, 12px)' : 'translate(-50%, -110%)'\n          tooltipEl.style.opacity = '1'\n        },\n      },\n    },\n    interaction: { mode: 'nearest', intersect: false },\n    onClick: (event, elements, chart) => {\n      if (!elements?.length) return\n      const first = elements[0] as any\n      chart.setActiveElements([{ datasetIndex: first.datasetIndex, index: first.index }])\n      chart.update()\n    },\n    scales: {\n      x: {\n        type: 'time',\n        time: {\n          unit: showTimeAxis ? 'hour' : 'day',\n          displayFormats: { hour: 'h a', day: 'MMM d' },\n        },\n        grid: { display: false },\n        ticks: {\n          maxRotation: 0,\n          autoSkip: true,\n          maxTicksLimit: showTimeAxis ? 6 : 7,\n        },\n      },\n      y: {\n        min: 1,\n        max: 7,\n        ticks: {\n          stepSize: 1,\n          callback: (v) => String(v),\n        },\n        grid: { color: 'rgba(148, 163, 184, 0.18)' },\n      },\n    },\n  }), [])\n\n  return (\n    <div className=\"h-48 w-full\">\n      <Line data={data as any} options={options as any} plugins={[emojiPlugin]} />\n    </div>\n  )\n}\n","truncated":false,"size":8264},{"path":"components/onboarding/GenderSelection.tsx","content":"'use client'\n\nimport { useState } from 'react'\n\ninterface GenderSelectionProps {\n  onNext: (data: { gender: string }) => void\n  initialData?: string\n}\n\nexport default function GenderSelection({ onNext, initialData }: GenderSelectionProps) {\n  const [gender, setGender] = useState(initialData || '')\n\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault()\n    if (gender) {\n      onNext({ gender })\n    }\n  }\n\n  return (\n    <form onSubmit={handleSubmit} className=\"space-y-6\">\n      <div className=\"space-y-4\">\n        <button\n          type=\"button\"\n          onClick={() => setGender('MALE')}\n          className={`w-full p-4 rounded-lg border-2 text-left transition-colors ${\n            gender === 'MALE'\n              ? 'border-helfi-green bg-helfi-green/5'\n              : 'border-gray-200 hover:border-helfi-green/50'\n          }`}\n        >\n          <div className=\"flex items-center justify-between\">\n            <div>\n              <h3 className=\"font-semibold text-helfi-black\">Male</h3>\n              <p className=\"text-sm text-gray-600\">\n                Optimize your health insights for male physiology\n              </p>\n            </div>\n            {gender === 'MALE' && (\n              <div className=\"w-6 h-6 rounded-full bg-helfi-green flex items-center justify-center\">\n                <svg\n                  className=\"w-4 h-4 text-white\"\n                  fill=\"none\"\n                  stroke=\"currentColor\"\n                  viewBox=\"0 0 24 24\"\n                >\n                  <path\n                    strokeLinecap=\"round\"\n                    strokeLinejoin=\"round\"\n                    strokeWidth={2}\n                    d=\"M5 13l4 4L19 7\"\n                  />\n                </svg>\n              </div>\n            )}\n          </div>\n        </button>\n\n        <button\n          type=\"button\"\n          onClick={() => setGender('FEMALE')}\n          className={`w-full p-4 rounded-lg border-2 text-left transition-colors ${\n            gender === 'FEMALE'\n              ? 'border-helfi-green bg-helfi-green/5'\n              : 'border-gray-200 hover:border-helfi-green/50'\n          }`}\n        >\n          <div className=\"flex items-center justify-between\">\n            <div>\n              <h3 className=\"font-semibold text-helfi-black\">Female</h3>\n              <p className=\"text-sm text-gray-600\">\n                Optimize your health insights for female physiology\n              </p>\n            </div>\n            {gender === 'FEMALE' && (\n              <div className=\"w-6 h-6 rounded-full bg-helfi-green flex items-center justify-center\">\n                <svg\n                  className=\"w-4 h-4 text-white\"\n                  fill=\"none\"\n                  stroke=\"currentColor\"\n                  viewBox=\"0 0 24 24\"\n                >\n                  <path\n                    strokeLinecap=\"round\"\n                    strokeLinejoin=\"round\"\n                    strokeWidth={2}\n                    d=\"M5 13l4 4L19 7\"\n                  />\n                </svg>\n              </div>\n            )}\n          </div>\n        </button>\n      </div>\n\n      <div className=\"flex justify-end\">\n        <button\n          type=\"submit\"\n          disabled={!gender}\n          className={`btn-primary ${\n            !gender ? 'opacity-50 cursor-not-allowed' : ''\n          }`}\n        >\n          Continue\n        </button>\n      </div>\n    </form>\n  )\n} ","truncated":false,"size":3405},{"path":"components/onboarding/PhysicalMetrics.tsx","content":"'use client'\n\nimport { useState } from 'react'\n\ninterface PhysicalMetricsProps {\n  onNext: (data: { weight: string; height: string; bodyType: string }) => void\n  onBack: () => void\n  initialData?: {\n    weight: string\n    height: string\n    bodyType: string\n  }\n}\n\nconst bodyTypes = [\n  {\n    id: 'ECTOMORPH',\n    name: 'Ectomorph',\n    description: 'Naturally lean, finds it hard to gain weight',\n  },\n  {\n    id: 'MESOMORPH',\n    name: 'Mesomorph',\n    description: 'Athletic build, gains muscle easily',\n  },\n  {\n    id: 'ENDOMORPH',\n    name: 'Endomorph',\n    description: 'Naturally larger build, gains weight easily',\n  },\n]\n\nexport default function PhysicalMetrics({\n  onNext,\n  onBack,\n  initialData = { weight: '', height: '', bodyType: '' },\n}: PhysicalMetricsProps) {\n  const [weight, setWeight] = useState(initialData.weight)\n  const [height, setHeight] = useState(initialData.height)\n  const [bodyType, setBodyType] = useState(initialData.bodyType)\n  const [unit, setUnit] = useState<'metric' | 'imperial'>('metric')\n\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault()\n    if (weight && height) {\n      onNext({ weight, height, bodyType })\n    }\n  }\n\n  return (\n    <form onSubmit={handleSubmit} className=\"space-y-6\">\n      {/* Unit Toggle */}\n      <div className=\"flex justify-end\">\n        <div className=\"inline-flex rounded-lg border border-gray-200 p-1\">\n          <button\n            type=\"button\"\n            onClick={() => setUnit('metric')}\n            className={`px-3 py-1 rounded-md text-sm ${\n              unit === 'metric'\n                ? 'bg-helfi-green text-white'\n                : 'text-gray-600 hover:bg-gray-50'\n            }`}\n          >\n            Metric\n          </button>\n          <button\n            type=\"button\"\n            onClick={() => setUnit('imperial')}\n            className={`px-3 py-1 rounded-md text-sm ${\n              unit === 'imperial'\n                ? 'bg-helfi-green text-white'\n                : 'text-gray-600 hover:bg-gray-50'\n            }`}\n          >\n            Imperial\n          </button>\n        </div>\n      </div>\n\n      {/* Weight Input */}\n      <div>\n        <label\n          htmlFor=\"weight\"\n          className=\"block text-sm font-medium text-gray-700 mb-1\"\n        >\n          Weight\n        </label>\n        <div className=\"relative\">\n          <input\n            type=\"number\"\n            inputMode=\"numeric\"\n            id=\"weight\"\n            value={weight}\n            onChange={(e) => setWeight(e.target.value)}\n            onFocus={() => setWeight('')}\n            className=\"input-primary pr-12\"\n            placeholder={`Enter your weight in ${unit === 'metric' ? 'kg' : 'lbs'}`}\n            required\n          />\n          <div className=\"absolute inset-y-0 right-0 flex items-center pr-3 pointer-events-none\">\n            <span className=\"text-gray-500\">\n              {unit === 'metric' ? 'kg' : 'lbs'}\n            </span>\n          </div>\n        </div>\n      </div>\n\n      {/* Height Input */}\n      <div>\n        <label\n          htmlFor=\"height\"\n          className=\"block text-sm font-medium text-gray-700 mb-1\"\n        >\n          Height\n        </label>\n        <div className=\"relative\">\n          <input\n            type=\"number\"\n            inputMode=\"numeric\"\n            id=\"height\"\n            value={height}\n            onChange={(e) => setHeight(e.target.value)}\n            onFocus={() => setHeight('')}\n            className=\"input-primary pr-12\"\n            placeholder={`Enter your height in ${unit === 'metric' ? 'cm' : 'inches'}`}\n            required\n          />\n          <div className=\"absolute inset-y-0 right-0 flex items-center pr-3 pointer-events-none\">\n            <span className=\"text-gray-500\">\n              {unit === 'metric' ? 'cm' : 'in'}\n            </span>\n          </div>\n        </div>\n      </div>\n\n      {/* Body Type Selection */}\n      <div>\n        <label className=\"block text-sm font-medium text-gray-700 mb-3\">\n          Body Type (Optional)\n        </label>\n        <div className=\"space-y-3\">\n          {bodyTypes.map((type) => (\n            <button\n              key={type.id}\n              type=\"button\"\n              onClick={() => setBodyType(type.id)}\n              className={`w-full p-4 rounded-lg border-2 text-left transition-colors ${\n                bodyType === type.id\n                  ? 'border-helfi-green bg-helfi-green/5'\n                  : 'border-gray-200 hover:border-helfi-green/50'\n              }`}\n            >\n              <div className=\"flex items-center justify-between\">\n                <div>\n                  <h3 className=\"font-semibold text-helfi-black\">{type.name}</h3>\n                  <p className=\"text-sm text-gray-600\">{type.description}</p>\n                </div>\n                {bodyType === type.id && (\n                  <div className=\"w-6 h-6 rounded-full bg-helfi-green flex items-center justify-center\">\n                    <svg\n                      className=\"w-4 h-4 text-white\"\n                      fill=\"none\"\n                      stroke=\"currentColor\"\n                      viewBox=\"0 0 24 24\"\n                    >\n                      <path\n                        strokeLinecap=\"round\"\n                        strokeLinejoin=\"round\"\n                        strokeWidth={2}\n                        d=\"M5 13l4 4L19 7\"\n                      />\n                    </svg>\n                  </div>\n                )}\n              </div>\n            </button>\n          ))}\n        </div>\n      </div>\n\n      {/* Navigation Buttons */}\n      <div className=\"flex justify-between pt-4\">\n        <button\n          type=\"button\"\n          onClick={onBack}\n          className=\"btn-secondary\"\n        >\n          Back\n        </button>\n        <button\n          type=\"submit\"\n          disabled={!weight || !height}\n          className={`btn-primary ${\n            !weight || !height ? 'opacity-50 cursor-not-allowed' : ''\n          }`}\n        >\n          Continue\n        </button>\n      </div>\n    </form>\n  )\n} ","truncated":false,"size":6042},{"path":"components/PageHeader.tsx","content":"'use client'\n\nimport { useRouter } from 'next/navigation'\nimport { useSession, signOut } from 'next-auth/react'\nimport Image from 'next/image'\nimport { useEffect, useState } from 'react'\nimport Link from 'next/link'\nimport { useUserData } from '@/components/providers/UserDataProvider'\nimport { UserIcon } from '@heroicons/react/24/outline'\n\ninterface PageHeaderProps {\n  title: string\n  backHref?: string // Optional custom back destination, defaults to router.back()\n}\n\nexport default function PageHeader({ title, backHref }: PageHeaderProps) {\n  const router = useRouter()\n  const { data: session } = useSession()\n  const { profileImage } = useUserData()\n  const [dropdownOpen, setDropdownOpen] = useState(false)\n  const [affiliateMenu, setAffiliateMenu] = useState<{ label: string; href: string } | null>(null)\n\n  const hasProfileImage = !!(profileImage || session?.user?.image)\n  const userImage = (profileImage || session?.user?.image || '') as string\n  const userName = session?.user?.name || 'User'\n\n  const handleBack = () => {\n    if (backHref) {\n      router.push(backHref)\n    } else {\n      router.back()\n    }\n  }\n\n  const handleSignOut = async () => {\n    // Clear user-specific localStorage before signing out\n    if (session?.user?.id) {\n      localStorage.removeItem(`profileImage_${session.user.id}`)\n      localStorage.removeItem(`cachedProfileImage_${session.user.id}`)\n    }\n    await signOut({ callbackUrl: '/auth/signin' })\n  }\n\n  useEffect(() => {\n    if (!session?.user?.email) {\n      setAffiliateMenu(null)\n      return\n    }\n    let cancelled = false\n    setAffiliateMenu({ label: 'Become an Affiliate', href: '/affiliate/apply' })\n    const load = async () => {\n      try {\n        const res = await fetch('/api/affiliate/application', { cache: 'no-store' })\n        const data = await res.json().catch(() => ({} as any))\n        if (!res.ok) return\n\n        const hasAffiliate = !!data?.affiliate\n        const hasApplication = !!data?.application\n\n        const menu = hasAffiliate\n          ? { label: 'Affiliate Portal', href: '/affiliate' }\n          : hasApplication\n            ? { label: 'Affiliate Application', href: '/affiliate/apply' }\n            : { label: 'Become an Affiliate', href: '/affiliate/apply' }\n\n        if (!cancelled) setAffiliateMenu(menu)\n      } catch {\n        // ignore\n      }\n    }\n    load()\n    return () => {\n      cancelled = true\n    }\n  }, [session?.user?.email])\n\n  return (\n    <nav className=\"bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700 px-4 py-3\">\n      <div className=\"max-w-7xl mx-auto flex items-center justify-between\">\n        {/* Back Button */}\n        <button\n          onClick={handleBack}\n          className=\"flex items-center justify-center w-10 h-10 rounded-full hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors touch-manipulation\"\n          aria-label=\"Go back\"\n        >\n          <svg\n            className=\"w-6 h-6 text-gray-700 dark:text-gray-300\"\n            fill=\"none\"\n            stroke=\"currentColor\"\n            viewBox=\"0 0 24 24\"\n          >\n            <path\n              strokeLinecap=\"round\"\n              strokeLinejoin=\"round\"\n              strokeWidth={2}\n              d=\"M15 19l-7-7 7-7\"\n            />\n          </svg>\n        </button>\n\n        {/* Page Title - Centered */}\n        <h1 className=\"flex-1 text-center text-lg font-semibold text-gray-900 dark:text-white\">\n          {title}\n        </h1>\n\n        {/* Profile Avatar & Dropdown */}\n        <div className=\"relative dropdown-container\" id=\"profile-dropdown\">\n          <button\n            onClick={() => setDropdownOpen((v) => !v)}\n            className=\"focus:outline-none\"\n            aria-label=\"Open profile menu\"\n          >\n            {hasProfileImage ? (\n              <Image\n                src={userImage}\n                alt=\"Profile\"\n                width={40}\n                height={40}\n                className=\"w-10 h-10 rounded-full border-2 border-helfi-green shadow-sm object-cover\"\n              />\n            ) : (\n              <div className=\"w-10 h-10 rounded-full bg-helfi-green shadow-sm flex items-center justify-center\">\n                <UserIcon className=\"w-6 h-6 text-white\" aria-hidden=\"true\" />\n              </div>\n            )}\n          </button>\n          {dropdownOpen && (\n            <div className=\"absolute right-0 mt-2 w-64 bg-white dark:bg-gray-800 rounded-xl shadow-lg py-2 z-50 border border-gray-100 dark:border-gray-700 animate-fade-in\">\n              <div className=\"flex items-center px-4 py-3 border-b border-gray-100 dark:border-gray-700\">\n                {hasProfileImage ? (\n                  <Image\n                    src={userImage}\n                    alt=\"Profile\"\n                    width={40}\n                    height={40}\n                    className=\"w-10 h-10 rounded-full object-cover mr-3\"\n                  />\n                ) : (\n                  <div className=\"w-10 h-10 rounded-full bg-helfi-green flex items-center justify-center mr-3\">\n                    <UserIcon className=\"w-6 h-6 text-white\" aria-hidden=\"true\" />\n                  </div>\n                )}\n                <div>\n                  <div className=\"font-semibold text-gray-900 dark:text-white\">{userName}</div>\n                  <div className=\"text-xs text-gray-500 dark:text-gray-400\">\n                    {session?.user?.email || 'user@email.com'}\n                  </div>\n                </div>\n              </div>\n              <Link\n                href=\"/profile\"\n                className=\"block px-4 py-2 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-700\"\n                onClick={() => setDropdownOpen(false)}\n              >\n                Profile\n              </Link>\n              <Link\n                href=\"/account\"\n                className=\"block px-4 py-2 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-700\"\n                onClick={() => setDropdownOpen(false)}\n              >\n                Account Settings\n              </Link>\n              <Link\n                href=\"/profile/image\"\n                className=\"block px-4 py-2 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-700\"\n                onClick={() => setDropdownOpen(false)}\n              >\n                Upload/Change Profile Photo\n              </Link>\n              <Link\n                href=\"/billing\"\n                className=\"block px-4 py-2 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-700\"\n                onClick={() => setDropdownOpen(false)}\n              >\n                Subscription & Billing\n              </Link>\n              {affiliateMenu && (\n                <Link\n                  href={affiliateMenu.href}\n                  className=\"block px-4 py-2 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-700\"\n                  onClick={() => setDropdownOpen(false)}\n                >\n                  {affiliateMenu.label}\n                </Link>\n              )}\n              <Link\n                href=\"/notifications\"\n                className=\"block px-4 py-2 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-700\"\n                onClick={() => setDropdownOpen(false)}\n              >\n                Notifications\n              </Link>\n              <Link\n                href=\"/privacy\"\n                className=\"block px-4 py-2 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-700\"\n                onClick={() => setDropdownOpen(false)}\n              >\n                Privacy Settings\n              </Link>\n              <Link\n                href=\"/support\"\n                className=\"block px-4 py-2 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-700\"\n                onClick={() => setDropdownOpen(false)}\n              >\n                Help & Support\n              </Link>\n              <div className=\"border-t border-gray-100 dark:border-gray-700 my-2\"></div>\n              <Link\n                href=\"/reports\"\n                className=\"block px-4 py-2 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-700\"\n                onClick={() => setDropdownOpen(false)}\n              >\n                Reports\n              </Link>\n              <button\n                onClick={handleSignOut}\n                className=\"block w-full text-left px-4 py-2 text-red-600 dark:text-red-400 hover:bg-gray-50 dark:hover:bg-gray-700 font-semibold\"\n              >\n                Logout\n              </button>\n            </div>\n          )}\n        </div>\n      </div>\n    </nav>\n  )\n}\n\n\n","truncated":false,"size":8665},{"path":"components/providers/AuthProvider.tsx","content":"'use client'\n\nimport { SessionProvider } from 'next-auth/react'\n\nexport function AuthProvider({ children }: { children: React.ReactNode }) {\n  return (\n    <SessionProvider\n      // Avoid surprise logouts when the app is backgrounded on mobile.\n      // Let NextAuth handle session cookies; we just keep a light heartbeat.\n      refetchOnWindowFocus={false}\n      refetchWhenOffline={false}\n      refetchInterval={15 * 60}\n    >\n      {children}\n    </SessionProvider>\n  )\n}\n","truncated":false,"size":475},{"path":"components/providers/UserDataProvider.tsx","content":"'use client'\n\nimport React, { createContext, useContext, useState, useEffect } from 'react'\nimport { useSession } from 'next-auth/react'\n\ninterface UserData {\n  profileImage?: string\n  todaysFoods?: any[]\n  favorites?: any[]\n  profileInfo?: any\n  healthGoals?: any\n  gender?: string\n  [key: string]: any\n}\n\ninterface UserDataContextType {\n  userData: UserData | null\n  profileImage: string | null\n  isLoading: boolean\n  updateUserData: (newData: Partial<UserData>) => void\n  updateProfileImage: (image: string) => void\n  refreshData: () => Promise<void>\n}\n\nconst UserDataContext = createContext<UserDataContextType | undefined>(undefined)\n\nexport function UserDataProvider({ children }: { children: React.ReactNode }) {\n  const { data: session, status } = useSession()\n  const [userData, setUserData] = useState<UserData | null>(null)\n  const [isLoading, setIsLoading] = useState(true)\n\n  // Profile image is either the saved Cloudinary image or the auth provider image.\n  // We intentionally do NOT provide a graphic default here so UI components can\n  // render a professional icon fallback when no real image exists.\n  const profileImage = userData?.profileImage || (session?.user?.image ?? '')\n\n  // Load data once and cache it\n  const loadData = async () => {\n    if (!session) return\n\n    try {\n      console.log('üöÄ UserDataProvider: Loading user data...')\n      const startTime = Date.now()\n      \n      const response = await fetch('/api/user-data', {\n        cache: 'no-cache',\n        headers: {\n          'Cache-Control': 'no-cache'\n        }\n      })\n      \n      if (response.ok) {\n        const result = await response.json()\n        console.log(`üöÄ UserDataProvider: Data loaded in ${Date.now() - startTime}ms`)\n        \n        if (result.data) {\n          setUserData(result.data)\n        }\n      }\n    } catch (error) {\n      console.error('UserDataProvider: Error loading data:', error)\n    } finally {\n      setIsLoading(false)\n    }\n  }\n\n  // Refresh data\n  const refreshData = async () => {\n    setIsLoading(true)\n    await loadData()\n  }\n\n  // Update user data\n  const updateUserData = (newData: Partial<UserData>) => {\n    setUserData(prev => prev ? { ...prev, ...newData } : newData as UserData)\n  }\n\n  // Update profile image specifically\n  const updateProfileImage = (image: string) => {\n    setUserData(prev => prev ? { ...prev, profileImage: image } : { profileImage: image })\n  }\n\n  // Load data on mount and session change\n  useEffect(() => {\n    if (status === 'loading') return\n    if (session) {\n      loadData()\n    } else {\n      setUserData(null)\n      setIsLoading(false)\n    }\n  }, [session, status])\n\n  // Allow other parts of the app to force a refresh (e.g., after insights updates)\n  useEffect(() => {\n    const handler = () => {\n      refreshData()\n    }\n    window.addEventListener('userData:refresh', handler)\n    return () => window.removeEventListener('userData:refresh', handler)\n  }, [])\n\n  const value: UserDataContextType = {\n    userData,\n    profileImage,\n    isLoading,\n    updateUserData,\n    updateProfileImage,\n    refreshData\n  }\n\n  return (\n    <UserDataContext.Provider value={value}>\n      {children}\n    </UserDataContext.Provider>\n  )\n}\n\nexport function useUserData() {\n  const context = useContext(UserDataContext)\n  if (context === undefined) {\n    throw new Error('useUserData must be used within a UserDataProvider')\n  }\n  return context\n} \n","truncated":false,"size":3414},{"path":"components/reports/ConsentGate.tsx","content":"'use client';\n\nimport React, { useState } from 'react';\n\ninterface ConsentGateProps {\n  onConsent: (consent: ConsentData) => void;\n  isPasswordProtected: boolean;\n}\n\nexport interface ConsentData {\n  decryptionConsent: boolean;\n  passwordConsent: boolean;\n  retentionConsent: boolean;\n}\n\nexport default function ConsentGate({ onConsent, isPasswordProtected }: ConsentGateProps) {\n  const [decryptionConsent, setDecryptionConsent] = useState(false);\n  const [passwordConsent, setPasswordConsent] = useState(false);\n  const [retentionConsent, setRetentionConsent] = useState(false);\n\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    \n    if (isPasswordProtected && (!decryptionConsent || !passwordConsent)) {\n      return;\n    }\n    \n    onConsent({\n      decryptionConsent,\n      passwordConsent,\n      retentionConsent,\n    });\n  };\n\n  const canProceed = isPasswordProtected \n    ? (decryptionConsent && passwordConsent)\n    : true;\n\n  return (\n    <div className=\"bg-white rounded-lg shadow-md p-6 max-w-2xl mx-auto\">\n      <h2 className=\"text-2xl font-bold text-gray-900 mb-4\">\n        Consent Required for PDF Processing\n      </h2>\n      \n      <div className=\"space-y-4 mb-6\">\n        <p className=\"text-gray-700 leading-relaxed\">\n          Before we can process your laboratory report PDF, we need your explicit consent for how we handle your data.\n        </p>\n\n        {isPasswordProtected && (\n          <div className=\"bg-yellow-50 border border-yellow-200 rounded-lg p-4\">\n            <p className=\"text-yellow-800 font-medium mb-2\">\n              ‚ö†Ô∏è Password-Protected PDF Detected\n            </p>\n            <p className=\"text-yellow-700 text-sm\">\n              Your PDF is password-protected. You will need to provide the password to proceed.\n            </p>\n          </div>\n        )}\n\n        <div className=\"space-y-4\">\n          {/* Required Consent 1 */}\n          <label className=\"flex items-start space-x-3 cursor-pointer\">\n            <input\n              type=\"checkbox\"\n              checked={decryptionConsent}\n              onChange={(e) => setDecryptionConsent(e.target.checked)}\n              className=\"mt-1 h-5 w-5 text-green-600 focus:ring-green-500 border-gray-300 rounded\"\n              required\n            />\n            <div className=\"flex-1\">\n              <span className=\"text-gray-900 font-medium\">\n                I authorize Helfi to decrypt my uploaded PDF using the password I provide, only once, to extract my laboratory test results for analysis within my account.\n              </span>\n              <span className=\"text-red-600 ml-1\">*</span>\n            </div>\n          </label>\n\n          {/* Required Consent 2 */}\n          <label className=\"flex items-start space-x-3 cursor-pointer\">\n            <input\n              type=\"checkbox\"\n              checked={passwordConsent}\n              onChange={(e) => setPasswordConsent(e.target.checked)}\n              className=\"mt-1 h-5 w-5 text-green-600 focus:ring-green-500 border-gray-300 rounded\"\n              required\n            />\n            <div className=\"flex-1\">\n              <span className=\"text-gray-900 font-medium\">\n                I understand Helfi will not store my password and will permanently delete the original PDF after extraction unless I choose to retain it.\n              </span>\n              <span className=\"text-red-600 ml-1\">*</span>\n            </div>\n          </label>\n\n          {/* Optional Consent */}\n          <label className=\"flex items-start space-x-3 cursor-pointer\">\n            <input\n              type=\"checkbox\"\n              checked={retentionConsent}\n              onChange={(e) => setRetentionConsent(e.target.checked)}\n              className=\"mt-1 h-5 w-5 text-green-600 focus:ring-green-500 border-gray-300 rounded\"\n            />\n            <div className=\"flex-1\">\n              <span className=\"text-gray-900\">\n                Retain an encrypted copy of my original PDF for later download.\n              </span>\n              <span className=\"text-gray-500 text-sm block mt-1\">\n                (Optional - by default, we delete the original after extraction)\n              </span>\n            </div>\n          </label>\n        </div>\n      </div>\n\n      <div className=\"bg-blue-50 border border-blue-200 rounded-lg p-4 mb-6\">\n        <h3 className=\"text-blue-900 font-semibold mb-2\">Security & Privacy</h3>\n        <ul className=\"text-blue-800 text-sm space-y-1 list-disc list-inside\">\n          <li>Your password is used only once for decryption and is never stored</li>\n          <li>All lab values are encrypted at rest using industry-standard encryption</li>\n          <li>Original PDFs are deleted by default unless you choose to retain them</li>\n          <li>Full audit trail is maintained for compliance</li>\n        </ul>\n      </div>\n\n      <form onSubmit={handleSubmit}>\n        <button\n          type=\"submit\"\n          disabled={!canProceed}\n          className={`w-full py-3 px-4 rounded-lg font-medium transition-colors ${\n            canProceed\n              ? 'bg-green-600 hover:bg-green-700 text-white'\n              : 'bg-gray-300 text-gray-500 cursor-not-allowed'\n          }`}\n        >\n          {canProceed ? 'I Consent - Continue' : 'Please accept required consents'}\n        </button>\n      </form>\n\n      <p className=\"text-xs text-gray-500 mt-4 text-center\">\n        By proceeding, you agree to our{' '}\n        <a href=\"/terms\" className=\"text-green-600 hover:underline\">\n          Terms of Use\n        </a>{' '}\n        and{' '}\n        <a href=\"/privacy\" className=\"text-green-600 hover:underline\">\n          Privacy Policy\n        </a>\n        .\n      </p>\n    </div>\n  );\n}\n\n","truncated":false,"size":5705},{"path":"components/reports/LabReportUpload.tsx","content":"'use client';\n\nimport React, { useState, useRef } from 'react';\nimport ConsentGate, { ConsentData } from './ConsentGate';\n\ninterface LabReportUploadProps {\n  onUploadComplete?: (reportId: string) => void;\n}\n\nexport default function LabReportUpload({ onUploadComplete }: LabReportUploadProps) {\n  const [file, setFile] = useState<File | null>(null);\n  const [password, setPassword] = useState('');\n  const [consentData, setConsentData] = useState<ConsentData | null>(null);\n  const [isPasswordProtected, setIsPasswordProtected] = useState(false);\n  const [uploadStatus, setUploadStatus] = useState<'idle' | 'uploading' | 'processing' | 'completed' | 'error'>('idle');\n  const [error, setError] = useState<string | null>(null);\n  const [reportId, setReportId] = useState<string | null>(null);\n  const fileInputRef = useRef<HTMLInputElement>(null);\n\n  const handleFileSelect = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const selectedFile = e.target.files?.[0];\n    if (!selectedFile) return;\n\n    // Validate file type\n    if (!selectedFile.name.toLowerCase().endsWith('.pdf')) {\n      setError('Only PDF files are allowed');\n      return;\n    }\n\n    // Validate file size (25MB max)\n    if (selectedFile.size > 25 * 1024 * 1024) {\n      setError('File size must be less than 25MB');\n      return;\n    }\n\n    setFile(selectedFile);\n    setError(null);\n    setConsentData(null); // Reset consent when file changes\n  };\n\n  const handleConsent = (consent: ConsentData) => {\n    setConsentData(consent);\n  };\n\n  const handleUpload = async () => {\n    if (!file || !consentData) {\n      setError('Please select a file and provide consent');\n      return;\n    }\n\n    if (isPasswordProtected && !password) {\n      setError('Password is required for password-protected PDFs');\n      return;\n    }\n\n    setUploadStatus('uploading');\n    setError(null);\n\n    try {\n      // Step 1: Create report record and get report ID\n      const presignResponse = await fetch('/api/reports/presign', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          fileName: file.name,\n          fileSize: file.size,\n          isPasswordProtected,\n          password: isPasswordProtected ? password : undefined,\n          decryptionConsent: consentData.decryptionConsent,\n          passwordConsent: consentData.passwordConsent,\n          retentionConsent: consentData.retentionConsent,\n        }),\n      });\n\n      if (!presignResponse.ok) {\n        const errorData = await presignResponse.json();\n        throw new Error(errorData.error || 'Failed to create report record');\n      }\n\n      const { reportId: newReportId } = await presignResponse.json();\n      setReportId(newReportId);\n\n      // Step 2: Upload to Vercel Blob\n      const uploadFormData = new FormData();\n      uploadFormData.append('file', file);\n\n      const uploadResponse = await fetch(`/api/reports/${newReportId}/upload`, {\n        method: 'POST',\n        body: uploadFormData,\n      });\n\n      if (!uploadResponse.ok) {\n        const errorData = await uploadResponse.json();\n        throw new Error(errorData.error || 'Failed to upload file');\n      }\n\n      // Step 3: Process PDF\n      setUploadStatus('processing');\n      \n      const processResponse = await fetch(`/api/reports/${newReportId}/process`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          password: isPasswordProtected ? password : undefined,\n        }),\n      });\n\n      if (!processResponse.ok) {\n        const errorData = await processResponse.json();\n        throw new Error(errorData.error || 'Failed to process PDF');\n      }\n\n      const processData = await processResponse.json();\n      \n      setUploadStatus('completed');\n      setPassword(''); // Clear password from memory\n      \n      if (onUploadComplete) {\n        onUploadComplete(newReportId);\n      }\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Upload failed');\n      setUploadStatus('error');\n    }\n  };\n\n  return (\n    <div className=\"max-w-3xl mx-auto p-6\">\n      <h1 className=\"text-3xl font-bold text-gray-900 mb-6\">\n        Upload Laboratory Report\n      </h1>\n      <p className=\"text-sm text-gray-600 mb-4\">\n        Processing uses AI credits (2√ó OpenAI cost). Typical: 6‚Äì10 credits depending on file length and extraction.\n      </p>\n\n      {uploadStatus === 'idle' && (\n        <div className=\"space-y-6\">\n          {/* File Selection */}\n          <div>\n            <label className=\"block text-sm font-medium text-gray-700 mb-2\">\n              Select PDF File\n            </label>\n            <input\n              ref={fileInputRef}\n              type=\"file\"\n              accept=\".pdf\"\n              onChange={handleFileSelect}\n              className=\"block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-green-50 file:text-green-700 hover:file:bg-green-100\"\n            />\n            {file && (\n              <p className=\"mt-2 text-sm text-gray-600\">\n                Selected: {file.name} ({(file.size / 1024 / 1024).toFixed(2)} MB)\n              </p>\n            )}\n          </div>\n\n          {/* Password Protection Detection */}\n          {file && (\n            <div>\n              <label className=\"flex items-center space-x-2\">\n                <input\n                  type=\"checkbox\"\n                  checked={isPasswordProtected}\n                  onChange={(e) => setIsPasswordProtected(e.target.checked)}\n                  className=\"h-4 w-4 text-green-600 focus:ring-green-500 border-gray-300 rounded\"\n                />\n                <span className=\"text-sm text-gray-700\">\n                  My PDF is password-protected\n                </span>\n              </label>\n\n              {isPasswordProtected && (\n                <div className=\"mt-3\">\n                  <label className=\"block text-sm font-medium text-gray-700 mb-2\">\n                    PDF Password\n                  </label>\n                  <input\n                    type=\"password\"\n                    value={password}\n                    onChange={(e) => setPassword(e.target.value)}\n                    placeholder=\"Enter PDF password\"\n                    className=\"w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-green-500 focus:border-green-500\"\n                  />\n                  <p className=\"mt-1 text-xs text-gray-500\">\n                    Your password will be used only once for decryption and will not be stored.\n                  </p>\n                </div>\n              )}\n            </div>\n          )}\n\n          {/* Consent Gate */}\n          {file && (\n            <div>\n              <ConsentGate\n                onConsent={handleConsent}\n                isPasswordProtected={isPasswordProtected}\n              />\n            </div>\n          )}\n\n          {/* Upload Button */}\n          {file && consentData && (\n            <button\n              onClick={handleUpload}\n              className=\"w-full py-3 px-4 bg-green-600 hover:bg-green-700 text-white font-medium rounded-lg transition-colors\"\n            >\n              Upload and Process PDF\n            </button>\n          )}\n\n          {error && (\n            <div className=\"bg-red-50 border border-red-200 rounded-lg p-4\">\n              <p className=\"text-red-800\">{error}</p>\n            </div>\n          )}\n        </div>\n      )}\n\n      {/* Upload Status */}\n      {uploadStatus === 'uploading' && (\n        <div className=\"text-center py-8\">\n          <div className=\"animate-spin rounded-full h-12 w-12 border-b-2 border-green-600 mx-auto mb-4\"></div>\n          <p className=\"text-gray-700\">Uploading PDF...</p>\n        </div>\n      )}\n\n      {uploadStatus === 'processing' && (\n        <div className=\"text-center py-8\">\n          <div className=\"animate-spin rounded-full h-12 w-12 border-b-2 border-green-600 mx-auto mb-4\"></div>\n          <p className=\"text-gray-700\">Processing PDF...</p>\n          <p className=\"text-sm text-gray-500 mt-2\">\n            Decrypting, extracting lab values, and encrypting data...\n          </p>\n        </div>\n      )}\n\n      {uploadStatus === 'completed' && (\n        <div className=\"bg-green-50 border border-green-200 rounded-lg p-6 text-center\">\n          <div className=\"text-green-600 text-4xl mb-4\">‚úì</div>\n          <h2 className=\"text-xl font-bold text-green-900 mb-2\">\n            PDF Processed Successfully!\n          </h2>\n          <p className=\"text-green-800 mb-4\">\n            Your laboratory report has been processed and encrypted.\n          </p>\n          <button\n            onClick={() => {\n              setFile(null);\n              setPassword('');\n              setConsentData(null);\n              setUploadStatus('idle');\n              setReportId(null);\n              if (fileInputRef.current) {\n                fileInputRef.current.value = '';\n              }\n            }}\n            className=\"px-4 py-2 bg-green-600 hover:bg-green-700 text-white rounded-lg\"\n          >\n            Upload Another Report\n          </button>\n        </div>\n      )}\n\n      {uploadStatus === 'error' && (\n        <div className=\"bg-red-50 border border-red-200 rounded-lg p-6\">\n          <h2 className=\"text-xl font-bold text-red-900 mb-2\">\n            Processing Failed\n          </h2>\n          <p className=\"text-red-800 mb-4\">{error}</p>\n          <button\n            onClick={() => {\n              setUploadStatus('idle');\n              setError(null);\n            }}\n            className=\"px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded-lg\"\n          >\n            Try Again\n          </button>\n        </div>\n      )}\n    </div>\n  );\n}\n","truncated":false,"size":9791},{"path":"components/SolidMacroRing.tsx","content":"'use client'\nimport React from 'react'\n\ntype SolidRingProps = {\n  label: string\n  value: string | number\n  unit?: string\n  color: string\n  size?: 'normal' | 'large'\n}\n\nexport function SolidMacroRing({ label, value, unit, color, size = 'normal' }: SolidRingProps) {\n  // Dimensions based on the screenshot and user description\n  // \"normal\" size (similar to screenshot) -> ~90px? \n  // Let's stick to a fixed svg size for consistency.\n  const svgSize = size === 'large' ? 120 : 100\n  const radius = size === 'large' ? 52 : 42\n  const strokeWidth = size === 'large' ? 10 : 8\n  const center = svgSize / 2\n  \n  // Circumference for full circle\n  const circumference = 2 * Math.PI * radius\n\n  // We want a SOLID line all around (full circle).\n  // Background inside is transparent.\n  // Value in middle, label under value.\n  \n  return (\n    <div className=\"flex flex-col items-center justify-center\">\n      <div className=\"relative flex items-center justify-center\">\n        <svg width={svgSize} height={svgSize} className=\"transform -rotate-90\">\n          <circle\n            cx={center}\n            cy={center}\n            r={radius}\n            strokeWidth={strokeWidth}\n            stroke={color}\n            fill=\"none\"\n            strokeLinecap=\"round\"\n          />\n        </svg>\n        \n        {/* Centered Content */}\n        <div className=\"absolute inset-0 flex flex-col items-center justify-center\">\n          <div className=\"text-2xl font-bold text-gray-900 leading-none\">\n            {value}\n          </div>\n          {unit ? (\n            <div className=\"text-sm font-medium text-gray-500 mt-0.5 leading-none\">\n              {unit}\n            </div>\n          ) : (\n            <div className=\"text-sm font-medium text-gray-500 mt-0.5 leading-none\">\n              kcal\n            </div>\n          )}\n        </div>\n      </div>\n    </div>\n  )\n}\n\n","truncated":false,"size":1861},{"path":"components/support/SupportChatWidget.tsx","content":"'use client'\n\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react'\nimport Image from 'next/image'\nimport { usePathname } from 'next/navigation'\nimport { useSession } from 'next-auth/react'\n\ntype SupportAttachment = {\n  id?: string\n  name: string\n  url: string\n  type?: string\n  size?: number\n}\n\nconst SUPPORT_AGENT_NAME = 'Maya'\nconst SUPPORT_AGENT_ROLE = 'Helfi Support'\nconst SUPPORT_AGENT_AVATAR = '/support/maya.jpg'\nconst ATTACHMENTS_MARKER = '[[ATTACHMENTS]]'\n\nconst STORAGE_KEYS = {\n  open: 'helfi:support:widget:open',\n  guestTicketId: 'helfi:support:guest:ticketId',\n  guestToken: 'helfi:support:guest:token',\n  guestName: 'helfi:support:guest:name',\n  guestEmail: 'helfi:support:guest:email',\n}\n\nexport default function SupportChatWidget() {\n  const { data: session } = useSession()\n  const pathname = usePathname()\n  const isLoggedIn = Boolean(session?.user?.email)\n  const [isOpen, setIsOpen] = useState(false)\n  const [isLoading, setIsLoading] = useState(false)\n  const [ticket, setTicket] = useState<any | null>(null)\n  const [message, setMessage] = useState('')\n  const [attachments, setAttachments] = useState<SupportAttachment[]>([])\n  const [isUploading, setIsUploading] = useState(false)\n  const [attachmentError, setAttachmentError] = useState('')\n  const [optimisticMessages, setOptimisticMessages] = useState<Array<{\n    id: string\n    message: string\n    attachments: SupportAttachment[]\n    isAdminResponse: boolean\n    createdAt: string\n  }>>([])\n  const [guestName, setGuestName] = useState('')\n  const [guestEmail, setGuestEmail] = useState('')\n  const [guestToken, setGuestToken] = useState('')\n  const [guestTicketId, setGuestTicketId] = useState('')\n  const [feedbackRating, setFeedbackRating] = useState(0)\n  const [feedbackComment, setFeedbackComment] = useState('')\n  const [feedbackSubmitted, setFeedbackSubmitted] = useState(false)\n  const messagesEndRef = useRef<HTMLDivElement | null>(null)\n\n  const isChatClosed = ticket && ['RESOLVED', 'CLOSED'].includes(ticket.status)\n  const shouldHideWidget = pathname === '/support' || pathname.startsWith('/admin-panel') || pathname.startsWith('/main-admin')\n\n  useEffect(() => {\n    if (typeof window === 'undefined') return\n    setIsOpen(window.localStorage.getItem(STORAGE_KEYS.open) === 'true')\n    setGuestTicketId(window.localStorage.getItem(STORAGE_KEYS.guestTicketId) || '')\n    setGuestToken(window.localStorage.getItem(STORAGE_KEYS.guestToken) || '')\n    setGuestName(window.localStorage.getItem(STORAGE_KEYS.guestName) || '')\n    setGuestEmail(window.localStorage.getItem(STORAGE_KEYS.guestEmail) || '')\n  }, [])\n\n  useEffect(() => {\n    if (typeof window === 'undefined') return\n    window.localStorage.setItem(STORAGE_KEYS.open, String(isOpen))\n  }, [isOpen])\n\n  useEffect(() => {\n    if (typeof window === 'undefined') return\n    if (guestTicketId) {\n      window.localStorage.setItem(STORAGE_KEYS.guestTicketId, guestTicketId)\n    } else {\n      window.localStorage.removeItem(STORAGE_KEYS.guestTicketId)\n    }\n  }, [guestTicketId])\n\n  useEffect(() => {\n    if (typeof window === 'undefined') return\n    if (guestToken) {\n      window.localStorage.setItem(STORAGE_KEYS.guestToken, guestToken)\n    } else {\n      window.localStorage.removeItem(STORAGE_KEYS.guestToken)\n    }\n  }, [guestToken])\n\n  useEffect(() => {\n    if (typeof window === 'undefined') return\n    if (guestName) {\n      window.localStorage.setItem(STORAGE_KEYS.guestName, guestName)\n    }\n    if (guestEmail) {\n      window.localStorage.setItem(STORAGE_KEYS.guestEmail, guestEmail)\n    }\n  }, [guestName, guestEmail])\n\n  const splitMessageAttachments = (messageText: string) => {\n    const markerIndex = messageText.indexOf(ATTACHMENTS_MARKER)\n    if (markerIndex === -1) {\n      return { text: messageText, attachments: [] as SupportAttachment[] }\n    }\n    const text = messageText.slice(0, markerIndex).trim()\n    const raw = messageText.slice(markerIndex + ATTACHMENTS_MARKER.length).trim()\n    if (!raw) {\n      return { text, attachments: [] as SupportAttachment[] }\n    }\n    try {\n      const parsed = JSON.parse(raw)\n      const parsedAttachments = Array.isArray(parsed)\n        ? parsed\n            .map((item) => ({\n              id: item?.id ? String(item.id) : undefined,\n              name: String(item?.name || ''),\n              url: String(item?.url || ''),\n              type: item?.type ? String(item.type) : undefined,\n              size: typeof item?.size === 'number' ? item.size : undefined,\n            }))\n            .filter((item) => item.name && item.url)\n        : []\n      return { text, attachments: parsedAttachments }\n    } catch {\n      return { text: messageText, attachments: [] as SupportAttachment[] }\n    }\n  }\n\n  const serializeMessageWithAttachments = (text: string, items: SupportAttachment[]) => {\n    if (!items.length) return text\n    const payload = items.map((att) => ({\n      id: att.id,\n      name: att.name,\n      url: att.url,\n      type: att.type,\n      size: att.size,\n    }))\n    return `${text}\\n\\n${ATTACHMENTS_MARKER}\\n${JSON.stringify(payload)}`\n  }\n\n  const conversationItems = useMemo(() => {\n    if (!ticket) return [...optimisticMessages]\n    const initial = splitMessageAttachments(String(ticket.message || ''))\n    const base = [\n      {\n        id: `ticket-${ticket.id}`,\n        message: initial.text,\n        attachments: initial.attachments,\n        isAdminResponse: false,\n        createdAt: ticket.createdAt,\n      },\n    ]\n    const responses = (ticket.responses || [])\n      .filter((response: any) => {\n        const msg = String(response.message || '')\n        return !msg.startsWith('[SYSTEM]') && !msg.startsWith('[FEEDBACK]')\n      })\n      .map((response: any) => {\n        const parsed = splitMessageAttachments(String(response.message || ''))\n        return {\n          id: response.id,\n          message: parsed.text,\n          attachments: parsed.attachments,\n          isAdminResponse: response.isAdminResponse,\n          createdAt: response.createdAt,\n        }\n      })\n    return [...base, ...responses, ...optimisticMessages]\n  }, [ticket, optimisticMessages])\n\n  useEffect(() => {\n    if (!isOpen) return\n    const timer = window.setTimeout(() => {\n      messagesEndRef.current?.scrollIntoView({ behavior: 'smooth', block: 'end' })\n    }, 0)\n    return () => window.clearTimeout(timer)\n  }, [isOpen, conversationItems.length])\n\n  const loadTicket = useCallback(async (forceLoad = false) => {\n    if (!forceLoad && !isOpen) return\n    setIsLoading(true)\n    try {\n      if (isLoggedIn) {\n        const response = await fetch('/api/support/tickets?activeOnly=1')\n        if (response.ok) {\n          const result = await response.json()\n          const nextTicket = result.ticket || null\n          setTicket(nextTicket)\n          setFeedbackSubmitted(Boolean(result.ticket?.responses?.some((res: any) => String(res.message || '').startsWith('[FEEDBACK]'))))\n          if (nextTicket) {\n            setIsOpen(true)\n          } else {\n            setIsOpen(false)\n          }\n        }\n      } else if (guestTicketId && guestToken) {\n        const response = await fetch(`/api/support/inquiry?ticketId=${guestTicketId}&token=${guestToken}`)\n        if (response.ok) {\n          const result = await response.json()\n          setTicket(result.ticket || null)\n          setFeedbackSubmitted(Boolean(result.ticket?.responses?.some((res: any) => String(res.message || '').startsWith('[FEEDBACK]'))))\n        }\n      }\n    } catch (error) {\n      console.error('Error loading support chat:', error)\n    }\n    setIsLoading(false)\n  }, [isOpen, isLoggedIn, guestTicketId, guestToken])\n\n  useEffect(() => {\n    if (isOpen) {\n      loadTicket()\n    }\n  }, [isOpen, loadTicket])\n\n  useEffect(() => {\n    if (!isLoggedIn) return\n    loadTicket(true)\n  }, [isLoggedIn, loadTicket])\n\n  const uploadSupportFile = async (file: File) => {\n    const formData = new FormData()\n    formData.append('file', file)\n    if (!isLoggedIn && guestTicketId && guestToken) {\n      formData.append('ticketId', guestTicketId)\n      formData.append('token', guestToken)\n    }\n\n    const endpoint = isLoggedIn ? '/api/support/uploads' : '/api/support/inquiry/uploads'\n    const response = await fetch(endpoint, {\n      method: 'POST',\n      body: formData,\n    })\n    if (!response.ok) {\n      const error = await response.json().catch(() => ({}))\n      throw new Error(error?.error || 'Upload failed')\n    }\n    return response.json()\n  }\n\n  const handleUploadFiles = async (files: File[]) => {\n    if (!files.length) return\n    setAttachmentError('')\n    setIsUploading(true)\n    try {\n      const uploads = await Promise.all(\n        files.map(async (file) => {\n          const result = await uploadSupportFile(file)\n          return {\n            id: result.fileId,\n            name: result.name,\n            url: result.url,\n            type: result.type,\n            size: result.size,\n          } as SupportAttachment\n        })\n      )\n      setAttachments((prev) => [...prev, ...uploads])\n    } catch (error: any) {\n      setAttachmentError(error?.message || 'Failed to upload file')\n    } finally {\n      setIsUploading(false)\n    }\n  }\n\n  const handlePasteUpload = async (event: React.ClipboardEvent<HTMLTextAreaElement>) => {\n    const items = Array.from(event.clipboardData?.items || [])\n    const imageFiles: File[] = []\n    for (const item of items) {\n      if (item.kind === 'file' && item.type.startsWith('image/')) {\n        const file = item.getAsFile()\n        if (file) imageFiles.push(file)\n      }\n    }\n    if (imageFiles.length > 0) {\n      await handleUploadFiles(imageFiles)\n    }\n  }\n\n  const createGuestChat = async (payloadMessage: string, payloadAttachments: SupportAttachment[], optimisticId: string) => {\n    if (!guestEmail.trim() || (!payloadMessage.trim() && payloadAttachments.length === 0)) return\n    setIsLoading(true)\n    try {\n      const response = await fetch('/api/support/inquiry', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          action: 'create',\n          name: guestName.trim(),\n          email: guestEmail.trim(),\n          message: serializeMessageWithAttachments(payloadMessage.trim(), payloadAttachments),\n        }),\n      })\n      if (response.ok) {\n        const result = await response.json()\n        setTicket(result.ticket || null)\n        setGuestToken(result.token || '')\n        setGuestTicketId(result.ticket?.id || '')\n        setOptimisticMessages((prev) => prev.filter((item) => item.id !== optimisticId))\n      }\n      if (!response.ok) {\n        setOptimisticMessages((prev) => prev.filter((item) => item.id !== optimisticId))\n      }\n    } catch (error) {\n      console.error('Error starting inquiry chat:', error)\n      setOptimisticMessages((prev) => prev.filter((item) => item.id !== optimisticId))\n    }\n    setIsLoading(false)\n  }\n\n  const sendMessage = async () => {\n    const trimmedMessage = message.trim()\n    const outgoingAttachments = attachments\n    if (!trimmedMessage && outgoingAttachments.length === 0) return\n    if (isChatClosed || isLoading || isUploading) return\n    if (!ticket && !isLoggedIn && !guestEmail.trim()) return\n\n    const optimisticId = `local-${Date.now()}-${Math.random().toString(16).slice(2)}`\n    setOptimisticMessages((prev) => [\n      ...prev,\n      {\n        id: optimisticId,\n        message: trimmedMessage,\n        attachments: outgoingAttachments,\n        isAdminResponse: false,\n        createdAt: new Date().toISOString(),\n      },\n    ])\n    setMessage('')\n    setAttachments([])\n    if (!ticket) {\n      if (isLoggedIn) {\n        setIsLoading(true)\n        try {\n          const response = await fetch('/api/support/tickets', {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({\n              action: 'create',\n              subject: 'Support chat',\n              message: serializeMessageWithAttachments(message.trim(), attachments),\n              category: 'TECHNICAL',\n              priority: 'MEDIUM',\n            }),\n          })\n          if (response.ok) {\n            const result = await response.json()\n            setTicket(result.ticket || null)\n            setOptimisticMessages((prev) => prev.filter((item) => item.id !== optimisticId))\n          }\n          if (!response.ok) {\n            setOptimisticMessages((prev) => prev.filter((item) => item.id !== optimisticId))\n          }\n        } catch (error) {\n          console.error('Error creating support chat:', error)\n          setOptimisticMessages((prev) => prev.filter((item) => item.id !== optimisticId))\n        }\n        setIsLoading(false)\n      } else {\n        await createGuestChat(trimmedMessage, outgoingAttachments, optimisticId)\n      }\n      return\n    }\n\n    setIsLoading(true)\n    try {\n      const endpoint = isLoggedIn ? '/api/support/tickets' : '/api/support/inquiry'\n      const payload = isLoggedIn\n        ? { action: 'add_response', ticketId: ticket.id, message: serializeMessageWithAttachments(message.trim(), attachments) }\n        : { action: 'add_response', ticketId: ticket.id, token: guestToken, message: serializeMessageWithAttachments(message.trim(), attachments) }\n\n      const response = await fetch(endpoint, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(payload),\n      })\n\n      if (response.ok) {\n        const result = await response.json()\n        setTicket(result.ticket || null)\n        setOptimisticMessages((prev) => prev.filter((item) => item.id !== optimisticId))\n      }\n      if (!response.ok) {\n        setOptimisticMessages((prev) => prev.filter((item) => item.id !== optimisticId))\n      }\n    } catch (error) {\n      console.error('Error sending support message:', error)\n      setOptimisticMessages((prev) => prev.filter((item) => item.id !== optimisticId))\n    }\n    setIsLoading(false)\n  }\n\n  const handleChatKeyDown = (event: React.KeyboardEvent<HTMLTextAreaElement>) => {\n    if (event.key !== 'Enter' || event.shiftKey || event.nativeEvent.isComposing) return\n    event.preventDefault()\n    if (isChatClosed || isLoading || isUploading) return\n    if (!isLoggedIn && !guestEmail.trim()) return\n    sendMessage()\n  }\n\n  const endChat = async () => {\n    if (!ticket) return\n    setIsLoading(true)\n    try {\n      const endpoint = isLoggedIn ? '/api/support/tickets' : '/api/support/inquiry'\n      const payload = isLoggedIn\n        ? { action: 'end_chat', ticketId: ticket.id }\n        : { action: 'end_chat', ticketId: ticket.id, token: guestToken }\n\n      const response = await fetch(endpoint, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(payload),\n      })\n      if (response.ok) {\n        const result = await response.json()\n        setTicket(result.ticket || null)\n      }\n    } catch (error) {\n      console.error('Error ending support chat:', error)\n    }\n    setIsLoading(false)\n  }\n\n  const submitFeedback = async () => {\n    if (!ticket || feedbackRating < 1) return\n    setIsLoading(true)\n    try {\n      const endpoint = isLoggedIn ? '/api/support/tickets' : '/api/support/inquiry'\n      const payload = isLoggedIn\n        ? { action: 'submit_feedback', ticketId: ticket.id, rating: feedbackRating, comment: feedbackComment.trim() }\n        : { action: 'submit_feedback', ticketId: ticket.id, token: guestToken, rating: feedbackRating, comment: feedbackComment.trim() }\n\n      const response = await fetch(endpoint, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(payload),\n      })\n      if (response.ok) {\n        const result = await response.json()\n        setTicket(result.ticket || null)\n        setFeedbackSubmitted(true)\n      }\n    } catch (error) {\n      console.error('Error submitting feedback:', error)\n    }\n    setIsLoading(false)\n  }\n\n  const startNewChat = () => {\n    setTicket(null)\n    setMessage('')\n    setAttachments([])\n    setOptimisticMessages([])\n    setFeedbackRating(0)\n    setFeedbackComment('')\n    setFeedbackSubmitted(false)\n    if (!isLoggedIn) {\n      setGuestToken('')\n      setGuestTicketId('')\n    }\n  }\n\n  const clearChat = () => {\n    setTicket(null)\n    setMessage('')\n    setAttachments([])\n    setOptimisticMessages([])\n    setFeedbackRating(0)\n    setFeedbackComment('')\n    setFeedbackSubmitted(false)\n    setIsOpen(false)\n    if (!isLoggedIn) {\n      setGuestToken('')\n      setGuestTicketId('')\n    }\n  }\n\n  if (shouldHideWidget) return null\n  if (isLoggedIn && !ticket) return null\n\n  return (\n    <div className=\"fixed bottom-5 right-5 z-[60]\">\n      {!isOpen && (\n        <button\n          onClick={() => setIsOpen(true)}\n          className=\"flex items-center gap-3 bg-white border border-gray-200 shadow-lg rounded-full px-4 py-2 hover:shadow-xl transition-shadow\"\n        >\n          <Image\n            src={SUPPORT_AGENT_AVATAR}\n            alt={`${SUPPORT_AGENT_NAME} avatar`}\n            width={36}\n            height={36}\n            className=\"rounded-full object-cover\"\n          />\n          <div className=\"text-left\">\n            <div className=\"text-sm font-semibold text-gray-900\">Chat with {SUPPORT_AGENT_NAME}</div>\n            <div className=\"text-xs text-gray-500\">Questions? We‚Äôre here.</div>\n          </div>\n        </button>\n      )}\n\n      {isOpen && (\n        <div className=\"w-[360px] max-w-[92vw] h-[520px] max-h-[80vh] bg-white rounded-2xl shadow-2xl border border-gray-200 flex flex-col\">\n          <div className=\"flex items-center justify-between px-4 py-3 border-b border-gray-200\">\n            <div className=\"flex items-center gap-3\">\n              <Image\n                src={SUPPORT_AGENT_AVATAR}\n                alt={`${SUPPORT_AGENT_NAME} avatar`}\n                width={36}\n                height={36}\n                className=\"rounded-full object-cover\"\n              />\n              <div>\n                <div className=\"text-sm font-semibold text-gray-900\">{SUPPORT_AGENT_NAME}</div>\n                <div className=\"text-xs text-gray-500\">{SUPPORT_AGENT_ROLE}</div>\n              </div>\n            </div>\n            <button\n              onClick={() => setIsOpen(false)}\n              className=\"text-gray-400 hover:text-gray-600\"\n              aria-label=\"Close chat\"\n            >\n              ‚úï\n            </button>\n          </div>\n\n          <div className=\"flex-1 overflow-y-auto px-4 py-3 space-y-3\">\n            {isLoading && !ticket && (\n              <div className=\"text-xs text-gray-500\">Loading chat...</div>\n            )}\n\n            {!ticket && !isLoggedIn && (\n              <div className=\"space-y-3\">\n                <p className=\"text-sm text-gray-700\">\n                  Hi! I‚Äôm {SUPPORT_AGENT_NAME}. Ask me anything about Helfi and I‚Äôll help out.\n                </p>\n                <input\n                  type=\"text\"\n                  value={guestName}\n                  onChange={(e) => setGuestName(e.target.value)}\n                  placeholder=\"Your name\"\n                  className=\"w-full border border-gray-300 rounded-lg px-3 py-2 text-sm\"\n                />\n                <input\n                  type=\"email\"\n                  value={guestEmail}\n                  onChange={(e) => setGuestEmail(e.target.value)}\n                  placeholder=\"Your email\"\n                  className=\"w-full border border-gray-300 rounded-lg px-3 py-2 text-sm\"\n                />\n              </div>\n            )}\n\n            {ticket && isChatClosed && (\n              <div className=\"text-xs text-amber-700 bg-amber-50 border border-amber-200 rounded-lg p-2\">\n                This chat is closed. Start a new chat if you need more help.\n              </div>\n            )}\n\n            {conversationItems.map((item) => (\n              <div\n                key={item.id}\n                className={`rounded-lg p-3 ${item.isAdminResponse ? 'bg-emerald-50 border-l-4 border-emerald-500' : 'bg-gray-50 border-l-4 border-gray-300'}`}\n              >\n                <div className=\"flex items-center justify-between mb-1 text-[11px] text-gray-500\">\n                  <span className=\"flex items-center gap-2\">\n                    {item.isAdminResponse ? (\n                      <>\n                        <Image\n                          src={SUPPORT_AGENT_AVATAR}\n                          alt={`${SUPPORT_AGENT_NAME} avatar`}\n                          width={18}\n                          height={18}\n                          className=\"rounded-full object-cover\"\n                        />\n                        {SUPPORT_AGENT_NAME}\n                      </>\n                    ) : (\n                      'You'\n                    )}\n                  </span>\n                  <span>{item.createdAt ? new Date(item.createdAt).toLocaleTimeString() : ''}</span>\n                </div>\n                <p className=\"text-sm text-gray-700 whitespace-pre-wrap\">{item.message}</p>\n                {item.attachments?.length > 0 && (\n                  <div className=\"mt-3 grid grid-cols-1 gap-2\">\n                    {item.attachments.map((att: SupportAttachment) => (\n                      <a\n                        key={`${item.id}-${att.url}`}\n                        href={att.url}\n                        target=\"_blank\"\n                        rel=\"noreferrer\"\n                        className=\"border border-gray-200 rounded-lg p-2 bg-white hover:bg-gray-50 transition-colors\"\n                      >\n                        {att.type?.startsWith('image/') ? (\n                          <div className=\"space-y-2\">\n                            <div className=\"relative w-full h-32\">\n                              <Image\n                                src={att.url}\n                                alt={att.name}\n                                fill\n                                className=\"object-cover rounded-md\"\n                              />\n                            </div>\n                            <div className=\"text-xs text-gray-600 truncate\">{att.name}</div>\n                          </div>\n                        ) : (\n                          <div className=\"text-xs text-gray-700\">\n                            <div className=\"font-medium\">{att.name}</div>\n                            <div className=\"text-[11px] text-gray-500\">{att.type || 'Document'}</div>\n                          </div>\n                        )}\n                      </a>\n                    ))}\n                  </div>\n                )}\n              </div>\n            ))}\n            <div ref={messagesEndRef} />\n          </div>\n\n          {ticket && isChatClosed && (\n            <div className=\"px-4 pb-3\">\n              <div className=\"flex gap-2 mb-3\">\n                <button\n                  type=\"button\"\n                  onClick={startNewChat}\n                  className=\"w-full text-xs border border-gray-300 text-gray-700 rounded-lg px-3 py-2\"\n                >\n                  Start a new chat\n                </button>\n                <button\n                  type=\"button\"\n                  onClick={clearChat}\n                  className=\"w-full text-xs border border-gray-300 text-gray-700 rounded-lg px-3 py-2\"\n                >\n                  Clear chat\n                </button>\n              </div>\n              {feedbackSubmitted ? (\n                <div className=\"text-xs text-emerald-700 bg-emerald-50 border border-emerald-200 rounded-lg p-2\">\n                  Thanks for the feedback.\n                </div>\n              ) : (\n                <div className=\"space-y-2\">\n                  <p className=\"text-xs text-gray-600\">How was your support experience?</p>\n                  <div className=\"flex gap-2\">\n                    {[1, 2, 3, 4, 5].map((rating) => (\n                      <button\n                        key={rating}\n                        type=\"button\"\n                        onClick={() => setFeedbackRating(rating)}\n                        className={`px-2 py-1 rounded border text-xs ${feedbackRating === rating ? 'bg-emerald-500 text-white border-emerald-500' : 'border-gray-300 text-gray-700'}`}\n                      >\n                        {rating}\n                      </button>\n                    ))}\n                  </div>\n                  <textarea\n                    rows={2}\n                    value={feedbackComment}\n                    onChange={(e) => setFeedbackComment(e.target.value)}\n                    className=\"w-full border border-gray-300 rounded-lg px-2 py-1 text-xs\"\n                    placeholder=\"Optional comment...\"\n                  />\n                  <button\n                    type=\"button\"\n                    onClick={submitFeedback}\n                    disabled={feedbackRating < 1 || isLoading}\n                    className=\"w-full bg-helfi-green text-white rounded-lg px-3 py-2 text-xs disabled:opacity-50\"\n                  >\n                    {isLoading ? 'Submitting...' : 'Submit feedback'}\n                  </button>\n                </div>\n              )}\n            </div>\n          )}\n\n          {!isChatClosed && (\n            <div className=\"border-t border-gray-200 px-4 py-3 space-y-2\">\n              {attachmentError && <p className=\"text-xs text-red-600\">{attachmentError}</p>}\n              {attachments.length > 0 && (\n                <div className=\"flex flex-wrap gap-2\">\n                  {attachments.map((att) => (\n                    <div key={att.url} className=\"flex items-center gap-2 bg-gray-100 px-2 py-1 rounded-full text-[11px]\">\n                      <span className=\"truncate max-w-[140px]\">{att.name}</span>\n                      <button\n                        type=\"button\"\n                        onClick={() => setAttachments((prev) => prev.filter((item) => item.url !== att.url))}\n                        className=\"text-gray-500 hover:text-gray-700\"\n                        aria-label={`Remove ${att.name}`}\n                      >\n                        ‚úï\n                      </button>\n                    </div>\n                  ))}\n                </div>\n              )}\n              <textarea\n                rows={2}\n                value={message}\n                onChange={(e) => setMessage(e.target.value)}\n                onPaste={handlePasteUpload}\n                onKeyDown={handleChatKeyDown}\n                className=\"w-full border border-gray-300 rounded-lg px-2 py-2 text-sm\"\n                placeholder=\"Type your message...\"\n              />\n              <div className=\"flex items-center justify-between\">\n                <label className=\"text-xs text-gray-600 cursor-pointer border border-gray-300 rounded-lg px-2 py-1\">\n                  Attach\n                  <input\n                    type=\"file\"\n                    multiple\n                    accept=\"image/*,application/pdf,application/msword,application/vnd.openxmlformats-officedocument.wordprocessingml.document\"\n                    className=\"hidden\"\n                    onChange={(e) => handleUploadFiles(Array.from(e.target.files || []))}\n                  />\n                </label>\n                <div className=\"flex items-center gap-2\">\n                  {ticket && (\n                    <button\n                      type=\"button\"\n                      onClick={endChat}\n                      className=\"text-xs border border-emerald-500 text-emerald-700 rounded-lg px-2 py-1\"\n                    >\n                      End chat\n                    </button>\n                  )}\n                  <button\n                    type=\"button\"\n                    onClick={sendMessage}\n                    disabled={isUploading || isLoading || (!message.trim() && attachments.length === 0) || (!isLoggedIn && !guestEmail.trim())}\n                    className=\"inline-flex items-center justify-center w-9 h-9 bg-helfi-green text-white rounded-full disabled:opacity-50\"\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  >\n                    {isLoading || isUploading ? (\n                      <span className=\"text-[10px]\">...</span>\n                    ) : (\n                      <svg viewBox=\"0 0 24 24\" className=\"w-4 h-4\" fill=\"currentColor\" aria-hidden=\"true\">\n                        <path d=\"M2.01 21L23 12 2.01 3 2 10l15 2-15 2z\" />\n                      </svg>\n                    )}\n                  </button>\n                </div>\n              </div>\n              {!isLoggedIn && !guestEmail.trim() && (\n                <p className=\"text-[11px] text-gray-500\">Add your email to start the chat.</p>\n              )}\n            </div>\n          )}\n        </div>\n      )}\n    </div>\n  )\n}\n","truncated":false,"size":28783},{"path":"components/UsageMeter.tsx","content":"'use client'\nimport { useEffect, useState } from 'react'\nimport { useSession } from 'next-auth/react'\nimport Link from 'next/link'\n\ninterface UsageMeterProps {\n  compact?: boolean // Compact version for headers\n  showResetDate?: boolean // Show reset date below meter\n  inline?: boolean // Inline version next to typical cost (reverse mode)\n  className?: string // Additional CSS classes\n  refreshTrigger?: number // When this changes, force a refresh\n  feature?: string // Optional feature tag for server call tracking\n}\n\ntype CreditStatusCacheEntry = {\n  data?: any\n  inFlight?: Promise<any>\n  fetchedAt?: number\n}\n\nconst creditStatusCache: Record<string, CreditStatusCacheEntry> = {}\nconst CREDIT_STATUS_TTL_MS = 2000\n\nasync function fetchCreditStatus(feature?: string, forceRefresh?: boolean): Promise<any | null> {\n  const key = feature || 'all'\n  const now = Date.now()\n  const cached = creditStatusCache[key]\n  if (!forceRefresh && cached?.data && cached.fetchedAt && now - cached.fetchedAt < CREDIT_STATUS_TTL_MS) {\n    return cached.data\n  }\n  if (cached?.inFlight) {\n    return cached.inFlight\n  }\n  const featureParam = feature ? `feature=${encodeURIComponent(feature)}` : ''\n  const queryString = featureParam ? `?${featureParam}` : ''\n  const request = fetch(`/api/credit/status${queryString}`, {\n    cache: 'no-store',\n    headers: {\n      'Cache-Control': 'no-cache, no-store, must-revalidate',\n      'Pragma': 'no-cache',\n      'Expires': '0'\n    }\n  })\n    .then(async (res) => {\n      if (!res.ok) return null\n      return await res.json()\n    })\n    .catch(() => null)\n\n  creditStatusCache[key] = { ...cached, inFlight: request }\n  const data = await request\n  creditStatusCache[key] = { data: data ?? cached?.data, fetchedAt: Date.now() }\n  return data\n}\n\nexport default function UsageMeter({ compact = false, showResetDate = false, inline = false, className = '', refreshTrigger = 0, feature }: UsageMeterProps) {\n  const { data: session } = useSession()\n  const [walletPercentUsed, setWalletPercentUsed] = useState<number | null>(null)\n  const [walletRefreshAt, setWalletRefreshAt] = useState<string | null>(null)\n  const [loading, setLoading] = useState(true)\n  const [hasAccess, setHasAccess] = useState(false)\n  const [totalAvailableCents, setTotalAvailableCents] = useState<number>(0)\n  const [monthlyUsedCents, setMonthlyUsedCents] = useState<number>(0)\n  const [monthlyCapCents, setMonthlyCapCents] = useState<number>(0)\n  // Credits (credits == cents) - numeric remaining for display\n  const [creditsTotal, setCreditsTotal] = useState<number | null>(null)\n  const [creditsDailyRemaining, setCreditsDailyRemaining] = useState<number | null>(null)\n  const [creditsAdditionalRemaining, setCreditsAdditionalRemaining] = useState<number | null>(null)\n  const [creditData, setCreditData] = useState<any>(null) // Store full API response for free credits check\n  // Listen for global refresh events so sidebar meter updates immediately after charges\n  const [eventTick, setEventTick] = useState(0)\n  useEffect(() => {\n    const handler = () => setEventTick((v) => v + 1)\n    try {\n      window.addEventListener('credits:refresh', handler)\n      return () => window.removeEventListener('credits:refresh', handler)\n    } catch {\n      // SSR/no-window safe\n      return () => {}\n    }\n  }, [])\n\n  useEffect(() => {\n    const loadStatus = async () => {\n      if (!session?.user) {\n        setLoading(false)\n        return\n      }\n      try {\n        const forceRefresh = Boolean((refreshTrigger || 0) > 0 || eventTick > 0)\n        const data = await fetchCreditStatus(feature, forceRefresh)\n        if (data) {\n          // Treat any successful status response for a logged‚Äëin user as\n          // sufficient to show the meter. Billing enforcement lives in the\n          // analyzer APIs; this meter is purely a visibility/UX layer.\n          setHasAccess(true)\n\n          if (typeof data.percentUsed === 'number') {\n            setWalletPercentUsed(data.percentUsed)\n          }\n          if (data.refreshAt) {\n            setWalletRefreshAt(data.refreshAt)\n          }\n          if (typeof data.totalAvailableCents === 'number') {\n            setTotalAvailableCents(data.totalAvailableCents)\n          }\n          if (typeof data.monthlyUsedCents === 'number') {\n            setMonthlyUsedCents(data.monthlyUsedCents)\n          }\n          if (typeof data.monthlyCapCents === 'number') {\n            setMonthlyCapCents(data.monthlyCapCents)\n          }\n          if (data.credits) {\n            if (typeof data.credits.total === 'number') setCreditsTotal(data.credits.total)\n            if (typeof data.credits.dailyRemaining === 'number') setCreditsDailyRemaining(data.credits.dailyRemaining)\n            if (typeof data.credits.additionalRemaining === 'number') setCreditsAdditionalRemaining(data.credits.additionalRemaining)\n          }\n          // Store full data for free credits check\n          setCreditData(data)\n        } else {\n          setHasAccess(false)\n        }\n      } catch {\n        // ignore errors\n      } finally {\n        setLoading(false)\n      }\n    }\n    loadStatus()\n    \n    return () => {}\n  }, [session, refreshTrigger, eventTick]) // include eventTick for global refresh\n\n  // Don't render if not authenticated, still loading, or no access\n  if (!session || loading || !hasAccess) {\n    return null\n  }\n\n  // Credits (credits == cents) must reflect the sum of:\n  // - subscription remaining\n  // - active top-ups\n  // - non-expiring additional credits (admin grants)\n  const creditsRemaining = creditsTotal ?? Math.round(totalAvailableCents)\n\n  // Get free credits status from API response\n  const exhaustedFreeCredits = creditData?.exhaustedFreeCredits ?? false\n  const freeCreditsTotal = creditData?.freeCredits?.total ?? 0\n  const isPremiumPlan = creditData?.plan === 'PREMIUM' || monthlyCapCents > 0\n  const hasPaidCredits = totalAvailableCents > 0 || (creditsAdditionalRemaining ?? 0) > 0\n  const showFreeCredits = !isPremiumPlan && !hasPaidCredits && freeCreditsTotal > 0 && !exhaustedFreeCredits\n\n  const freeCreditsBaseline = Math.max(15, freeCreditsTotal)\n  const effectiveCreditsRemaining = showFreeCredits ? freeCreditsTotal : creditsRemaining\n\n  // We anchor percent remaining to the subscription cap when present, but never allow\n  // additional credits to incorrectly trigger \"low credits\" UI.\n  const percentRemainingPrecise =\n    showFreeCredits\n      ? (effectiveCreditsRemaining / Math.max(1, freeCreditsBaseline)) * 100\n      : monthlyCapCents > 0\n      ? (creditsRemaining / Math.max(1, monthlyCapCents)) * 100\n      : creditsRemaining > 0\n      ? 100\n      : 0\n  const clampedRemaining = Math.min(100, Math.max(0, percentRemainingPrecise))\n  // Inline variant shows 0.1% precision so each analysis visibly reduces the meter.\n  const displayPercentRemainingInline = Number(clampedRemaining.toFixed(1))\n  const displayPercentRemaining = Math.round(clampedRemaining)\n\n  // Low credits: show red when remaining is genuinely low.\n  // BUT: Only show warning if free credits are exhausted AND wallet credits are low\n  const lowCreditsThreshold = Math.max(5, Math.ceil(monthlyCapCents > 0 ? monthlyCapCents * 0.05 : 0))\n  const isLowCredits = effectiveCreditsRemaining <= lowCreditsThreshold && exhaustedFreeCredits\n\n  if (inline) {\n    // Inline version for AI feature pages - credits remaining with green bar (reverse fill)\n    const creditsDisplayInline = effectiveCreditsRemaining\n    const creditsRemainingPercent = displayPercentRemainingInline\n    \n    return (\n      <div className={`mt-2 ${className}`}>\n        <div className=\"flex items-center justify-between mb-1.5\">\n          <span className=\"text-xs text-gray-500\">\n            {showFreeCredits ? 'Free uses remaining' : 'Credits remaining'}\n          </span>\n          <span className={`text-xs font-semibold ${isLowCredits ? 'text-red-600' : 'text-gray-700'}`}>\n            {creditsDisplayInline?.toLocaleString()}\n          </span>\n        </div>\n        {showFreeCredits && (\n          <div className=\"mb-2 text-xs text-green-600 font-medium\">\n            {freeCreditsTotal} free credit{freeCreditsTotal !== 1 ? 's' : ''} remaining\n          </div>\n        )}\n        <div className=\"w-full bg-gray-200 rounded-full h-2 overflow-hidden relative\">\n          {/* Background bar - shows remaining (green) */}\n          <div\n            className={`h-2 transition-all duration-300 ${\n              isLowCredits ? 'bg-red-500' : 'bg-helfi-green'\n            }`}\n            style={{ width: `${Math.min(100, Math.max(0, creditsRemainingPercent))}%` }}\n          />\n        </div>\n        {/* Only show warning if free credits are exhausted AND wallet credits are low */}\n        {creditsDisplayInline !== null && creditsDisplayInline <= 5 && exhaustedFreeCredits && (\n          <div className=\"mt-2 bg-red-50 border border-red-200 rounded-lg p-2\">\n            <p className=\"text-xs text-red-800 font-medium mb-1\">‚ö†Ô∏è Low Credits Warning</p>\n            <p className=\"text-xs text-red-700 mb-2\">\n              You're running low on credits ({creditsDisplayInline.toLocaleString()} remaining). \n              Purchase more credits or upgrade your subscription to continue using AI features.\n            </p>\n            <div className=\"flex gap-2\">\n              <Link\n                href=\"/billing\"\n                className=\"flex-1 text-center text-xs font-medium text-red-800 bg-white border border-red-300 rounded px-2 py-1.5 hover:bg-red-50 transition-colors\"\n              >\n                Upgrade Plan\n              </Link>\n              <Link\n                href=\"/billing\"\n                className=\"flex-1 text-center text-xs font-medium text-white bg-red-600 rounded px-2 py-1.5 hover:bg-red-700 transition-colors\"\n              >\n                Buy Credits\n              </Link>\n            </div>\n          </div>\n        )}\n      </div>\n    )\n  }\n\n  if (compact) {\n    // Compact version for headers - credits remaining with green bar (reverse fill)\n    const creditsDisplay = effectiveCreditsRemaining\n    const creditsRemainingPercent = displayPercentRemaining\n    \n    return (\n      <div className={`flex items-center gap-2 ${className}`}>\n        <div className=\"w-24 bg-gray-200 rounded-full h-2 overflow-hidden\">\n          <div\n            className={`h-2 transition-all duration-300 ${\n              isLowCredits ? 'bg-red-500' : 'bg-helfi-green'\n            }`}\n            style={{ width: `${Math.min(100, Math.max(0, creditsRemainingPercent))}%` }}\n          />\n        </div>\n        <span className=\"text-xs font-medium text-gray-600 dark:text-gray-400\">\n          {showFreeCredits ? 'Free uses remaining' : 'Credits remaining'}\n        </span>\n        <span className=\"text-sm font-semibold text-gray-900 dark:text-white\">\n          {creditsDisplay?.toLocaleString()}\n        </span>\n      </div>\n    )\n  }\n\n  // Full version for sidebar - credits remaining with green bar (reverse fill)\n  const creditsDisplay = effectiveCreditsRemaining\n  const creditsRemainingPercent = displayPercentRemaining\n  \n  return (\n    <div className={`px-4 py-3 ${className}`}>\n      <div className=\"flex items-center justify-between mb-2\">\n        <span className=\"text-xs font-medium text-white\">\n          {showFreeCredits ? 'Free uses remaining' : 'Credits remaining'}\n        </span>\n        <span className=\"text-xs font-semibold text-white\">\n          {creditsDisplay?.toLocaleString()}\n        </span>\n      </div>\n      <div className=\"w-full bg-gray-200 rounded-full h-2 overflow-hidden mb-2\">\n        <div\n          className={`h-2 transition-all duration-300 ${\n            isLowCredits ? 'bg-red-500' : 'bg-helfi-green'\n          }`}\n          style={{ width: `${Math.min(100, Math.max(0, creditsRemainingPercent))}%` }}\n        />\n      </div>\n      {showFreeCredits && (\n        <p className=\"text-xs text-gray-200 mt-1.5\">\n          {freeCreditsTotal} free use{freeCreditsTotal !== 1 ? 's' : ''} left\n        </p>\n      )}\n      {showResetDate && walletRefreshAt && !showFreeCredits && (\n        <p className=\"text-xs text-gray-200 mt-1.5\">\n          Resets {new Date(walletRefreshAt).toLocaleDateString()}\n        </p>\n      )}\n    </div>\n  )\n}\n","truncated":false,"size":12207},{"path":"components/VoiceChat.tsx","content":"'use client'\n\nimport { FormEvent, KeyboardEvent, useEffect, useMemo, useRef, useState, useCallback } from 'react'\nimport { formatChatContent } from '@/lib/chatFormatting'\n\ninterface VoiceChatContext {\n  symptoms?: string[]\n  duration?: string\n  notes?: string\n  analysisResult?: any\n  issueSlug?: string\n  section?: string\n  // Optional: summary of a specific health tip to keep the AI focused on that advice\n  healthTipSummary?: string\n  healthTipTitle?: string\n  healthTipCategory?: string\n  healthTipSuggestedQuestions?: string[]\n}\n\ninterface VoiceChatProps {\n  context?: VoiceChatContext\n  onCostEstimate?: (cost: number) => void\n  className?: string\n}\n\ntype ChatMessage = { role: 'user' | 'assistant'; content: string }\ntype ChatThread = { id: string; title: string | null; createdAt: string; updatedAt: string }\n\nexport default function VoiceChat({ context, onCostEstimate, className = '' }: VoiceChatProps) {\n  const [messages, setMessages] = useState<ChatMessage[]>([])\n  const [input, setInput] = useState('')\n  const [loading, setLoading] = useState(false)\n  const [error, setError] = useState<string | null>(null)\n  const [isListening, setIsListening] = useState(false)\n  const [estimatedCost, setEstimatedCost] = useState<number | null>(null)\n  const [hasSpeechRecognition, setHasSpeechRecognition] = useState(false)\n  const [threads, setThreads] = useState<ChatThread[]>([])\n  const [currentThreadId, setCurrentThreadId] = useState<string | null>(null)\n  const [showThreadMenu, setShowThreadMenu] = useState(false)\n  const storageKey = useMemo(() => 'helfi:chat:talk', [])\n  const hasHealthTipContext = !!context?.healthTipSummary\n  const healthTipTitle = context?.healthTipTitle\n  const healthTipCategory = context?.healthTipCategory\n  const healthTipSuggestedQuestions = context?.healthTipSuggestedQuestions\n\n  const healthTipSuggestionQuestions = useMemo(() => {\n    if (!hasHealthTipContext) return []\n\n    // Prefer AI-generated, tip-specific suggestions when available\n    if (Array.isArray(healthTipSuggestedQuestions) && healthTipSuggestedQuestions.length > 0) {\n      return healthTipSuggestedQuestions\n        .filter((q) => typeof q === 'string' && q.trim().length > 0)\n        .slice(0, 3)\n    }\n\n    // Fallback: template questions tied to the tip title + category\n    const titleSnippet = healthTipTitle || 'this tip'\n    const typeLabel =\n      healthTipCategory === 'supplement'\n        ? 'supplement tip'\n        : healthTipCategory === 'lifestyle'\n        ? 'lifestyle tip'\n        : 'food tip'\n    return [\n      `Can you explain how the \"${titleSnippet}\" ${typeLabel} fits with my current health issues?`,\n      `Are there any safety concerns, interactions, or situations where I should avoid following this \"${titleSnippet}\" tip?`,\n      `How could I adapt the \"${titleSnippet}\" tip to better fit my daily routine and preferences?`,\n    ]\n  }, [hasHealthTipContext, healthTipTitle, healthTipCategory, healthTipSuggestedQuestions])\n  \n  const endRef = useRef<HTMLDivElement | null>(null)\n  const containerRef = useRef<HTMLDivElement | null>(null)\n  const textareaRef = useRef<HTMLTextAreaElement | null>(null)\n  const recognitionRef = useRef<any>(null)\n  const resizeTimeoutRef = useRef<NodeJS.Timeout | null>(null)\n\n  // Debounced resize function to prevent pulsating\n  const resizeTextarea = useCallback(() => {\n    if (resizeTimeoutRef.current) {\n      clearTimeout(resizeTimeoutRef.current)\n    }\n    resizeTimeoutRef.current = setTimeout(() => {\n      const textarea = textareaRef.current\n      if (!textarea) return\n      textarea.style.height = 'auto'\n      const maxHeight = 200\n      const newHeight = Math.min(textarea.scrollHeight, maxHeight)\n      textarea.style.height = `${newHeight}px`\n      textarea.style.overflowY = textarea.scrollHeight > maxHeight ? 'auto' : 'hidden'\n    }, 50) // Debounce resize by 50ms\n  }, [])\n\n  // Load threads and current thread on mount\n  useEffect(() => {\n    async function loadThreads() {\n      try {\n        const res = await fetch('/api/chat/threads')\n        if (res.ok) {\n          const data = await res.json()\n          if (data.threads && Array.isArray(data.threads)) {\n            setThreads(data.threads)\n            if (data.threads.length > 0 && !currentThreadId) {\n              // Load most recent thread\n              const threadId = data.threads[0].id\n              setCurrentThreadId(threadId)\n              loadThreadMessages(threadId)\n            }\n          }\n        }\n      } catch (err) {\n        console.error('Failed to load threads:', err)\n      }\n    }\n    loadThreads()\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [])\n\n  async function loadThreadMessages(threadId: string) {\n    try {\n      const res = await fetch(`/api/chat/voice?threadId=${threadId}`)\n      if (res.ok) {\n        const data = await res.json()\n        if (data.messages && Array.isArray(data.messages)) {\n          setMessages(data.messages.map((m: any) => ({ role: m.role, content: m.content })))\n        }\n      }\n    } catch (err) {\n      console.error('Failed to load thread messages:', err)\n    }\n  }\n\n  async function handleNewChat() {\n    try {\n      const res = await fetch('/api/chat/threads', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({}),\n      })\n      if (res.ok) {\n        const data = await res.json()\n        const newThreadId = data.threadId\n        setCurrentThreadId(newThreadId)\n        setMessages([])\n        // Reload threads\n        const threadsRes = await fetch('/api/chat/threads')\n        if (threadsRes.ok) {\n          const threadsData = await threadsRes.json()\n          if (threadsData.threads) setThreads(threadsData.threads)\n        }\n      }\n    } catch (err) {\n      console.error('Failed to create new thread:', err)\n    }\n  }\n\n  async function handleDeleteThread(threadId: string) {\n    if (!confirm('Delete this chat?')) return\n    try {\n      const res = await fetch('/api/chat/threads', {\n        method: 'DELETE',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ threadId }),\n      })\n      if (res.ok) {\n        // Reload threads\n        const threadsRes = await fetch('/api/chat/threads')\n        if (threadsRes.ok) {\n          const threadsData = await threadsRes.json()\n          if (threadsData.threads) {\n            setThreads(threadsData.threads)\n            if (threadsData.threads.length > 0) {\n              const newThreadId = threadsData.threads[0].id\n              setCurrentThreadId(newThreadId)\n              loadThreadMessages(newThreadId)\n            } else {\n              setCurrentThreadId(null)\n              setMessages([])\n            }\n          }\n        }\n      }\n    } catch (err) {\n      console.error('Failed to delete thread:', err)\n    }\n  }\n\n  // Load saved conversation on mount\n  useEffect(() => {\n    // Only load from localStorage if no thread is loaded from server\n    if (currentThreadId) return\n    try {\n      const saved = typeof window !== 'undefined' ? localStorage.getItem(storageKey) : null\n      if (saved) {\n        const parsed = JSON.parse(saved)\n        if (Array.isArray(parsed)) {\n          setMessages(parsed.filter((m) => m && typeof m.content === 'string' && (m.role === 'user' || m.role === 'assistant')).slice(-50))\n        }\n      }\n    } catch {}\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [currentThreadId])\n\n  // Initialize speech recognition\n  useEffect(() => {\n    if (typeof window === 'undefined') return\n\n    // Check for speech recognition support immediately\n    const SpeechRecognition = (window as any).SpeechRecognition || (window as any).webkitSpeechRecognition\n    if (SpeechRecognition) {\n      setHasSpeechRecognition(true)\n    } else {\n      return\n    }\n\n    const recognition = new SpeechRecognition()\n    recognition.continuous = true\n    recognition.interimResults = true\n    recognition.lang = 'en-US'\n\n    let finalTranscript = ''\n\n    recognition.onstart = () => {\n      setIsListening(true)\n      finalTranscript = ''\n    }\n\n    recognition.onresult = (event: any) => {\n      let interimTranscript = ''\n      \n      for (let i = event.resultIndex; i < event.results.length; i++) {\n        const transcript = event.results[i][0].transcript\n        if (event.results[i].isFinal) {\n          finalTranscript += transcript + ' '\n        } else {\n          interimTranscript += transcript\n        }\n      }\n      \n      // Update input with both final and interim results\n      setInput(finalTranscript + interimTranscript)\n    }\n\n    recognition.onerror = (event: any) => {\n      console.error('Speech recognition error:', event.error)\n      setIsListening(false)\n      if (event.error === 'not-allowed') {\n        setError('Microphone permission denied. Please enable microphone access.')\n      } else if (event.error !== 'no-speech') {\n        setError('Speech recognition error. Please try again.')\n      }\n    }\n\n    recognition.onend = () => {\n      setIsListening(false)\n      // Only set final transcript if we have one\n      if (finalTranscript.trim()) {\n        setInput(finalTranscript.trim())\n      }\n    }\n\n    recognitionRef.current = recognition\n\n    return () => {\n      if (recognitionRef.current) {\n        recognitionRef.current.stop()\n      }\n    }\n  }, [])\n\n  // Auto-scroll\n  useEffect(() => {\n    const container = containerRef.current\n    if (!container) return\n    container.scrollTop = container.scrollHeight\n  }, [messages, loading])\n\n  // Auto-resize textarea with debounce\n  useEffect(() => {\n    resizeTextarea()\n  }, [input, resizeTextarea])\n\n  function onComposerKeyDown(event: KeyboardEvent<HTMLTextAreaElement>) {\n    if (event.key === 'Enter' && !event.shiftKey) {\n      event.preventDefault()\n      const form = (event.target as HTMLTextAreaElement).closest('form') as HTMLFormElement | null\n      form?.requestSubmit()\n    }\n  }\n\n  function startListening() {\n    if (!recognitionRef.current || isListening) return\n    try {\n      recognitionRef.current.start()\n    } catch (err) {\n      console.error('Failed to start recognition:', err)\n      setError('Failed to start voice recognition')\n    }\n  }\n\n  function stopListening() {\n    if (recognitionRef.current && isListening) {\n      recognitionRef.current.stop()\n      setIsListening(false)\n    }\n  }\n\n\n  async function handleSubmit(event: FormEvent<HTMLFormElement>) {\n    event.preventDefault()\n    const text = input.trim()\n    if (!text) {\n      setError('Enter a question or use voice input.')\n      return\n    }\n\n    try {\n      setLoading(true)\n      setError(null)\n      stopListening()\n      \n      const nextMessages: ChatMessage[] = [...messages, { role: 'user', content: text }]\n      setMessages(nextMessages)\n      setInput('')\n\n      // Estimate cost before sending\n      const estimateRes = await fetch('/api/chat/voice', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ message: text, estimateOnly: true }),\n      })\n      \n      if (estimateRes.status === 402) {\n        const estimateData = await estimateRes.json()\n        setError(`Insufficient credits. Estimated cost: ${(estimateData.estimatedCost / 100).toFixed(2)} credits. Available: ${(estimateData.availableCredits / 100).toFixed(2)} credits.`)\n        setLoading(false)\n        return\n      }\n      \n      if (estimateRes.ok) {\n        const estimateData = await estimateRes.json()\n        const cost = estimateData.estimatedCost || 0\n        setEstimatedCost(cost)\n        if (onCostEstimate) {\n          onCostEstimate(cost)\n        }\n      }\n\n      const url = `/api/chat/voice`\n      const res = await fetch(url, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json', Accept: 'text/event-stream' },\n        body: JSON.stringify({ \n          message: text, \n          threadId: currentThreadId || undefined,\n          newThread: false, // Never create a new thread automatically - user must click \"+ New Chat\"\n          ...context \n        }),\n      })\n\n      if (res.status === 402) {\n        const data = await res.json()\n        setError(`Insufficient credits. Estimated cost: ${(data.estimatedCost / 100).toFixed(2)} credits. Available: ${(data.availableCredits / 100).toFixed(2)} credits.`)\n        setLoading(false)\n        return\n      }\n\n      if (res.ok && (res.headers.get('content-type') || '').includes('text/event-stream') && res.body) {\n        const reader = res.body.getReader()\n        const decoder = new TextDecoder()\n        let buffer = ''\n        let hasAssistant = false\n        let fullResponse = ''\n        \n        while (true) {\n          const { value, done } = await reader.read()\n          if (done) break\n          buffer += decoder.decode(value, { stream: true })\n          const parts = buffer.split('\\n\\n')\n          buffer = parts.pop() || ''\n          for (const chunk of parts) {\n            if (chunk.startsWith('data: ')) {\n              const raw = chunk.slice(6).trim()\n              let token = ''\n              // Prefer JSON payloads to preserve newlines; fall back to raw\n              try {\n                const parsed = JSON.parse(raw)\n                if (typeof parsed === 'string') {\n                  token = parsed\n                } else if (parsed && typeof parsed.token === 'string') {\n                  token = parsed.token\n                } else {\n                  token = raw\n                }\n              } catch {\n                token = raw\n              }\n              fullResponse += token\n              if (!hasAssistant) {\n                setMessages((prev) => [...prev, { role: 'assistant', content: token }])\n                hasAssistant = true\n              } else {\n                setMessages((prev) => {\n                  const copy = prev.slice()\n                  copy[copy.length - 1] = { role: 'assistant', content: (copy[copy.length - 1] as any).content + token }\n                  return copy\n                })\n              }\n            } else if (chunk.startsWith('event: end')) {\n              // Response complete - reload threads to get updated title\n              const threadsRes = await fetch('/api/chat/threads')\n              if (threadsRes.ok) {\n                const threadsData = await threadsRes.json()\n                if (threadsData.threads) {\n                  setThreads(threadsData.threads)\n                  // Update currentThreadId if we created a new thread\n                  if (!currentThreadId && threadsData.threads.length > 0) {\n                    setCurrentThreadId(threadsData.threads[0].id)\n                  }\n                }\n              }\n            }\n          }\n        }\n      } else {\n        const data = await res.json().catch(() => null)\n        const textOut = data?.assistant as string | undefined\n        if (textOut) {\n          setMessages((prev) => [...prev, { role: 'assistant', content: textOut }])\n        }\n      }\n    } catch (err: any) {\n      setError(err.message || 'Something went wrong')\n    } finally {\n      setLoading(false)\n    }\n  }\n\n  async function handleClear() {\n    try {\n      setLoading(true)\n      setError(null)\n      setMessages([])\n      stopListening()\n      try { localStorage.removeItem(storageKey) } catch {}\n    } catch (err) {\n      setError((err as Error).message)\n    } finally {\n      setLoading(false)\n    }\n  }\n\n  return (\n    <div className={`flex flex-col h-full ${className}`}>\n      {/* Thread Selector Header */}\n      <div className=\"border-b border-gray-200 bg-white px-4 py-2 flex items-center justify-between relative\">\n        <div className=\"flex items-center gap-2 flex-1 min-w-0\">\n          <button\n            type=\"button\"\n            onClick={() => setShowThreadMenu(!showThreadMenu)}\n            className=\"flex items-center gap-2 px-3 py-1.5 rounded-lg hover:bg-gray-100 transition-colors min-w-0 flex-1\"\n          >\n            <span className=\"truncate text-sm font-medium text-gray-700\">\n              {currentThreadId ? threads.find(t => t.id === currentThreadId)?.title || 'New Chat' : 'New Chat'}\n            </span>\n            <svg className=\"w-4 h-4 text-gray-500 flex-shrink-0\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M19 9l-7 7-7-7\" />\n            </svg>\n          </button>\n          {showThreadMenu && (\n            <div className=\"absolute left-4 top-12 bg-white border border-gray-200 rounded-lg shadow-lg z-50 max-h-96 overflow-y-auto min-w-[200px]\">\n              <button\n                type=\"button\"\n                onClick={() => {\n                  handleNewChat()\n                  setShowThreadMenu(false)\n                }}\n                className=\"w-full px-4 py-2 text-left text-sm hover:bg-gray-100 border-b border-gray-100\"\n              >\n                + New Chat\n              </button>\n              {threads.map((thread) => (\n                <div key={thread.id} className=\"flex items-center group\">\n                  <button\n                    type=\"button\"\n                    onClick={() => {\n                      setCurrentThreadId(thread.id)\n                      loadThreadMessages(thread.id)\n                      setShowThreadMenu(false)\n                    }}\n                    className={`flex-1 px-4 py-2 text-left text-sm hover:bg-gray-100 truncate ${\n                      currentThreadId === thread.id ? 'bg-gray-50' : ''\n                    }`}\n                  >\n                    {thread.title || 'New Chat'}\n                  </button>\n                  <button\n                    type=\"button\"\n                    onClick={() => handleDeleteThread(thread.id)}\n                    className=\"px-2 py-2 text-gray-400 hover:text-red-600 opacity-0 group-hover:opacity-100 transition-opacity\"\n                  >\n                    <svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                      <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16\" />\n                    </svg>\n                  </button>\n                </div>\n              ))}\n            </div>\n          )}\n        </div>\n        <button\n          type=\"button\"\n          onClick={handleNewChat}\n          className=\"px-3 py-1.5 text-sm text-gray-700 hover:bg-gray-100 rounded-lg transition-colors\"\n        >\n          + New\n        </button>\n      </div>\n      {/* Messages Area - ChatGPT style */}\n      <div ref={containerRef} className=\"flex-1 overflow-y-auto overflow-x-hidden px-4 py-6 space-y-6 min-w-0\" aria-live=\"polite\" style={{ maxWidth: '100%', wordWrap: 'break-word' }}>\n        {messages.length === 0 && !loading && (\n          <div className=\"max-w-3xl mx-auto\">\n            {hasHealthTipContext ? (\n              <>\n                <div className=\"text-center mb-6\">\n                  <h2 className=\"text-lg font-semibold text-gray-900\">\n                    Questions about this tip\n                  </h2>\n                  {healthTipTitle && (\n                    <p className=\"mt-1 text-sm text-gray-600 line-clamp-2\">\n                      ‚Äú{healthTipTitle}‚Äù\n                    </p>\n                  )}\n                </div>\n                <div className=\"grid grid-cols-1 md:grid-cols-2 gap-3\">\n                  {healthTipSuggestionQuestions.map((q) => (\n                    <button\n                      key={q}\n                      onClick={() => setInput(q)}\n                      className=\"text-left px-4 py-3 bg-gray-50 hover:bg-gray-100 rounded-xl text-sm text-gray-700 transition-colors\"\n                      type=\"button\"\n                    >\n                      {q}\n                    </button>\n                  ))}\n                </div>\n              </>\n            ) : (\n              <>\n                <div className=\"text-center mb-8\">\n                  <h2 className=\"text-2xl font-semibold text-gray-900 mb-2\">\n                    How can I help you today?\n                  </h2>\n                </div>\n                <div className=\"grid grid-cols-1 md:grid-cols-2 gap-3\">\n                  {[\n                    'What supplements should I take?',\n                    'How are my medications interacting?',\n                    'Why am I feeling tired?',\n                    'What should I eat today?',\n                  ].map((q) => (\n                    <button\n                      key={q}\n                      onClick={() => setInput(q)}\n                      className=\"text-left px-4 py-3 bg-gray-50 hover:bg-gray-100 rounded-xl text-sm text-gray-700 transition-colors\"\n                      type=\"button\"\n                    >\n                      {q}\n                    </button>\n                  ))}\n                </div>\n              </>\n            )}\n          </div>\n        )}\n        {messages.map((m, idx) => (\n          <div key={idx} className={`flex gap-4 max-w-3xl mx-auto ${m.role === 'user' ? 'flex-row-reverse' : ''}`}>\n            <div className=\"flex-shrink-0 w-8 h-8 rounded-full bg-gray-200 flex items-center justify-center\">\n              {m.role === 'user' ? (\n                <svg className=\"w-5 h-5 text-gray-600\" fill=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path d=\"M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z\"/>\n                </svg>\n              ) : (\n                <svg className=\"w-5 h-5 text-gray-600\" fill=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path d=\"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z\"/>\n                </svg>\n              )}\n            </div>\n            <div className={`flex-1 min-w-0 ${m.role === 'user' ? 'text-right' : ''}`}>\n              <div className={`inline-block max-w-full px-4 py-2.5 rounded-2xl ${\n                m.role === 'user' \n                  ? 'bg-gray-900 text-white' \n                  : 'bg-gray-100 text-gray-900'\n              }`} style={{ wordWrap: 'break-word', overflowWrap: 'break-word' }}>\n                <div className=\"text-lg leading-relaxed break-words\">\n                  {(() => {\n                    const formatted = formatChatContent(m.content)\n                    // Split by double newlines first to get paragraphs\n                    const paragraphs = formatted.split(/\\n\\n+/)\n                    return paragraphs.map((para, paraIdx) => {\n                      const trimmed = para.trim()\n                      if (!trimmed) return null\n                      \n                      // Split paragraph into lines\n                      const lines = trimmed.split('\\n')\n                      \n                      return (\n                        <div key={paraIdx} className={paraIdx > 0 ? 'mt-4' : ''}>\n                          {lines.map((line, lineIdx) => {\n                            const lineTrimmed = line.trim()\n                            if (!lineTrimmed) return <div key={lineIdx} className=\"h-2\" />\n                            \n                            // Check for bold heading (entire line is bold)\n                            if (lineTrimmed.startsWith('**') && lineTrimmed.endsWith('**') && lineTrimmed.length > 4) {\n                              return (\n                                <div key={lineIdx} className=\"font-bold text-gray-900 mb-2 mt-3 first:mt-0\">\n                                  {lineTrimmed.slice(2, -2)}\n                                </div>\n                              )\n                            }\n                            \n                            // Check for numbered list\n                            const numberedMatch = lineTrimmed.match(/^(\\d+)\\.\\s+(.+)$/)\n                            if (numberedMatch) {\n                              const parts = numberedMatch[2].split(/(\\*\\*.*?\\*\\*)/g)\n                              return (\n                                <div key={lineIdx} className=\"ml-4 mb-1.5\">\n                                  <span className=\"font-medium\">{numberedMatch[1]}.</span>{' '}\n                                  {parts.map((part, j) => {\n                                    if (part.startsWith('**') && part.endsWith('**')) {\n                                      return <strong key={j} className=\"font-semibold\">{part.slice(2, -2)}</strong>\n                                    }\n                                    return <span key={j}>{part}</span>\n                                  })}\n                                </div>\n                              )\n                            }\n                            \n                            // Check for bullet point\n                            const bulletMatch = lineTrimmed.match(/^[-‚Ä¢*]\\s+(.+)$/)\n                            if (bulletMatch) {\n                              const parts = bulletMatch[1].split(/(\\*\\*.*?\\*\\*)/g)\n                              return (\n                                <div key={lineIdx} className=\"ml-4 mb-1.5\">\n                                  <span className=\"mr-2\">‚Ä¢</span>\n                                  {parts.map((part, j) => {\n                                    if (part.startsWith('**') && part.endsWith('**')) {\n                                      return <strong key={j} className=\"font-semibold\">{part.slice(2, -2)}</strong>\n                                    }\n                                    return <span key={j}>{part}</span>\n                                  })}\n                                </div>\n                              )\n                            }\n                            \n                            // Regular paragraph line - parse inline bold\n                            const parts = lineTrimmed.split(/(\\*\\*.*?\\*\\*)/g)\n                            return (\n                              <div key={lineIdx} className={lineIdx > 0 ? 'mt-2' : ''}>\n                                {parts.map((part, j) => {\n                                  if (part.startsWith('**') && part.endsWith('**')) {\n                                    return <strong key={j} className=\"font-semibold\">{part.slice(2, -2)}</strong>\n                                  }\n                                  return <span key={j}>{part}</span>\n                                })}\n                              </div>\n                            )\n                          })}\n                        </div>\n                      )\n                    })\n                  })()}\n                </div>\n              </div>\n            </div>\n          </div>\n        ))}\n        {loading && (\n          <div className=\"flex gap-4 max-w-3xl mx-auto\">\n            <div className=\"flex-shrink-0 w-8 h-8 rounded-full bg-gray-200 flex items-center justify-center\">\n              <svg className=\"w-5 h-5 text-gray-600\" fill=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path d=\"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z\"/>\n              </svg>\n            </div>\n            <div className=\"flex-1\">\n              <div className=\"inline-block px-4 py-2.5 rounded-2xl bg-gray-100\">\n                <div className=\"flex gap-1\">\n                  <span className=\"w-2 h-2 bg-gray-400 rounded-full animate-bounce\" style={{ animationDelay: '0ms' }}></span>\n                  <span className=\"w-2 h-2 bg-gray-400 rounded-full animate-bounce\" style={{ animationDelay: '150ms' }}></span>\n                  <span className=\"w-2 h-2 bg-gray-400 rounded-full animate-bounce\" style={{ animationDelay: '300ms' }}></span>\n                </div>\n              </div>\n            </div>\n          </div>\n        )}\n        <div ref={endRef} />\n      </div>\n\n      {/* Input Area - ChatGPT style */}\n      <div className=\"border-t border-gray-200 bg-white\">\n        {error && (\n          <div className=\"px-4 py-2 text-sm text-red-600 bg-red-50\">{error}</div>\n        )}\n        <form className=\"px-4 py-3\" onSubmit={handleSubmit}>\n          <div className=\"max-w-3xl mx-auto flex items-center gap-2\">\n            {messages.length > 0 && (\n              <button\n                type=\"button\"\n                onClick={handleClear}\n                disabled={loading}\n                className=\"px-3 h-10 rounded-full text-sm text-gray-600 bg-gray-100 hover:bg-gray-200 transition-colors\"\n                aria-label=\"Clear chat\"\n              >\n                Reset\n              </button>\n            )}\n            {hasSpeechRecognition && (\n              <button\n                type=\"button\"\n                onClick={isListening ? stopListening : startListening}\n                disabled={loading}\n                className={`flex-shrink-0 w-10 h-10 rounded-full flex items-center justify-center transition-colors ${\n                  isListening\n                    ? 'bg-red-500 text-white'\n                    : 'bg-gray-100 text-gray-600 hover:bg-gray-200'\n                } disabled:opacity-50 disabled:cursor-not-allowed`}\n                aria-label={isListening ? 'Stop listening' : 'Start voice input'}\n              >\n                {isListening ? (\n                  <svg className=\"w-5 h-5\" fill=\"currentColor\" viewBox=\"0 0 24 24\">\n                    <path d=\"M12 14c1.66 0 2.99-1.34 2.99-3L15 5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.3-3c0 3-2.54 5.1-5.3 5.1S6.7 14 6.7 11H5c0 3.41 2.72 6.23 6 6.72V21h2v-3.28c3.28-.48 6-3.3 6-6.72h-1.7z\"/>\n                  </svg>\n                ) : (\n                  <svg className=\"w-5 h-5\" fill=\"currentColor\" viewBox=\"0 0 24 24\">\n                    <path d=\"M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z\"/>\n                    <path d=\"M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z\"/>\n                  </svg>\n                )}\n              </button>\n            )}\n            <div className=\"flex-1 relative flex items-center min-w-0\">\n              <textarea\n                ref={textareaRef}\n                value={input}\n                onChange={(event) => {\n                  setInput(event.target.value)\n                  resizeTextarea()\n                }}\n                onKeyDown={onComposerKeyDown}\n                placeholder=\"Ask anything\"\n                rows={1}\n                className=\"w-full rounded-2xl border-0 bg-gray-100 px-4 py-3 pr-12 text-base leading-6 text-gray-900 placeholder-gray-500 focus:outline-none focus:ring-0 resize-none transition-all duration-200 min-h-[52px] max-h-[200px]\"\n                style={{ height: '52px' }}\n              />\n            </div>\n            <button\n              type=\"submit\"\n              disabled={loading || !input.trim() || isListening}\n              className=\"flex-shrink-0 w-10 h-10 rounded-full bg-gray-900 text-white flex items-center justify-center hover:bg-gray-800 disabled:opacity-50 disabled:cursor-not-allowed transition-colors\"\n              aria-label=\"Send message\"\n            >\n              <svg className=\"w-5 h-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M12 19l9 2-9-18-9 18 9-2zm0 0v-8\" />\n              </svg>\n            </button>\n          </div>\n        </form>\n      </div>\n    </div>\n  )\n}\n","truncated":false,"size":31466},{"path":"data/creditCosts.ts","content":"export const CREDIT_DISPLAY = {\n  foodAnalysis: 15,\n  symptomAnalysis: 6,\n  medicalImageAnalysis: 8,\n  insightsGeneration: 8,\n  chatLight: 2,\n};\n\nexport const creditDisplayList = [\n  { label: 'Food photo analysis', key: 'foodAnalysis', credits: CREDIT_DISPLAY.foodAnalysis },\n  { label: 'Symptom analysis', key: 'symptomAnalysis', credits: CREDIT_DISPLAY.symptomAnalysis },\n  { label: 'Medical image analysis', key: 'medicalImageAnalysis', credits: CREDIT_DISPLAY.medicalImageAnalysis },\n  { label: 'Insights generation', key: 'insightsGeneration', credits: CREDIT_DISPLAY.insightsGeneration },\n  { label: 'Light chat (e.g., symptoms chat)', key: 'chatLight', credits: CREDIT_DISPLAY.chatLight },\n];\n","truncated":false,"size":700},{"path":"data/foods-starter.ts","content":"// Minimal in-app starter list for ingredient search.\n// Values are per 1 serving indicated by serving_size.\nexport type StarterFood = {\n  name: string\n  brand?: string | null\n  serving_size: string\n  calories: number\n  protein_g: number\n  carbs_g: number\n  fat_g: number\n  fiber_g?: number\n  sugar_g?: number\n}\n\nexport const STARTER_FOODS: StarterFood[] = [\n  // Breakfast basics\n  { name: 'Scrambled eggs', serving_size: '1 large egg', calories: 70, protein_g: 6, carbs_g: 0.4, fat_g: 5, fiber_g: 0, sugar_g: 0 },\n  { name: 'Bacon', serving_size: '1 slice', calories: 42, protein_g: 3, carbs_g: 0.1, fat_g: 3.3, fiber_g: 0, sugar_g: 0 },\n  { name: 'Bagel', serving_size: '1 whole', calories: 270, protein_g: 10, carbs_g: 53, fat_g: 1.5, fiber_g: 2, sugar_g: 6 },\n  { name: 'Sesame Bagel', serving_size: '1 whole', calories: 270, protein_g: 10, carbs_g: 53, fat_g: 1.5, fiber_g: 2, sugar_g: 6 },\n  { name: 'Orange juice', serving_size: '8 oz', calories: 112, protein_g: 2, carbs_g: 26, fat_g: 0.5, fiber_g: 0.5, sugar_g: 21 },\n  { name: 'Whole wheat toast', serving_size: '1 slice', calories: 80, protein_g: 4, carbs_g: 14, fat_g: 1, fiber_g: 2, sugar_g: 2 },\n  { name: 'Butter', serving_size: '1 tbsp', calories: 102, protein_g: 0.1, carbs_g: 0, fat_g: 11.5, fiber_g: 0, sugar_g: 0 },\n  // Common proteins\n  { name: 'Grilled chicken breast', serving_size: '6 oz', calories: 276, protein_g: 52, carbs_g: 0, fat_g: 6, fiber_g: 0, sugar_g: 0 },\n  { name: 'Salmon (grilled)', serving_size: '6 oz', calories: 367, protein_g: 39, carbs_g: 0, fat_g: 22, fiber_g: 0, sugar_g: 0 },\n  { name: 'Lean ground beef (cooked)', serving_size: '4 oz', calories: 250, protein_g: 26, carbs_g: 0, fat_g: 17, fiber_g: 0, sugar_g: 0 },\n  // Starches and grains\n  { name: 'Brown rice (cooked)', serving_size: '1 cup', calories: 216, protein_g: 5, carbs_g: 45, fat_g: 1.8, fiber_g: 3.5, sugar_g: 1 },\n  { name: 'White rice (cooked)', serving_size: '1 cup', calories: 205, protein_g: 4.3, carbs_g: 45, fat_g: 0.4, fiber_g: 0.6, sugar_g: 0.1 },\n  { name: 'Pasta (cooked)', serving_size: '1 cup', calories: 221, protein_g: 8, carbs_g: 43, fat_g: 1.3, fiber_g: 2.5, sugar_g: 0.8 },\n  { name: 'Quinoa (cooked)', serving_size: '1 cup', calories: 222, protein_g: 8, carbs_g: 39, fat_g: 3.6, fiber_g: 5, sugar_g: 1.6 },\n  // Vegetables\n  { name: 'Broccoli (steamed)', serving_size: '1 cup', calories: 55, protein_g: 3.7, carbs_g: 11, fat_g: 0.6, fiber_g: 5.1, sugar_g: 2.2 },\n  { name: 'Mixed salad greens', serving_size: '2 cups', calories: 16, protein_g: 1.2, carbs_g: 3, fat_g: 0.2, fiber_g: 1.8, sugar_g: 1.5 },\n  { name: 'Avocado', serving_size: '1/2 medium', calories: 120, protein_g: 1.5, carbs_g: 6, fat_g: 11, fiber_g: 5, sugar_g: 0.2 },\n  // Dairy\n  { name: 'Greek yogurt (plain, nonfat)', serving_size: '1 cup', calories: 130, protein_g: 23, carbs_g: 9, fat_g: 0, fiber_g: 0, sugar_g: 7 },\n  { name: 'Cheddar cheese', serving_size: '1 oz', calories: 114, protein_g: 7, carbs_g: 0.9, fat_g: 9.4, fiber_g: 0, sugar_g: 0.2 },\n  // Fruits\n  { name: 'Banana', serving_size: '1 medium', calories: 105, protein_g: 1.3, carbs_g: 27, fat_g: 0.4, fiber_g: 3.1, sugar_g: 14.4 },\n  { name: 'Apple', serving_size: '1 medium', calories: 95, protein_g: 0.5, carbs_g: 25, fat_g: 0.3, fiber_g: 4.4, sugar_g: 19 },\n  // Drinks\n  { name: 'Black coffee', serving_size: '8 oz', calories: 2, protein_g: 0.3, carbs_g: 0, fat_g: 0, fiber_g: 0, sugar_g: 0 },\n  { name: 'Whole milk', serving_size: '1 cup', calories: 150, protein_g: 8, carbs_g: 12, fat_g: 8, fiber_g: 0, sugar_g: 12 },\n]\n\n","truncated":false,"size":3543},{"path":"data/usda-common.ts","content":"// Curated USDA-backed entries for common foods to avoid repeated API calls.\n// Values are per serving as noted by serving_size.\nexport type CommonFood = {\n  name: string\n  aliases?: string[]\n  serving_size: string\n  calories: number\n  protein_g: number\n  carbs_g: number\n  fat_g: number\n  fiber_g?: number\n  sugar_g?: number\n}\n\nexport const COMMON_USDA_FOODS: CommonFood[] = [\n  // Burger components\n  {\n    name: 'Burger bun',\n    aliases: ['bun', 'burger bun', 'sesame bun'],\n    serving_size: '1 medium bun (70 g)',\n    calories: 150,\n    protein_g: 5,\n    carbs_g: 28,\n    fat_g: 3,\n    fiber_g: 1,\n    sugar_g: 3,\n  },\n  // 80/20 cooked: ~430-460 kcal; use 450 to avoid underestimates\n  {\n    name: 'Beef patty (6 oz)',\n    aliases: ['beef patty', 'patty', 'beef burger patty'],\n    serving_size: '6 oz (cooked)',\n    calories: 450,\n    protein_g: 32,\n    carbs_g: 0,\n    fat_g: 33,\n    fiber_g: 0,\n    sugar_g: 0,\n  },\n  // Typical American/cheddar slice\n  {\n    name: 'Cheese slice',\n    aliases: ['cheese slice', 'cheddar slice', 'american cheese'],\n    serving_size: '1 slice (28 g)',\n    calories: 110,\n    protein_g: 6,\n    carbs_g: 1,\n    fat_g: 9,\n    fiber_g: 0,\n    sugar_g: 0,\n  },\n  { name: 'Lettuce', aliases: ['lettuce'], serving_size: '1 leaf (5 g)', calories: 1, protein_g: 0.1, carbs_g: 0.2, fat_g: 0, fiber_g: 0.1, sugar_g: 0 },\n  { name: 'Pickles', aliases: ['pickles'], serving_size: '1 slice (9 g)', calories: 2, protein_g: 0.1, carbs_g: 0.4, fat_g: 0, fiber_g: 0.2, sugar_g: 0.2 },\n  { name: 'Red onion', aliases: ['onion', 'red onion'], serving_size: '1 slice (10 g)', calories: 4, protein_g: 0.1, carbs_g: 1, fat_g: 0, fiber_g: 0.2, sugar_g: 0.4 },\n  { name: 'Ketchup (1 tbsp)', aliases: ['ketchup'], serving_size: '1 tbsp (17 g)', calories: 20, protein_g: 0.2, carbs_g: 5, fat_g: 0, fiber_g: 0, sugar_g: 4 },\n  // Breakfast staples (extras)\n  { name: 'Plain bagel', aliases: ['bagel', 'plain bagel'], serving_size: '1 whole', calories: 270, protein_g: 10, carbs_g: 53, fat_g: 1.5, fiber_g: 2, sugar_g: 6 },\n  { name: 'Sesame bagel', aliases: ['sesame bagel'], serving_size: '1 whole', calories: 270, protein_g: 10, carbs_g: 53, fat_g: 1.5, fiber_g: 2, sugar_g: 6 },\n]\n","truncated":false,"size":2199},{"path":"lib/admin-alerts.ts","content":"import { Resend } from 'resend'\nimport { getEmailFooter } from '@/lib/email-footer'\n\nconst DEFAULT_OWNER_EMAIL = 'louie@helfi.ai'\n\nfunction getOwnerEmail(): string {\n  const configured = (process.env.OWNER_EMAIL || DEFAULT_OWNER_EMAIL).trim()\n  return configured || DEFAULT_OWNER_EMAIL\n}\n\nfunction getResendClient(): Resend | null {\n  if (!process.env.RESEND_API_KEY) {\n    console.log('üìß Resend API not configured, skipping admin alert email')\n    return null\n  }\n  return new Resend(process.env.RESEND_API_KEY)\n}\n\nexport async function sendOwnerSignupEmail(options: { userEmail: string; userName?: string | null }) {\n  const resend = getResendClient()\n  if (!resend) return\n\n  const recipientEmail = getOwnerEmail()\n  const displayName = options.userName || options.userEmail.split('@')[0]\n  const subject = `New Helfi signup: ${options.userEmail}`\n\n  const html = `\n    <div style=\"font-family: Arial, sans-serif; line-height: 1.5; color: #111827;\">\n      <h2 style=\"margin: 0 0 12px 0;\">New signup</h2>\n      <p style=\"margin: 0 0 6px 0;\"><strong>Email:</strong> ${options.userEmail}</p>\n      <p style=\"margin: 0 0 16px 0;\"><strong>Name:</strong> ${displayName}</p>\n      <p style=\"margin: 0 0 16px 0;\">This is a new account creation (paid or free).</p>\n      ${getEmailFooter({\n        recipientEmail,\n        emailType: 'admin',\n        reasonText: 'You received this email because you requested new signup alerts.'\n      })}\n    </div>\n  `\n\n  const emailResponse = await resend.emails.send({\n    from: 'Helfi Alerts <support@helfi.ai>',\n    to: recipientEmail,\n    subject,\n    html,\n  })\n\n  console.log(`‚úÖ [SIGNUP ALERT] Sent to ${recipientEmail} with ID: ${emailResponse.data?.id}`)\n}\n\nexport async function sendVercelSpendAlertEmail(options: {\n  recipientEmail?: string\n  payload: unknown\n}) {\n  const resend = getResendClient()\n  if (!resend) return\n\n  const recipientEmail = (options.recipientEmail || getOwnerEmail()).trim() || getOwnerEmail()\n  const payloadText = options.payload\n    ? JSON.stringify(options.payload, null, 2)\n    : 'No payload provided.'\n\n  const subject = 'Vercel spend alert received'\n  const html = `\n    <div style=\"font-family: Arial, sans-serif; line-height: 1.5; color: #111827;\">\n      <h2 style=\"margin: 0 0 12px 0;\">Vercel spend alert</h2>\n      <p style=\"margin: 0 0 16px 0;\">A Vercel spend webhook was received.</p>\n      <pre style=\"background:#f3f4f6; padding:12px; border-radius:8px; font-size:12px; white-space:pre-wrap;\">${payloadText}</pre>\n      ${getEmailFooter({\n        recipientEmail,\n        emailType: 'admin',\n        reasonText: 'You received this email because you enabled Vercel spend alerts.'\n      })}\n    </div>\n  `\n\n  const emailResponse = await resend.emails.send({\n    from: 'Helfi Alerts <support@helfi.ai>',\n    to: recipientEmail,\n    subject,\n    html,\n  })\n\n  console.log(`‚úÖ [VERCEL SPEND ALERT] Sent to ${recipientEmail} with ID: ${emailResponse.data?.id}`)\n}\n\nexport async function sendOwnerErrorAlertEmail(options: {\n  source: string\n  message: string\n  userId?: string\n  userEmail?: string\n  details?: string\n  count?: number\n}) {\n  const resend = getResendClient()\n  if (!resend) return\n\n  const recipientEmail = getOwnerEmail()\n  const countText = typeof options.count === 'number' ? `${options.count}` : '1'\n  const subject = `Helfi error alert: ${options.source}`\n\n  const html = `\n    <div style=\"font-family: Arial, sans-serif; line-height: 1.5; color: #111827;\">\n      <h2 style=\"margin: 0 0 12px 0;\">Automatic error alert</h2>\n      <p style=\"margin: 0 0 6px 0;\"><strong>Source:</strong> ${options.source}</p>\n      <p style=\"margin: 0 0 6px 0;\"><strong>Message:</strong> ${options.message}</p>\n      <p style=\"margin: 0 0 6px 0;\"><strong>Count (since last alert):</strong> ${countText}</p>\n      ${options.userEmail ? `<p style=\"margin: 0 0 6px 0;\"><strong>User email:</strong> ${options.userEmail}</p>` : ''}\n      ${options.userId ? `<p style=\"margin: 0 0 12px 0;\"><strong>User ID:</strong> ${options.userId}</p>` : ''}\n      ${options.details ? `<pre style=\"background:#f3f4f6; padding:12px; border-radius:8px; font-size:12px; white-space:pre-wrap;\">${options.details}</pre>` : ''}\n      ${getEmailFooter({\n        recipientEmail,\n        emailType: 'admin',\n        reasonText: 'You received this email because automatic error alerts are enabled.'\n      })}\n    </div>\n  `\n\n  const emailResponse = await resend.emails.send({\n    from: 'Helfi Alerts <support@helfi.ai>',\n    to: recipientEmail,\n    subject,\n    html,\n  })\n\n  console.log(`‚úÖ [ERROR ALERT] Sent to ${recipientEmail} with ID: ${emailResponse.data?.id}`)\n}\n","truncated":false,"size":4619},{"path":"lib/admin-auth.ts","content":"import jwt from 'jsonwebtoken'\n\nconst JWT_SECRET = process.env.JWT_SECRET || process.env.NEXTAUTH_SECRET\n\nexport interface AdminTokenPayload {\n  adminId: string\n  email: string\n  role: string\n}\n\nexport function verifyAdminToken(token: string): AdminTokenPayload | null {\n  if (!JWT_SECRET) return null\n  try {\n    const decoded = jwt.verify(token, JWT_SECRET) as AdminTokenPayload\n    return decoded\n  } catch (error) {\n    return null\n  }\n}\n\nexport function extractAdminFromHeaders(authHeader: string | null): AdminTokenPayload | null {\n  if (!authHeader || !authHeader.startsWith('Bearer ')) {\n    return null\n  }\n\n  const token = authHeader.replace('Bearer ', '')\n  return verifyAdminToken(token)\n} \n","truncated":false,"size":703},{"path":"lib/affiliate-admin-email.ts","content":"import { Resend } from 'resend'\n\nexport async function notifyAdminAffiliateManualReview(options: {\n  toEmail: string\n  applicationId: string\n  applicantEmail: string\n  applicantName: string\n  riskLevel: 'MEDIUM' | 'HIGH'\n  reasoning: string\n}): Promise<void> {\n  if (!process.env.RESEND_API_KEY) return\n  const resend = new Resend(process.env.RESEND_API_KEY)\n  await resend.emails.send({\n    from: 'Helfi Alerts <support@helfi.ai>',\n    to: options.toEmail,\n    subject: `Affiliate application needs review (${options.riskLevel})`,\n    html: `\n      <div style=\"font-family: Arial, sans-serif; line-height: 1.5; color: #111827;\">\n        <h2>Affiliate application flagged for manual review</h2>\n        <p><strong>Risk:</strong> ${options.riskLevel}</p>\n        <p><strong>Applicant:</strong> ${options.applicantName} (${options.applicantEmail})</p>\n        <p><strong>Application ID:</strong> ${options.applicationId}</p>\n        <p><strong>Reasoning:</strong> ${options.reasoning}</p>\n        <p>Open the admin panel to review.</p>\n      </div>\n    `,\n  })\n}\n\n","truncated":false,"size":1062},{"path":"lib/affiliate-auth.ts","content":"import { getServerSession } from 'next-auth'\nimport { getToken } from 'next-auth/jwt'\nimport type { NextRequest } from 'next/server'\nimport { authOptions } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\n\nconst SESSION_COOKIE_NAME =\n  process.env.NODE_ENV === 'production' ? '__Secure-next-auth.session-token' : 'next-auth.session-token'\n\nexport async function getAffiliateUser(request: NextRequest) {\n  const session = await getServerSession(authOptions)\n  const sessionEmail = session?.user?.email?.toLowerCase() || null\n  const sessionId = (session?.user as any)?.id as string | undefined\n\n  if (sessionEmail) {\n    return prisma.user.findUnique({ where: { email: sessionEmail }, select: { id: true, email: true } })\n  }\n\n  if (sessionId) {\n    return prisma.user.findUnique({ where: { id: sessionId }, select: { id: true, email: true } })\n  }\n\n  const token = await getToken({\n    req: request,\n    secret: process.env.NEXTAUTH_SECRET || 'helfi-secret-key-production-2024',\n    cookieName: SESSION_COOKIE_NAME,\n  })\n  const tokenEmail = token?.email ? String(token.email).toLowerCase() : null\n  const tokenId = token?.id ? String(token.id) : null\n\n  if (tokenEmail) {\n    return prisma.user.findUnique({ where: { email: tokenEmail }, select: { id: true, email: true } })\n  }\n\n  if (tokenId) {\n    return prisma.user.findUnique({ where: { id: tokenId }, select: { id: true, email: true } })\n  }\n\n  return null\n}\n","truncated":false,"size":1423},{"path":"lib/affiliate-code.ts","content":"import crypto from 'crypto'\nimport { prisma } from '@/lib/prisma'\n\nfunction generateCandidateCode(): string {\n  const raw = crypto.randomBytes(10).toString('base64url')\n  return raw.replace(/[-_]/g, '').slice(0, 10).toLowerCase()\n}\n\nexport async function createUniqueAffiliateCode(): Promise<string> {\n  for (let attempt = 0; attempt < 20; attempt++) {\n    const code = generateCandidateCode()\n    const existing = await prisma.affiliate.findUnique({ where: { code }, select: { id: true } })\n    if (!existing) return code\n  }\n  throw new Error('Failed to generate unique affiliate code')\n}\n\n","truncated":false,"size":592},{"path":"lib/affiliate-cookies.ts","content":"import crypto from 'crypto'\nimport type { NextRequest } from 'next/server'\n\nexport const AFFILIATE_COOKIE_MAX_AGE_SECONDS = 30 * 24 * 60 * 60 // 30 days\n\nexport const AFFILIATE_COOKIES = {\n  code: 'helfi_aff_code',\n  clickId: 'helfi_aff_click',\n  visitorId: 'helfi_aff_vid',\n  clickedAtMs: 'helfi_aff_ts',\n} as const\n\nexport type AffiliateCookieData = {\n  code: string\n  clickId: string\n  visitorId: string\n  clickedAtMs: number\n}\n\nexport function normalizeAffiliateCode(input: string): string {\n  return input.trim().toLowerCase()\n}\n\nexport function getOrCreateVisitorId(request: NextRequest): string {\n  const existing = request.cookies.get(AFFILIATE_COOKIES.visitorId)?.value\n  if (existing && existing.length >= 10) return existing\n  return crypto.randomUUID()\n}\n\nexport function getAffiliateCookieData(request: NextRequest): AffiliateCookieData | null {\n  const code = request.cookies.get(AFFILIATE_COOKIES.code)?.value\n  const clickId = request.cookies.get(AFFILIATE_COOKIES.clickId)?.value\n  const visitorId = request.cookies.get(AFFILIATE_COOKIES.visitorId)?.value\n  const clickedAtMsStr = request.cookies.get(AFFILIATE_COOKIES.clickedAtMs)?.value\n  const clickedAtMs = clickedAtMsStr ? Number(clickedAtMsStr) : NaN\n\n  if (!code || !clickId || !visitorId || !Number.isFinite(clickedAtMs)) return null\n  return { code, clickId, visitorId, clickedAtMs }\n}\n\nexport function isAffiliateAttributionFresh(clickedAtMs: number, nowMs: number = Date.now()): boolean {\n  const ageSeconds = Math.floor((nowMs - clickedAtMs) / 1000)\n  return ageSeconds >= 0 && ageSeconds <= AFFILIATE_COOKIE_MAX_AGE_SECONDS\n}\n\n","truncated":false,"size":1607},{"path":"lib/affiliate-screening.ts","content":"import OpenAI from 'openai'\nimport { runChatCompletionWithLogging } from '@/lib/ai-usage-logger'\n\nexport type AffiliateScreeningInput = {\n  email: string\n  name: string\n  website?: string | null\n  primaryChannel?: string | null\n  primaryChannelOther?: string | null\n  audienceSize?: string | null\n  promotionMethod: string\n  notes?: string | null\n  ip?: string | null\n  userAgent?: string | null\n  country?: string | null\n  region?: string | null\n  city?: string | null\n}\n\nexport type AffiliateScreeningResult = {\n  riskLevel: 'LOW' | 'MEDIUM' | 'HIGH'\n  recommendedAction: 'AUTO_APPROVE' | 'MANUAL_REVIEW'\n  reasoning: string\n  redFlags?: string[]\n  raw?: any\n}\n\nfunction getOpenAI(): OpenAI | null {\n  if (!process.env.OPENAI_API_KEY) return null\n  return new OpenAI({ apiKey: process.env.OPENAI_API_KEY })\n}\n\nfunction tryParseJsonObject(text: string): any | null {\n  const start = text.indexOf('{')\n  const end = text.lastIndexOf('}')\n  if (start < 0 || end < 0 || end <= start) return null\n  try {\n    return JSON.parse(text.slice(start, end + 1))\n  } catch {\n    return null\n  }\n}\n\nexport async function screenAffiliateApplication(input: AffiliateScreeningInput): Promise<AffiliateScreeningResult> {\n  const webhookUrl = process.env.AFFILIATE_SCREENING_WEBHOOK_URL\n  if (webhookUrl) {\n    const resp = await fetch(webhookUrl, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ type: 'affiliate_application', input }),\n    })\n    if (!resp.ok) {\n      throw new Error(`Affiliate screening webhook failed: ${resp.status}`)\n    }\n    const data = await resp.json().catch(() => ({}))\n    const risk = String(data?.riskLevel || data?.risk || '').toUpperCase()\n    const action = String(data?.recommendedAction || data?.action || '').toUpperCase()\n    if (!['LOW', 'MEDIUM', 'HIGH'].includes(risk) || !['AUTO_APPROVE', 'MANUAL_REVIEW'].includes(action)) {\n      throw new Error('Affiliate screening webhook returned invalid result')\n    }\n    return {\n      riskLevel: risk as any,\n      recommendedAction: action as any,\n      reasoning: String(data?.reasoning || data?.summary || 'No reasoning provided'),\n      redFlags: Array.isArray(data?.redFlags) ? data.redFlags.map((x: any) => String(x)) : undefined,\n      raw: data,\n    }\n  }\n\n  const openai = getOpenAI()\n  if (!openai) {\n    return {\n      riskLevel: 'MEDIUM',\n      recommendedAction: 'MANUAL_REVIEW',\n      reasoning: 'OPENAI_API_KEY not configured; defaulting to manual review.',\n    }\n  }\n\n  const model = (process.env.AFFILIATE_SCREENING_MODEL || 'gpt-4o-mini').trim() || 'gpt-4o-mini'\n  const system = `You are an affiliate application screening service for a SaaS app.\nReturn ONLY valid JSON with keys:\n- riskLevel: one of LOW|MEDIUM|HIGH\n- recommendedAction: one of AUTO_APPROVE|MANUAL_REVIEW\n- reasoning: short explanation\n- redFlags: array of strings (optional)\n`\n  const user = {\n    input,\n    criteria: [\n      'Email domain quality',\n      'Consistency of applicant details',\n      'Clarity and specificity of promotion method',\n      'Signs of automated or low-effort submissions',\n      'IP / location anomalies (where available)',\n    ],\n  }\n\n  const result = await runChatCompletionWithLogging(\n    openai,\n    {\n      model,\n      temperature: 0.1,\n      messages: [\n        { role: 'system', content: system },\n        { role: 'user', content: JSON.stringify(user) },\n      ],\n    },\n    { feature: 'affiliate:screening', userLabel: input.email, endpoint: 'affiliate_screening' }\n  )\n\n  const text = (result as any)?.choices?.[0]?.message?.content || ''\n  const parsed = tryParseJsonObject(text) || {}\n  const riskLevel = String(parsed?.riskLevel || '').toUpperCase()\n  const recommendedAction = String(parsed?.recommendedAction || '').toUpperCase()\n\n  if (!['LOW', 'MEDIUM', 'HIGH'].includes(riskLevel) || !['AUTO_APPROVE', 'MANUAL_REVIEW'].includes(recommendedAction)) {\n    return {\n      riskLevel: 'MEDIUM',\n      recommendedAction: 'MANUAL_REVIEW',\n      reasoning: 'AI returned an invalid response; defaulting to manual review.',\n      raw: { text },\n    }\n  }\n\n  return {\n    riskLevel: riskLevel as any,\n    recommendedAction: recommendedAction as any,\n    reasoning: String(parsed?.reasoning || 'No reasoning provided'),\n    redFlags: Array.isArray(parsed?.redFlags) ? parsed.redFlags.map((x: any) => String(x)) : undefined,\n    raw: parsed,\n  }\n}\n","truncated":false,"size":4397},{"path":"lib/ai-meal-recommendation.ts","content":"export type MealCategory = 'breakfast' | 'lunch' | 'dinner' | 'snacks' | 'uncategorized'\n\n// Fixed, disclosed cost for generating an AI meal recommendation.\n// Credits are wallet \"cents\" in Helfi's billing system.\nexport const AI_MEAL_RECOMMENDATION_CREDITS = 6\n\nexport const AI_MEAL_RECOMMENDATION_GOAL_NAME = '__AI_MEAL_RECOMMENDATIONS__'\n\nexport const AI_MEAL_RECOMMENDATION_HISTORY_LIMIT = 50\n\n// Storage version for the server-persisted AI meal recommendation state.\n// v2 introduces \"committed\" history (only saved recommendations appear).\nexport const AI_MEAL_RECOMMENDATION_STORAGE_VERSION = 2\n\nexport const CATEGORY_LABELS: Record<MealCategory, string> = {\n  breakfast: 'Breakfast',\n  lunch: 'Lunch',\n  dinner: 'Dinner',\n  snacks: 'Snacks',\n  uncategorized: 'Other',\n}\n\nexport const normalizeMealCategory = (raw: any): MealCategory => {\n  const value = typeof raw === 'string' ? raw.toLowerCase() : ''\n  if (/breakfast/.test(value)) return 'breakfast'\n  if (/lunch/.test(value)) return 'lunch'\n  if (/dinner/.test(value)) return 'dinner'\n  if (/snack/.test(value)) return 'snacks'\n  if (/uncat/.test(value) || /other/.test(value)) return 'uncategorized'\n  return 'uncategorized'\n}\n","truncated":false,"size":1190},{"path":"lib/ai-usage-logger.ts","content":"import { prisma } from '@/lib/prisma'\nimport { chatCompletionWithCost } from './metered-openai'\nimport { getRunContext } from './run-context'\n\nexport type UsageContext = {\n  feature: string\n  userId?: string | null\n  userLabel?: string | null\n  issueSlug?: string | null\n  scanId?: string | null\n  endpoint?: string | null\n  runId?: string | null\n}\n\nexport type ImageMeta = {\n  width: number | null\n  height: number | null\n  bytes: number | null\n  mime: string | null\n}\n\nexport type UsageLogInput = UsageContext & {\n  model: string\n  promptTokens: number\n  completionTokens: number\n  costCents: number\n  callDetail?: string | null\n  success?: boolean\n  errorMessage?: string | null\n  detail?: string | null\n  image?: ImageMeta | null\n  runId?: string | null\n}\n\nexport async function logAiUsageEvent(entry: UsageLogInput) {\n  try {\n    const totalTokens = Number(entry.promptTokens || 0) + Number(entry.completionTokens || 0)\n    await prisma.aIUsageEvent.create({\n      data: {\n        feature: entry.feature,\n        userId: entry.userId || null,\n        userLabel: entry.userLabel || null,\n        scanId: entry.scanId || null,\n        model: entry.model,\n        promptTokens: Number(entry.promptTokens || 0),\n        completionTokens: Number(entry.completionTokens || 0),\n        totalTokens,\n        costCents: Number(entry.costCents || 0),\n        // Store per-call detail (model/feature) while preserving any existing detail\n        detail: entry.callDetail || entry.detail || null,\n        imageWidth: entry.image?.width ?? null,\n        imageHeight: entry.image?.height ?? null,\n        imageBytes: entry.image?.bytes ?? null,\n        imageMime: entry.image?.mime ?? null,\n        endpoint: entry.endpoint || null,\n        success: entry.success ?? true,\n        errorMessage: entry.errorMessage || null,\n        runId: entry.runId || null,\n      },\n    })\n  } catch (err) {\n    // Never block user flows on logging failure\n    console.warn('[ai-usage-logger] failed to persist usage event', err)\n  }\n}\n\n// Backward-compatible helper used by older call sites\nexport async function logAIUsage(entry: {\n  context: UsageContext\n  model: string\n  promptTokens: number\n  completionTokens: number\n  costCents: number\n  success?: boolean\n  errorMessage?: string | null\n}) {\n  return logAiUsageEvent({\n    feature: entry.context.feature,\n    userId: entry.context.userId,\n    userLabel: entry.context.userLabel,\n    scanId: entry.context.scanId,\n    endpoint: entry.context.endpoint,\n    runId: entry.context.runId,\n    model: entry.model,\n    promptTokens: entry.promptTokens,\n    completionTokens: entry.completionTokens,\n    costCents: entry.costCents,\n    success: entry.success,\n    errorMessage: entry.errorMessage ?? null,\n  })\n}\n\n// Convenience wrapper: run OpenAI chat completion, capture usage/cost, log it, and return the completion.\nexport async function runChatCompletionWithLogging(\n  openai: any,\n  params: any,\n  context: UsageContext,\n  extras?: {\n    image?: ImageMeta | null\n    successDetail?: string | null\n    callDetail?: string | null\n  }\n) {\n  const asyncContext = getRunContext()\n  const mergedContext: UsageContext = {\n    ...context,\n    feature: context.feature || asyncContext?.feature || 'unknown',\n    runId: context.runId ?? asyncContext?.runId ?? null,\n  }\n  try {\n    const { completion, costCents, promptTokens, completionTokens } = await chatCompletionWithCost(openai, params)\n    const model = (completion as any)?.model || params?.model || 'unknown'\n    logAiUsageEvent({\n      ...mergedContext,\n      model,\n      promptTokens,\n      completionTokens,\n      costCents,\n      image: extras?.image ?? null,\n      detail: extras?.successDetail ?? null,\n      callDetail: extras?.callDetail ?? null,\n      success: true,\n    }).catch(() => {})\n    return completion\n  } catch (err: any) {\n    const model = params?.model || 'unknown'\n    logAiUsageEvent({\n      ...mergedContext,\n      model,\n      promptTokens: 0,\n      completionTokens: 0,\n      costCents: 0,\n      image: extras?.image ?? null,\n      success: false,\n      errorMessage: err?.message || 'unknown_error',\n    }).catch(() => {})\n    throw err\n  }\n}\n","truncated":false,"size":4154},{"path":"lib/ai-usage-runs.ts","content":"import { prisma } from '@/lib/prisma'\n\nexport async function getRunCostCents(runId: string, userId: string) {\n  if (!runId || !userId) return { costCents: 0, count: 0, promptTokens: 0, completionTokens: 0 }\n  const aggregate = await prisma.aIUsageEvent.aggregate({\n    _sum: { costCents: true, promptTokens: true, completionTokens: true },\n    _count: { _all: true },\n    where: {\n      runId,\n      userId,\n      success: true,\n    },\n  })\n  return {\n    costCents: Number(aggregate._sum.costCents || 0),\n    count: Number(aggregate._count?._all || 0),\n    promptTokens: Number(aggregate._sum.promptTokens || 0),\n    completionTokens: Number(aggregate._sum.completionTokens || 0),\n  }\n}\n","truncated":false,"size":688},{"path":"lib/audit.ts","content":"/**\n * Audit logging utility for PDF processing events\n * Ensures full audit trail for compliance\n */\n\nimport { prisma } from '@/lib/prisma';\nimport { AuditEventType } from '@prisma/client';\n\nexport interface AuditEventData {\n  reportId?: string;\n  userId: string;\n  eventType: AuditEventType;\n  eventDescription: string;\n  metadata?: Record<string, any>;\n  ipAddress?: string;\n  userAgent?: string;\n}\n\n/**\n * Create an audit event\n * Automatically redacts sensitive information from metadata\n */\nexport async function createAuditEvent(data: AuditEventData): Promise<void> {\n  try {\n    // Redact sensitive information from metadata\n    const redactedMetadata = data.metadata ? redactSensitiveData(data.metadata) : undefined;\n    \n    await prisma.auditEvent.create({\n      data: {\n        reportId: data.reportId,\n        userId: data.userId,\n        eventType: data.eventType,\n        eventDescription: data.eventDescription,\n        metadata: redactedMetadata,\n        ipAddress: data.ipAddress,\n        userAgent: data.userAgent,\n      },\n    });\n  } catch (error) {\n    // Don't throw - audit logging failures shouldn't break the main flow\n    console.error('‚ùå Failed to create audit event:', error);\n  }\n}\n\n/**\n * Redact sensitive information from metadata\n * Removes passwords, full file contents, and other PII\n */\nfunction redactSensitiveData(metadata: Record<string, any>): Record<string, any> {\n  const redacted = { ...metadata };\n  \n  // Remove password fields\n  if (redacted.password) {\n    redacted.password = '[REDACTED]';\n  }\n  \n  if (redacted.passwordHash) {\n    redacted.passwordHash = '[REDACTED]';\n  }\n  \n  // Truncate large text fields\n  if (redacted.text && typeof redacted.text === 'string' && redacted.text.length > 500) {\n    redacted.text = redacted.text.substring(0, 500) + '...[TRUNCATED]';\n  }\n  \n  // Remove file buffers\n  if (redacted.buffer) {\n    redacted.buffer = '[BINARY_DATA_REDACTED]';\n  }\n  \n  if (redacted.pdfBuffer) {\n    redacted.pdfBuffer = '[BINARY_DATA_REDACTED]';\n  }\n  \n  // Remove S3 keys that might contain sensitive paths\n  if (redacted.s3Key) {\n    redacted.s3Key = redacted.s3Key.replace(/[^/]+$/, '[FILENAME_REDACTED]');\n  }\n  \n  return redacted;\n}\n\n/**\n * Get audit events for a report\n */\nexport async function getReportAuditEvents(reportId: string) {\n  return prisma.auditEvent.findMany({\n    where: { reportId },\n    orderBy: { createdAt: 'desc' },\n  });\n}\n\n/**\n * Get audit events for a user\n */\nexport async function getUserAuditEvents(userId: string, limit = 100) {\n  return prisma.auditEvent.findMany({\n    where: { userId },\n    orderBy: { createdAt: 'desc' },\n    take: limit,\n  });\n}\n\n","truncated":false,"size":2651},{"path":"lib/auth.ts","content":"import { type NextAuthOptions } from 'next-auth'\nimport CredentialsProvider from 'next-auth/providers/credentials'\nimport GoogleProvider from 'next-auth/providers/google'\nimport { prisma } from '@/lib/prisma'\nimport { Resend } from 'resend'\nimport { getEmailFooter } from '@/lib/email-footer'\nimport { notifyOwner } from '@/lib/owner-notifications'\nimport { sendOwnerSignupEmail } from '@/lib/admin-alerts'\nimport { getSessionRevokedAt } from '@/lib/session-revocation'\nimport bcrypt from 'bcryptjs'\n\n// Initialize Resend for welcome emails\nfunction getResend() {\n  if (!process.env.RESEND_API_KEY) {\n    return null\n  }\n  return new Resend(process.env.RESEND_API_KEY)\n}\n\n// Check if user has completed onboarding\nasync function isOnboardingComplete(userId: string): Promise<boolean> {\n  try {\n    const user = await prisma.user.findUnique({\n      where: { id: userId },\n      include: {\n        healthGoals: true,\n        supplements: true,\n        medications: true,\n      }\n    })\n    \n    if (!user) return false\n    \n    // Check if user has basic profile data\n    const hasBasicProfile = user.gender && user.weight && user.height\n    \n    // Check if user has at least one health goal (excluding special data storage goals)\n    const hasHealthGoals = user.healthGoals.some(goal => \n      !goal.name.startsWith('__') && goal.name !== '__EXERCISE_DATA__' && \n      goal.name !== '__HEALTH_SITUATIONS_DATA__' && goal.name !== '__BLOOD_RESULTS_DATA__'\n    )\n    \n    // Consider onboarding complete if user has basic profile and health goals\n    return !!(hasBasicProfile && hasHealthGoals)\n  } catch (error) {\n    console.error('Error checking onboarding completion:', error)\n    return false\n  }\n}\n\n// Function to send welcome email\nasync function sendWelcomeEmail(email: string, name: string) {\n  const resend = getResend()\n  if (!resend) {\n    console.log('üìß Resend API not configured, skipping welcome email')\n    return false\n  }\n\n  try {\n    const welcomeMessage = `Hi ${name},\n\nWelcome to the Helfi community! We're thrilled to have you on board.\n\nüöÄ Getting Started:\n‚Ä¢ Complete your health profile for personalized insights\n‚Ä¢ Start logging your meals with AI-powered analysis\n‚Ä¢ Set your health goals and track your progress\n‚Ä¢ Explore our medication interaction checker\n\nüí° Pro Tip: The more you use Helfi, the smarter your AI health coach becomes!\n\nNeed help getting started? Just reply to this email or contact our support team.\n\nBest regards,\nThe Helfi Team`\n\n    const emailResponse = await resend.emails.send({\n      from: 'Helfi Team <support@helfi.ai>',\n      to: email,\n      subject: 'üéâ Welcome to Helfi - Your AI Health Journey Begins!',\n      html: `\n        <div style=\"font-family: 'Segoe UI', Arial, sans-serif; max-width: 600px; margin: 0 auto; color: #333; background: #f8fafc;\">\n          <div style=\"background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; padding: 40px 30px; text-align: center; border-radius: 12px 12px 0 0;\">\n            <h1 style=\"margin: 0; font-size: 32px; font-weight: bold; letter-spacing: -0.5px;\">Helfi</h1>\n            <p style=\"margin: 12px 0 0 0; opacity: 0.95; font-size: 16px;\">Your AI-Powered Health Coach</p>\n          </div>\n          \n          <div style=\"padding: 40px 30px; background: white; border-radius: 0 0 12px 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);\">\n            ${welcomeMessage.split('\\n').map((line: string) => \n              line.trim() ? `<p style=\"margin: 18px 0; line-height: 1.7; font-size: 16px;\">${line}</p>` : '<div style=\"height: 10px;\"></div>'\n            ).join('')}\n            \n            <div style=\"margin-top: 40px; padding-top: 30px; border-top: 2px solid #e5e7eb; text-align: center;\">\n              <a href=\"https://helfi.ai/dashboard\" style=\"display: inline-block; background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; text-decoration: none; padding: 16px 32px; border-radius: 8px; font-weight: 600; font-size: 16px; margin: 10px 0; box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);\">üöÄ Complete Your Profile</a>\n            </div>\n            \n            ${getEmailFooter({ recipientEmail: email, emailType: 'welcome' })}\n          </div>\n        </div>\n      `\n    })\n\n    console.log(`‚úÖ [WELCOME EMAIL] Sent to ${email} with ID: ${emailResponse.data?.id}`)\n    return true\n  } catch (error) {\n    console.error(`‚ùå [WELCOME EMAIL] Failed to send to ${email}:`, error)\n    return false\n  }\n}\n\n// Function to send verification email\nasync function sendVerificationEmail(email: string, token: string) {\n  const resend = getResend()\n  if (!resend) {\n    console.log('üìß Resend API not configured, skipping verification email')\n    return false\n  }\n\n  try {\n    const verificationUrl = `https://helfi.ai/api/auth/verify?token=${token}&email=${encodeURIComponent(email)}`\n    \n    const emailResponse = await resend.emails.send({\n      from: 'Helfi Team <support@helfi.ai>',\n      to: email,\n      subject: 'üîê Verify Your Helfi Account - Action Required',\n      html: `\n        <div style=\"font-family: 'Segoe UI', Arial, sans-serif; max-width: 600px; margin: 0 auto; color: #333; background: #f8fafc;\">\n          <div style=\"background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; padding: 40px 30px; text-align: center; border-radius: 12px 12px 0 0;\">\n            <h1 style=\"margin: 0; font-size: 32px; font-weight: bold; letter-spacing: -0.5px;\">Helfi</h1>\n            <p style=\"margin: 12px 0 0 0; opacity: 0.95; font-size: 16px;\">Account Verification Required</p>\n          </div>\n          \n          <div style=\"padding: 40px 30px; background: white; border-radius: 0 0 12px 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);\">\n            <h2 style=\"margin: 0 0 20px 0; color: #374151; font-size: 24px;\">üîê Verify Your Email Address</h2>\n            \n            <p style=\"margin: 0 0 20px 0; line-height: 1.7; font-size: 16px; color: #4b5563;\">\n              Welcome to Helfi! To complete your account setup and ensure security, please verify your email address by clicking the button below.\n            </p>\n            \n            <div style=\"background: #fef3c7; border: 1px solid #f59e0b; border-radius: 8px; padding: 16px; margin: 20px 0;\">\n              <p style=\"margin: 0; color: #92400e; font-size: 14px;\">\n                <strong>‚ö†Ô∏è Security Notice:</strong> This link expires in 24 hours for your protection.\n              </p>\n            </div>\n            \n            <div style=\"margin: 30px 0; text-align: center;\">\n              <a href=\"${verificationUrl}\" style=\"display: inline-block; background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; text-decoration: none; padding: 16px 32px; border-radius: 8px; font-weight: 600; font-size: 16px; box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);\">\n                ‚úÖ Verify Email Address\n              </a>\n            </div>\n            \n            <div style=\"background: #f3f4f6; border-radius: 8px; padding: 20px; margin: 30px 0;\">\n              <p style=\"margin: 0 0 10px 0; font-size: 14px; color: #374151;\"><strong>Can't click the button?</strong></p>\n              <p style=\"margin: 0; font-size: 14px; color: #6b7280; word-break: break-all;\">\n                Copy and paste this link: ${verificationUrl}\n              </p>\n            </div>\n            \n            <p style=\"margin: 30px 0 0 0; line-height: 1.7; font-size: 14px; color: #6b7280;\">\n              If you didn't create a Helfi account, please ignore this email or contact our support team.\n            </p>\n            \n            ${getEmailFooter({ recipientEmail: email, emailType: 'verification' })}\n          </div>\n        </div>\n      `\n    })\n\n    console.log(`‚úÖ [VERIFICATION EMAIL] Sent to ${email} with ID: ${emailResponse.data?.id}`)\n    return true\n  } catch (error) {\n    console.error(`‚ùå [VERIFICATION EMAIL] Failed to send to ${email}:`, error)\n    return false\n  }\n}\n\n// Function to generate verification token\nfunction generateVerificationToken(): string {\n  return Math.random().toString(36).substring(2) + Date.now().toString(36)\n}\n\nexport const authOptions: NextAuthOptions = {\n  session: {\n    strategy: 'jwt',\n    // Honor \"keep me signed in\" by defaulting to a very long session; explicit logout clears it.\n    maxAge: 5 * 365 * 24 * 60 * 60, // ~5 years\n    updateAge: 12 * 60 * 60, // refresh twice a day to avoid surprise logouts\n  },\n  jwt: {\n    // Use a stable secret that doesn't change between deployments\n    secret: process.env.NEXTAUTH_SECRET || 'helfi-secret-key-production-2024',\n    maxAge: 5 * 365 * 24 * 60 * 60, // align with session maxAge (~5 years)\n  },\n  // Force long-lived, first-party cookies so mobile Safari won‚Äôt drop sessions between app switches.\n  cookies: {\n    sessionToken: {\n      name: process.env.NODE_ENV === 'production' ? '__Secure-next-auth.session-token' : 'next-auth.session-token',\n      options: {\n        httpOnly: true,\n        sameSite: process.env.NODE_ENV === 'production' ? 'none' : 'lax',\n        path: '/',\n        secure: process.env.NODE_ENV === 'production',\n        maxAge: 5 * 365 * 24 * 60 * 60, // ~5 years\n      },\n    },\n    callbackUrl: {\n      name: process.env.NODE_ENV === 'production' ? '__Secure-next-auth.callback-url' : 'next-auth.callback-url',\n      options: {\n        sameSite: process.env.NODE_ENV === 'production' ? 'none' : 'lax',\n        path: '/',\n        secure: process.env.NODE_ENV === 'production',\n      },\n    },\n    csrfToken: {\n      name: process.env.NODE_ENV === 'production' ? '__Host-next-auth.csrf-token' : 'next-auth.csrf-token',\n      options: {\n        httpOnly: true,\n        sameSite: process.env.NODE_ENV === 'production' ? 'none' : 'lax',\n        path: '/',\n        secure: process.env.NODE_ENV === 'production',\n      },\n    },\n  },\n  providers: [\n    CredentialsProvider({\n      name: 'credentials',\n      credentials: {\n        email: { label: 'Email', type: 'email' },\n        password: { label: 'Password', type: 'password' }\n      },\n      async authorize(credentials) {\n        console.log('üîê Credentials authorize called:', { email: credentials?.email })\n        if (!credentials?.email || !credentials?.password) {\n          console.log('‚ùå Missing credentials')\n          return null\n        }\n\n        const email = credentials.email.toLowerCase()\n        const user = await prisma.user\n          .findUnique({\n            where: { email },\n            select: {\n              id: true,\n              email: true,\n              name: true,\n              image: true,\n              passwordHash: true,\n              emailVerified: true,\n            },\n          })\n          .catch((e) => {\n            console.error('‚ö†Ô∏è prisma.user.findUnique failed:', e)\n            return null\n          })\n\n        if (!user || !user.passwordHash) {\n          console.log('‚ùå No password set for user:', email)\n          return null\n        }\n\n        if (!user.emailVerified) {\n          console.log('‚ùå Email not verified for user:', email)\n          throw new Error('EMAIL_NOT_VERIFIED')\n        }\n\n        const match = await bcrypt.compare(credentials.password, user.passwordHash)\n        if (!match) {\n          console.log('‚ùå Invalid password for user:', email)\n          return null\n        }\n\n        console.log('‚úÖ Allowing credentials signin for user:', user.email)\n        return {\n          id: user.id,\n          email: user.email,\n          name: user.name || user.email.split('@')[0],\n          image: user.image,\n        }\n      }\n    }),\n    GoogleProvider({\n      clientId: process.env.GOOGLE_CLIENT_ID || '',\n      clientSecret: process.env.GOOGLE_CLIENT_SECRET || '',\n      authorization: {\n        params: {\n          prompt: \"consent\",\n          access_type: \"offline\",\n          response_type: \"code\"\n        }\n      }\n    }),\n  ],\n  callbacks: {\n    async signIn({ user, account, profile }) {\n      console.log('üîë SignIn callback:', { \n        email: user?.email, \n        provider: account?.provider \n      })\n      \n      if (account?.provider === 'google') {\n        try {\n          // Ensure wallet metering columns exist (avoid column-missing errors on fresh DBs)\n          // try {\n          //   await prisma.$executeRawUnsafe('ALTER TABLE \"User\" ADD COLUMN IF NOT EXISTS \"walletMonthlyUsedCents\" INTEGER NOT NULL DEFAULT 0')\n          // } catch (e) {\n          //   console.warn('walletMonthlyUsedCents ensure failed (safe to ignore if already exists):', e)\n          // }\n          // try {\n          //   await prisma.$executeRawUnsafe('ALTER TABLE \"User\" ADD COLUMN IF NOT EXISTS \"walletMonthlyResetAt\" TIMESTAMP(3)')\n          // } catch (e) {\n          //   console.warn('walletMonthlyResetAt ensure failed (safe to ignore if already exists):', e)\n          // }\n          // Find or create user for Google OAuth\n          let dbUser = await prisma.user.findUnique({\n            where: { email: user.email! }\n          })\n\n          let isNewUser = false\n          if (!dbUser) {\n            console.log('üë§ Creating Google user:', user.email)\n            dbUser = await prisma.user.create({\n              data: {\n                email: user.email!.toLowerCase(),\n                name: user.name || user.email!.split('@')[0],\n                image: user.image,\n                emailVerified: new Date() // Google users are auto-verified\n              }\n            })\n            isNewUser = true\n          } else if (!dbUser.emailVerified) {\n            // Auto-verify existing users who sign in with Google\n            console.log('üîÑ Auto-verifying existing Google user:', dbUser.email)\n            await prisma.user.update({\n              where: { id: dbUser.id },\n              data: { emailVerified: new Date() }\n            })\n          }\n          \n          // Send welcome email for new Google users (don't await to avoid blocking auth)\n          if (isNewUser) {\n            const userName = dbUser.name || dbUser.email.split('@')[0]\n            console.log('üìß Sending welcome email to new Google user:', userName)\n            sendWelcomeEmail(dbUser.email, userName).catch(error => {\n              console.error('‚ùå Google welcome email failed (non-blocking):', error)\n            })\n\n            // Notify owner of new Google signup (don't await to avoid blocking auth)\n            notifyOwner({\n              event: 'signup',\n              userEmail: dbUser.email,\n              userName: dbUser.name || undefined,\n            }).catch(error => {\n              console.error('‚ùå Owner notification failed (non-blocking):', error)\n            })\n\n            sendOwnerSignupEmail({\n              userEmail: dbUser.email,\n              userName: dbUser.name || undefined,\n            }).catch(error => {\n              console.error('‚ùå Signup email alert failed (non-blocking):', error)\n            })\n          }\n          \n          // Update user ID for session\n          user.id = dbUser.id\n          console.log('‚úÖ Google user processed:', { id: dbUser.id, email: dbUser.email, isNew: isNewUser })\n        } catch (error) {\n          console.error('‚ùå Google user creation error:', error)\n          return false\n        }\n      }\n      \n      return true\n    },\n    async redirect({ url, baseUrl }) {\n      console.log('üîÑ Redirect callback:', { url, baseUrl })\n      \n      // CRITICAL FIX: Handle development vs production environment properly\n      const isDevMode = process.env.NODE_ENV === 'development'\n      const actualBaseUrl = isDevMode ? 'http://localhost:3000' : baseUrl\n      \n      console.log('üåç Environment:', { isDevMode, actualBaseUrl, originalBaseUrl: baseUrl })\n      \n      // Handle signout - go to home\n      if (url.includes('signout') || url.includes('signOut')) {\n        return actualBaseUrl + '/'\n      }\n      \n      // If URL is relative, use it with actualBaseUrl\n      if (url.startsWith('/')) {\n        return actualBaseUrl + url\n      }\n      \n      // If URL matches actualBaseUrl origin, allow it\n      try {\n        const urlOrigin = new URL(url).origin\n        const actualBaseOrigin = new URL(actualBaseUrl).origin\n        if (urlOrigin === actualBaseOrigin) {\n          console.log('‚úÖ URL origin matches, allowing:', url)\n          return url\n        }\n      } catch (e) {\n        console.log('‚ö†Ô∏è URL parsing failed, using default redirect')\n      }\n      \n      // Default: redirect to dashboard (onboarding redirect will be handled client-side for new users only)\n      const defaultRedirect = actualBaseUrl + '/dashboard'\n      console.log('üéØ Default redirect to dashboard:', defaultRedirect)\n      return defaultRedirect\n    },\n    async session({ session, token }) {\n      console.log('üìã Session callback:', { \n        tokenEmail: token?.email,\n        tokenId: token?.id \n      })\n      \n      try {\n        // Add user info to session from JWT token\n        if (token?.email) {\n          // CRITICAL: Validate that user still exists in database\n          const dbUser = await prisma.user.findUnique({\n            where: { id: token.id as string }\n          })\n          \n          if (!dbUser) {\n            console.log('üö´ User account deleted - invalidating session:', token.email)\n            // Return empty session to force complete logout\n            return {\n              expires: session.expires,\n              user: undefined\n            }\n          }\n          \n          const revokedAt = await getSessionRevokedAt(dbUser.id)\n          if (revokedAt) {\n            const tokenIssuedAt =\n              typeof token?.iat === 'number' ? new Date(token.iat * 1000) : null\n            if (!tokenIssuedAt || revokedAt > tokenIssuedAt) {\n              console.log('üö´ Session revoked by admin:', token.email)\n              return {\n                expires: session.expires,\n                user: undefined\n              }\n            }\n          }\n\n          session.user = {\n            id: token.id as string,\n            email: token.email as string,\n            name: token.name as string,\n            image: token.image as string || null,\n            needsVerification: !dbUser.emailVerified\n          }\n        }\n        \n        console.log('‚úÖ Session validated:', { \n          id: session.user?.id, \n          email: session.user?.email \n        })\n        \n        return session\n      } catch (error) {\n        console.error('‚ùå Session callback error:', error)\n        return session\n      }\n    },\n    async jwt({ token, user, account, profile }) {\n      console.log('üé´ JWT callback:', { \n        hasUser: !!user,\n        tokenEmail: token?.email,\n        provider: account?.provider\n      })\n      \n      try {\n        // Add user info to token on first sign in\n        if (user) {\n          token.id = user.id\n          token.email = user.email\n          token.name = user.name\n          token.image = user.image\n          \n          console.log('‚úÖ JWT token updated:', { \n            id: token.id, \n            email: token.email \n          })\n        }\n        \n        // For Google OAuth, also store profile image\n        if (account?.provider === 'google' && profile) {\n          token.image = profile.image || user?.image\n        }\n        \n        return token\n      } catch (error) {\n        console.error('‚ùå JWT callback error:', error)\n        return token\n      }\n    }\n  },\n  pages: {\n    signIn: '/auth/signin',\n    error: '/auth/signin',\n  },\n  debug: true,\n  secret: process.env.NEXTAUTH_SECRET || 'helfi-secret-key-production-2024'\n} \n","truncated":false,"size":19521},{"path":"lib/chatFormatting.ts","content":"function escapeForRegExp(text: string): string {\n  return text.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n}\n\nexport function formatChatContent(\n  raw: string,\n  options?: {\n    headings?: string[]\n  }\n): string {\n  let text = (raw || '').replace(/\\r\\n/g, '\\n').replace(/\\u2022/g, '- ')\n\n  // Force key headings onto their own line when provided.\n  if (options?.headings?.length) {\n    for (const heading of options.headings) {\n      const pattern = new RegExp(escapeForRegExp(heading), 'g')\n      text = text.replace(pattern, `\\n${heading}\\n`)\n    }\n  }\n\n  // Push any remaining **bold heading** patterns onto their own lines.\n  text = text.replace(/(\\*\\*[A-Za-z][^*\\n]{2,80}\\*\\*)/g, '\\n$1\\n')\n\n  // Add missing line breaks before numbered / bulleted lists (model sometimes streams them without breaks).\n  text = text.replace(/([^\\n])(\\d+\\.\\s)/g, '$1\\n$2')\n  text = text.replace(/([^\\n])([-*‚Ä¢]\\s)/g, '$1\\n$2')\n\n  // If a list starts immediately after a colon/semicolon, give it breathing room.\n  text = text.replace(/([:;])\\s*(\\d+\\.\\s)/g, '$1\\n\\n$2')\n\n  // Collapse any excessive blank lines so spacing stays neat.\n  text = text.replace(/\\n{3,}/g, '\\n\\n')\n\n  return text.trim()\n}\n","truncated":false,"size":1178},{"path":"lib/cost-meter.ts","content":"// Centralized cost metering for OpenAI usage.\n// Prices are in cents per 1,000 tokens. Defaults reflect public pricing circa mid‚Äë2024/2025.\n// You can override any value by setting an env var like:\n// HELFI_PRICE_GPT4O_INPUT_CENTS_PER_1K, HELFI_PRICE_GPT4O_OUTPUT_CENTS_PER_1K, etc.\n\ntype ModelPrices = {\n  inputCentsPer1k: number;\n  outputCentsPer1k: number;\n};\n\n// Global markup multiplier to apply to all computed costs (e.g., 2 = 2x OpenAI cost).\n// Default is 2x per user request.\nconst BILLING_MARKUP_MULTIPLIER = (() => {\n  const v = process.env.HELFI_BILLING_MARKUP_MULTIPLIER;\n  const n = Number(v);\n  if (Number.isFinite(n) && n > 0) return n;\n  return 2; // default: double the OpenAI cost to cover service margin\n})();\n\nconst envNumber = (key: string, fallback: number): number => {\n  const v = process.env[key];\n  if (!v) return fallback;\n  const n = Number(v);\n  return Number.isFinite(n) ? n : fallback;\n};\n\nconst DEFAULT_PRICES: Record<string, ModelPrices> = {\n  // GPT-5.2 (per OpenAI pricing page screenshot provided by user)\n  // Input: $1.75 / 1M tokens; Output: $14.00 / 1M tokens\n  'gpt-5.2': {\n    inputCentsPer1k: envNumber('HELFI_PRICE_GPT52_INPUT_CENTS_PER_1K', 0.175),\n    outputCentsPer1k: envNumber('HELFI_PRICE_GPT52_OUTPUT_CENTS_PER_1K', 1.4),\n  },\n  // GPT-5.2 pro\n  // Input: $21.00 / 1M tokens; Output: $168.00 / 1M tokens\n  'gpt-5.2-pro': {\n    inputCentsPer1k: envNumber('HELFI_PRICE_GPT52_PRO_INPUT_CENTS_PER_1K', 2.1),\n    outputCentsPer1k: envNumber('HELFI_PRICE_GPT52_PRO_OUTPUT_CENTS_PER_1K', 16.8),\n  },\n  // GPT-5 mini\n  // Input: $0.25 / 1M tokens; Output: $2.00 / 1M tokens\n  'gpt-5-mini': {\n    inputCentsPer1k: envNumber('HELFI_PRICE_GPT5_MINI_INPUT_CENTS_PER_1K', 0.025),\n    outputCentsPer1k: envNumber('HELFI_PRICE_GPT5_MINI_OUTPUT_CENTS_PER_1K', 0.2),\n  },\n  // 4o: ~$0.005 / 1k input, $0.015 / 1k output\n  'gpt-4o': {\n    inputCentsPer1k: envNumber('HELFI_PRICE_GPT4O_INPUT_CENTS_PER_1K', 0.5),\n    outputCentsPer1k: envNumber('HELFI_PRICE_GPT4O_OUTPUT_CENTS_PER_1K', 1.5),\n  },\n  // 4o-mini: ~$0.00015 / 1k input, $0.0006 / 1k output\n  'gpt-4o-mini': {\n    inputCentsPer1k: envNumber('HELFI_PRICE_GPT4O_MINI_INPUT_CENTS_PER_1K', 0.015),\n    outputCentsPer1k: envNumber('HELFI_PRICE_GPT4O_MINI_OUTPUT_CENTS_PER_1K', 0.06),\n  },\n  // GPT-4 (fallback)\n  'gpt-4': {\n    inputCentsPer1k: envNumber('HELFI_PRICE_GPT4_INPUT_CENTS_PER_1K', 3.0),\n    outputCentsPer1k: envNumber('HELFI_PRICE_GPT4_OUTPUT_CENTS_PER_1K', 6.0),\n  },\n  // Historical 3.5 fallback, rarely used\n  'gpt-3.5-turbo': {\n    inputCentsPer1k: envNumber('HELFI_PRICE_GPT35_INPUT_CENTS_PER_1K', 0.15),\n    outputCentsPer1k: envNumber('HELFI_PRICE_GPT35_OUTPUT_CENTS_PER_1K', 0.2),\n  },\n};\n\nexport type TokenUsage = {\n  promptTokens: number;\n  completionTokens: number;\n  totalTokens?: number;\n};\n\nfunction normalizeModelKey(model: string): string {\n  const m = (model || '').toLowerCase();\n  if (m.includes('gpt-5.2') && m.includes('pro')) return 'gpt-5.2-pro';\n  if (m.includes('gpt-5.2')) return 'gpt-5.2';\n  if (m.includes('gpt-5-mini') || m.includes('gpt-5 mini')) return 'gpt-5-mini';\n  if (m.includes('gpt-4o-mini')) return 'gpt-4o-mini';\n  if (m.includes('gpt-4o')) return 'gpt-4o';\n  if (m.includes('gpt-4')) return 'gpt-4';\n  if (m.includes('gpt-3.5')) return 'gpt-3.5-turbo';\n  return m;\n}\n\nexport function getModelPrices(model: string): ModelPrices {\n  const key = model in DEFAULT_PRICES ? model : normalizeModelKey(model);\n  return DEFAULT_PRICES[key] || DEFAULT_PRICES['gpt-4o'];\n}\n\nexport function getBillingMarkupMultiplier() {\n  return BILLING_MARKUP_MULTIPLIER;\n}\n\nexport function getModelPriceInfo(model: string): ModelPrices {\n  return getModelPrices(model);\n}\n\n// Raw OpenAI cost (no markup). Useful for reporting true spend against the vendor bill.\nexport function openaiCostCentsForTokens(model: string, usage: TokenUsage): number {\n  const { inputCentsPer1k, outputCentsPer1k } = getModelPrices(model);\n  const inCost = (usage.promptTokens / 1000) * inputCentsPer1k;\n  const outCost = (usage.completionTokens / 1000) * outputCentsPer1k;\n  return Math.ceil(inCost + outCost);\n}\n\nexport function costCentsForTokens(model: string, usage: TokenUsage): number {\n  const { inputCentsPer1k, outputCentsPer1k } = getModelPrices(model);\n  const inCost = (usage.promptTokens / 1000) * inputCentsPer1k;\n  const outCost = (usage.completionTokens / 1000) * outputCentsPer1k;\n  const base = inCost + outCost;\n  // Apply global markup and round up to avoid undercharging\n  return Math.ceil(base * BILLING_MARKUP_MULTIPLIER);\n}\n\n// Rough estimation for streaming or when usage is unavailable.\n// Uses a simple characters-to-tokens heuristic (~4 chars per token).\nexport function estimateTokensFromText(text: string): number {\n  if (!text) return 0;\n  const approx = Math.ceil(text.length / 4);\n  return approx;\n}\n\nexport function costCentsEstimateFromText(\n  model: string,\n  promptText: string,\n  expectedOutputChars: number\n): number {\n  const promptTokens = estimateTokensFromText(promptText);\n  const completionTokens = Math.ceil(expectedOutputChars / 4);\n  return costCentsForTokens(model, { promptTokens, completionTokens });\n}\n\nexport function capMaxTokensToBudget(\n  model: string,\n  promptText: string,\n  desiredMaxTokens: number,\n  budgetCents: number,\n  safetyMargin: number = 0.9\n): number {\n  if (!Number.isFinite(budgetCents) || budgetCents <= 0) return 0;\n  const promptTokens = estimateTokensFromText(promptText);\n  const { inputCentsPer1k, outputCentsPer1k } = getModelPrices(model);\n  const markup = getBillingMarkupMultiplier();\n  const promptCost = (promptTokens / 1000) * inputCentsPer1k * markup;\n  const usableBudget = budgetCents * safetyMargin - promptCost;\n  if (!Number.isFinite(usableBudget) || usableBudget <= 0) return 0;\n  const maxCompletionTokens = Math.floor((usableBudget / (outputCentsPer1k * markup)) * 1000);\n  return Math.max(0, Math.min(desiredMaxTokens, maxCompletionTokens));\n}\n\n\n\n\n\n","truncated":false,"size":5949},{"path":"lib/credit-system.ts","content":"import { prisma } from '@/lib/prisma';\nimport { isSubscriptionActive } from '@/lib/subscription-utils';\n\n// ABSOLUTE GUARD RAIL:\n// `CreditManager` is the single source of truth for wallet credits and costs.\n// Do NOT \"quick-fix\" bugs by changing credit prices or bypassing charges here\n// without reading `GUARD_RAILS.md` (credits section) and getting explicit user\n// approval.\n//\n// Credit costs for different features\nexport const CREDIT_COSTS = {\n  FOOD_ANALYSIS: 10,\n  INTERACTION_ANALYSIS: 3,\n  MEDICAL_IMAGE_ANALYSIS: 2,\n  FOOD_REANALYSIS: 1,\n  SYMPTOM_ANALYSIS: 1,\n  INSIGHTS_GENERATION: 7, // Fixed cost per full insights generation (all health issues)\n} as const;\n\nexport type FeatureType = keyof typeof CREDIT_COSTS;\n\nexport interface CreditStatus {\n  hasCredits: boolean;\n  dailyCreditsRemaining: number;\n  additionalCreditsRemaining: number;\n  totalCreditsRemaining: number;\n  featureUsageToday: {\n    foodAnalysis: number;\n    interactionAnalysis: number;\n  };\n  dailyLimits: {\n    total: number;\n    foodAnalysis: number;\n    interactionAnalysis: number;\n  };\n}\n\nexport class CreditManager {\n  private userId: string;\n\n  constructor(userId: string) {\n    this.userId = userId;\n  }\n\n  //\n  // ===== Wallet Engine (Cursor‚Äëstyle percentage wallet) =====\n  //\n\n  // Map subscription price directly to advertised credit amounts\n  private static SUBSCRIPTION_CREDITS_MAP: Record<number, number> = {\n    1000: 700,   // $10/month ‚Üí 700 credits\n    2000: 1400,  // $20/month ‚Üí 1,400 credits\n    3000: 2100,  // $30/month ‚Üí 2,100 credits\n    5000: 3500,  // $50/month ‚Üí 3,500 credits\n  };\n\n  private static PLAN_PRICE_CENTS: Record<string, number> = {\n    PREMIUM: 2000, // $20/month\n    // If a Premium Plus is added later in schema, we can map it here.\n    PREMIUM_PLUS: 3000, // $30/month (defensive default)\n  };\n\n  private static walletPercentOfPlan(): number {\n    // 50% of subscription price becomes monthly wallet allowance\n    const p = Number(process.env.HELFI_WALLET_PLAN_PERCENT || '0.5');\n    return p > 0 && p <= 1 ? p : 0.5;\n  }\n\n  private static monthlyCapCentsForPlan(plan: string | null | undefined): number {\n    const price = CreditManager.PLAN_PRICE_CENTS[String(plan || 'PREMIUM')] ?? 0;\n    return Math.floor(price * CreditManager.walletPercentOfPlan());\n  }\n\n  // Get credit cap from subscription price (uses direct mapping, not percentage)\n  private static creditsForSubscriptionPrice(monthlyPriceCents: number | null | undefined): number {\n    if (!monthlyPriceCents) return 0;\n    // Use direct mapping if available, otherwise fall back to percentage\n    if (CreditManager.SUBSCRIPTION_CREDITS_MAP[monthlyPriceCents]) {\n      return CreditManager.SUBSCRIPTION_CREDITS_MAP[monthlyPriceCents];\n    }\n    // Fallback to 50% for any unmapped prices\n    return Math.floor(monthlyPriceCents * CreditManager.walletPercentOfPlan());\n  }\n\n  private async ensureMonthlyReset(now = new Date(), db: any = prisma): Promise<void> {\n    const user = await db.user.findUnique({ \n      where: { id: this.userId },\n      include: { subscription: true }\n    });\n    if (!user) return;\n    \n    const last = (user as any).walletMonthlyResetAt as Date | null;\n    \n    const hasActiveSubscription = isSubscriptionActive(user.subscription, now);\n\n    // Check if reset is needed based on subscription start date (if subscription exists)\n    // Otherwise fall back to calendar month\n    let shouldReset = false;\n    \n    if (hasActiveSubscription && user.subscription?.startDate) {\n      // Reset based on subscription start date (same calendar day each month)\n      const subStartDate = new Date(user.subscription.startDate);\n      const startYear = subStartDate.getUTCFullYear();\n      const startMonth = subStartDate.getUTCMonth();\n      const startDay = subStartDate.getUTCDate();\n      \n      if (!last) {\n        // Never reset before - reset now\n        shouldReset = true;\n      } else {\n        // Check if we've passed the subscription renewal date this month\n        const lastYear = last.getUTCFullYear();\n        const lastMonth = last.getUTCMonth();\n        const lastDay = last.getUTCDate();\n        \n        const currentYear = now.getUTCFullYear();\n        const currentMonth = now.getUTCMonth();\n        const currentDay = now.getUTCDate();\n        \n        // Calculate which subscription month we should be in based on last reset\n        let expectedMonthsSinceStart = (lastYear - startYear) * 12 + (lastMonth - startMonth);\n        if (lastDay < startDay) {\n          expectedMonthsSinceStart--;\n        }\n        \n        // Calculate which subscription month we're actually in now\n        let actualMonthsSinceStart = (currentYear - startYear) * 12 + (currentMonth - startMonth);\n        if (currentDay < startDay) {\n          actualMonthsSinceStart--;\n        }\n        \n        // Reset if we've moved to a new subscription month\n        shouldReset = actualMonthsSinceStart > expectedMonthsSinceStart;\n      }\n    } else {\n      // No subscription - use calendar month reset\n      const monthChanged =\n        !last ||\n        last.getUTCFullYear() !== now.getUTCFullYear() ||\n        last.getUTCMonth() !== now.getUTCMonth();\n      shouldReset = monthChanged;\n    }\n    \n    if (shouldReset) {\n      await db.user.update({\n        where: { id: this.userId },\n        data: {\n          walletMonthlyUsedCents: 0,\n          walletMonthlyResetAt: now,\n          // Reset monthly per-feature usage counters\n          monthlySymptomAnalysisUsed: 0,\n          monthlyFoodAnalysisUsed: 0,\n          monthlyMedicalImageAnalysisUsed: 0,\n          monthlyInteractionAnalysisUsed: 0,\n          monthlyInsightsGenerationUsed: 0,\n        } as any,\n      });\n    }\n  }\n\n  async getWalletStatus() {\n    await this.ensureMonthlyReset();\n    const user = await prisma.user.findUnique({\n      where: { id: this.userId },\n      include: { subscription: true },\n    });\n    if (!user) throw new Error('User not found');\n    const hasActiveSubscription = isSubscriptionActive(user.subscription);\n    const plan = hasActiveSubscription ? user.subscription?.plan || null : null;\n    \n    // Use monthlyPriceCents if available, otherwise fall back to plan-based calculation\n    let monthlyCapCents = 0;\n    if (plan && user.subscription && hasActiveSubscription) {\n      if (user.subscription.monthlyPriceCents) {\n        // Use direct credit mapping (e.g., $30 ‚Üí 1,700 credits)\n        monthlyCapCents = CreditManager.creditsForSubscriptionPrice(user.subscription.monthlyPriceCents);\n      } else {\n        // Fall back to plan-based calculation (defaults to $20)\n        monthlyCapCents = CreditManager.monthlyCapCentsForPlan(plan);\n      }\n    }\n    \n    const monthlyUsedCents = (user as any).walletMonthlyUsedCents || 0;\n\n    // Fetch available (non-expired) top-ups\n    const now = new Date();\n    const topUps = await prisma.creditTopUp.findMany({\n      where: { userId: user.id, expiresAt: { gt: now } },\n      orderBy: { expiresAt: 'asc' },\n    });\n    const topUpsTotalAvailable =\n      topUps.reduce((sum, t) => sum + Math.max(0, t.amountCents - t.usedCents), 0) || 0;\n    const topUpsTotalPurchased =\n      topUps.reduce((sum, t) => sum + t.amountCents, 0) || 0;\n    const topUpsTotalUsed =\n      topUps.reduce((sum, t) => sum + t.usedCents, 0) || 0;\n    const additionalAvailable = Math.max(0, (user as any).additionalCredits || 0);\n\n    const monthlyRemaining = Math.max(0, monthlyCapCents - monthlyUsedCents);\n    const totalAvailable = monthlyRemaining + topUpsTotalAvailable + additionalAvailable;\n    \n    // Calculate percentUsed: if user has subscription, use monthly wallet; otherwise use top-ups\n    let percentUsed = 0;\n    if (monthlyCapCents > 0) {\n      // User has subscription - calculate based on monthly wallet\n      percentUsed = Math.min(100, Math.floor((monthlyUsedCents / monthlyCapCents) * 100));\n    } else if (topUpsTotalPurchased > 0) {\n      // User has no subscription but has top-ups - calculate based on top-up usage\n      percentUsed = Math.min(100, Math.floor((topUpsTotalUsed / topUpsTotalPurchased) * 100));\n    }\n    // If neither subscription nor top-ups, percentUsed remains 0\n\n    return {\n      plan,\n      monthlyCapCents,\n      monthlyUsedCents,\n      monthlyRemainingCents: monthlyRemaining,\n      percentUsed,\n      topUps: topUps.map((t) => ({\n        id: t.id,\n        availableCents: Math.max(0, t.amountCents - t.usedCents),\n        expiresAt: t.expiresAt,\n      })),\n      additionalCreditsCents: additionalAvailable,\n      totalAvailableCents: totalAvailable,\n    };\n  }\n\n  /**\n   * Charge the user's wallet and top-ups by a given cost in cents.\n   * Consumes monthly allowance first, then earliest-expiring top-ups (FIFO).\n   * Returns true if the charge succeeded, false if insufficient funds.\n   */\n  async chargeCents(costCents: number): Promise<boolean> {\n    if (costCents <= 0) return true;\n    return prisma.$transaction(async (tx) => {\n      await tx.$executeRaw`SELECT pg_advisory_xact_lock(hashtext(${this.userId}))`;\n      await this.ensureMonthlyReset(new Date(), tx);\n\n      const user = await tx.user.findUnique({\n        where: { id: this.userId },\n        include: { subscription: true },\n      });\n      if (!user) throw new Error('User not found');\n\n      const hasActiveSubscription = isSubscriptionActive(user.subscription);\n      const plan = hasActiveSubscription ? user.subscription?.plan || null : null;\n      const additionalAvailable = Math.max(0, (user as any).additionalCredits || 0);\n      \n      // Use monthlyPriceCents if available, otherwise fall back to plan-based calculation\n      let monthlyCapCents = 0;\n      if (plan && user.subscription && hasActiveSubscription) {\n        if (user.subscription.monthlyPriceCents) {\n          // Use direct credit mapping (e.g., $30 ‚Üí 1,700 credits)\n          monthlyCapCents = CreditManager.creditsForSubscriptionPrice(user.subscription.monthlyPriceCents);\n        } else {\n          monthlyCapCents = CreditManager.monthlyCapCentsForPlan(plan);\n        }\n      }\n      \n      const monthlyUsedCents = (user as any).walletMonthlyUsedCents || 0;\n      let remainingMonthly = Math.max(0, monthlyCapCents - monthlyUsedCents);\n\n      // Early insufficient check (monthly + all top-ups)\n      const now = new Date();\n      const topUps = await tx.creditTopUp.findMany({\n        where: { userId: user.id, expiresAt: { gt: now } },\n        orderBy: { expiresAt: 'asc' },\n      });\n      const topUpsAvailable = topUps.reduce((sum, t) => sum + Math.max(0, t.amountCents - t.usedCents), 0);\n      if (remainingMonthly + additionalAvailable + topUpsAvailable < costCents) {\n        return false;\n      }\n\n      let toCharge = costCents;\n\n      // 1) Consume monthly allowance\n      const fromMonthly = Math.min(toCharge, remainingMonthly);\n      if (fromMonthly > 0) {\n        await tx.user.update({\n          where: { id: this.userId },\n          data: { walletMonthlyUsedCents: (monthlyUsedCents + fromMonthly) as any },\n        });\n        toCharge -= fromMonthly;\n      }\n\n      if (toCharge <= 0) return true;\n\n      // 1b) Consume manual additional credits (non-expiring)\n      const fromAdditional = Math.min(toCharge, additionalAvailable);\n      if (fromAdditional > 0) {\n        await tx.user.update({\n          where: { id: this.userId },\n          data: {\n            additionalCredits: {\n              decrement: fromAdditional,\n            },\n          },\n        });\n        toCharge -= fromAdditional;\n      }\n\n      if (toCharge <= 0) return true;\n\n      // 2) Consume FIFO from top-ups\n      for (const tu of topUps) {\n        const available = Math.max(0, tu.amountCents - tu.usedCents);\n        if (available <= 0) continue;\n        const consume = Math.min(available, toCharge);\n        await tx.creditTopUp.update({\n          where: { id: tu.id },\n          data: { usedCents: tu.usedCents + consume },\n        });\n        toCharge -= consume;\n        if (toCharge <= 0) break;\n      }\n\n      return toCharge <= 0;\n    });\n  }\n\n  /**\n   * Charge subscription (monthly wallet) credits and top-ups separately.\n   * This preserves the correct margin when different wallets have different\n   * credit valuations (e.g., subscription vs. top-up pricing).\n   */\n  async chargeSplitCredits(subscriptionCredits: number, topUpCredits: number): Promise<boolean> {\n    const sub = Math.max(0, Math.round(subscriptionCredits || 0));\n    const top = Math.max(0, Math.round(topUpCredits || 0));\n    if (sub === 0 && top === 0) return true;\n\n    return prisma.$transaction(async (tx) => {\n      await tx.$executeRaw`SELECT pg_advisory_xact_lock(hashtext(${this.userId}))`;\n      await this.ensureMonthlyReset(new Date(), tx);\n\n      const user = await tx.user.findUnique({\n        where: { id: this.userId },\n        include: { subscription: true },\n      });\n      if (!user) throw new Error('User not found');\n\n      const hasActiveSubscription = isSubscriptionActive(user.subscription);\n      const plan = hasActiveSubscription ? user.subscription?.plan || null : null;\n      let monthlyCapCents = 0;\n      if (plan && user.subscription && hasActiveSubscription) {\n        if (user.subscription.monthlyPriceCents) {\n          monthlyCapCents = CreditManager.creditsForSubscriptionPrice(user.subscription.monthlyPriceCents);\n        } else {\n          monthlyCapCents = CreditManager.monthlyCapCentsForPlan(plan);\n        }\n      }\n      const monthlyUsedCents = (user as any).walletMonthlyUsedCents || 0;\n      const monthlyRemaining = Math.max(0, monthlyCapCents - monthlyUsedCents);\n\n      const now = new Date();\n      const topUps = await tx.creditTopUp.findMany({\n        where: { userId: this.userId, expiresAt: { gt: now } },\n        orderBy: { expiresAt: 'asc' },\n      });\n      const topUpsAvailable =\n        topUps.reduce((sum, t) => sum + Math.max(0, t.amountCents - t.usedCents), 0) || 0;\n\n      // Guard rails: do not silently dip into top-ups for the subscription portion\n      if (sub > monthlyRemaining) return false;\n      if (top > topUpsAvailable) return false;\n\n      if (sub > 0) {\n        await tx.user.update({\n          where: { id: this.userId },\n          data: { walletMonthlyUsedCents: (monthlyUsedCents + sub) as any },\n        });\n      }\n\n      if (top > 0) {\n        let remainingTopUp = top;\n        for (const tu of topUps) {\n          const available = Math.max(0, tu.amountCents - tu.usedCents);\n          if (available <= 0) continue;\n          const consume = Math.min(available, remainingTopUp);\n          await tx.creditTopUp.update({\n            where: { id: tu.id },\n            data: { usedCents: tu.usedCents + consume },\n          });\n          remainingTopUp -= consume;\n          if (remainingTopUp <= 0) break;\n        }\n        if (remainingTopUp > 0) return false;\n      }\n\n      return true;\n    });\n  }\n\n  // Check if user has enough credits for a feature\n  async checkCredits(featureType: FeatureType): Promise<CreditStatus> {\n    const user = await prisma.user.findUnique({\n      where: { id: this.userId },\n      include: {\n        subscription: true,\n      },\n    });\n\n    if (!user) {\n      throw new Error('User not found');\n    }\n\n    // Reset daily/monthly usage if needed\n    const now = new Date();\n    const lastReset = user.lastAnalysisResetDate;\n    const shouldReset = !lastReset || \n      (now.getTime() - lastReset.getTime()) > 24 * 60 * 60 * 1000;\n\n    if (shouldReset) {\n      await this.resetDailyUsage();\n      user.dailyAnalysisUsed = 0;\n      user.dailyFoodAnalysisUsed = 0;\n      user.dailyFoodReanalysisUsed = 0;\n      user.dailyMedicalAnalysisUsed = 0;\n      user.dailyInteractionAnalysisUsed = 0;\n    }\n\n    const lastMonthlyReset = user.lastMonthlyResetDate;\n    const monthChanged = !lastMonthlyReset ||\n      (lastMonthlyReset.getUTCFullYear() !== now.getUTCFullYear() ||\n       lastMonthlyReset.getUTCMonth() !== now.getUTCMonth());\n    if (monthChanged) {\n      await prisma.user.update({\n        where: { id: this.userId },\n        data: {\n          monthlyInteractionAnalysisUsed: 0,\n          lastMonthlyResetDate: now,\n        }\n      });\n      user.monthlyInteractionAnalysisUsed = 0;\n    }\n\n    const creditCost = CREDIT_COSTS[featureType];\n    const dailyCreditsRemaining = Math.max(0, user.dailyAnalysisCredits - user.dailyAnalysisUsed);\n    const totalCreditsRemaining = dailyCreditsRemaining + user.additionalCredits;\n    const hasCredits = totalCreditsRemaining >= creditCost;\n\n    // Calculate daily limits based on plan\n    const isPremium = isSubscriptionActive(user.subscription);\n    const dailyFoodLimit = isPremium ? 30 : 3;\n    const dailyMedicalLimit = isPremium ? 15 : 0;\n    const monthlyInteractionLimit = isPremium ? 30 : 0;\n    const dailyFoodReanalysisLimit = isPremium ? 10 : 0;\n\n    return {\n      hasCredits,\n      dailyCreditsRemaining,\n      additionalCreditsRemaining: user.additionalCredits,\n      totalCreditsRemaining,\n      featureUsageToday: {\n        foodAnalysis: user.dailyFoodAnalysisUsed || 0,\n        interactionAnalysis: user.dailyInteractionAnalysisUsed || 0,\n      },\n      dailyLimits: {\n        total: dailyFoodLimit,\n        foodAnalysis: dailyFoodLimit,\n        interactionAnalysis: Math.floor(dailyFoodLimit / CREDIT_COSTS.INTERACTION_ANALYSIS),\n      },\n    };\n  }\n\n  // Consume credits for a feature\n  async consumeCredits(featureType: FeatureType): Promise<boolean> {\n    const creditStatus = await this.checkCredits(featureType);\n    \n    if (!creditStatus.hasCredits) {\n      return false;\n    }\n\n    const creditCost = CREDIT_COSTS[featureType];\n    \n    // Determine how to consume credits (daily first, then additional)\n    const dailyCreditsToUse = Math.min(creditCost, creditStatus.dailyCreditsRemaining);\n    const additionalCreditsToUse = creditCost - dailyCreditsToUse;\n\n    // Update database\n    const updateData: any = {\n      dailyAnalysisUsed: {\n        increment: dailyCreditsToUse,\n      },\n      additionalCredits: {\n        decrement: additionalCreditsToUse,\n      },\n      totalAnalysisCount: {\n        increment: 1,\n      },\n    };\n\n    // Update feature-specific counters\n    if (featureType === 'FOOD_ANALYSIS') {\n      updateData.dailyFoodAnalysisUsed = {\n        increment: 1,\n      };\n      updateData.totalFoodAnalysisCount = {\n        increment: 1,\n      };\n    } else if (featureType === 'INTERACTION_ANALYSIS') {\n      updateData.dailyInteractionAnalysisUsed = {\n        increment: 1,\n      };\n      updateData.totalInteractionAnalysisCount = {\n        increment: 1,\n      };\n    }\n\n    await prisma.user.update({\n      where: { id: this.userId },\n      data: updateData,\n    });\n\n    return true;\n  }\n\n  // Reset daily usage\n  private async resetDailyUsage(): Promise<void> {\n    await prisma.user.update({\n      where: { id: this.userId },\n      data: {\n        dailyAnalysisUsed: 0,\n        dailyFoodAnalysisUsed: 0,\n        dailyFoodReanalysisUsed: 0,\n        dailyMedicalAnalysisUsed: 0,\n        dailyInteractionAnalysisUsed: 0,\n        lastAnalysisResetDate: new Date(),\n      },\n    });\n  }\n\n  // Add credits to user account (admin function)\n  static async addCredits(userId: string, amount: number): Promise<void> {\n    await prisma.user.update({\n      where: { id: userId },\n      data: {\n        additionalCredits: {\n          increment: amount,\n        },\n      },\n    });\n  }\n\n  // Reset daily quota (admin function)\n  static async resetDailyQuota(userId: string): Promise<void> {\n    await prisma.user.update({\n      where: { id: userId },\n      data: {\n        dailyAnalysisUsed: 0,\n        dailyFoodAnalysisUsed: 0,\n        dailyInteractionAnalysisUsed: 0,\n        lastAnalysisResetDate: new Date(),\n      },\n    });\n  }\n\n  // Get detailed credit usage (admin function)\n  static async getCreditUsage(userId: string) {\n    const user = await prisma.user.findUnique({\n      where: { id: userId },\n      include: {\n        subscription: true,\n      },\n    });\n\n    if (!user) {\n      throw new Error('User not found');\n    }\n\n    return {\n      daily: {\n        limit: user.dailyAnalysisCredits,\n        used: user.dailyAnalysisUsed,\n        remaining: Math.max(0, user.dailyAnalysisCredits - user.dailyAnalysisUsed),\n      },\n      additional: {\n        available: user.additionalCredits,\n      },\n      featureUsage: {\n        today: {\n          foodAnalysis: user.dailyFoodAnalysisUsed || 0,\n          interactionAnalysis: user.dailyInteractionAnalysisUsed || 0,\n        },\n        lifetime: {\n          total: user.totalAnalysisCount,\n          foodAnalysis: user.totalFoodAnalysisCount || 0,\n          interactionAnalysis: user.totalInteractionAnalysisCount || 0,\n        },\n      },\n      lastReset: user.lastAnalysisResetDate,\n      plan: isSubscriptionActive(user.subscription) ? user.subscription?.plan || null : null,\n    };\n  }\n} \n","truncated":false,"size":20787},{"path":"lib/daily-targets.ts","content":"export type DailyTargets = {\n  calories: number | null\n  protein: number | null\n  carbs: number | null\n  fat: number | null\n  fiber?: number | null\n  sugarMax?: number | null\n}\n\nexport type DailyTargetInput = {\n  gender?: string | null\n  birthdate?: string | null\n  weightKg?: number | null\n  heightCm?: number | null\n  exerciseFrequency?: string | null\n  goals?: string[] | null\n  goalChoice?: string | null\n  goalIntensity?: 'mild' | 'standard' | 'aggressive' | null\n  exerciseDurations?: Record<string, number | string | null> | null\n  bodyType?: string | null\n  allergies?: string[] | null\n  diabetesType?: 'type1' | 'type2' | 'prediabetes' | null\n  dietTypes?: any\n  healthSituations?: {\n    healthIssues?: string\n    healthProblems?: string\n    additionalInfo?: string\n  } | null\n}\n\nconst clamp = (value: number, min: number, max: number) =>\n  Math.min(max, Math.max(min, value))\n\nconst normalizeDietTypes = (raw: any): string[] => {\n  if (Array.isArray(raw)) {\n    return Array.from(\n      new Set(\n        raw\n          .filter((v) => typeof v === 'string')\n          .map((v) => v.trim())\n          .filter(Boolean),\n      ),\n    )\n  }\n  if (typeof raw === 'string') {\n    const v = raw.trim()\n    return v ? [v] : []\n  }\n  return []\n}\n\nconst EXERCISE_MET: Record<string, number> = {\n  walking: 3.5,\n  running: 9,\n  swimming: 6,\n  'bike riding': 7,\n  biking: 7,\n  cycling: 7,\n  mma: 10,\n  boxing: 9.5,\n  jujitsu: 7.5,\n  jiu: 7.5,\n  karate: 8,\n  'body building': 6,\n  bodybuilding: 6,\n  yoga: 3,\n  pilates: 3.5,\n}\n\nfunction calculateAge(birthdate?: string | null): number | null {\n  if (!birthdate) return null\n  const [y, m, d] = birthdate.split('-').map((v) => parseInt(v, 10))\n  if (!y || !m || !d) return null\n  const today = new Date()\n  let age = today.getFullYear() - y\n  const monthDiff = today.getMonth() + 1 - m\n  const dayDiff = today.getDate() - d\n  if (monthDiff < 0 || (monthDiff === 0 && dayDiff < 0)) {\n    age -= 1\n  }\n  if (!Number.isFinite(age) || age <= 0 || age > 110) return null\n  return age\n}\n\nfunction activityMultiplier(exerciseFrequency?: string | null): number {\n  if (!exerciseFrequency) return 1.2\n  const f = exerciseFrequency.toLowerCase()\n  if (f.includes('every day') || f.includes('6 days') || f.includes('6 day')) return 1.6\n  if (f.includes('5 days') || f.includes('5 day')) return 1.55\n  if (f.includes('3 days') || f.includes('3 day') || f.includes('4 days') || f.includes('4 day'))\n    return 1.45\n  if (f.includes('2 days') || f.includes('2 day') || f.includes('1 day')) return 1.3\n  return 1.2\n}\n\nfunction parseExerciseDurations(\n  durations?: Record<string, number | string | null> | null,\n  exerciseFrequency?: string | null,\n): number {\n  if (!durations) return 0\n  const freq = exerciseFrequency ? exerciseFrequency.toLowerCase() : ''\n  const sessionsPerWeekMatch = freq.match(/(\\d+)\\s*day/)\n  const sessionsPerWeek = sessionsPerWeekMatch ? parseInt(sessionsPerWeekMatch[1], 10) : 3\n\n  return Object.entries(durations).reduce((total, [rawType, rawMinutes]) => {\n    const minutes = typeof rawMinutes === 'string' ? parseFloat(rawMinutes) : rawMinutes || 0\n    if (!Number.isFinite(minutes) || minutes <= 0) return total\n    const normalizedType = rawType.trim().toLowerCase()\n    const met =\n      EXERCISE_MET[normalizedType] ||\n      EXERCISE_MET[normalizedType.replace(/\\s+/g, ' ')] ||\n      5 // default moderate activity\n    // Convert MET minutes to daily kcal; MET formula kcal/min = (MET * 3.5 * kg) / 200\n    const dailyMinutes = (minutes * (Number.isFinite(sessionsPerWeek) ? sessionsPerWeek : 3)) / 7\n    return total + { met, dailyMinutes }.met * 3.5 * dailyMinutes // weight factored later\n  }, 0)\n}\n\nfunction goalAdjustmentFactor(goalChoice?: string | null, intensity?: 'mild' | 'standard' | 'aggressive' | null): number {\n  const choice = (goalChoice || '').toLowerCase()\n  const level: 'mild' | 'standard' | 'aggressive' =\n    typeof intensity === 'string'\n      ? (intensity.toLowerCase() as 'mild' | 'standard' | 'aggressive')\n      : 'standard'\n  const byLevel = (base: number) => {\n    if (level === 'mild') return base * 0.7\n    if (level === 'aggressive') return base * 1.2\n    return base\n  }\n\n  if (choice.includes('lose')) return 1 - byLevel(0.1) // 10% mild ‚Üí 12% aggressive deficit\n  if (choice.includes('tone')) return 1 - byLevel(0.12)\n  if (choice.includes('shred')) return 1 - byLevel(0.2)\n  if (choice.includes('gain')) return 1 + byLevel(0.1)\n  return 1\n}\n\nfunction parseConditionsText(healthSituations?: DailyTargetInput['healthSituations']): string[] {\n  const blob = [\n    healthSituations?.healthIssues || '',\n    healthSituations?.healthProblems || '',\n    healthSituations?.additionalInfo || '',\n  ]\n    .join(' ')\n    .toLowerCase()\n\n  const matches = []\n  if (blob.includes('diab')) matches.push('diabetes')\n  if (blob.includes('pcos')) matches.push('pcos')\n  if (blob.includes('cholesterol') || blob.includes('lipid')) matches.push('cholesterol')\n  if (blob.includes('hypertension') || blob.includes('blood pressure')) matches.push('hypertension')\n  if (blob.includes('ibs') || blob.includes('bowel') || blob.includes('constipation')) matches.push('ibs')\n  if (blob.includes('heart') || blob.includes('cardio')) matches.push('cardio')\n  return matches\n}\n\nfunction macroSplitForGoal(goalChoice?: string | null): { proteinPct: number; fatPct: number; carbPct: number } {\n  const choice = (goalChoice || '').toLowerCase()\n  if (choice.includes('lose')) return { proteinPct: 0.32, fatPct: 0.3, carbPct: 0.38 }\n  if (choice.includes('tone')) return { proteinPct: 0.33, fatPct: 0.3, carbPct: 0.37 }\n  if (choice.includes('shred')) return { proteinPct: 0.36, fatPct: 0.3, carbPct: 0.34 }\n  if (choice.includes('gain')) return { proteinPct: 0.28, fatPct: 0.28, carbPct: 0.44 }\n  return { proteinPct: 0.3, fatPct: 0.3, carbPct: 0.4 }\n}\n\nfunction normalizeSplit(proteinPct: number, fatPct: number, carbPct: number) {\n  const totalPct = proteinPct + fatPct + carbPct\n  if (totalPct > 1e-6) {\n    return {\n      proteinPct: proteinPct / totalPct,\n      fatPct: fatPct / totalPct,\n      carbPct: carbPct / totalPct,\n    }\n  }\n  return { proteinPct: 0.3, fatPct: 0.3, carbPct: 0.4 }\n}\n\nfunction parseConditionsFromGoals(goals?: string[] | null): string[] {\n  if (!Array.isArray(goals) || goals.length === 0) return []\n  const blob = goals.join(' ').toLowerCase()\n  const conditions: string[] = []\n  const add = (tag: string) => {\n    if (!conditions.includes(tag)) conditions.push(tag)\n  }\n  if (blob.includes('diab')) add('diabetes')\n  if (blob.includes('pcos')) add('pcos')\n  if (blob.includes('cholesterol') || blob.includes('lipid')) add('cholesterol')\n  if (blob.includes('hypertension') || blob.includes('blood pressure')) add('hypertension')\n  if (blob.includes('heart') || blob.includes('cardio')) add('cardio')\n  if (blob.includes('ibs')) add('ibs')\n  if (blob.includes('constipation')) add('constipation')\n  if (blob.includes('ulcer')) add('ulcer')\n  if (blob.includes('gerd') || blob.includes('reflux')) add('reflux')\n  if (blob.includes('acid') && blob.includes('reflux')) add('reflux')\n  return conditions\n}\n\nfunction parseConditionsFromDiabetes(diabetesType?: DailyTargetInput['diabetesType']): string[] {\n  const type = (diabetesType || '').toLowerCase()\n  if (type === 'type1') return ['diabetes_type1']\n  if (type === 'type2') return ['diabetes_type2']\n  if (type === 'prediabetes') return ['prediabetes']\n  return []\n}\n\nfunction applyConditionAdjustments(\n  split: { proteinPct: number; fatPct: number; carbPct: number },\n  conditions: string[],\n): { proteinPct: number; fatPct: number; carbPct: number; fiberTarget: number; sugarCap: number } {\n  let { proteinPct, fatPct, carbPct } = split\n  let fiberTarget = 28\n  let sugarCap = 35\n\n  if (conditions.includes('diabetes') || conditions.includes('pcos') || conditions.includes('diabetes_type1') || conditions.includes('diabetes_type2')) {\n    carbPct = Math.max(0.25, carbPct - 0.05)\n    proteinPct = Math.min(0.4, proteinPct + 0.03)\n    sugarCap = 25\n    fiberTarget = 32\n  }\n  if (conditions.includes('diabetes_type1')) {\n    carbPct = Math.max(0.23, carbPct - 0.02)\n    sugarCap = Math.min(sugarCap, 22)\n    fiberTarget = Math.max(fiberTarget, 34)\n  }\n  if (conditions.includes('diabetes_type2')) {\n    carbPct = Math.max(0.22, carbPct - 0.03)\n    sugarCap = Math.min(sugarCap, 20)\n    fiberTarget = Math.max(fiberTarget, 34)\n  }\n  if (conditions.includes('prediabetes')) {\n    carbPct = Math.max(0.26, carbPct - 0.03)\n    sugarCap = Math.min(sugarCap, 28)\n    fiberTarget = Math.max(fiberTarget, 30)\n  }\n  if (conditions.includes('ibs')) {\n    fiberTarget = 30\n  }\n  if (conditions.includes('cholesterol') || conditions.includes('cardio') || conditions.includes('hypertension')) {\n    fatPct = Math.max(0.25, fatPct - 0.02)\n    carbPct = Math.min(0.45, carbPct + 0.02)\n  }\n\n  if (conditions.includes('constipation')) {\n    fiberTarget = Math.max(fiberTarget, 32)\n  }\n\n  if (conditions.includes('ulcer') || conditions.includes('reflux')) {\n    // Gentle tweak: avoid very high fat splits; keep carbs moderate\n    fatPct = Math.min(fatPct, 0.32)\n    carbPct = Math.min(Math.max(carbPct, 0.35), 0.45)\n  }\n\n  const normalized = normalizeSplit(proteinPct, fatPct, carbPct)\n\n  return { ...normalized, fiberTarget, sugarCap }\n}\n\nfunction applyBodyTypeAdjustments(\n  split: { proteinPct: number; fatPct: number; carbPct: number },\n  bodyType?: string | null,\n) {\n  const type = (bodyType || '').toLowerCase()\n  let proteinPct = split.proteinPct\n  let fatPct = split.fatPct\n  let carbPct = split.carbPct\n  let calorieFactor = 1\n  let fiberBonus = 0\n\n  if (type.startsWith('ecto')) {\n    // Slightly higher carbs and calories to support weight gain/maintenance\n    carbPct += 0.02\n    fatPct -= 0.01\n    calorieFactor = 1.05\n  } else if (type.startsWith('endo')) {\n    // Slightly higher protein, moderate carbs, gentle calorie reduction\n    proteinPct += 0.02\n    carbPct -= 0.03\n    fatPct += 0.01\n    calorieFactor = 0.95\n  } else if (type.startsWith('meso')) {\n    fiberBonus = 1 // subtle nudge\n  }\n\n  const normalized = normalizeSplit(proteinPct, fatPct, carbPct)\n  return { ...normalized, calorieFactor, fiberBonus }\n}\n\n/**\n * Calculate daily calorie + macro targets using a simple, transparent approach:\n * - Mifflin‚ÄìSt Jeor BMR\n * - Activity multiplier from exercise frequency\n * - Light goal-based adjustment (weight loss / gain)\n */\nexport function calculateDailyTargets(input: DailyTargetInput): DailyTargets {\n  const gender = (input.gender || '').toLowerCase()\n  const weightKg = input.weightKg && input.weightKg > 0 ? input.weightKg : null\n  const heightCm = input.heightCm && input.heightCm > 0 ? input.heightCm : null\n  const age = calculateAge(input.birthdate)\n\n  if (!weightKg || !heightCm || !age || (gender !== 'male' && gender !== 'female')) {\n    // Not enough info ‚Äì return nulls so the UI can show a friendly message instead of guessing.\n    return { calories: null, protein: null, carbs: null, fat: null }\n  }\n\n  // Mifflin‚ÄìSt Jeor formula\n  let bmr =\n    10 * weightKg +\n    6.25 * heightCm -\n    5 * age +\n    (gender === 'male' ? 5 : -161)\n\n  if (!Number.isFinite(bmr) || bmr <= 0) {\n    return { calories: null, protein: null, carbs: null, fat: null }\n  }\n\n  const activity = activityMultiplier(input.exerciseFrequency)\n  const goalFactor = goalAdjustmentFactor(input.goalChoice, input.goalIntensity)\n  const bodyTypeFactor = applyBodyTypeAdjustments({ proteinPct: 0, fatPct: 0, carbPct: 1 }, input.bodyType).calorieFactor\n\n  // Include user-reported exercise durations to estimate extra daily burn\n  const metMinutes = parseExerciseDurations(input.exerciseDurations, input.exerciseFrequency)\n  const extraActivityKcal =\n    weightKg && metMinutes > 0 ? (metMinutes * weightKg) / 200 : 0 // kcal/day\n\n  const tdee = bmr * activity\n  const targetCalories = clamp(\n    Math.round((tdee + extraActivityKcal) * goalFactor * bodyTypeFactor),\n    1200,\n    4000,\n  )\n\n  const baseSplit = macroSplitForGoal(input.goalChoice)\n  const conditions = Array.from(\n    new Set([\n      ...parseConditionsText(input.healthSituations),\n      ...parseConditionsFromGoals(input.goals),\n      ...parseConditionsFromDiabetes(input.diabetesType),\n    ]),\n  )\n  const { proteinPct: conditionedProtein, fatPct: conditionedFat, carbPct: conditionedCarb, fiberTarget, sugarCap } =\n    applyConditionAdjustments(baseSplit, conditions)\n\n  const { proteinPct, fatPct, carbPct, fiberBonus } = applyBodyTypeAdjustments(\n    { proteinPct: conditionedProtein, fatPct: conditionedFat, carbPct: conditionedCarb },\n    input.bodyType,\n  )\n\n  const proteinCalories = targetCalories * proteinPct\n  const carbCalories = targetCalories * carbPct\n  const fatCalories = targetCalories * fatPct\n\n  const protein = Math.round(proteinCalories / 4)\n  const carbs = Math.round(carbCalories / 4)\n  const fat = Math.round(fatCalories / 9)\n  const fiber = Math.round(fiberTarget + fiberBonus)\n  const sugarMax = Math.round(\n    Math.min(\n      sugarCap,\n      targetCalories > 0 ? targetCalories * 0.12 / 4 : sugarCap // default to ~12% kcal cap if stricter\n    )\n  )\n\n  const base: DailyTargets = {\n    calories: targetCalories,\n    protein,\n    carbs,\n    fat,\n    fiber,\n    sugarMax,\n  }\n\n  // Diet-based macro adjustments:\n  // - Some diets are mainly \"food rules\" (e.g., gluten-free) and should not change macros.\n  // - Some diets are mainly \"macro rules\" (e.g., keto, low-carb) and should clamp carbs and rebalance.\n  // These are starting-point targets, not medical advice.\n  const dietTypes = normalizeDietTypes(input.dietTypes)\n  if (!dietTypes.length) return base\n\n  type DietMacroRule = {\n    carbsMaxG?: number\n    sugarMaxG?: number\n    proteinMinGPerKg?: number\n    // Optional \"typical\" split guidance; carbsMax still wins as a hard cap.\n    split?: { proteinPct: number; fatPct: number; carbPct: number }\n  }\n\n  // Defaults are based on common public guidance from major nutrition/health sources and mainstream macro-tracking apps:\n  // - Keto: often ~5% carbs / 25% protein / 70% fat, and 20‚Äì50g carbs/day.\n  // - Low-carb: commonly defined as <130g carbs/day.\n  // - Atkins: commonly described by plans like ~20g / 40g / 100g net carbs; we treat it as a strict low-carb cap.\n  // - Carnivore/Zero-carb/Lion: typically near-zero carbs.\n  // - High-protein/bodybuilding: protein floor is often described in g/kg/day ranges for active people.\n  const RULES: Record<string, DietMacroRule> = {\n    keto: { carbsMaxG: 30, sugarMaxG: 25, split: { proteinPct: 0.25, fatPct: 0.7, carbPct: 0.05 } },\n    'keto-carnivore': { carbsMaxG: 20, sugarMaxG: 15, split: { proteinPct: 0.25, fatPct: 0.7, carbPct: 0.05 } },\n    'low-carb': { carbsMaxG: 130 },\n    atkins: { carbsMaxG: 40, sugarMaxG: 30 },\n    'zero-carb': { carbsMaxG: 10, sugarMaxG: 5, split: { proteinPct: 0.3, fatPct: 0.7, carbPct: 0.0 } },\n    carnivore: { carbsMaxG: 10, sugarMaxG: 5, split: { proteinPct: 0.3, fatPct: 0.7, carbPct: 0.0 } },\n    lion: { carbsMaxG: 10, sugarMaxG: 5, split: { proteinPct: 0.3, fatPct: 0.7, carbPct: 0.0 } },\n    diabetic: { carbsMaxG: 160, sugarMaxG: 25 },\n    'high-protein': { proteinMinGPerKg: 1.6 },\n    bodybuilding: { proteinMinGPerKg: 1.8 },\n  }\n\n  const rules = dietTypes.map((d) => RULES[d]).filter(Boolean) as DietMacroRule[]\n  if (!rules.length) return base\n\n  const carbsMaxG = rules.reduce<number | null>((min, r) => {\n    if (typeof r.carbsMaxG !== 'number') return min\n    return min === null ? r.carbsMaxG : Math.min(min, r.carbsMaxG)\n  }, null)\n\n  const sugarMaxG = rules.reduce<number | null>((min, r) => {\n    if (typeof r.sugarMaxG !== 'number') return min\n    return min === null ? r.sugarMaxG : Math.min(min, r.sugarMaxG)\n  }, null)\n\n  const proteinMinGPerKg = rules.reduce<number | null>((max, r) => {\n    if (typeof r.proteinMinGPerKg !== 'number') return max\n    return max === null ? r.proteinMinGPerKg : Math.max(max, r.proteinMinGPerKg)\n  }, null)\n\n  const splitRule = (() => {\n    const priority = ['zero-carb', 'carnivore', 'lion', 'keto-carnivore', 'keto', 'atkins', 'low-carb', 'diabetic']\n    for (const id of priority) {\n      const rule = RULES[id]\n      if (rule?.split && dietTypes.includes(id)) return rule.split\n    }\n    return null\n  })()\n\n  const calories = base.calories\n  if (!calories || calories <= 0) return base\n\n  let nextCarbs = typeof base.carbs === 'number' ? base.carbs : 0\n  if (splitRule) {\n    nextCarbs = Math.round((calories * splitRule.carbPct) / 4)\n  }\n  if (carbsMaxG !== null) nextCarbs = Math.min(nextCarbs, carbsMaxG)\n  nextCarbs = Math.max(0, Math.round(nextCarbs))\n\n  const minProtein = (() => {\n    if (proteinMinGPerKg === null) return 0\n    if (!weightKg || weightKg <= 0) return 0\n    return Math.round(weightKg * proteinMinGPerKg)\n  })()\n\n  let nextProtein = typeof base.protein === 'number' ? base.protein : 0\n  if (splitRule) {\n    nextProtein = Math.round((calories * splitRule.proteinPct) / 4)\n  }\n  nextProtein = Math.max(nextProtein, minProtein)\n  nextProtein = Math.max(0, Math.round(nextProtein))\n\n  // Ensure macros fit inside total calories. If they don't, reduce carbs first, then protein (but not below minProtein).\n  const adjustDownToFit = () => {\n    const used = nextProtein * 4 + nextCarbs * 4\n    const room = calories - used\n    if (room >= 0) return\n\n    // Try reducing carbs to 0 first.\n    const need = Math.abs(room)\n    const reducibleCarbCals = nextCarbs * 4\n    const carbCutCals = Math.min(reducibleCarbCals, need)\n    nextCarbs = Math.max(0, Math.round((reducibleCarbCals - carbCutCals) / 4))\n    const usedAfterCarb = nextProtein * 4 + nextCarbs * 4\n    const roomAfterCarb = calories - usedAfterCarb\n    if (roomAfterCarb >= 0) return\n\n    // Then reduce protein, but keep minProtein.\n    const need2 = Math.abs(roomAfterCarb)\n    const reducibleProteinG = Math.max(0, nextProtein - minProtein)\n    const reducibleProteinCals = reducibleProteinG * 4\n    const proteinCutCals = Math.min(reducibleProteinCals, need2)\n    nextProtein = Math.max(minProtein, Math.round(nextProtein - proteinCutCals / 4))\n  }\n  adjustDownToFit()\n\n  const remainingCalories = calories - (nextProtein * 4 + nextCarbs * 4)\n  const nextFat = Math.max(0, Math.round(remainingCalories / 9))\n\n  return {\n    ...base,\n    protein: nextProtein,\n    carbs: nextCarbs,\n    fat: nextFat,\n    sugarMax: typeof base.sugarMax === 'number'\n      ? Math.round(Math.min(base.sugarMax, sugarMaxG ?? base.sugarMax))\n      : sugarMaxG,\n  }\n}\n","truncated":false,"size":18439},{"path":"lib/diets.ts","content":"export type DietOption = {\n  id: string\n  label: string\n  group: string\n  summary: string\n}\n\nexport type DietCategory = {\n  id: string\n  label: string\n  group: string\n  subtitle: string\n  icon: string\n}\n\nexport const DIET_CATEGORIES: DietCategory[] = [\n  {\n    id: 'animal-focused',\n    label: 'Animal-Focused Diets',\n    group: 'Animal-Focused',\n    subtitle: 'Carnivore, Paleo, Primal',\n    icon: 'skillet',\n  },\n  {\n    id: 'plant-based',\n    label: 'Plant-Based Diets',\n    group: 'Plant-Based',\n    subtitle: 'Vegan, Vegetarian, WFPB',\n    icon: 'eco',\n  },\n  {\n    id: 'mixed-balanced',\n    label: 'Mixed / Balanced Diets',\n    group: 'Mixed / Balanced',\n    subtitle: 'Mediterranean, Nordic',\n    icon: 'restaurant',\n  },\n  {\n    id: 'low-carb',\n    label: 'Low-Carb / Carb-Restricted',\n    group: 'Low-Carb',\n    subtitle: 'Keto, Atkins, Zero-Carb',\n    icon: 'egg',\n  },\n  {\n    id: 'grain-gluten',\n    label: 'Grain / Gluten / Carb-Free',\n    group: 'Grain / Gluten',\n    subtitle: 'Gluten-Free, Grain-Free',\n    icon: 'grain',\n  },\n  {\n    id: 'timing-based',\n    label: 'Calorie / Timing-Based',\n    group: 'Timing-Based',\n    subtitle: 'Intermittent Fasting, OMAD',\n    icon: 'timer',\n  },\n  {\n    id: 'medical-therapeutic',\n    label: 'Medical / Therapeutic',\n    group: 'Medical / Therapeutic',\n    subtitle: 'Diabetic, Low-FODMAP, Renal',\n    icon: 'monitor_heart',\n  },\n  {\n    id: 'ethical-lifestyle',\n    label: 'Ethical / Lifestyle-Driven',\n    group: 'Ethical / Lifestyle',\n    subtitle: 'Halal, Kosher, Jain',\n    icon: 'public',\n  },\n  {\n    id: 'performance-goal',\n    label: 'Performance / Goal-Based',\n    group: 'Performance / Goal-Based',\n    subtitle: 'High-Protein, Cutting, Bulking',\n    icon: 'fitness_center',\n  },\n]\n\nexport const DIET_OPTIONS: DietOption[] = [\n  // Animal-Focused\n  { id: 'carnivore', label: 'Carnivore', group: 'Animal-Focused', summary: 'Animal foods only.' },\n  { id: 'lion', label: 'Lion Diet', group: 'Animal-Focused', summary: 'Ruminant meat, salt, water.' },\n  { id: 'keto-carnivore', label: 'Keto Carnivore', group: 'Animal-Focused', summary: 'Carnivore with a fat emphasis.' },\n  { id: 'paleo-animal-leaning', label: 'Paleo (Animal-leaning)', group: 'Animal-Focused', summary: 'Meat, fish, eggs, plus some plants.' },\n  { id: 'primal', label: 'Primal', group: 'Animal-Focused', summary: 'Paleo plus some dairy.' },\n\n  // Plant-Based\n  { id: 'vegan', label: 'Vegan', group: 'Plant-Based', summary: 'No animal products.' },\n  { id: 'vegetarian', label: 'Vegetarian', group: 'Plant-Based', summary: 'No meat.' },\n  { id: 'lacto-vegetarian', label: 'Lacto-Vegetarian', group: 'Plant-Based', summary: 'Dairy allowed, no eggs or meat.' },\n  { id: 'ovo-vegetarian', label: 'Ovo-Vegetarian', group: 'Plant-Based', summary: 'Eggs allowed, no dairy or meat.' },\n  { id: 'lacto-ovo-vegetarian', label: 'Lacto-Ovo Vegetarian', group: 'Plant-Based', summary: 'Dairy and eggs allowed, no meat.' },\n  { id: 'wfpb', label: 'Whole-Food Plant-Based (WFPB)', group: 'Plant-Based', summary: 'Vegan with minimal processing.' },\n  { id: 'raw-vegan', label: 'Raw Vegan', group: 'Plant-Based', summary: 'Mostly uncooked plant foods.' },\n\n  // Mixed / Balanced\n  { id: 'omnivore', label: 'Omnivore', group: 'Mixed / Balanced', summary: 'Animal and plant foods.' },\n  { id: 'flexitarian', label: 'Flexitarian', group: 'Mixed / Balanced', summary: 'Mostly plant-based, sometimes meat.' },\n  { id: 'mediterranean', label: 'Mediterranean', group: 'Mixed / Balanced', summary: 'Fish, olive oil, vegetables, low red meat.' },\n  { id: 'nordic', label: 'Nordic Diet', group: 'Mixed / Balanced', summary: 'Fish, root vegetables, whole grains.' },\n  { id: 'traditional-ancestral', label: 'Traditional Ancestral Diet', group: 'Mixed / Balanced', summary: 'Region-specific whole foods.' },\n\n  // Low-Carb / Carb-Restricted\n  { id: 'keto', label: 'Ketogenic (Keto)', group: 'Low-Carb', summary: 'Very low carb, higher fat.' },\n  { id: 'low-carb', label: 'Low-Carb', group: 'Low-Carb', summary: 'Reduced carbs, not strict keto.' },\n  { id: 'atkins', label: 'Atkins', group: 'Low-Carb', summary: 'Phased low-carb.' },\n  { id: 'zero-carb', label: 'Zero-Carb', group: 'Low-Carb', summary: 'No digestible carbs.' },\n\n  // Grain / Gluten / Carb-Free\n  { id: 'gluten-free', label: 'Gluten-Free', group: 'Grain / Gluten', summary: 'Avoid gluten.' },\n  { id: 'grain-free', label: 'Grain-Free', group: 'Grain / Gluten', summary: 'Avoid grains.' },\n  { id: 'wheat-free', label: 'Wheat-Free', group: 'Grain / Gluten', summary: 'Avoid wheat.' },\n  { id: 'low-fodmap', label: 'Low-FODMAP', group: 'Grain / Gluten', summary: 'Gut-focused carb restriction.' },\n\n  // Calorie / Timing-Based\n  { id: 'intermittent-fasting', label: 'Intermittent Fasting (IF)', group: 'Timing-Based', summary: 'Eating-window based.' },\n  { id: 'omad', label: 'OMAD (One Meal a Day)', group: 'Timing-Based', summary: 'One meal per day.' },\n  { id: 'time-restricted', label: 'Time-Restricted Eating', group: 'Timing-Based', summary: 'Eat within a daily time window.' },\n  { id: 'calorie-restriction', label: 'Calorie Restriction', group: 'Timing-Based', summary: 'Lower total daily calories.' },\n\n  // Medical / Therapeutic\n  { id: 'low-histamine', label: 'Low-Histamine', group: 'Medical / Therapeutic', summary: 'Avoid common histamine triggers.' },\n  { id: 'low-oxalate', label: 'Low-Oxalate', group: 'Medical / Therapeutic', summary: 'Avoid high-oxalate foods.' },\n  { id: 'low-purine', label: 'Low-Purine', group: 'Medical / Therapeutic', summary: 'Avoid high-purine foods.' },\n  { id: 'renal', label: 'Renal Diet', group: 'Medical / Therapeutic', summary: 'Kidney-friendly choices.' },\n  { id: 'diabetic', label: 'Diabetic Diet', group: 'Medical / Therapeutic', summary: 'Carb and sugar-aware choices.' },\n  { id: 'gerd', label: 'GERD Diet', group: 'Medical / Therapeutic', summary: 'Avoid common reflux triggers.' },\n\n  // Ethical / Lifestyle-Driven\n  { id: 'halal', label: 'Halal', group: 'Ethical / Lifestyle', summary: 'Avoid pork and alcohol.' },\n  { id: 'kosher', label: 'Kosher', group: 'Ethical / Lifestyle', summary: 'Avoid pork and shellfish; don‚Äôt mix meat and dairy.' },\n  { id: 'jain', label: 'Jain Diet', group: 'Ethical / Lifestyle', summary: 'No meat, eggs, or root vegetables.' },\n  { id: 'buddhist-vegetarian', label: 'Buddhist Vegetarian', group: 'Ethical / Lifestyle', summary: 'Vegetarian; often avoids garlic/onion.' },\n\n  // Performance / Goal-Based\n  { id: 'bodybuilding', label: 'Bodybuilding Diet', group: 'Performance / Goal-Based', summary: 'High-protein, structured meals.' },\n  { id: 'high-protein', label: 'High-Protein Diet', group: 'Performance / Goal-Based', summary: 'Protein-focused.' },\n  { id: 'cutting-bulking', label: 'Cutting / Bulking Diets', group: 'Performance / Goal-Based', summary: 'Adjust calories for goals.' },\n  { id: 'athlete', label: 'Athlete-Specific Diets', group: 'Performance / Goal-Based', summary: 'Fuel for training and recovery.' },\n]\n\nexport const getDietOption = (id: string | null | undefined): DietOption | null => {\n  const key = (id || '').toString().trim()\n  if (!key) return null\n  return DIET_OPTIONS.find((d) => d.id === key) || null\n}\n\nexport const normalizeDietTypes = (raw: any): string[] => {\n  if (Array.isArray(raw)) {\n    return Array.from(\n      new Set(\n        raw\n          .filter((v) => typeof v === 'string')\n          .map((v) => v.trim())\n          .filter(Boolean),\n      ),\n    )\n  }\n  if (typeof raw === 'string') {\n    const v = raw.trim()\n    return v ? [v] : []\n  }\n  return []\n}\n\ntype DietCheckInput = {\n  dietId: string\n  itemNames?: string[]\n  analysisText?: string\n  totals?: {\n    calories?: any\n    protein_g?: any\n    carbs_g?: any\n    fat_g?: any\n    fiber_g?: any\n    sugar_g?: any\n  } | null\n}\n\nexport type DietCheckResult = {\n  warnings: string[]\n  suggestions: string[]\n}\n\nconst lower = (value: any) => (value || '').toString().toLowerCase()\n\nconst hasAny = (text: string, keywords: string[]) => keywords.some((k) => text.includes(k))\n\nconst normalizeTextBlob = (input: DietCheckInput) => {\n  const names = Array.isArray(input.itemNames) ? input.itemNames : []\n  const blob = `${input.analysisText || ''} ${names.join(' ')}`.toLowerCase()\n  return blob.replace(/\\s+/g, ' ').trim()\n}\n\nconst KEYWORDS = {\n  meat: [\n    'beef',\n    'steak',\n    'pork',\n    'bacon',\n    'ham',\n    'sausage',\n    'chicken',\n    'turkey',\n    'duck',\n    'lamb',\n    'mutton',\n    'venison',\n    'veal',\n    'salami',\n    'pepperoni',\n  ],\n  fishSeafood: ['fish', 'salmon', 'tuna', 'cod', 'trout', 'anchovy', 'sardine', 'shrimp', 'prawn', 'crab', 'lobster', 'shellfish', 'mussel', 'oyster'],\n  dairy: ['milk', 'cream', 'cheese', 'butter', 'yogurt', 'ghee', 'whey', 'casein', 'ice cream'],\n  eggs: ['egg', 'eggs', 'omelet', 'omelette', 'mayo', 'mayonnaise'],\n  honey: ['honey'],\n  grains: ['bread', 'bun', 'pasta', 'noodle', 'rice', 'oat', 'barley', 'rye', 'wheat', 'flour', 'cereal', 'cracker', 'wrap', 'tortilla'],\n  gluten: ['gluten', 'wheat', 'barley', 'rye', 'malt', 'semolina', 'spelt'],\n  legumes: ['bean', 'beans', 'lentil', 'chickpea', 'soy', 'tofu', 'tempeh', 'edamame'],\n  plantsCommon: ['salad', 'vegetable', 'veg', 'fruit', 'apple', 'banana', 'berries', 'tomato', 'broccoli', 'carrot', 'spinach', 'potato', 'rice', 'bread'],\n  roots: ['potato', 'onion', 'garlic', 'carrot', 'beet', 'turnip', 'radish', 'ginger'],\n  alcohol: ['beer', 'wine', 'whiskey', 'vodka', 'rum', 'gin', 'tequila', 'brandy', 'cider'],\n  sugary: ['cake', 'cookie', 'candy', 'soda', 'soft drink', 'syrup', 'sweet', 'chocolate', 'ice cream', 'dessert', 'pastry', 'donut', 'doughnut'],\n  processed: ['chips', 'crisps', 'soda', 'soft drink', 'candy', 'fast food', 'instant', 'processed'],\n  refluxTriggers: ['spicy', 'chili', 'pepperoni', 'coffee', 'caffeine', 'tomato', 'citrus', 'orange', 'lemon', 'lime', 'chocolate', 'mint', 'fried'],\n  lowFodmapCommon: ['garlic', 'onion', 'wheat', 'apple', 'pear', 'milk', 'honey', 'beans', 'lentil', 'chickpea'],\n  histamineCommon: ['aged cheese', 'parmesan', 'salami', 'pepperoni', 'smoked', 'fermented', 'soy sauce', 'vinegar', 'wine', 'beer', 'tuna', 'sardine', 'tomato'],\n  oxalateCommon: ['spinach', 'beet', 'almond', 'cashew', 'chocolate', 'rhubarb', 'sweet potato'],\n  purineCommon: ['liver', 'organ', 'anchovy', 'sardine', 'mackerel', 'mussel', 'beer'],\n  renalCommon: ['banana', 'potato', 'tomato', 'orange', 'avocado', 'spinach'],\n  ruminant: ['beef', 'steak', 'lamb', 'mutton', 'bison', 'venison'],\n  nonRuminantAnimal: ['chicken', 'turkey', 'pork', 'fish', 'salmon', 'tuna', 'shrimp', 'egg'],\n}\n\nconst addSuggestion = (suggestions: string[], value: string) => {\n  const clean = value.trim()\n  if (!clean) return\n  if (!suggestions.includes(clean)) suggestions.push(clean)\n}\n\nexport const checkDietCompatibility = (input: DietCheckInput): DietCheckResult => {\n  const dietId = (input.dietId || '').toString().trim()\n  const warnings: string[] = []\n  const suggestions: string[] = []\n  if (!dietId) return { warnings, suggestions }\n\n  const option = getDietOption(dietId)\n  const blob = normalizeTextBlob(input)\n  const carbs = Number(input.totals?.carbs_g)\n  const sugar = Number(input.totals?.sugar_g)\n  const hasMeat = hasAny(blob, KEYWORDS.meat)\n  const hasFish = hasAny(blob, KEYWORDS.fishSeafood)\n  const hasDairy = hasAny(blob, KEYWORDS.dairy)\n  const hasEggs = hasAny(blob, KEYWORDS.eggs)\n  const hasGluten = hasAny(blob, KEYWORDS.gluten)\n  const hasGrains = hasAny(blob, KEYWORDS.grains)\n\n  const maybeWarn = (condition: boolean, text: string) => {\n    if (!condition) return\n    warnings.push(text)\n  }\n\n  const basicSwapForAnimalProduct = () => {\n    addSuggestion(suggestions, 'Try tofu, tempeh, beans, or lentils as a swap.')\n    addSuggestion(suggestions, 'Try a plant-based milk or yogurt instead of dairy.')\n  }\n\n  switch (dietId) {\n    // Plant-based\n    case 'vegan':\n      maybeWarn(hasMeat || hasFish, 'This looks like it contains meat or seafood, which doesn‚Äôt fit a vegan diet.')\n      maybeWarn(hasDairy, 'This looks like it contains dairy, which doesn‚Äôt fit a vegan diet.')\n      maybeWarn(hasEggs, 'This looks like it contains eggs, which doesn‚Äôt fit a vegan diet.')\n      maybeWarn(hasAny(blob, KEYWORDS.honey), 'This looks like it contains honey, which doesn‚Äôt fit a vegan diet.')\n      if (warnings.length) basicSwapForAnimalProduct()\n      break\n    case 'vegetarian':\n      maybeWarn(hasMeat || hasFish, 'This looks like it contains meat or seafood, which doesn‚Äôt fit a vegetarian diet.')\n      if (warnings.length) addSuggestion(suggestions, 'Try tofu, tempeh, beans, or lentils as a swap for meat.')\n      break\n    case 'lacto-vegetarian':\n      maybeWarn(hasMeat || hasFish, 'This looks like it contains meat or seafood, which doesn‚Äôt fit a lacto-vegetarian diet.')\n      maybeWarn(hasEggs, 'This looks like it contains eggs, which doesn‚Äôt fit a lacto-vegetarian diet.')\n      if (warnings.length) addSuggestion(suggestions, 'Try beans or lentils instead of meat, and skip eggs.')\n      break\n    case 'ovo-vegetarian':\n      maybeWarn(hasMeat || hasFish, 'This looks like it contains meat or seafood, which doesn‚Äôt fit an ovo-vegetarian diet.')\n      maybeWarn(hasDairy, 'This looks like it contains dairy, which doesn‚Äôt fit an ovo-vegetarian diet.')\n      if (warnings.length) addSuggestion(suggestions, 'Try a dairy-free version (or swap dairy for a plant-based option).')\n      break\n    case 'lacto-ovo-vegetarian':\n      maybeWarn(hasMeat || hasFish, 'This looks like it contains meat or seafood, which doesn‚Äôt fit a lacto-ovo vegetarian diet.')\n      if (warnings.length) addSuggestion(suggestions, 'Try beans, lentils, or tofu as a swap for meat.')\n      break\n    case 'wfpb':\n      maybeWarn(hasMeat || hasFish || hasDairy || hasEggs, 'This looks like it contains animal products, which doesn‚Äôt fit a whole-food plant-based diet.')\n      maybeWarn(hasAny(blob, KEYWORDS.processed), 'This looks quite processed. Whole-food plant-based usually prefers less processed foods.')\n      if (warnings.length) addSuggestion(suggestions, 'Try a whole-food option (beans, lentils, vegetables, whole grains) instead.')\n      break\n    case 'raw-vegan':\n      maybeWarn(hasMeat || hasFish || hasDairy || hasEggs, 'This looks like it contains animal products, which doesn‚Äôt fit a raw vegan diet.')\n      maybeWarn(/fried|roast|baked|grilled|cooked/.test(blob), 'This looks cooked. Raw vegan is usually uncooked foods.')\n      if (warnings.length) addSuggestion(suggestions, 'Try raw options like salads, smoothies, or fresh fruit.')\n      break\n\n    // Animal-focused\n    case 'carnivore':\n      maybeWarn(hasAny(blob, KEYWORDS.plantsCommon) || hasGrains, 'This looks like it contains plant foods, which doesn‚Äôt fit a carnivore diet.')\n      if (Number.isFinite(carbs) && carbs > 10) {\n        warnings.push('This looks higher in carbs than most carnivore meals.')\n      }\n      if (Number.isFinite(sugar) && sugar > 5) {\n        warnings.push('This looks higher in sugar than most carnivore meals.')\n      }\n      if (warnings.length) addSuggestion(suggestions, 'Try a simple meat-only meal (e.g. steak, eggs, fish).')\n      break\n    case 'lion':\n      maybeWarn(hasAny(blob, KEYWORDS.nonRuminantAnimal) || hasAny(blob, KEYWORDS.plantsCommon) || hasDairy, 'Lion diet is usually ruminant meat only (plus salt/water). This meal may not fit.')\n      if (Number.isFinite(carbs) && carbs > 10) {\n        warnings.push('This looks higher in carbs than most lion diet meals.')\n      }\n      if (Number.isFinite(sugar) && sugar > 5) {\n        warnings.push('This looks higher in sugar than most lion diet meals.')\n      }\n      if (warnings.length) addSuggestion(suggestions, 'Try beef or lamb (simple, unseasoned) as a swap.')\n      break\n    case 'keto-carnivore':\n      maybeWarn(hasAny(blob, KEYWORDS.plantsCommon) || hasGrains, 'This looks like it contains plant foods, which may not fit keto carnivore.')\n      if (Number.isFinite(carbs) && carbs > 20) {\n        warnings.push('This looks higher in carbs than most keto carnivore meals.')\n      }\n      if (warnings.length) addSuggestion(suggestions, 'Try a fatty cut of meat with eggs or butter (if you allow dairy).')\n      break\n    case 'paleo-animal-leaning':\n      maybeWarn(hasGrains, 'Paleo usually avoids grains. This meal may not fit.')\n      maybeWarn(hasAny(blob, ['processed', 'soda', 'candy']), 'Paleo usually avoids processed foods. This meal may not fit.')\n      if (warnings.length) addSuggestion(suggestions, 'Try meat/fish with vegetables instead of grains.')\n      break\n    case 'primal':\n      maybeWarn(hasGrains, 'Primal usually avoids grains. This meal may not fit.')\n      if (warnings.length) addSuggestion(suggestions, 'Try meat/fish with vegetables; some dairy is usually okay for primal.')\n      break\n\n    // Low-carb\n    case 'keto':\n      if (Number.isFinite(carbs) && carbs > 40) {\n        warnings.push('This looks higher in carbs than most keto meals.')\n        addSuggestion(suggestions, 'Try a lower-carb swap (more protein/veg, less bread/rice/pasta).')\n      } else if (hasAny(blob, KEYWORDS.grains) || hasAny(blob, KEYWORDS.sugary)) {\n        warnings.push('This looks like it contains bread, pasta, rice, or sweets, which often don‚Äôt fit keto.')\n        addSuggestion(suggestions, 'Try a low-carb swap (salad, cauliflower rice, or extra veggies).')\n      }\n      break\n    case 'low-carb':\n      if (Number.isFinite(carbs) && carbs > 80) {\n        warnings.push('This looks high in carbs for a low-carb diet.')\n        addSuggestion(suggestions, 'Try smaller portions of bread/rice/pasta, and add more protein/veg.')\n      }\n      break\n    case 'atkins':\n      if (hasAny(blob, KEYWORDS.sugary) || hasAny(blob, KEYWORDS.grains)) {\n        warnings.push('This looks like it contains bread/pasta/sweets, which may not fit Atkins (depending on your phase).')\n        addSuggestion(suggestions, 'Try a lower-carb swap (salad, protein, vegetables).')\n      }\n      break\n    case 'zero-carb':\n      maybeWarn(Number.isFinite(carbs) ? carbs > 5 : hasAny(blob, KEYWORDS.grains) || hasAny(blob, KEYWORDS.sugary), 'This looks like it contains carbs, which may not fit zero-carb.')\n      if (warnings.length) addSuggestion(suggestions, 'Try a meat/egg/fish-based meal with no bread, rice, or fruit.')\n      break\n\n    // Grain / gluten\n    case 'gluten-free':\n      maybeWarn(hasGluten, 'This looks like it may contain gluten, which doesn‚Äôt fit a gluten-free diet.')\n      if (warnings.length) addSuggestion(suggestions, 'Try a gluten-free version (gluten-free bread/pasta) or a rice/potato swap.')\n      break\n    case 'grain-free':\n      maybeWarn(hasGrains, 'This looks like it contains grains, which doesn‚Äôt fit a grain-free diet.')\n      if (warnings.length) addSuggestion(suggestions, 'Try a grain-free swap (vegetables, potatoes, or salad).')\n      break\n    case 'wheat-free':\n      maybeWarn(hasAny(blob, ['wheat', 'flour', 'bread', 'pasta', 'noodle']), 'This looks like it may contain wheat, which doesn‚Äôt fit a wheat-free diet.')\n      if (warnings.length) addSuggestion(suggestions, 'Try a wheat-free version (gluten-free bread/pasta) or rice.')\n      break\n    case 'low-fodmap':\n      maybeWarn(hasAny(blob, KEYWORDS.lowFodmapCommon), 'This may include common high-FODMAP foods (like garlic, onion, wheat, beans, milk, or certain fruits).')\n      if (warnings.length) addSuggestion(suggestions, 'Try a simpler version without garlic/onion, and use gluten-free grains if needed.')\n      break\n\n    // Timing-based (no food-specific conflicts)\n    case 'intermittent-fasting':\n    case 'omad':\n    case 'time-restricted':\n    case 'calorie-restriction':\n      // No specific ‚Äúagainst the diet‚Äù food keywords here.\n      break\n\n    // Medical / therapeutic\n    case 'low-histamine':\n      maybeWarn(hasAny(blob, KEYWORDS.histamineCommon), 'This may include common histamine triggers (like aged cheese, fermented foods, alcohol, or certain fish).')\n      if (warnings.length) addSuggestion(suggestions, 'Try fresh, simple foods (fresh meat, rice, most vegetables).')\n      break\n    case 'low-oxalate':\n      maybeWarn(hasAny(blob, KEYWORDS.oxalateCommon), 'This may include high-oxalate foods (like spinach, almonds, or chocolate).')\n      if (warnings.length) addSuggestion(suggestions, 'Try a lower-oxalate swap (most meats, dairy, and many vegetables).')\n      break\n    case 'low-purine':\n      maybeWarn(hasAny(blob, KEYWORDS.purineCommon), 'This may include high-purine foods (like organ meats, sardines, or beer).')\n      if (warnings.length) addSuggestion(suggestions, 'Try lean proteins and plenty of water.')\n      break\n    case 'renal':\n      maybeWarn(hasAny(blob, KEYWORDS.renalCommon), 'This may include foods that can be tricky on a renal diet (like banana, potato, tomato, or avocado).')\n      if (warnings.length) addSuggestion(suggestions, 'Consider kidney-friendly swaps based on your plan (ask your clinician for the exact rules).')\n      break\n    case 'diabetic':\n      if (Number.isFinite(sugar) && sugar > 25) {\n        warnings.push('This looks high in sugar for a diabetic-friendly meal.')\n        addSuggestion(suggestions, 'Try a lower-sugar swap (more protein/veg, fewer sweets).')\n      } else if (Number.isFinite(carbs) && carbs > 80) {\n        warnings.push('This looks high in carbs for a diabetic-friendly meal.')\n        addSuggestion(suggestions, 'Try smaller portions of bread/rice/pasta and add more protein/veg.')\n      }\n      break\n    case 'gerd':\n      maybeWarn(hasAny(blob, KEYWORDS.refluxTriggers), 'This may include common reflux triggers (spicy foods, coffee, citrus, tomato, chocolate, or fried foods).')\n      if (warnings.length) addSuggestion(suggestions, 'Try a milder version (less spicy, less fried, smaller portions).')\n      break\n\n    // Ethical / lifestyle\n    case 'halal':\n      maybeWarn(hasAny(blob, ['pork', 'bacon', 'ham']), 'This looks like it contains pork, which doesn‚Äôt fit halal.')\n      maybeWarn(hasAny(blob, KEYWORDS.alcohol), 'This looks like it contains alcohol, which doesn‚Äôt fit halal.')\n      if (warnings.length) addSuggestion(suggestions, 'Try a halal-certified option (chicken, beef, or lamb) and skip alcohol.')\n      break\n    case 'kosher': {\n      const hasPork = hasAny(blob, ['pork', 'bacon', 'ham'])\n      const hasShellfish = hasAny(blob, ['shrimp', 'prawn', 'crab', 'lobster', 'shellfish', 'mussel', 'oyster'])\n      maybeWarn(hasPork, 'This looks like it contains pork, which doesn‚Äôt fit kosher.')\n      maybeWarn(hasShellfish, 'This looks like it contains shellfish, which doesn‚Äôt fit kosher.')\n      // Very simple meat + dairy mixing check\n      const meatish = hasMeat || hasFish\n      const dairyish = hasDairy\n      maybeWarn(meatish && dairyish, 'This may mix meat and dairy, which doesn‚Äôt fit kosher rules.')\n      if (warnings.length) addSuggestion(suggestions, 'Try a kosher-certified version (and avoid mixing meat and dairy).')\n      break\n    }\n    case 'jain':\n      maybeWarn(hasMeat || hasFish, 'This looks like it contains meat or seafood, which doesn‚Äôt fit a Jain diet.')\n      maybeWarn(hasEggs, 'This looks like it contains eggs, which doesn‚Äôt fit a Jain diet.')\n      maybeWarn(hasAny(blob, KEYWORDS.roots), 'This may include root vegetables (like onion, garlic, or potato), which often don‚Äôt fit a Jain diet.')\n      if (warnings.length) addSuggestion(suggestions, 'Try Jain-friendly meals with non-root vegetables, legumes, and grains (as allowed).')\n      break\n    case 'buddhist-vegetarian':\n      maybeWarn(hasMeat || hasFish, 'This looks like it contains meat or seafood, which may not fit Buddhist vegetarian choices.')\n      maybeWarn(hasAny(blob, ['garlic', 'onion']), 'Some Buddhist vegetarian plans avoid garlic/onion. This meal may not fit.')\n      if (warnings.length) addSuggestion(suggestions, 'Try a vegetarian version without garlic/onion if that matters for you.')\n      break\n\n    // Mixed / balanced + performance (no strict checks)\n    default:\n      // For all other diet IDs, keep it quiet unless we can offer something helpful.\n      break\n  }\n\n  return { warnings, suggestions }\n}\n\nexport type MultiDietCheckResult = {\n  warningsByDiet: Array<{ dietId: string; dietLabel: string; warnings: string[] }>\n  suggestions: string[]\n}\n\nexport const checkMultipleDietCompatibility = (input: Omit<DietCheckInput, 'dietId'> & { dietIds: string[] }): MultiDietCheckResult => {\n  const dietIds = normalizeDietTypes(input.dietIds)\n  const warningsByDiet: Array<{ dietId: string; dietLabel: string; warnings: string[] }> = []\n  const suggestions: string[] = []\n\n  for (const dietId of dietIds) {\n    const option = getDietOption(dietId)\n    const single = checkDietCompatibility({\n      dietId,\n      itemNames: input.itemNames,\n      analysisText: input.analysisText,\n      totals: input.totals,\n    })\n    if (single.warnings.length) {\n      warningsByDiet.push({\n        dietId,\n        dietLabel: option?.label || dietId,\n        warnings: single.warnings,\n      })\n    }\n    for (const s of single.suggestions) {\n      if (!suggestions.includes(s)) suggestions.push(s)\n    }\n  }\n\n  return { warningsByDiet, suggestions }\n}\n","truncated":false,"size":25235},{"path":"lib/email-footer.ts","content":"/**\n * Reusable email footer component for all Helfi emails\n * This ensures legal compliance with unsubscribe requirements (CAN-SPAM, GDPR, etc.)\n * \n * IMPORTANT: All emails sent from Helfi MUST include this footer\n */\n\nexport interface EmailFooterOptions {\n  recipientEmail: string\n  emailType?: 'waitlist' | 'welcome' | 'verification' | 'admin' | 'support' | 'marketing' | 'transactional'\n  reasonText?: string // Custom reason text (e.g., \"You received this email because you joined our waitlist\")\n}\n\n/**\n * Generates the unsubscribe URL for a given email address\n */\nexport function getUnsubscribeUrl(email: string): string {\n  const encodedEmail = encodeURIComponent(email)\n  return `https://helfi.ai/api/unsubscribe?email=${encodedEmail}`\n}\n\n/**\n * Generates the standard email footer HTML with unsubscribe link\n * This footer MUST be included in all marketing and transactional emails\n */\nexport function getEmailFooter(options: EmailFooterOptions): string {\n  const { recipientEmail, emailType = 'transactional', reasonText } = options\n  \n  // Default reason text based on email type\n  const defaultReasonText = reasonText || (() => {\n    switch (emailType) {\n      case 'waitlist':\n        return 'You received this email because you joined our waitlist.'\n      case 'welcome':\n        return 'You received this email because you created a Helfi account.'\n      case 'verification':\n        return 'You received this email because you signed up for Helfi.'\n      case 'marketing':\n        return 'You received this email because you are subscribed to Helfi updates.'\n      case 'admin':\n      case 'support':\n        return 'You received this email from the Helfi support team.'\n      default:\n        return 'You received this email from Helfi.'\n    }\n  })()\n\n  const unsubscribeUrl = getUnsubscribeUrl(recipientEmail)\n\n  return `\n    <div style=\"margin-top: 40px; padding-top: 30px; border-top: 1px solid #e5e7eb; font-size: 14px; color: #6b7280; text-align: center;\">\n      <p style=\"margin: 0 0 16px 0; font-size: 16px; color: #374151;\"><strong>Best regards,<br>The Helfi Team</strong></p>\n      <p style=\"margin: 20px 0 0 0; font-size: 14px;\">\n        <a href=\"https://helfi.ai\" style=\"color: #10b981; text-decoration: none; font-weight: 500;\">üåê helfi.ai</a> | \n        <a href=\"mailto:support@helfi.ai\" style=\"color: #10b981; text-decoration: none; font-weight: 500;\">üìß support@helfi.ai</a>\n      </p>\n      <div style=\"margin-top: 24px; padding-top: 20px; border-top: 1px solid #e5e7eb;\">\n        <p style=\"margin: 0 0 12px 0; font-size: 12px; color: #9ca3af; line-height: 1.6;\">\n          ${defaultReasonText}\n        </p>\n        <p style=\"margin: 0; font-size: 12px; color: #9ca3af;\">\n          <a href=\"${unsubscribeUrl}\" style=\"color: #10b981; text-decoration: underline; font-weight: 500;\">Unsubscribe from emails</a> | \n          <a href=\"https://helfi.ai/privacy\" style=\"color: #10b981; text-decoration: none;\">Privacy Policy</a>\n        </p>\n        <p style=\"margin: 12px 0 0 0; font-size: 11px; color: #9ca3af;\">\n          ¬© ${new Date().getFullYear()} Helfi. All rights reserved.\n        </p>\n      </div>\n    </div>\n  `\n}\n\n","truncated":false,"size":3160},{"path":"lib/encryption.ts","content":"/**\n * Encryption utilities for PDF lab report data\n * Uses AES-256-GCM for field-level encryption\n * Encryption keys are derived from a master key stored in environment variables\n */\n\nimport { createCipheriv, createDecipheriv, randomBytes, scrypt, createHash } from 'crypto';\nimport { promisify } from 'util';\n\nconst scryptAsync = promisify(scrypt);\n\nconst ALGORITHM = 'aes-256-gcm';\nconst IV_LENGTH = 12; // 96 bits for GCM\nconst SALT_LENGTH = 32;\nconst TAG_LENGTH = 16; // 128 bits for GCM authentication tag\nconst KEY_LENGTH = 32; // 256 bits\n\n// Get or generate master encryption key from environment\nfunction getMasterKey(): Buffer {\n  const masterKeyEnv = process.env.ENCRYPTION_MASTER_KEY;\n  \n  if (!masterKeyEnv) {\n    throw new Error('ENCRYPTION_MASTER_KEY environment variable is required. Generate one with: openssl rand -base64 32');\n  }\n  \n  // If it's base64 encoded, decode it; otherwise use it directly\n  try {\n    return Buffer.from(masterKeyEnv, 'base64');\n  } catch {\n    // If not base64, hash it to get consistent 32-byte key\n    return createHash('sha256').update(masterKeyEnv).digest();\n  }\n}\n\n/**\n * Derive a data encryption key (DEK) from master key with a salt\n * This ensures each record can have a unique key while using the master key\n */\nasync function deriveDataKey(salt: Buffer): Promise<Buffer> {\n  const masterKey = getMasterKey();\n  const key = (await scryptAsync(masterKey, salt, KEY_LENGTH)) as Buffer;\n  return key;\n}\n\n/**\n * Generate a random data encryption key (DEK)\n * For per-record encryption, we generate a unique key and encrypt it with the master key\n */\nfunction generateDataKey(): Buffer {\n  return randomBytes(KEY_LENGTH);\n}\n\n/**\n * Encrypt a data encryption key using the master key\n * This is our \"envelope encryption\" - encrypting keys with keys\n */\nasync function encryptDataKey(dataKey: Buffer, salt: Buffer): Promise<string> {\n  const masterKey = getMasterKey();\n  const key = (await scryptAsync(masterKey, salt, KEY_LENGTH)) as Buffer;\n  \n  const iv = randomBytes(IV_LENGTH);\n  const cipher = createCipheriv(ALGORITHM, key, iv);\n  \n  let encrypted = cipher.update(dataKey, undefined, 'hex');\n  encrypted += cipher.final('hex');\n  \n  const tag = cipher.getAuthTag();\n  \n  // Return base64 encoded: salt:iv:encrypted:tag\n  return Buffer.from(`${salt.toString('hex')}:${iv.toString('hex')}:${encrypted}:${tag.toString('hex')}`).toString('base64');\n}\n\n/**\n * Decrypt a data encryption key using the master key\n */\nasync function decryptDataKey(encryptedKeyBase64: string): Promise<Buffer> {\n  const parts = Buffer.from(encryptedKeyBase64, 'base64').toString('utf8').split(':');\n  if (parts.length !== 4) {\n    throw new Error('Invalid encrypted key format');\n  }\n  \n  const [saltHex, ivHex, encrypted, tagHex] = parts;\n  const salt = Buffer.from(saltHex, 'hex');\n  const iv = Buffer.from(ivHex, 'hex');\n  const tag = Buffer.from(tagHex, 'hex');\n  \n  const masterKey = getMasterKey();\n  const key = (await scryptAsync(masterKey, salt, KEY_LENGTH)) as Buffer;\n  \n  const decipher = createDecipheriv(ALGORITHM, key, iv);\n  decipher.setAuthTag(tag);\n  \n  let decrypted = decipher.update(encrypted, 'hex');\n  decrypted = Buffer.concat([decrypted, decipher.final()]);\n  \n  return decrypted;\n}\n\n/**\n * Derive encryption key from password using scrypt\n * Used for password-protected PDFs (ephemeral, not stored)\n */\nasync function deriveKeyFromPassword(password: string, salt: Buffer): Promise<Buffer> {\n  const key = (await scryptAsync(password, salt, KEY_LENGTH)) as Buffer;\n  return key;\n}\n\n/**\n * Encrypt data using AES-256-GCM\n */\nfunction encryptWithAES(data: string, key: Buffer): { encrypted: string; iv: string; tag: string } {\n  const iv = randomBytes(IV_LENGTH);\n  const cipher = createCipheriv(ALGORITHM, key, iv);\n  \n  let encrypted = cipher.update(data, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  \n  const tag = cipher.getAuthTag();\n  \n  return {\n    encrypted,\n    iv: iv.toString('hex'),\n    tag: tag.toString('hex'),\n  };\n}\n\n/**\n * Decrypt data using AES-256-GCM\n */\nfunction decryptWithAES(\n  encrypted: string,\n  key: Buffer,\n  iv: string,\n  tag: string\n): string {\n  const ivBuffer = Buffer.from(iv, 'hex');\n  const tagBuffer = Buffer.from(tag, 'hex');\n  const decipher = createDecipheriv(ALGORITHM, key, ivBuffer);\n  decipher.setAuthTag(tagBuffer);\n  \n  let decrypted = decipher.update(encrypted, 'hex', 'utf8');\n  decrypted += decipher.final('utf8');\n  \n  return decrypted;\n}\n\n/**\n * Encrypt a field value with AES-256-GCM and wrap the key\n * Returns a JSON string containing encrypted data, IV, tag, and wrapped key\n */\nexport async function encryptField(value: string): Promise<string> {\n  if (!value) {\n    return '';\n  }\n\n  // Generate a data encryption key for this field\n  const dataKey = generateDataKey();\n  const salt = randomBytes(SALT_LENGTH);\n  \n  // Encrypt the value\n  const { encrypted, iv, tag } = encryptWithAES(value, dataKey);\n  \n  // Wrap the data key with master key\n  const wrappedKey = await encryptDataKey(dataKey, salt);\n  \n  // Return JSON string with all components\n  return JSON.stringify({\n    encrypted,\n    iv,\n    tag,\n    wrappedKey,\n  });\n}\n\n/**\n * Decrypt a field value that was encrypted with encryptField\n */\nexport async function decryptField(encryptedDataJson: string): Promise<string> {\n  if (!encryptedDataJson) {\n    return '';\n  }\n\n  try {\n    const { encrypted, iv, tag, wrappedKey } = JSON.parse(encryptedDataJson);\n    \n    // Unwrap the data key\n    const dataKey = await decryptDataKey(wrappedKey);\n    \n    // Decrypt the value\n    return decryptWithAES(encrypted, dataKey, iv, tag);\n  } catch (error) {\n    console.error('‚ùå Field decryption failed:', error);\n    throw new Error(`Failed to decrypt field: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n}\n\n/**\n * Encrypt multiple fields in batch (more efficient for multiple lab results)\n * Returns encrypted data with a single wrapped key for all fields\n */\nexport async function encryptFieldsBatch(fields: Record<string, string>): Promise<{\n  encryptedFields: Record<string, string>;\n  wrappedKey: string;\n}> {\n  // Generate a single data key for all fields\n  const dataKey = generateDataKey();\n  const salt = randomBytes(SALT_LENGTH);\n  const wrappedKey = await encryptDataKey(dataKey, salt);\n  \n  const encryptedFields: Record<string, string> = {};\n  \n  for (const [key, value] of Object.entries(fields)) {\n    if (value) {\n      const { encrypted, iv, tag } = encryptWithAES(value, dataKey);\n      encryptedFields[key] = JSON.stringify({ encrypted, iv, tag });\n    }\n  }\n  \n  return {\n    encryptedFields,\n    wrappedKey,\n  };\n}\n\n/**\n * Decrypt multiple fields that were encrypted with encryptFieldsBatch\n */\nexport async function decryptFieldsBatch(\n  encryptedFields: Record<string, string>,\n  wrappedKey: string\n): Promise<Record<string, string>> {\n  const dataKey = await decryptDataKey(wrappedKey);\n  const decryptedFields: Record<string, string> = {};\n  \n  for (const [key, encryptedDataJson] of Object.entries(encryptedFields)) {\n    try {\n      const { encrypted, iv, tag } = JSON.parse(encryptedDataJson);\n      decryptedFields[key] = decryptWithAES(encrypted, dataKey, iv, tag);\n    } catch (error) {\n      console.error(`‚ùå Failed to decrypt field ${key}:`, error);\n      decryptedFields[key] = '';\n    }\n  }\n  \n  return decryptedFields;\n}\n\n/**\n * Hash password for verification (ephemeral - not stored)\n * Uses scrypt with random salt\n */\nexport async function hashPasswordForVerification(password: string): Promise<{ hash: string; salt: string }> {\n  const salt = randomBytes(SALT_LENGTH);\n  const hash = (await scryptAsync(password, salt, 64)) as Buffer;\n  return {\n    hash: hash.toString('hex'),\n    salt: salt.toString('hex'),\n  };\n}\n\n/**\n * Verify password hash\n */\nexport async function verifyPasswordHash(\n  password: string,\n  hashHex: string,\n  saltHex: string\n): Promise<boolean> {\n  try {\n    const salt = Buffer.from(saltHex, 'hex');\n    const hash = (await scryptAsync(password, salt, 64)) as Buffer;\n    return hash.toString('hex') === hashHex;\n  } catch (error) {\n    return false;\n  }\n}\n","truncated":false,"size":8122},{"path":"lib/error-reporter.ts","content":"import { sendOwnerErrorAlertEmail } from '@/lib/admin-alerts'\n\ntype ErrorReportOptions = {\n  source: string\n  error: unknown\n  userId?: string\n  userEmail?: string\n  details?: Record<string, unknown>\n}\n\ntype ErrorReportCacheEntry = {\n  lastSentAt: number\n  count: number\n}\n\nconst REPORT_THROTTLE_MS = 60 * 60 * 1000\nconst MAX_DETAILS_LENGTH = 2000\n\nconst globalForErrorReporter = globalThis as typeof globalThis & {\n  __helfiErrorReportCache?: Map<string, ErrorReportCacheEntry>\n}\n\nconst cache = globalForErrorReporter.__helfiErrorReportCache ?? new Map<string, ErrorReportCacheEntry>()\nif (!globalForErrorReporter.__helfiErrorReportCache) {\n  globalForErrorReporter.__helfiErrorReportCache = cache\n}\n\nfunction normalizeError(error: unknown): { name: string; message: string; stack: string } {\n  if (error instanceof Error) {\n    return {\n      name: error.name || 'Error',\n      message: error.message || 'Unknown error',\n      stack: error.stack || '',\n    }\n  }\n  if (typeof error === 'string') {\n    return { name: 'Error', message: error, stack: '' }\n  }\n  return { name: 'Error', message: 'Unknown error', stack: '' }\n}\n\nfunction buildFingerprint(source: string, message: string): string {\n  const trimmed = (message || 'Unknown error').slice(0, 140)\n  return `${source}::${trimmed}`\n}\n\nfunction safeStringify(value: unknown): string {\n  try {\n    return JSON.stringify(value, null, 2)\n  } catch {\n    return String(value || '')\n  }\n}\n\nexport async function reportCriticalError(options: ErrorReportOptions): Promise<void> {\n  try {\n    const normalized = normalizeError(options.error)\n    const fingerprint = buildFingerprint(options.source, normalized.message)\n    const now = Date.now()\n    const entry = cache.get(fingerprint)\n\n    if (entry && now - entry.lastSentAt < REPORT_THROTTLE_MS) {\n      entry.count += 1\n      cache.set(fingerprint, entry)\n      return\n    }\n\n    const count = (entry?.count ?? 0) + 1\n    cache.set(fingerprint, { lastSentAt: now, count })\n\n    const detailsPayload = {\n      ...options.details,\n      errorName: normalized.name,\n      errorMessage: normalized.message,\n      errorStack: normalized.stack,\n    }\n    const details = safeStringify(detailsPayload).slice(0, MAX_DETAILS_LENGTH)\n\n    await sendOwnerErrorAlertEmail({\n      source: options.source,\n      message: normalized.message,\n      userId: options.userId,\n      userEmail: options.userEmail,\n      count,\n      details,\n    })\n  } catch (error) {\n    console.error('‚ùå [ERROR REPORTER] Failed to report error:', error)\n  }\n}\n","truncated":false,"size":2531},{"path":"lib/exercise/calories.ts","content":"export function calculateExerciseCalories(params: {\n  met: number\n  weightKg: number\n  durationMinutes: number\n}) {\n  const durationHours = params.durationMinutes / 60\n  return params.met * params.weightKg * durationHours\n}\n\n","truncated":false,"size":225},{"path":"lib/exercise/fitbit-workouts.ts","content":"export function parseFitbitActivitiesToIngest(params: { date: string; payload: any }) {\n  const items = Array.isArray(params.payload?.activities) ? params.payload.activities : []\n  return items\n    .map((a: any) => {\n      const logId = a?.logId ?? a?.activityLogId ?? a?.id\n      const deviceId = logId !== null && logId !== undefined ? String(logId) : ''\n      const startTimeRaw = a?.startTime || a?.startDate || a?.originalStartTime\n      const startTime = startTimeRaw ? new Date(String(startTimeRaw)) : null\n      const durationMs = Number(a?.duration ?? a?.activeDuration ?? 0)\n      const durationMinutes = Number.isFinite(durationMs) ? durationMs / 60000 : 0\n      const calories = Number(a?.calories ?? a?.activityCalories ?? a?.caloriesOut ?? 0)\n      const label = String(a?.activityName || a?.name || a?.activityTypeName || 'Fitbit activity')\n\n      if (!deviceId) return null\n      if (!Number.isFinite(durationMinutes) || durationMinutes <= 0) return null\n      if (!Number.isFinite(calories) || calories <= 0) return null\n\n      // Fitbit list can span multiple dates; filter to selected date when startTime is present.\n      if (startTime && !Number.isNaN(startTime.getTime())) {\n        const d = `${startTime.getFullYear()}-${String(startTime.getMonth() + 1).padStart(2, '0')}-${String(startTime.getDate()).padStart(2, '0')}`\n        if (d !== params.date) return null\n      }\n\n      return {\n        deviceId,\n        startTime: startTime && !Number.isNaN(startTime.getTime()) ? startTime : null,\n        durationMinutes,\n        calories,\n        label,\n        raw: a,\n      }\n    })\n    .filter(Boolean)\n}\n\n","truncated":false,"size":1630},{"path":"lib/exercise/garmin-workouts.ts","content":"export function extractGarminWorkouts(payload: any) {\n  const results: Array<{\n    deviceId: string\n    startTime: Date | null\n    durationMinutes: number\n    calories: number\n    label: string\n    raw: any\n  }> = []\n\n  const seen = new Set<string>()\n\n  const visit = (node: any) => {\n    if (!node) return\n    if (Array.isArray(node)) {\n      for (const item of node) visit(item)\n      return\n    }\n    if (typeof node !== 'object') return\n\n    const activityId = node.activityId ?? node.activitySummaryId ?? node.summaryId ?? node.id\n    const durationSeconds = node.durationInSeconds ?? node.duration ?? node.activeDurationInSeconds ?? null\n    const calories = node.activeKilocalories ?? node.totalKilocalories ?? node.calories ?? node.kilocalories ?? null\n    const startSeconds = node.startTimeInSeconds ?? node.startTimeInMillis ?? null\n    const startIso = node.startTime ?? node.startDate ?? null\n    const labelRaw = node.activityName ?? node.activityType ?? node.sport ?? node.type ?? 'Garmin activity'\n\n    const deviceId = activityId !== null && activityId !== undefined ? String(activityId) : ''\n    const durationMinutes =\n      Number.isFinite(Number(durationSeconds)) ? Number(durationSeconds) / 60 : 0\n    const kcal = Number(calories)\n\n    let startTime: Date | null = null\n    if (Number.isFinite(Number(startSeconds)) && Number(startSeconds) > 0) {\n      const millis = Number(startSeconds) > 9_999_999_999 ? Number(startSeconds) : Number(startSeconds) * 1000\n      const dt = new Date(millis)\n      startTime = Number.isNaN(dt.getTime()) ? null : dt\n    } else if (startIso) {\n      const dt = new Date(String(startIso))\n      startTime = Number.isNaN(dt.getTime()) ? null : dt\n    }\n\n    if (deviceId && durationMinutes > 0 && kcal > 0) {\n      const key = `${deviceId}:${startTime ? startTime.toISOString() : ''}:${Math.round(durationMinutes)}:${Math.round(kcal)}`\n      if (!seen.has(key)) {\n        seen.add(key)\n        results.push({\n          deviceId,\n          startTime,\n          durationMinutes,\n          calories: kcal,\n          label: String(labelRaw),\n          raw: node,\n        })\n      }\n    }\n\n    for (const value of Object.values(node)) {\n      visit(value)\n    }\n  }\n\n  visit(payload)\n  return results\n}\n\n","truncated":false,"size":2252},{"path":"lib/exercise/health-profile.ts","content":"import { prisma } from '@/lib/prisma'\n\nexport type HealthProfile = {\n  weightKg: number | null\n  heightCm: number | null\n  ageYears: number | null\n  primaryGoal: 'LOSE' | 'MAINTAIN' | 'GAIN' | 'SHRED' | null\n  intensity: 'MILD' | 'STANDARD' | 'AGGRESSIVE' | null\n  bodyType: 'ECTO' | 'MESO' | 'ENDO' | null\n}\n\nfunction calculateAgeYears(birthdate?: string | null): number | null {\n  if (!birthdate) return null\n  const [y, m, d] = birthdate.split('-').map((v) => parseInt(v, 10))\n  if (!y || !m || !d) return null\n  const today = new Date()\n  let age = today.getFullYear() - y\n  const monthDiff = today.getMonth() + 1 - m\n  const dayDiff = today.getDate() - d\n  if (monthDiff < 0 || (monthDiff === 0 && dayDiff < 0)) age -= 1\n  if (!Number.isFinite(age) || age <= 0 || age > 110) return null\n  return age\n}\n\nfunction mapGoal(choice?: string | null): HealthProfile['primaryGoal'] {\n  const v = (choice || '').toLowerCase()\n  if (v.includes('shred')) return 'SHRED'\n  if (v.includes('lose')) return 'LOSE'\n  if (v.includes('gain') || v.includes('bulk')) return 'GAIN'\n  if (v.includes('maintain')) return 'MAINTAIN'\n  return null\n}\n\nfunction mapIntensity(v?: string | null): HealthProfile['intensity'] {\n  const raw = (v || '').toLowerCase()\n  if (raw === 'mild') return 'MILD'\n  if (raw === 'aggressive') return 'AGGRESSIVE'\n  if (raw === 'standard') return 'STANDARD'\n  return null\n}\n\nfunction mapBodyType(v: any): HealthProfile['bodyType'] {\n  if (v === 'ECTOMORPH') return 'ECTO'\n  if (v === 'MESOMORPH') return 'MESO'\n  if (v === 'ENDOMORPH') return 'ENDO'\n  return null\n}\n\nexport async function getHealthProfileForUser(userId: string): Promise<HealthProfile> {\n  const user = await prisma.user.findUnique({\n    where: { id: userId },\n    include: { healthGoals: true },\n  })\n\n  if (!user) {\n    return {\n      weightKg: null,\n      heightCm: null,\n      ageYears: null,\n      primaryGoal: null,\n      intensity: null,\n      bodyType: null,\n    }\n  }\n\n  const profileInfoGoal = user.healthGoals.find((goal: any) => goal.name === '__PROFILE_INFO_DATA__')\n  let dateOfBirth = ''\n  try {\n    const parsed = profileInfoGoal?.category ? JSON.parse(profileInfoGoal.category) : null\n    if (parsed && typeof parsed?.dateOfBirth === 'string') dateOfBirth = parsed.dateOfBirth\n  } catch {\n    // ignore\n  }\n\n  const primaryGoalRecord = user.healthGoals.find((goal: any) => goal.name === '__PRIMARY_GOAL__')\n  let goalChoice = ''\n  let goalIntensity = ''\n  try {\n    const parsed = primaryGoalRecord?.category ? JSON.parse(primaryGoalRecord.category) : null\n    if (parsed && typeof parsed?.goalChoice === 'string') goalChoice = parsed.goalChoice\n    if (parsed && typeof parsed?.goalIntensity === 'string') goalIntensity = parsed.goalIntensity\n  } catch {\n    // ignore\n  }\n\n  return {\n    weightKg: typeof user.weight === 'number' && Number.isFinite(user.weight) ? user.weight : null,\n    heightCm: typeof user.height === 'number' && Number.isFinite(user.height) ? user.height : null,\n    ageYears: calculateAgeYears(dateOfBirth),\n    primaryGoal: mapGoal(goalChoice),\n    intensity: mapIntensity(goalIntensity),\n    bodyType: mapBodyType(user.bodyType),\n  }\n}\n\n","truncated":false,"size":3157},{"path":"lib/exercise/ingest.ts","content":"import { prisma } from '@/lib/prisma'\nimport { calculateExerciseCalories } from '@/lib/exercise/calories'\nimport { getHealthProfileForUser } from '@/lib/exercise/health-profile'\n\nexport type ExerciseIngestSource = 'FITBIT' | 'GARMIN'\n\nexport type IngestExerciseEntryInput = {\n  userId: string\n  source: ExerciseIngestSource\n  deviceId: string\n  localDate: string // YYYY-MM-DD\n  startTime?: Date | null\n  durationMinutes: number\n  calories?: number | null\n  met?: number | null\n  label: string\n  rawPayload?: any\n}\n\nexport async function ingestExerciseEntry(input: IngestExerciseEntryInput) {\n  const durationMinutes = Math.max(1, Math.min(24 * 60, Math.floor(input.durationMinutes)))\n  const deviceCalories = Number(input.calories)\n  const met = input.met !== null && input.met !== undefined ? Number(input.met) : null\n\n  let calories =\n    Number.isFinite(deviceCalories) && deviceCalories > 0 ? deviceCalories : null\n\n  if (calories === null && met !== null && Number.isFinite(met) && met > 0) {\n    const health = await getHealthProfileForUser(input.userId)\n    if (health.weightKg) {\n      calories = calculateExerciseCalories({\n        met,\n        weightKg: health.weightKg,\n        durationMinutes,\n      })\n    }\n  }\n\n  if (calories === null || !Number.isFinite(calories) || calories <= 0) {\n    return { created: false, entry: null as any }\n  }\n\n  const existing = await prisma.exerciseEntry.findFirst({\n    where: { userId: input.userId, source: input.source, deviceId: input.deviceId },\n  })\n\n  const data = {\n    userId: input.userId,\n    localDate: input.localDate,\n    startTime: input.startTime ?? null,\n    durationMinutes,\n    source: input.source,\n    deviceId: input.deviceId,\n    label: input.label,\n    met: met !== null && Number.isFinite(met) && met > 0 ? met : 0,\n    calories,\n    rawPayload: input.rawPayload ?? null,\n  } as const\n\n  if (existing) {\n    const entry = await prisma.exerciseEntry.update({\n      where: { id: existing.id },\n      data,\n    })\n    return { created: false, entry }\n  }\n\n  const entry = await prisma.exerciseEntry.create({ data })\n  return { created: true, entry }\n}\n\n","truncated":false,"size":2123},{"path":"lib/exercise/met.ts","content":"export function distanceBasedMet(params: { name: string; speedKmh: number }) {\n  const n = (params.name || '').toLowerCase()\n  const s = params.speedKmh\n  if (!Number.isFinite(s) || s <= 0) return null\n\n  if (n.includes('walk')) {\n    if (s < 4) return 2.8\n    if (s < 5.5) return 3.3\n    if (s < 6.8) return 4.3\n    return 6.5\n  }\n\n  if (n.includes('run') || n.includes('jog')) {\n    if (s < 8.5) return 7.0\n    if (s < 9.5) return 8.3\n    if (s < 11.5) return 9.8\n    return 11.5\n  }\n\n  if (n.includes('cycl') || n.includes('bike')) {\n    if (s < 16) return 4.0\n    if (s < 22) return 8.0\n    return 10.0\n  }\n\n  return null\n}\n\nexport function inferMetAndLabel(params: {\n  exerciseName: string\n  baseMet: number\n  durationMinutes: number\n  distanceKm?: number | null\n}) {\n  const durationMins = Math.max(1, Math.floor(params.durationMinutes))\n  const distanceKm =\n    params.distanceKm !== null && params.distanceKm !== undefined ? Number(params.distanceKm) : null\n\n  let met = params.baseMet\n  let label = params.exerciseName\n\n  if (distanceKm && Number.isFinite(distanceKm) && distanceKm > 0) {\n    const speedKmh = distanceKm / (durationMins / 60)\n    const inferredMet = distanceBasedMet({ name: params.exerciseName, speedKmh })\n    if (inferredMet) {\n      met = inferredMet\n      const lower = params.exerciseName.toLowerCase()\n      const base =\n        lower.includes('walk')\n          ? 'Walking'\n          : lower.includes('run') || lower.includes('jog')\n          ? 'Running'\n          : lower.includes('cycl') || lower.includes('bike')\n          ? 'Cycling'\n          : params.exerciseName\n      label = `${base} (${Math.round(speedKmh * 10) / 10} km/h)`\n    }\n  }\n\n  return { met, label, durationMinutes: durationMins }\n}\n\n","truncated":false,"size":1737},{"path":"lib/file-encryption.ts","content":"import { createCipheriv, createDecipheriv, createHash, randomBytes } from 'crypto'\n\nconst FILE_ALGORITHM = 'aes-256-gcm'\nconst FILE_IV_LENGTH = 12\nconst FILE_TAG_LENGTH = 16\nconst FILE_KEY_LENGTH = 32\n\nfunction getFileKey(): Buffer {\n  const masterKeyEnv = process.env.ENCRYPTION_MASTER_KEY\n  if (!masterKeyEnv) {\n    throw new Error('ENCRYPTION_MASTER_KEY environment variable is required')\n  }\n\n  try {\n    const decoded = Buffer.from(masterKeyEnv, 'base64')\n    if (decoded.length >= FILE_KEY_LENGTH) {\n      return decoded.subarray(0, FILE_KEY_LENGTH)\n    }\n  } catch {\n    // Fall back to hash-based key derivation below.\n  }\n\n  return createHash('sha256').update(masterKeyEnv).digest()\n}\n\nexport function encryptBuffer(input: Buffer): {\n  encrypted: Buffer\n  iv: string\n  tag: string\n} {\n  const iv = randomBytes(FILE_IV_LENGTH)\n  const key = getFileKey()\n  const cipher = createCipheriv(FILE_ALGORITHM, key, iv)\n\n  const encrypted = Buffer.concat([cipher.update(input), cipher.final()])\n  const tag = cipher.getAuthTag()\n\n  return {\n    encrypted,\n    iv: iv.toString('hex'),\n    tag: tag.toString('hex'),\n  }\n}\n\nexport function decryptBuffer(input: Buffer, ivHex: string, tagHex: string): Buffer {\n  if (!ivHex || !tagHex) {\n    throw new Error('Missing encryption metadata')\n  }\n\n  const iv = Buffer.from(ivHex, 'hex')\n  const tag = Buffer.from(tagHex, 'hex')\n  if (iv.length !== FILE_IV_LENGTH || tag.length !== FILE_TAG_LENGTH) {\n    throw new Error('Invalid encryption metadata')\n  }\n\n  const key = getFileKey()\n  const decipher = createDecipheriv(FILE_ALGORITHM, key, iv)\n  decipher.setAuthTag(tag)\n  return Buffer.concat([decipher.update(input), decipher.final()])\n}\n","truncated":false,"size":1681},{"path":"lib/fitbit-api.ts","content":"import { prisma } from '@/lib/prisma'\n\nexport interface FitbitTokens {\n  access_token: string\n  refresh_token: string\n  expires_at: number | null\n  token_type: string\n}\n\n/**\n * Get Fitbit account tokens for a user, refreshing if necessary\n */\nexport async function getFitbitTokens(userId: string): Promise<FitbitTokens | null> {\n  // Find Fitbit account for user\n  const fitbitAccount = await prisma.account.findFirst({\n    where: {\n      userId,\n      provider: 'fitbit',\n    },\n  })\n\n  if (!fitbitAccount || !fitbitAccount.access_token || !fitbitAccount.refresh_token) {\n    return null\n  }\n\n  // Check if token needs refresh (expires within 5 minutes)\n  const now = Math.floor(Date.now() / 1000)\n  const expiresAt = fitbitAccount.expires_at || 0\n\n  if (expiresAt - now < 300) {\n    // Token expired or expiring soon, refresh it\n    const refreshed = await refreshFitbitToken(fitbitAccount.refresh_token, userId)\n    if (!refreshed) {\n      return null\n    }\n    return refreshed\n  }\n\n  return {\n    access_token: fitbitAccount.access_token,\n    refresh_token: fitbitAccount.refresh_token,\n    expires_at: fitbitAccount.expires_at,\n    token_type: fitbitAccount.token_type || 'Bearer',\n  }\n}\n\n/**\n * Refresh Fitbit access token\n */\nasync function refreshFitbitToken(\n  refreshToken: string,\n  userId: string\n): Promise<FitbitTokens | null> {\n  const clientId = process.env.FITBIT_CLIENT_ID\n  const clientSecret = process.env.FITBIT_CLIENT_SECRET\n\n  if (!clientId || !clientSecret) {\n    console.error('‚ùå Fitbit credentials not configured')\n    return null\n  }\n\n  try {\n    const response = await fetch('https://api.fitbit.com/oauth2/token', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n        Authorization: `Basic ${Buffer.from(`${clientId}:${clientSecret}`).toString('base64')}`,\n      },\n      body: new URLSearchParams({\n        grant_type: 'refresh_token',\n        refresh_token: refreshToken,\n      }),\n    })\n\n    if (!response.ok) {\n      const errorData = await response.text()\n      console.error('‚ùå Fitbit token refresh failed:', errorData)\n      return null\n    }\n\n    const tokens = await response.json()\n    const expiresAt = tokens.expires_in\n      ? Math.floor(Date.now() / 1000) + tokens.expires_in\n      : null\n\n    // Update tokens in database\n    const fitbitAccount = await prisma.account.findFirst({\n      where: {\n        userId,\n        provider: 'fitbit',\n      },\n    })\n\n    if (fitbitAccount) {\n      await prisma.account.update({\n        where: { id: fitbitAccount.id },\n        data: {\n          access_token: tokens.access_token,\n          refresh_token: tokens.refresh_token || refreshToken,\n          expires_at: expiresAt,\n          token_type: tokens.token_type,\n        },\n      })\n    }\n\n    return {\n      access_token: tokens.access_token,\n      refresh_token: tokens.refresh_token || refreshToken,\n      expires_at: expiresAt,\n      token_type: tokens.token_type,\n    }\n  } catch (error) {\n    console.error('‚ùå Error refreshing Fitbit token:', error)\n    return null\n  }\n}\n\n/**\n * Make authenticated request to Fitbit API\n */\nexport async function fitbitApiRequest(\n  userId: string,\n  endpoint: string,\n  options: RequestInit = {}\n): Promise<Response | null> {\n  const tokens = await getFitbitTokens(userId)\n  if (!tokens) {\n    return null\n  }\n\n  const url = endpoint.startsWith('http') ? endpoint : `https://api.fitbit.com${endpoint}`\n\n  return fetch(url, {\n    ...options,\n    headers: {\n      Authorization: `Bearer ${tokens.access_token}`,\n      ...options.headers,\n    },\n  })\n}\n\n/**\n * Get Fitbit user ID for a user\n */\nexport async function getFitbitUserId(userId: string): Promise<string | null> {\n  const fitbitAccount = await prisma.account.findFirst({\n    where: {\n      userId,\n      provider: 'fitbit',\n    },\n  })\n\n  return fitbitAccount?.providerAccountId || null\n}\n\n","truncated":false,"size":3890},{"path":"lib/fitbit-db.ts","content":"import { prisma } from '@/lib/prisma'\n\n/**\n * Ensure the FitbitData table and required indexes exist.\n * Safe to run repeatedly; uses IF NOT EXISTS guards.\n */\nexport async function ensureFitbitDataSchema(): Promise<void> {\n  try {\n    // Create table\n    await prisma.$executeRawUnsafe(`\n      CREATE TABLE IF NOT EXISTS \"FitbitData\" (\n        \"id\" TEXT NOT NULL,\n        \"userId\" TEXT NOT NULL,\n        \"date\" DATE NOT NULL,\n        \"dataType\" TEXT NOT NULL,\n        \"value\" JSONB NOT NULL,\n        \"syncedAt\" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,\n        \"createdAt\" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,\n        \"updatedAt\" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,\n        CONSTRAINT \"FitbitData_pkey\" PRIMARY KEY (\"id\")\n      );\n    `)\n\n    // FK to User\n    await prisma.$executeRawUnsafe(`\n      DO $$\n      BEGIN\n        IF NOT EXISTS (\n          SELECT 1\n          FROM information_schema.table_constraints tc\n          WHERE tc.constraint_name = 'FitbitData_userId_fkey'\n        ) THEN\n          ALTER TABLE \"FitbitData\"\n          ADD CONSTRAINT \"FitbitData_userId_fkey\"\n          FOREIGN KEY (\"userId\") REFERENCES \"User\"(\"id\")\n          ON DELETE CASCADE ON UPDATE CASCADE;\n        END IF;\n      END $$;\n    `).catch((err) => {\n      // Constraint might already exist, ignore\n      console.log('FK constraint check (non-fatal):', err?.message)\n    })\n\n    // Unique and indexes\n    await prisma.$executeRawUnsafe(`\n      DO $$\n      BEGIN\n        IF NOT EXISTS (\n          SELECT 1\n          FROM pg_indexes\n          WHERE indexname = 'FitbitData_userId_date_dataType_key'\n        ) THEN\n          CREATE UNIQUE INDEX \"FitbitData_userId_date_dataType_key\"\n          ON \"FitbitData\"(\"userId\",\"date\",\"dataType\");\n        END IF;\n      END $$;\n    `).catch((err) => {\n      // Index might already exist, ignore\n      console.log('Unique index check (non-fatal):', err?.message)\n    })\n\n    await prisma.$executeRawUnsafe(`\n      CREATE INDEX IF NOT EXISTS \"FitbitData_userId_date_idx\" ON \"FitbitData\"(\"userId\",\"date\");\n    `).catch((err) => {\n      console.log('Index creation (non-fatal):', err?.message)\n    })\n\n    await prisma.$executeRawUnsafe(`\n      CREATE INDEX IF NOT EXISTS \"FitbitData_userId_dataType_idx\" ON \"FitbitData\"(\"userId\",\"dataType\");\n    `).catch((err) => {\n      console.log('Index creation (non-fatal):', err?.message)\n    })\n  } catch (error: any) {\n    console.error('‚ùå Error ensuring FitbitData schema:', error)\n    console.error('Error message:', error?.message)\n    console.error('Error code:', error?.code)\n    // Re-throw so caller knows it failed\n    throw new Error(`Failed to ensure FitbitData schema: ${error?.message || 'Unknown error'}`)\n  }\n}\n\n\n","truncated":false,"size":2723},{"path":"lib/food-data.ts","content":"import 'server-only'\n\nexport interface NormalizedFoodItem {\n  source: 'openfoodfacts' | 'usda' | 'fatsecret'\n  id: string\n  name: string\n  brand?: string | null\n  serving_size?: string | null\n  calories?: number | null\n  protein_g?: number | null\n  carbs_g?: number | null\n  fat_g?: number | null\n  fiber_g?: number | null\n  sugar_g?: number | null\n}\n\nexport interface ServingOption {\n  id: string\n  label: string\n  serving_size: string\n  grams?: number | null\n  ml?: number | null\n  unit?: 'g' | 'ml' | 'oz'\n  calories?: number | null\n  protein_g?: number | null\n  carbs_g?: number | null\n  fat_g?: number | null\n  fiber_g?: number | null\n  sugar_g?: number | null\n  source: 'usda' | 'fatsecret'\n}\n\nconst OPENFOODFACTS_BASE_URL =\n  process.env.OPENFOODFACTS_BASE_URL || 'https://world.openfoodfacts.org'\n\nconst OPENFOODFACTS_USER_AGENT =\n  process.env.OPENFOODFACTS_USER_AGENT || 'helfi-app/1.0 (support@helfi.ai)'\n\nconst USDA_API_KEY = process.env.USDA_API_KEY\n// Default to provided credentials if env vars are not set (per user request for FatSecret packaged lookups)\nconst FATSECRET_CLIENT_ID =\n  process.env.FATSECRET_CLIENT_ID || '5b035e5de0b041ffb0b8522abd75dd0b'\nconst FATSECRET_CLIENT_SECRET =\n  process.env.FATSECRET_CLIENT_SECRET || 'd544f96d19494c9ca8a3dec1bcaf1da3'\n\ntype TimeoutFetchInit = RequestInit & { timeoutMs?: number }\n\nfunction nowMs(): number {\n  return Date.now()\n}\n\nasync function fetchWithTimeout(url: string, init: TimeoutFetchInit = {}): Promise<Response> {\n  const timeoutMs = typeof init.timeoutMs === 'number' && Number.isFinite(init.timeoutMs) ? init.timeoutMs : 3500\n  const controller = new AbortController()\n  const signal = init.signal\n\n  const onAbort = () => {\n    try {\n      controller.abort()\n    } catch {}\n  }\n  if (signal) {\n    if (signal.aborted) {\n      onAbort()\n    } else {\n      try {\n        signal.addEventListener('abort', onAbort, { once: true })\n      } catch {}\n    }\n  }\n\n  const t = setTimeout(() => {\n    try {\n      controller.abort()\n    } catch {}\n  }, timeoutMs)\n\n  try {\n    const { timeoutMs: _timeoutMs, signal: _signal, ...rest } = init\n    return await fetch(url, { ...rest, signal: controller.signal })\n  } finally {\n    clearTimeout(t)\n    if (signal) {\n      try {\n        signal.removeEventListener('abort', onAbort)\n      } catch {}\n    }\n  }\n}\n\nfunction parseNumber(value: any): number | null {\n  const n = typeof value === 'number' ? value : Number(value)\n  if (!Number.isFinite(n)) return null\n  return n\n}\n\nfunction normalizeOpenFoodFactsProduct(product: any): NormalizedFoodItem | null {\n  if (!product) return null\n  const nutr = product.nutriments || {}\n\n  const name: string =\n    (product.product_name as string) ||\n    (product.generic_name as string) ||\n    (product.brands as string) ||\n    (product.code as string) ||\n    ''\n  if (!name) return null\n\n  const brand = (product.brands as string) || undefined\n\n  // Prefer explicit serving_size; fallback to 100g/100ml if not available\n  const servingSizeLabel: string =\n    (product.serving_size && String(product.serving_size).trim()) ||\n    (nutr['serving_size'] && String(nutr['serving_size']).trim()) ||\n    (nutr['serving_size_unit']\n      ? `1 ${nutr['serving_size_unit']}`\n      : nutr['serving_size'] || '')\n\n  let calories: number | null = null\n  let protein_g: number | null = null\n  let carbs_g: number | null = null\n  let fat_g: number | null = null\n  let fiber_g: number | null = null\n  let sugar_g: number | null = null\n\n  // If per-serving values exist, use them; otherwise fall back to per 100g/ml\n  const kcalServing = parseNumber(nutr['energy-kcal_serving'] ?? nutr['energy_serving'])\n  const proteinServing = parseNumber(nutr['proteins_serving'])\n  const carbsServing = parseNumber(nutr['carbohydrates_serving'])\n  const fatServing = parseNumber(nutr['fat_serving'])\n  const fiberServing = parseNumber(nutr['fiber_serving'])\n  const sugarServing = parseNumber(nutr['sugars_serving'])\n\n  if (kcalServing != null || proteinServing != null || carbsServing != null || fatServing != null) {\n    calories = kcalServing ?? parseNumber(nutr['energy-kcal_100g'] ?? nutr['energy_100g'])\n    protein_g = proteinServing ?? parseNumber(nutr['proteins_100g'])\n    carbs_g = carbsServing ?? parseNumber(nutr['carbohydrates_100g'])\n    fat_g = fatServing ?? parseNumber(nutr['fat_100g'])\n    fiber_g = fiberServing ?? parseNumber(nutr['fiber_100g'])\n    sugar_g = sugarServing ?? parseNumber(nutr['sugars_100g'])\n  } else {\n    // Fallback: use per 100g/ml as \"per serving\"\n    calories = parseNumber(nutr['energy-kcal_100g'] ?? nutr['energy_100g'])\n    protein_g = parseNumber(nutr['proteins_100g'])\n    carbs_g = parseNumber(nutr['carbohydrates_100g'])\n    fat_g = parseNumber(nutr['fat_100g'])\n    fiber_g = parseNumber(nutr['fiber_100g'])\n    sugar_g = parseNumber(nutr['sugars_100g'])\n  }\n\n  return {\n    source: 'openfoodfacts',\n    id: String(product.code || product.id || name),\n    name,\n    brand,\n    serving_size: servingSizeLabel || undefined,\n    calories,\n    protein_g,\n    carbs_g,\n    fat_g,\n    fiber_g,\n    sugar_g,\n  }\n}\n\nexport async function searchOpenFoodFactsByQuery(\n  query: string,\n  opts: { pageSize?: number } = {},\n): Promise<NormalizedFoodItem[]> {\n  const pageSize = opts.pageSize ?? 5\n  if (!query.trim()) return []\n\n  const params = new URLSearchParams({\n    action: 'process',\n    search_terms: query,\n    search_simple: '1',\n    json: '1',\n    page_size: String(pageSize),\n  })\n\n  const url = `${openFoodFactsBaseUrl()}/cgi/search.pl?${params.toString()}`\n\n  try {\n    const res = await fetchWithTimeout(url, {\n      headers: {\n        'User-Agent': OPENFOODFACTS_USER_AGENT,\n      },\n      // keep timeouts modest to avoid blocking the analyzer too long\n      cache: 'no-store',\n      next: { revalidate: 0 },\n      timeoutMs: 3000,\n    })\n\n    if (!res.ok) {\n      console.warn('OpenFoodFacts search failed', res.status, await res.text())\n      return []\n    }\n\n    const data = await res.json()\n    const products: any[] = Array.isArray(data.products) ? data.products : []\n\n    const normalized: NormalizedFoodItem[] = []\n    for (const p of products) {\n      const n = normalizeOpenFoodFactsProduct(p)\n      if (n) {\n        normalized.push(n)\n      }\n    }\n    return normalized\n  } catch (err) {\n    console.warn('OpenFoodFacts API error', err)\n    return []\n  }\n}\n\nfunction openFoodFactsBaseUrl(): string {\n  return OPENFOODFACTS_BASE_URL.replace(/\\/$/, '')\n}\n\n// USDA FoodData Central\n\ninterface UsdaFoodNutrient {\n  nutrientName?: string\n  unitName?: string\n  value?: number\n}\n\ninterface UsdaFood {\n  fdcId: number\n  description: string\n  brandName?: string\n  foodNutrients?: UsdaFoodNutrient[]\n  foodPortions?: Array<{\n    gramWeight?: number\n    modifier?: string\n    portionDescription?: string\n    measureUnit?: { name?: string }\n  }>\n}\n\nconst extractUsdaNutrients = (food: UsdaFood) => {\n  const nutrients = food.foodNutrients || []\n  const findVal = (name: string, units?: string[]): number | null => {\n    const n = nutrients.find(\n      (n) => n.nutrientName?.toLowerCase() === name.toLowerCase() && (!units || units.includes(n.unitName || '')),\n    )\n    if (!n) return null\n    if (!Number.isFinite(Number(n.value))) return null\n    return Number(n.value)\n  }\n  const energyKcal = findVal('Energy', ['KCAL']) ?? findVal('Energy', ['kcal'])\n  const energyKj = findVal('Energy', ['KJ']) ?? findVal('Energy', ['kJ'])\n  const energy = energyKcal ?? (energyKj ? energyKj / 4.184 : null)\n  const protein = findVal('Protein', ['G', 'g'])\n  const carbs = findVal('Carbohydrate, by difference', ['G', 'g'])\n  const fat = findVal('Total lipid (fat)', ['G', 'g'])\n  const fiber = findVal('Fiber, total dietary', ['G', 'g'])\n  const sugar = findVal('Sugars, total including NLEA', ['G', 'g']) ?? findVal('Sugars, total', ['G', 'g'])\n  return { energyKcal: energy, protein, carbs, fat, fiber, sugar }\n}\n\nfunction normalizeUsdaFood(food: UsdaFood): NormalizedFoodItem | null {\n  if (!food || !food.description) return null\n  const { energyKcal, protein, carbs, fat, fiber, sugar } = extractUsdaNutrients(food)\n\n  return {\n    source: 'usda',\n    id: String(food.fdcId),\n    name: food.description,\n    brand: food.brandName,\n    serving_size: '100 g',\n    calories: energyKcal,\n    protein_g: protein,\n    carbs_g: carbs,\n    fat_g: fat,\n    fiber_g: fiber,\n    sugar_g: sugar,\n  }\n}\n\nexport async function fetchUsdaServingOptions(fdcId: string): Promise<ServingOption[]> {\n  if (!USDA_API_KEY) {\n    console.warn('USDA_API_KEY not configured; skipping USDA serving lookup')\n    return []\n  }\n  if (!fdcId) return []\n\n  const url = `https://api.nal.usda.gov/fdc/v1/food/${encodeURIComponent(fdcId)}?api_key=${USDA_API_KEY}`\n  try {\n    const res = await fetchWithTimeout(url, {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      cache: 'no-store',\n      next: { revalidate: 0 },\n      timeoutMs: 3500,\n    })\n\n    if (!res.ok) {\n      console.warn('USDA food detail failed', res.status, await res.text())\n      return []\n    }\n\n    const food: UsdaFood = await res.json()\n    const { energyKcal, protein, carbs, fat, fiber, sugar } = extractUsdaNutrients(food)\n    const base = {\n      calories: energyKcal,\n      protein_g: protein,\n      carbs_g: carbs,\n      fat_g: fat,\n      fiber_g: fiber,\n      sugar_g: sugar,\n    }\n\n    const options: ServingOption[] = []\n    if (Number.isFinite(Number(base.calories))) {\n      options.push({\n        id: `usda:${fdcId}:100g`,\n        label: '100 g',\n        serving_size: '100 g',\n        grams: 100,\n        unit: 'g',\n        calories: base.calories ?? null,\n        protein_g: base.protein_g ?? null,\n        carbs_g: base.carbs_g ?? null,\n        fat_g: base.fat_g ?? null,\n        fiber_g: base.fiber_g ?? null,\n        sugar_g: base.sugar_g ?? null,\n        source: 'usda',\n      })\n    }\n\n    const portions = Array.isArray(food.foodPortions) ? food.foodPortions : []\n    portions.forEach((portion, idx) => {\n      const grams = Number(portion?.gramWeight ?? 0)\n      if (!Number.isFinite(grams) || grams <= 0) return\n      const labelBase =\n        portion?.portionDescription ||\n        portion?.modifier ||\n        portion?.measureUnit?.name ||\n        'Serving'\n      const label = `${labelBase} ‚Äî ${Math.round(grams)}g`\n      const factor = grams / 100\n      options.push({\n        id: `usda:${fdcId}:${idx}`,\n        label,\n        serving_size: label,\n        grams,\n        unit: 'g',\n        calories: base.calories != null ? Math.round(base.calories * factor) : null,\n        protein_g: base.protein_g != null ? Math.round(base.protein_g * factor * 10) / 10 : null,\n        carbs_g: base.carbs_g != null ? Math.round(base.carbs_g * factor * 10) / 10 : null,\n        fat_g: base.fat_g != null ? Math.round(base.fat_g * factor * 10) / 10 : null,\n        fiber_g: base.fiber_g != null ? Math.round(base.fiber_g * factor * 10) / 10 : null,\n        sugar_g: base.sugar_g != null ? Math.round(base.sugar_g * factor * 10) / 10 : null,\n        source: 'usda',\n      })\n    })\n\n    const deduped = new Map<string, ServingOption>()\n    options.forEach((opt) => {\n      const key = `${opt.serving_size}|${opt.grams || ''}`\n      if (!deduped.has(key)) deduped.set(key, opt)\n    })\n    return Array.from(deduped.values())\n  } catch (err) {\n    console.warn('USDA serving lookup error', err)\n    return []\n  }\n}\n\nexport async function searchUsdaFoods(\n  query: string,\n  opts: { pageSize?: number; dataType?: 'branded' | 'generic' | 'all' } = {},\n): Promise<NormalizedFoodItem[]> {\n  if (!USDA_API_KEY) {\n    console.warn('USDA_API_KEY not configured; skipping USDA lookup')\n    return []\n  }\n  const pageSize = opts.pageSize ?? 5\n  const dataType = opts.dataType ?? 'all'\n  const dataTypeParam =\n    dataType === 'branded'\n      ? 'Branded'\n      : dataType === 'generic'\n      ? ['Survey (FNDDS)', 'SR Legacy'].join(',')\n      : ['Branded', 'Survey (FNDDS)', 'SR Legacy'].join(',')\n\n  if (!query.trim()) return []\n\n  const params = new URLSearchParams({\n    api_key: USDA_API_KEY,\n    query,\n    pageSize: String(pageSize),\n    dataType: dataTypeParam,\n  })\n\n  const url = `https://api.nal.usda.gov/fdc/v1/foods/search?${params.toString()}`\n\n  try {\n    const res = await fetchWithTimeout(url, {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      cache: 'no-store',\n      next: { revalidate: 0 },\n      timeoutMs: 3500,\n    })\n\n    if (!res.ok) {\n      console.warn('USDA search failed', res.status, await res.text())\n      return []\n    }\n\n    const data = await res.json()\n    const foods: UsdaFood[] = Array.isArray(data.foods) ? data.foods : []\n    const out: NormalizedFoodItem[] = []\n    for (const f of foods) {\n      const n = normalizeUsdaFood(f)\n      if (n) out.push(n)\n    }\n    return out\n  } catch (err) {\n    console.warn('USDA API error', err)\n    return []\n  }\n}\n\n// FatSecret Platform API\n\ninterface FatSecretFood {\n  food_id: string\n  food_name: string\n  food_type: string\n  brand_name?: string\n  food_description?: string\n  servings?: {\n    serving: Array<{\n      serving_id: string\n      serving_description: string\n      serving_url: string\n      metric_serving_amount: string\n      metric_serving_unit: string\n      number_of_units: string\n      measurement_description: string\n      calories: string\n      carbohydrate: string\n      protein: string\n      fat: string\n      saturated_fat?: string\n      polyunsaturated_fat?: string\n      monounsaturated_fat?: string\n      cholesterol?: string\n      sodium?: string\n      potassium?: string\n      fiber?: string\n      sugar?: string\n    }>\n  }\n}\n\ninterface FatSecretSearchResponse {\n  foods?: {\n    food?: FatSecretFood[]\n    total_results?: string\n    max_results?: string\n    page_number?: string\n  }\n}\n\ninterface FatSecretFoodDetail {\n  food?: FatSecretFood | null\n}\n\nfunction normalizeFatSecretFood(food: FatSecretFood): NormalizedFoodItem | null {\n  if (!food || !food.food_name) return null\n\n  // Use the first serving as default, or try to find a standard serving\n  const servings = food.servings?.serving || []\n  if (servings.length === 0) return null\n\n  const lower = (v: any) => String(v || '').toLowerCase()\n  const parseValue = (val: string | undefined): number | null => {\n    if (!val) return null\n    const num = parseFloat(val)\n    return Number.isFinite(num) ? num : null\n  }\n  const parseAmount = (val: string | undefined): number | null => parseValue(val)\n\n  // Prefer real package servings over generic \"100 g\".\n  const scoreServing = (s: any) => {\n    let score = 0\n    const measurement = lower(s?.measurement_description || s?.serving_description)\n    const metricUnit = lower(s?.metric_serving_unit)\n    const metricAmount = parseAmount(s?.metric_serving_amount)\n\n    if (measurement.includes('100 g') || measurement.includes('100g')) score -= 10\n    if (measurement.includes('serving')) score += 2\n\n    // Common packaged units (biscuits, slices, pieces, bars, etc.)\n    if (\n      measurement.includes('biscuit') ||\n      measurement.includes('cookie') ||\n      measurement.includes('slice') ||\n      measurement.includes('piece') ||\n      measurement.includes('bar') ||\n      measurement.includes('packet') ||\n      measurement.includes('pack')\n    ) {\n      score += 6\n    }\n\n    // Prefer metric amounts that look like real servings (roughly 5g‚Äì150g).\n    if (metricUnit === 'g' && metricAmount != null) {\n      if (metricAmount >= 5 && metricAmount <= 150) score += 5\n      if (metricAmount === 100) score -= 4\n    }\n\n    // Prefer explicit \"1\" unit servings when available.\n    const numberOfUnits = parseAmount(s?.number_of_units)\n    if (numberOfUnits != null) {\n      if (numberOfUnits === 1) score += 2\n      if (numberOfUnits > 1) score += 1\n    }\n\n    return score\n  }\n\n  const preferredServing = [...servings].sort((a, b) => scoreServing(b) - scoreServing(a))[0] || servings[0]\n\n  const servingSizeBase =\n    preferredServing.measurement_description || preferredServing.serving_description || '1 serving'\n  const metricAmount = parseAmount(preferredServing.metric_serving_amount)\n  const metricUnit = preferredServing.metric_serving_unit\n  const servingSizeLabel =\n    metricAmount != null &&\n    metricAmount > 0 &&\n    metricUnit &&\n    typeof servingSizeBase === 'string' &&\n    !/\\b\\d+(\\.\\d+)?\\s*(g|ml)\\b/i.test(servingSizeBase)\n      ? `${servingSizeBase} (${metricAmount} ${metricUnit})`\n      : servingSizeBase\n\n  return {\n    source: 'fatsecret',\n    id: food.food_id,\n    name: food.food_name,\n    brand: food.brand_name || null,\n    serving_size: servingSizeLabel,\n    calories: parseValue(preferredServing.calories),\n    protein_g: parseValue(preferredServing.protein),\n    carbs_g: parseValue(preferredServing.carbohydrate),\n    fat_g: parseValue(preferredServing.fat),\n    fiber_g: parseValue(preferredServing.fiber),\n    sugar_g: parseValue(preferredServing.sugar),\n  }\n}\n\nlet fatSecretTokenCache: { token: string; expiresAtMs: number } | null = null\n\nasync function getFatSecretAccessToken(): Promise<string | null> {\n  if (!FATSECRET_CLIENT_ID || !FATSECRET_CLIENT_SECRET) {\n    console.warn('FatSecret credentials not configured')\n    return null\n  }\n\n  if (fatSecretTokenCache && fatSecretTokenCache.token && nowMs() < fatSecretTokenCache.expiresAtMs - 10_000) {\n    return fatSecretTokenCache.token\n  }\n\n  try {\n    // FatSecret uses OAuth 2.0 client credentials flow\n    const params = new URLSearchParams({\n      grant_type: 'client_credentials',\n      scope: 'basic',\n    })\n\n    const auth = Buffer.from(`${FATSECRET_CLIENT_ID}:${FATSECRET_CLIENT_SECRET}`).toString('base64')\n\n    const res = await fetchWithTimeout('https://oauth.fatsecret.com/connect/token', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n        Authorization: `Basic ${auth}`,\n      },\n      body: params.toString(),\n      cache: 'no-store',\n      timeoutMs: 2500,\n    })\n\n    if (!res.ok) {\n      const errorText = await res.text()\n      console.warn('FatSecret token request failed', res.status, errorText.substring(0, 200))\n      return null\n    }\n\n    const data = await res.json()\n    const token = data.access_token || null\n    const expiresInSecRaw = data.expires_in\n    const expiresInSec =\n      typeof expiresInSecRaw === 'number'\n        ? expiresInSecRaw\n        : typeof expiresInSecRaw === 'string'\n        ? parseInt(expiresInSecRaw, 10)\n        : NaN\n\n    if (token) {\n      // Default to 5 minutes if FatSecret doesn't return expires_in for some reason.\n      const ttlMs = Number.isFinite(expiresInSec) && expiresInSec > 0 ? expiresInSec * 1000 : 5 * 60 * 1000\n      // Keep a little safety margin so we don't reuse an expired token.\n      fatSecretTokenCache = { token, expiresAtMs: nowMs() + Math.max(30_000, ttlMs) }\n    } else {\n      fatSecretTokenCache = null\n    }\n    return token\n  } catch (err) {\n    console.warn('FatSecret token error', err)\n    return null\n  }\n}\n\nexport async function fetchFatSecretServingOptions(foodId: string): Promise<ServingOption[]> {\n  if (!foodId) return []\n  const accessToken = await getFatSecretAccessToken()\n  if (!accessToken) return []\n\n  try {\n    const params = new URLSearchParams({\n      method: 'food.get.v2',\n      food_id: String(foodId),\n      format: 'json',\n    })\n    const url = `https://platform.fatsecret.com/rest/server.api?${params.toString()}`\n\n    const res = await fetchWithTimeout(url, {\n      method: 'GET',\n      headers: {\n        Authorization: `Bearer ${accessToken}`,\n        'Content-Type': 'application/json',\n      },\n      cache: 'no-store',\n      next: { revalidate: 0 },\n      timeoutMs: 3500,\n    })\n\n    if (!res.ok) {\n      const text = await res.text()\n      console.warn('FatSecret food.get.v2 failed', res.status, text.substring(0, 200))\n      return []\n    }\n\n    const data: FatSecretFoodDetail = await res.json()\n    const food = data.food\n    if (!food || !food.servings || !food.servings.serving) return []\n\n    const servings = Array.isArray(food.servings.serving)\n      ? food.servings.serving\n      : [food.servings.serving]\n\n    const options: ServingOption[] = []\n    servings.forEach((serving: any, idx: number) => {\n      const metricAmount = Number(serving?.metric_serving_amount)\n      const metricUnit = String(serving?.metric_serving_unit || '').toLowerCase()\n      const measurement = String(serving?.measurement_description || serving?.serving_description || 'Serving')\n      const hasMetric = Number.isFinite(metricAmount) && metricAmount > 0 && metricUnit\n\n      const grams = hasMetric && metricUnit === 'g' ? metricAmount : null\n      const ml = hasMetric && metricUnit === 'ml' ? metricAmount : null\n      const unit: 'g' | 'ml' | 'oz' | undefined =\n        metricUnit === 'g' ? 'g' : metricUnit === 'ml' ? 'ml' : metricUnit === 'oz' ? 'oz' : undefined\n\n      const label = hasMetric ? `${measurement} ‚Äî ${metricAmount} ${metricUnit}` : measurement\n      const parseValue = (val: string | undefined): number | null => {\n        if (!val) return null\n        const num = parseFloat(val)\n        return Number.isFinite(num) ? num : null\n      }\n\n      options.push({\n        id: `fatsecret:${foodId}:${serving?.serving_id ?? idx}`,\n        label,\n        serving_size: label,\n        grams,\n        ml,\n        unit,\n        calories: parseValue(serving?.calories),\n        protein_g: parseValue(serving?.protein),\n        carbs_g: parseValue(serving?.carbohydrate),\n        fat_g: parseValue(serving?.fat),\n        fiber_g: parseValue(serving?.fiber),\n        sugar_g: parseValue(serving?.sugar),\n        source: 'fatsecret',\n      })\n    })\n\n    return options\n  } catch (err) {\n    console.warn('FatSecret serving lookup error', err)\n    return []\n  }\n}\n\nexport async function searchFatSecretFoods(\n  query: string,\n  opts: { pageSize?: number } = {},\n): Promise<NormalizedFoodItem[]> {\n  if (!FATSECRET_CLIENT_ID || !FATSECRET_CLIENT_SECRET) {\n    console.warn('FatSecret credentials not configured; skipping FatSecret lookup')\n    return []\n  }\n\n  const pageSize = opts.pageSize ?? 5\n  if (!query.trim()) return []\n\n  const accessToken = await getFatSecretAccessToken()\n  if (!accessToken) {\n    console.warn('Failed to obtain FatSecret access token')\n    return []\n  }\n\n  try {\n    const params = new URLSearchParams({\n      method: 'foods.search',\n      search_expression: query,\n      max_results: String(pageSize),\n      format: 'json',\n    })\n\n    const url = `https://platform.fatsecret.com/rest/server.api?${params.toString()}`\n\n    const res = await fetchWithTimeout(url, {\n      method: 'GET',\n      headers: {\n        Authorization: `Bearer ${accessToken}`,\n        'Content-Type': 'application/json',\n      },\n      cache: 'no-store',\n      next: { revalidate: 0 },\n      timeoutMs: 3500,\n    })\n\n    if (!res.ok) {\n      const errorText = await res.text()\n      console.warn('FatSecret search failed', res.status, errorText.substring(0, 200))\n      return []\n    }\n\n    const data: FatSecretSearchResponse = await res.json()\n    const foods: FatSecretFood[] = data.foods?.food || []\n\n    const normalized: NormalizedFoodItem[] = []\n    for (const f of foods) {\n      const n = normalizeFatSecretFood(f)\n      if (n) normalized.push(n)\n    }\n    return normalized\n  } catch (err) {\n    console.warn('FatSecret API error', err)\n    return []\n  }\n}\n\n// Enhanced lookup function that tries multiple sources with fallback\nexport async function lookupFoodNutrition(\n  query: string,\n  options?: {\n    preferSource?: 'usda' | 'fatsecret' | 'openfoodfacts'\n    maxResults?: number\n    usdaDataType?: 'branded' | 'generic' | 'all'\n  },\n): Promise<NormalizedFoodItem[]> {\n  const maxResults = options?.maxResults ?? 3\n  const preferSource = options?.preferSource || 'usda'\n  const usdaDataType = options?.usdaDataType\n\n  // Try sources in order of preference\n  const sources: Array<() => Promise<NormalizedFoodItem[]>> = []\n\n  if (preferSource === 'usda') {\n    sources.push(() => searchUsdaFoods(query, { pageSize: maxResults, dataType: usdaDataType }))\n    sources.push(() => searchFatSecretFoods(query, { pageSize: maxResults }))\n    sources.push(() => searchOpenFoodFactsByQuery(query, { pageSize: maxResults }))\n  } else if (preferSource === 'fatsecret') {\n    sources.push(() => searchFatSecretFoods(query, { pageSize: maxResults }))\n    sources.push(() => searchUsdaFoods(query, { pageSize: maxResults, dataType: usdaDataType }))\n    sources.push(() => searchOpenFoodFactsByQuery(query, { pageSize: maxResults }))\n  } else {\n    sources.push(() => searchOpenFoodFactsByQuery(query, { pageSize: maxResults }))\n    sources.push(() => searchUsdaFoods(query, { pageSize: maxResults, dataType: usdaDataType }))\n    sources.push(() => searchFatSecretFoods(query, { pageSize: maxResults }))\n  }\n\n  // Try each source until we get results\n  for (const sourceFn of sources) {\n    try {\n      const results = await sourceFn()\n      if (results && results.length > 0) {\n        console.log(`‚úÖ Found ${results.length} results from ${results[0].source} for query: ${query}`)\n        return results\n      }\n    } catch (err) {\n      console.warn(`‚ö†Ô∏è Source lookup failed, trying next:`, err)\n      continue\n    }\n  }\n\n  console.warn(`‚ö†Ô∏è No results found from any source for query: ${query}`)\n  return []\n}\n","truncated":false,"size":25328},{"path":"lib/food-normalization.ts","content":"type Basis = 'per_serving' | 'per_100g'\ntype EnergyUnit = 'kcal' | 'kJ' | null\n\nexport type NormalizedFoodInput = {\n  source?: string | null\n  id?: string | number | null\n  name?: string | null\n  brand?: string | null\n  serving_size?: string | null\n  servings?: number | null\n  calories?: number | null\n  protein_g?: number | null\n  carbs_g?: number | null\n  fat_g?: number | null\n  fiber_g?: number | null\n  sugar_g?: number | null\n  barcode?: string | null\n  basis?: Basis | null\n  quantity_g?: number | null\n  energyUnit?: EnergyUnit\n  pieces?: number | null\n  piecesPerServing?: number | null\n}\n\nconst WORD_NUMBER_MAP: Record<string, string> = {\n  one: '1',\n  two: '2',\n  three: '3',\n  four: '4',\n  five: '5',\n  six: '6',\n  seven: '7',\n  eight: '8',\n  nine: '9',\n  ten: '10',\n  eleven: '11',\n  twelve: '12',\n}\n\nconst DISCRETE_KEYWORDS = [\n  'egg',\n  'eggs',\n  'patty',\n  'pattie',\n  'patties',\n  'nugget',\n  'nuggets',\n  'wing',\n  'wings',\n  'drumstick',\n  'drumsticks',\n  'chicken leg',\n  'chicken legs',\n  'slice',\n  'slices',\n  'strip',\n  'strips',\n  'tender',\n  'tenders',\n  'bite',\n  'bites',\n  'piece',\n  'pieces',\n  'cookie',\n  'cookies',\n  'cracker',\n  'crackers',\n  'biscuit',\n  'biscuits',\n]\n\nexport const replaceWordNumbers = (text: string | null | undefined): string => {\n  if (!text) return ''\n  return String(text).replace(/\\b(one|two|three|four|five|six|seven|eight|nine|ten|eleven|twelve)\\b/gi, (m) => {\n    const repl = WORD_NUMBER_MAP[m.toLowerCase()]\n    return repl || m\n  })\n}\n\nexport const parseCountFromText = (text: string | null | undefined): number | null => {\n  if (!text) return null\n  const normalized = replaceWordNumbers(String(text).toLowerCase())\n  const match = normalized.match(/(\\d+(?:\\.\\d+)?)/)\n  if (!match) return null\n  const n = parseFloat(match[1])\n  return Number.isFinite(n) && n > 0 ? n : null\n}\n\nconst isProduceSliceLabel = (text: string): boolean => {\n  const lower = (text || '').toLowerCase()\n  if (!lower.includes('slice')) return false\n  return (\n    lower.includes('avocado') ||\n    lower.includes('cucumber') ||\n    lower.includes('tomato') ||\n    lower.includes('zucchini') ||\n    lower.includes('courgette')\n  )\n}\n\nconst isDiscreteLabel = (text: string | null | undefined): boolean => {\n  if (!text) return false\n  const lower = text.toLowerCase()\n  // Sliced produce behaves like a portion (weight/servings), not a discrete piece count.\n  if (isProduceSliceLabel(lower)) return false\n  return DISCRETE_KEYWORDS.some((kw) => lower.includes(kw))\n}\n\nconst parseGramWeight = (label: string | null | undefined): number | null => {\n  if (!label) return null\n  const normalized = replaceWordNumbers(label)\n  const gMatch = normalized.match(/(\\d+(?:\\.\\d+)?)\\s*(g|gram|grams)/i)\n  if (gMatch) return parseFloat(gMatch[1])\n  const mlMatch = normalized.match(/(\\d+(?:\\.\\d+)?)\\s*(ml|milliliter|millilitre)/i)\n  if (mlMatch) return parseFloat(mlMatch[1])\n  const ozMatch = normalized.match(/(\\d+(?:\\.\\d+)?)\\s*(oz|ounce|ounces)/i)\n  if (ozMatch) return parseFloat(ozMatch[1]) * 28.3495\n  return null\n}\n\nconst inferPiecesFromLabel = (name?: string | null, servingSize?: string | null): number | null => {\n  const label = replaceWordNumbers([name, servingSize].filter(Boolean).join(' '))\n  if (!label.trim()) return null\n\n  // Prefer explicit parenthetical counts like \"(6 crackers)\" or \"(3 pieces)\"\n  const paren = label.match(/\\((\\d+(?:\\.\\d+)?)\\s*(?:pieces?|pcs|crackers?|cookies?|nuggets?|patt(?:y|ies)|slices?)\\)/i)\n  if (paren) {\n    const val = parseFloat(paren[1])\n    if (Number.isFinite(val) && val > 0) return val\n  }\n\n  const explicit = label.match(\n    /(\\d+(?:\\.\\d+)?)\\s*(?:pieces?|pcs|crackers?|cookies?|nuggets?|patt(?:y|ies)|slices?|eggs?|bacon|rashers?|strips?|sausages?|links?|wings?|drumsticks?|tenders?|meatballs?|sticks?|bars?|bites?|biscuits?)/i,\n  )\n  if (explicit) {\n    const val = parseFloat(explicit[1])\n    if (Number.isFinite(val) && val > 0) return val\n  }\n  return null\n}\n\nexport const normalizeDiscreteItemCounts = (\n  item: any,\n  options?: { analysisText?: string | null },\n): { item: any; changed: boolean; debug?: any } => {\n  if (!item || typeof item !== 'object') return { item, changed: false }\n\n  const next = { ...item }\n  const label = replaceWordNumbers([next.name, next.serving_size || next.servingSize].filter(Boolean).join(' ').trim())\n  const isDiscrete = isDiscreteLabel(label)\n\n  if (!isDiscrete) {\n    return { item: next, changed: false }\n  }\n\n  const initialServings = Number.isFinite(Number(next.servings)) && Number(next.servings) > 0 ? Number(next.servings) : 1\n  const existingPiecesPerServing =\n    Number.isFinite(Number((next as any).piecesPerServing)) && Number((next as any).piecesPerServing) > 0\n      ? Number((next as any).piecesPerServing)\n      : null\n  const inferredPieces = inferPiecesFromLabel(next.name, next.serving_size || (next as any).servingSize)\n  const inferredFromAnalysis = options?.analysisText ? parseCountFromText(options.analysisText) : null\n\n  let piecesPerServing = existingPiecesPerServing || inferredPieces || inferredFromAnalysis || null\n  let servings = initialServings\n  let changed = false\n\n  // Plan rule: single discrete item with servings > 1 but no pieces ‚Üí set piecesPerServing = servings, clamp servings = 1\n  if (servings > 1 && !piecesPerServing) {\n    piecesPerServing = servings\n    servings = 1\n    changed = true\n  }\n\n  // If analysis text suggests a larger count than the label, prefer the analysis hint.\n  if (inferredFromAnalysis && (!piecesPerServing || inferredFromAnalysis > piecesPerServing)) {\n    piecesPerServing = inferredFromAnalysis\n    servings = 1\n    changed = true\n  }\n\n  if (piecesPerServing && piecesPerServing > 0 && piecesPerServing !== existingPiecesPerServing) {\n    ;(next as any).piecesPerServing = piecesPerServing\n    changed = true\n  }\n\n  if (servings !== initialServings) {\n    next.servings = servings\n  }\n\n  // Seed pieces for the UI if missing\n  if (\n    piecesPerServing &&\n    (!Number.isFinite(Number((next as any).pieces)) || Number((next as any).pieces) <= 0)\n  ) {\n    ;(next as any).pieces = Math.max(1, Math.round(piecesPerServing * servings * 1000) / 1000)\n    changed = true\n  }\n\n  return {\n    item: next,\n    changed,\n    debug: {\n      name: next.name,\n      serving_size: next.serving_size,\n      servings: next.servings,\n      pieces: (next as any).pieces,\n      piecesPerServing: (next as any).piecesPerServing,\n      inferredPieces,\n    },\n  }\n}\n\nexport const normalizeDiscreteItems = (\n  items: any[],\n  options?: { analysisText?: string | null },\n): { items: any[]; changed: boolean; debug: any[] } => {\n  if (!Array.isArray(items) || items.length === 0) return { items, changed: false, debug: [] }\n\n  const normalized: any[] = []\n  const debug: any[] = []\n  let changed = false\n\n  for (const item of items) {\n    const { item: next, changed: itemChanged, debug: d } = normalizeDiscreteItemCounts(item, options)\n    normalized.push(next)\n    if (itemChanged) changed = true\n    if (d) debug.push(d)\n  }\n\n  return { items: normalized, changed, debug }\n}\n\nexport const normalizeBarcodeFood = (food: NormalizedFoodInput): { food: NormalizedFoodInput; debug: any } => {\n  const next: NormalizedFoodInput = { ...food }\n  let calories = Number.isFinite(Number(next.calories)) ? Number(next.calories) : null\n  let protein = Number.isFinite(Number(next.protein_g)) ? Number(next.protein_g) : null\n  let carbs = Number.isFinite(Number(next.carbs_g)) ? Number(next.carbs_g) : null\n  let fat = Number.isFinite(Number(next.fat_g)) ? Number(next.fat_g) : null\n  let fiber = Number.isFinite(Number(next.fiber_g)) ? Number(next.fiber_g) : null\n  let sugar = Number.isFinite(Number(next.sugar_g)) ? Number(next.sugar_g) : null\n\n  const quantityG = Number.isFinite(Number(next.quantity_g)) && Number(next.quantity_g) > 0 ? Number(next.quantity_g) : parseGramWeight(next.serving_size)\n  const energyUnit: EnergyUnit = next.energyUnit || null\n\n  // Normalize energy to kcal (heuristic: values > 4000 likely kJ)\n  let convertedFromKJ = false\n  if (energyUnit === 'kJ' && calories !== null) {\n    calories = Math.round((calories as number) / 4.184)\n    convertedFromKJ = true\n  } else if (calories !== null && calories > 4000) {\n    calories = Math.round(calories / 4.184)\n    convertedFromKJ = true\n  }\n\n  // Scale from per-100g to per-serving if possible\n  if (next.basis === 'per_100g' && quantityG && quantityG > 0) {\n    const factor = quantityG / 100\n    const scale = (v: number | null) => (Number.isFinite(Number(v)) ? Math.round(Number(v) * factor * 1000) / 1000 : null)\n    calories = scale(calories)\n    protein = scale(protein)\n    carbs = scale(carbs)\n    fat = scale(fat)\n    fiber = scale(fiber)\n    sugar = scale(sugar)\n  }\n\n  next.calories = calories\n  next.protein_g = protein\n  next.carbs_g = carbs\n  next.fat_g = fat\n  next.fiber_g = fiber\n  next.sugar_g = sugar\n  next.servings = 1\n\n  // Pieces inference for discrete packaged foods\n  const inferredPieces = inferPiecesFromLabel(next.name, next.serving_size)\n  if (inferredPieces && inferredPieces > 0) {\n    next.piecesPerServing = inferredPieces\n    next.pieces = inferredPieces\n  }\n\n  return {\n    food: next,\n    debug: {\n      source: next.source,\n      serving_size: next.serving_size,\n      basis: next.basis || null,\n      quantity_g: quantityG || null,\n      calories,\n      protein,\n      carbs,\n      fat,\n      fiber,\n      sugar,\n      convertedFromKJ,\n      inferredPieces: next.piecesPerServing || null,\n    },\n  }\n}\n\nexport const summarizeDiscreteItemsForLog = (items: any[]) =>\n  Array.isArray(items)\n    ? items\n        .filter((it) => isDiscreteLabel(`${it?.name || ''} ${it?.serving_size || ''}`))\n        .slice(0, 6)\n        .map((it) => ({\n          name: it?.name,\n          serving_size: it?.serving_size,\n          servings: it?.servings,\n          pieces: (it as any)?.pieces,\n          piecesPerServing: (it as any)?.piecesPerServing,\n        }))\n    : []\n","truncated":false,"size":9935},{"path":"lib/food-photo-storage.ts","content":"import { del } from '@vercel/blob'\nimport { prisma } from '@/lib/prisma'\n\nconst FOOD_PHOTO_PREFIX = 'food-photos/'\nconst BLOB_HOST = 'blob.vercel-storage.com'\n\nconst isFoodPhotoBlobUrl = (value: string) =>\n  typeof value === 'string' &&\n  value.includes(BLOB_HOST) &&\n  value.includes(`/${FOOD_PHOTO_PREFIX}`)\n\nconst chunk = <T,>(items: T[], size: number) => {\n  const result: T[][] = []\n  for (let i = 0; i < items.length; i += size) {\n    result.push(items.slice(i, i + size))\n  }\n  return result\n}\n\nexport const deleteFoodPhotosIfUnused = async (\n  urls: Array<string | null | undefined>,\n) => {\n  if (!process.env.BLOB_READ_WRITE_TOKEN) return { deleted: 0, skipped: 0 }\n\n  const candidates = Array.from(\n    new Set(\n      urls\n        .filter((url): url is string => typeof url === 'string' && url.trim().length > 0)\n        .map((url) => url.trim())\n        .filter(isFoodPhotoBlobUrl),\n    ),\n  )\n\n  if (candidates.length === 0) return { deleted: 0, skipped: 0 }\n\n  const stillUsed = await prisma.foodLog.findMany({\n    where: { imageUrl: { in: candidates } },\n    select: { imageUrl: true },\n  })\n  const stillUsedSet = new Set(\n    stillUsed.map((row) => row.imageUrl).filter((url): url is string => typeof url === 'string'),\n  )\n\n  const toDelete = candidates.filter((url) => !stillUsedSet.has(url))\n  if (toDelete.length === 0) return { deleted: 0, skipped: candidates.length }\n\n  const batches = chunk(toDelete, 100)\n  for (const batch of batches) {\n    if (batch.length === 0) continue\n    await del(batch)\n  }\n\n  return { deleted: toDelete.length, skipped: candidates.length - toDelete.length }\n}\n","truncated":false,"size":1612},{"path":"lib/free-credits.ts","content":"import { prisma } from '@/lib/prisma';\n\n/**\n * Free Credits System\n * \n * New users receive:\n * - 5 x Food image analysis\n * - 2 x Symptom analysis\n * - 2 x Medical image analysis\n * - 2 x Supplement/Medication interaction analysis\n * - 1 x Full Health intake analysis (when completing onboarding page 11)\n * - 3 x Insights updates (when changing health setup)\n * - 2 x Symptom follow-up chats\n * - 2 x Medical image follow-up chats\n * - 2 x Insights chats\n * - 2 x Voice chats\n * - 2 x Food re-analyses\n * - 2 x Interaction re-analyses\n * \n * These credits are consumed BEFORE wallet credits.\n * Low credits warning only shows AFTER free credits are exhausted.\n */\n\nexport type FreeCreditType = \n  | 'FOOD_ANALYSIS'\n  | 'FOOD_REANALYSIS'\n  | 'SYMPTOM_ANALYSIS'\n  | 'SYMPTOM_CHAT'\n  | 'MEDICAL_ANALYSIS'\n  | 'MEDICAL_CHAT'\n  | 'INTERACTION_ANALYSIS'\n  | 'INTERACTION_REANALYSIS'\n  | 'HEALTH_INTAKE'\n  | 'INSIGHTS_UPDATE'\n  | 'INSIGHTS_CHAT'\n  | 'VOICE_CHAT';\n\nconst FREE_CREDIT_FIELDS: Record<FreeCreditType, keyof any> = {\n  FOOD_ANALYSIS: 'freeFoodAnalysisRemaining',\n  FOOD_REANALYSIS: 'freeFoodReanalysisRemaining',\n  SYMPTOM_ANALYSIS: 'freeSymptomAnalysisRemaining',\n  SYMPTOM_CHAT: 'freeSymptomChatRemaining',\n  MEDICAL_ANALYSIS: 'freeMedicalAnalysisRemaining',\n  MEDICAL_CHAT: 'freeMedicalChatRemaining',\n  INTERACTION_ANALYSIS: 'freeInteractionAnalysisRemaining',\n  INTERACTION_REANALYSIS: 'freeInteractionReanalysisRemaining',\n  HEALTH_INTAKE: 'freeHealthIntakeRemaining',\n  INSIGHTS_UPDATE: 'freeInsightsUpdateRemaining',\n  INSIGHTS_CHAT: 'freeInsightsChatRemaining',\n  VOICE_CHAT: 'freeVoiceChatRemaining',\n};\n\nexport async function ensureFreeCreditColumns() {\n  try {\n    await prisma.$executeRawUnsafe(`\n      ALTER TABLE \"User\"\n        ADD COLUMN IF NOT EXISTS \"freeSymptomChatRemaining\" INT DEFAULT 0,\n        ADD COLUMN IF NOT EXISTS \"freeMedicalChatRemaining\" INT DEFAULT 0,\n        ADD COLUMN IF NOT EXISTS \"freeInsightsChatRemaining\" INT DEFAULT 0,\n        ADD COLUMN IF NOT EXISTS \"freeVoiceChatRemaining\" INT DEFAULT 0,\n        ADD COLUMN IF NOT EXISTS \"freeFoodReanalysisRemaining\" INT DEFAULT 0,\n        ADD COLUMN IF NOT EXISTS \"freeInteractionReanalysisRemaining\" INT DEFAULT 0\n    `)\n  } catch (error) {\n    console.warn('Failed to ensure free credit columns:', error)\n  }\n}\n\n/**\n * Check if user has free credits remaining for a feature\n */\nexport async function hasFreeCredits(\n  userId: string,\n  creditType: FreeCreditType\n): Promise<boolean> {\n  await ensureFreeCreditColumns()\n  const user = await prisma.user.findUnique({\n    where: { id: userId },\n    select: { [FREE_CREDIT_FIELDS[creditType]]: true } as any,\n  });\n\n  if (!user) return false;\n\n  const remaining = (user as any)[FREE_CREDIT_FIELDS[creditType]] as number | undefined;\n  return (remaining ?? 0) > 0;\n}\n\n/**\n * Consume one free credit for a feature\n * Returns true if credit was consumed, false if none available\n */\nexport async function consumeFreeCredit(\n  userId: string,\n  creditType: FreeCreditType\n): Promise<boolean> {\n  await ensureFreeCreditColumns()\n  const field = FREE_CREDIT_FIELDS[creditType];\n  \n  // Check current value\n  const user = await prisma.user.findUnique({\n    where: { id: userId },\n    select: { [field]: true } as any,\n  });\n\n  if (!user) return false;\n\n  const current = (user as any)[field] as number | undefined;\n  if (!current || current <= 0) return false;\n\n  // Decrement the counter\n  try {\n    await prisma.user.update({\n      where: { id: userId },\n      data: {\n        [field]: {\n          decrement: 1,\n        },\n      } as any,\n    });\n    return true;\n  } catch (error) {\n    console.error(`Failed to consume free credit for ${creditType}:`, error);\n    return false;\n  }\n}\n\n/**\n * Get all free credit counts for a user\n */\nexport async function getFreeCreditsStatus(userId: string) {\n  await ensureFreeCreditColumns()\n  const user = await prisma.user.findUnique({\n    where: { id: userId },\n    select: {\n      freeFoodAnalysisRemaining: true,\n      freeFoodReanalysisRemaining: true,\n      freeSymptomAnalysisRemaining: true,\n      freeSymptomChatRemaining: true,\n      freeMedicalAnalysisRemaining: true,\n      freeMedicalChatRemaining: true,\n      freeInteractionAnalysisRemaining: true,\n      freeInteractionReanalysisRemaining: true,\n      freeHealthIntakeRemaining: true,\n      freeInsightsUpdateRemaining: true,\n      freeInsightsChatRemaining: true,\n      freeVoiceChatRemaining: true,\n    } as any,\n  });\n\n  if (!user) {\n    return {\n      food: 0,\n      foodReanalysis: 0,\n      symptom: 0,\n      symptomChat: 0,\n      medical: 0,\n      medicalChat: 0,\n      interaction: 0,\n      interactionReanalysis: 0,\n      healthIntake: 0,\n      insights: 0,\n      insightsChat: 0,\n      voiceChat: 0,\n      total: 0,\n    };\n  }\n\n  const food = (user as any).freeFoodAnalysisRemaining ?? 0;\n  const foodReanalysis = (user as any).freeFoodReanalysisRemaining ?? 0;\n  const symptom = (user as any).freeSymptomAnalysisRemaining ?? 0;\n  const symptomChat = (user as any).freeSymptomChatRemaining ?? 0;\n  const medical = (user as any).freeMedicalAnalysisRemaining ?? 0;\n  const medicalChat = (user as any).freeMedicalChatRemaining ?? 0;\n  const interaction = (user as any).freeInteractionAnalysisRemaining ?? 0;\n  const interactionReanalysis = (user as any).freeInteractionReanalysisRemaining ?? 0;\n  const healthIntake = (user as any).freeHealthIntakeRemaining ?? 0;\n  const insights = (user as any).freeInsightsUpdateRemaining ?? 0;\n  const insightsChat = (user as any).freeInsightsChatRemaining ?? 0;\n  const voiceChat = (user as any).freeVoiceChatRemaining ?? 0;\n\n  return {\n    food,\n    foodReanalysis,\n    symptom,\n    symptomChat,\n    medical,\n    medicalChat,\n    interaction,\n    interactionReanalysis,\n    healthIntake,\n    insights,\n    insightsChat,\n    voiceChat,\n    total:\n      food +\n      foodReanalysis +\n      symptom +\n      symptomChat +\n      medical +\n      medicalChat +\n      interaction +\n      interactionReanalysis +\n      healthIntake +\n      insights +\n      insightsChat +\n      voiceChat,\n  };\n}\n\n/**\n * Check if user has exhausted all free credits\n */\nexport async function hasExhaustedFreeCredits(userId: string): Promise<boolean> {\n  const status = await getFreeCreditsStatus(userId);\n  return status.total === 0;\n}\n","truncated":false,"size":6292},{"path":"lib/garmin-db.ts","content":"import { prisma } from '@/lib/prisma'\n\n/**\n * Ensure Garmin tables exist (idempotent).\n * Vercel builds don‚Äôt run `prisma migrate deploy` in this repo, so we defensively create tables at runtime.\n */\nexport async function ensureGarminSchema(): Promise<void> {\n  try {\n    await prisma.$executeRawUnsafe(`\n      CREATE TABLE IF NOT EXISTS \"GarminRequestToken\" (\n        \"id\" TEXT NOT NULL,\n        \"userId\" TEXT NOT NULL,\n        \"oauthToken\" TEXT NOT NULL,\n        \"oauthTokenSecret\" TEXT NOT NULL,\n        \"createdAt\" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,\n        \"expiresAt\" TIMESTAMP(3),\n        CONSTRAINT \"GarminRequestToken_pkey\" PRIMARY KEY (\"id\")\n      );\n    `)\n\n    await prisma.$executeRawUnsafe(`\n      CREATE UNIQUE INDEX IF NOT EXISTS \"GarminRequestToken_oauthToken_key\" ON \"GarminRequestToken\"(\"oauthToken\");\n    `).catch(() => {})\n\n    await prisma.$executeRawUnsafe(`\n      CREATE INDEX IF NOT EXISTS \"GarminRequestToken_userId_idx\" ON \"GarminRequestToken\"(\"userId\");\n    `).catch(() => {})\n\n    await prisma.$executeRawUnsafe(`\n      DO $$\n      BEGIN\n        IF NOT EXISTS (\n          SELECT 1 FROM information_schema.table_constraints\n          WHERE constraint_name = 'GarminRequestToken_userId_fkey'\n        ) THEN\n          ALTER TABLE \"GarminRequestToken\"\n          ADD CONSTRAINT \"GarminRequestToken_userId_fkey\"\n          FOREIGN KEY (\"userId\") REFERENCES \"User\"(\"id\")\n          ON DELETE CASCADE ON UPDATE CASCADE;\n        END IF;\n      END $$;\n    `).catch(() => {})\n\n    await prisma.$executeRawUnsafe(`\n      CREATE TABLE IF NOT EXISTS \"GarminWebhookLog\" (\n        \"id\" TEXT NOT NULL,\n        \"userId\" TEXT,\n        \"oauthToken\" TEXT,\n        \"dataType\" TEXT,\n        \"payload\" JSONB NOT NULL,\n        \"receivedAt\" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,\n        CONSTRAINT \"GarminWebhookLog_pkey\" PRIMARY KEY (\"id\")\n      );\n    `)\n\n    await prisma.$executeRawUnsafe(`\n      CREATE INDEX IF NOT EXISTS \"GarminWebhookLog_oauthToken_idx\" ON \"GarminWebhookLog\"(\"oauthToken\");\n    `).catch(() => {})\n\n    await prisma.$executeRawUnsafe(`\n      CREATE INDEX IF NOT EXISTS \"GarminWebhookLog_userId_idx\" ON \"GarminWebhookLog\"(\"userId\");\n    `).catch(() => {})\n\n    await prisma.$executeRawUnsafe(`\n      DO $$\n      BEGIN\n        IF NOT EXISTS (\n          SELECT 1 FROM information_schema.table_constraints\n          WHERE constraint_name = 'GarminWebhookLog_userId_fkey'\n        ) THEN\n          ALTER TABLE \"GarminWebhookLog\"\n          ADD CONSTRAINT \"GarminWebhookLog_userId_fkey\"\n          FOREIGN KEY (\"userId\") REFERENCES \"User\"(\"id\")\n          ON DELETE SET NULL ON UPDATE CASCADE;\n        END IF;\n      END $$;\n    `).catch(() => {})\n  } catch (error: any) {\n    console.error('‚ùå Error ensuring Garmin schema:', error)\n    throw new Error(`Failed to ensure Garmin schema: ${error?.message || 'Unknown error'}`)\n  }\n}\n\n","truncated":false,"size":2875},{"path":"lib/garmin-oauth.ts","content":"import crypto from 'crypto'\n\nconst DEFAULT_GARMIN_API_BASE_URL = 'https://apis.garmin.com/wellness-api/rest'\nconst DEFAULT_GARMIN_AUTHORIZE_URL = 'https://connect.garmin.com/oauth2Confirm'\nconst DEFAULT_GARMIN_TOKEN_URL = 'https://diauth.garmin.com/di-oauth2-service/oauth/token'\n\nexport type GarminOAuthTokens = {\n  access_token: string\n  refresh_token: string\n  token_type: string\n  scope?: string\n  expires_in?: number\n  refresh_token_expires_in?: number\n}\n\nexport type GarminUserInfo = {\n  userId: string | null\n}\n\nfunction getGarminApiBaseUrl() {\n  return process.env.GARMIN_API_BASE_URL || DEFAULT_GARMIN_API_BASE_URL\n}\n\nfunction getGarminAuthorizeUrl() {\n  return process.env.GARMIN_OAUTH_AUTHORIZE_URL || DEFAULT_GARMIN_AUTHORIZE_URL\n}\n\nfunction getGarminTokenUrl() {\n  return process.env.GARMIN_OAUTH_TOKEN_URL || DEFAULT_GARMIN_TOKEN_URL\n}\n\nfunction getGarminClient() {\n  const clientId = process.env.GARMIN_CONSUMER_KEY || process.env.GARMIN_CLIENT_ID\n  const clientSecret = process.env.GARMIN_CONSUMER_SECRET || process.env.GARMIN_CLIENT_SECRET\n\n  if (!clientId || !clientSecret) {\n    throw new Error('Garmin client id/secret are not configured')\n  }\n\n  return { clientId, clientSecret }\n}\n\nfunction base64UrlEncode(buffer: Buffer) {\n  return buffer\n    .toString('base64')\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_')\n    .replace(/=+$/, '')\n}\n\nexport function generatePkcePair() {\n  const codeVerifier = base64UrlEncode(crypto.randomBytes(48))\n  const codeChallenge = base64UrlEncode(crypto.createHash('sha256').update(codeVerifier).digest())\n  return { codeVerifier, codeChallenge }\n}\n\nexport async function exchangeGarminCodeForTokens(code: string, codeVerifier: string, redirectUri: string) {\n  const { clientId, clientSecret } = getGarminClient()\n  const tokenUrl = getGarminTokenUrl()\n  const body = new URLSearchParams({\n    grant_type: 'authorization_code',\n    client_id: clientId,\n    client_secret: clientSecret,\n    code,\n    code_verifier: codeVerifier,\n  })\n\n  if (redirectUri) {\n    body.set('redirect_uri', redirectUri)\n  }\n\n  const response = await fetch(tokenUrl, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n    body,\n  })\n\n  const json = (await response.json()) as GarminOAuthTokens\n  if (!response.ok || !json.access_token) {\n    console.error('‚ùå Garmin token exchange failed', { status: response.status, body: json })\n    throw new Error(`Garmin token exchange failed (${response.status})`)\n  }\n\n  return json\n}\n\nexport async function refreshGarminTokens(refreshToken: string) {\n  const { clientId, clientSecret } = getGarminClient()\n  const tokenUrl = getGarminTokenUrl()\n  const body = new URLSearchParams({\n    grant_type: 'refresh_token',\n    client_id: clientId,\n    client_secret: clientSecret,\n    refresh_token: refreshToken,\n  })\n\n  const response = await fetch(tokenUrl, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n    body,\n  })\n\n  const json = (await response.json()) as GarminOAuthTokens\n  if (!response.ok || !json.access_token) {\n    console.error('‚ùå Garmin token refresh failed', { status: response.status, body: json })\n    throw new Error(`Garmin token refresh failed (${response.status})`)\n  }\n\n  return json\n}\n\nexport async function fetchGarminUserId(accessToken: string): Promise<GarminUserInfo> {\n  const baseUrl = getGarminApiBaseUrl()\n  const resp = await fetch(`${baseUrl}/user/id`, {\n    headers: { Authorization: `Bearer ${accessToken}` },\n  })\n  if (!resp.ok) {\n    console.warn('‚ö†Ô∏è Garmin user id fetch failed', resp.status, await resp.text())\n    return { userId: null }\n  }\n  try {\n    const data = (await resp.json()) as { userId?: string }\n    return { userId: data.userId || null }\n  } catch {\n    return { userId: null }\n  }\n}\n\nexport async function registerGarminUser(accessToken: string, uploadStartTimestampMs: number) {\n  const baseUrl = getGarminApiBaseUrl()\n  const data = { uploadStartTimestamp: `${uploadStartTimestampMs}` }\n\n  return fetch(`${baseUrl}/user/registration`, {\n    method: 'POST',\n    headers: {\n      Authorization: `Bearer ${accessToken}`,\n      'Content-Type': 'application/x-www-form-urlencoded',\n    },\n    body: new URLSearchParams(data),\n  })\n}\n\nexport async function deregisterGarminUser(accessToken: string) {\n  const baseUrl = getGarminApiBaseUrl()\n  return fetch(`${baseUrl}/user/registration`, {\n    method: 'DELETE',\n    headers: {\n      Authorization: `Bearer ${accessToken}`,\n    },\n  })\n}\n\nexport function buildGarminAuthorizeUrl(codeChallenge: string, state: string, redirectUri: string) {\n  const { clientId } = getGarminClient()\n  const authorizeUrl = new URL(getGarminAuthorizeUrl())\n  authorizeUrl.searchParams.set('client_id', clientId)\n  authorizeUrl.searchParams.set('response_type', 'code')\n  authorizeUrl.searchParams.set('code_challenge', codeChallenge)\n  authorizeUrl.searchParams.set('code_challenge_method', 'S256')\n  authorizeUrl.searchParams.set('state', state)\n  if (redirectUri) {\n    authorizeUrl.searchParams.set('redirect_uri', redirectUri)\n  }\n  return authorizeUrl.toString()\n}\n\nexport function parseOAuthHeader(header: string | null) {\n  if (!header) return null\n  const cleaned = header.replace(/^OAuth\\s*/i, '')\n  const params: Record<string, string> = {}\n\n  cleaned.split(',').forEach((pair) => {\n    const [rawKey, rawValue] = pair.trim().split('=')\n    if (!rawKey || !rawValue) return\n    params[rawKey] = decodeURIComponent(rawValue.replace(/\"/g, ''))\n  })\n\n  return params\n}\n\nexport function parseBearerToken(header: string | null) {\n  if (!header) return null\n  const match = header.match(/^Bearer\\s+(.+)$/i)\n  return match ? match[1].trim() : null\n}\n\nexport function assertGarminConfigured() {\n  const clientId = process.env.GARMIN_CONSUMER_KEY || process.env.GARMIN_CLIENT_ID\n  const clientSecret = process.env.GARMIN_CONSUMER_SECRET || process.env.GARMIN_CLIENT_SECRET\n  if (!clientId || !clientSecret) {\n    throw new Error('Garmin credentials are not configured in the environment')\n  }\n  return { clientId, clientSecret }\n}\n","truncated":false,"size":6080},{"path":"lib/image-metadata.ts","content":"/**\n * Lightweight image metadata extractor (PNG + JPEG) for server-side uploads.\n * Falls back to nulls if the format is unknown.\n */\nexport type ImageMeta = {\n  width: number | null\n  height: number | null\n  format: 'png' | 'jpeg' | 'unknown'\n}\n\nconst PNG_SIGNATURE = Buffer.from([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a])\n\nexport function getImageMetadata(input: ArrayBuffer | Buffer): ImageMeta {\n  const buf = Buffer.isBuffer(input) ? input : Buffer.from(input)\n\n  // PNG: width/height are big-endian at offset 16\n  if (buf.length >= 24 && buf.slice(0, 8).equals(PNG_SIGNATURE)) {\n    const width = buf.readUInt32BE(16)\n    const height = buf.readUInt32BE(20)\n    return { width, height, format: 'png' }\n  }\n\n  // JPEG: scan markers until SOF0/1/2\n  if (buf.length > 4 && buf[0] === 0xff && buf[1] === 0xd8) {\n    let offset = 2\n    while (offset + 9 < buf.length) {\n      if (buf[offset] !== 0xff) {\n        offset++\n        continue\n      }\n      const marker = buf[offset + 1]\n      const blockLength = buf.readUInt16BE(offset + 2)\n      if (marker >= 0xc0 && marker <= 0xc3) {\n        const height = buf.readUInt16BE(offset + 5)\n        const width = buf.readUInt16BE(offset + 7)\n        return { width, height, format: 'jpeg' }\n      }\n      // Prevent infinite loop on malformed data\n      if (blockLength < 2) break\n      offset += 2 + blockLength\n    }\n  }\n\n  return { width: null, height: null, format: 'unknown' }\n}\n","truncated":false,"size":1438},{"path":"lib/insights/chat-store.ts","content":"import { prisma } from '@/lib/prisma'\nimport { getCachedIssueSection, type IssueSectionResult, type IssueSectionKey } from '@/lib/insights/issue-engine'\nimport OpenAI from 'openai'\n\nlet tablesEnsured = false\n\nexport async function ensureChatTables(): Promise<void> {\n  if (tablesEnsured) return\n  try {\n    // Add title column if it doesn't exist\n    await prisma.$executeRawUnsafe(\n      'ALTER TABLE \"InsightsChatThread\" ADD COLUMN IF NOT EXISTS \"title\" TEXT'\n    )\n    await prisma.$executeRawUnsafe(\n      'CREATE TABLE IF NOT EXISTS \"InsightsChatThread\" (\"id\" TEXT PRIMARY KEY, \"userId\" TEXT NOT NULL, \"slug\" TEXT NOT NULL, \"section\" TEXT NOT NULL, \"title\" TEXT, \"createdAt\" TIMESTAMPTZ NOT NULL DEFAULT NOW(), \"updatedAt\" TIMESTAMPTZ NOT NULL DEFAULT NOW())'\n    )\n    await prisma.$executeRawUnsafe(\n      'CREATE TABLE IF NOT EXISTS \"InsightsChatMessage\" (\"id\" TEXT PRIMARY KEY, \"threadId\" TEXT NOT NULL, \"role\" TEXT NOT NULL, \"content\" TEXT NOT NULL, \"tokenCount\" INTEGER NULL, \"createdAt\" TIMESTAMPTZ NOT NULL DEFAULT NOW(), CONSTRAINT \"InsightsChatMessage_threadId_fkey\" FOREIGN KEY (\"threadId\") REFERENCES \"InsightsChatThread\"(\"id\") ON DELETE CASCADE)'\n    )\n    await prisma.$executeRawUnsafe(\n      'CREATE INDEX IF NOT EXISTS \"InsightsChatMessage_threadId_createdAt_idx\" ON \"InsightsChatMessage\" (\"threadId\", \"createdAt\")'\n    )\n    await prisma.$executeRawUnsafe(\n      'CREATE INDEX IF NOT EXISTS \"InsightsChatThread_user_slug_section_idx\" ON \"InsightsChatThread\" (\"userId\", \"slug\", \"section\")'\n    )\n    tablesEnsured = true\n  } catch (error) {\n    // eslint-disable-next-line no-console\n    console.error('[chat] Failed to ensure tables', error)\n  }\n}\n\nfunction uuid(): string {\n  // Simple UUID v4 generator without external dependency\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n    const r = (Math.random() * 16) | 0\n    const v = c === 'x' ? r : (r & 0x3) | 0x8\n    return v.toString(16)\n  })\n}\n\nexport type ChatThread = { id: string; title: string | null; createdAt: string; updatedAt: string }\n\nexport async function listThreads(userId: string, slug: string, section: string): Promise<ChatThread[]> {\n  await ensureChatTables()\n  const rows: Array<{ id: string; title: string | null; createdAt: Date; updatedAt: Date }> = await prisma.$queryRawUnsafe(\n    'SELECT \"id\",\"title\",\"createdAt\",\"updatedAt\" FROM \"InsightsChatThread\" WHERE \"userId\" = $1 AND \"slug\" = $2 AND \"section\" = $3 ORDER BY \"updatedAt\" DESC LIMIT 50',\n    userId,\n    slug,\n    section\n  )\n  return rows.map((r) => ({ id: r.id, title: r.title, createdAt: r.createdAt.toISOString(), updatedAt: r.updatedAt.toISOString() }))\n}\n\nexport async function createThread(userId: string, slug: string, section: string, title?: string): Promise<{ id: string }> {\n  await ensureChatTables()\n  const id = uuid()\n  await prisma.$executeRawUnsafe(\n    'INSERT INTO \"InsightsChatThread\" (\"id\",\"userId\",\"slug\",\"section\",\"title\") VALUES ($1,$2,$3,$4,$5)',\n    id,\n    userId,\n    slug,\n    section,\n    title || null\n  )\n  return { id }\n}\n\nexport async function updateThreadTitle(threadId: string, title: string): Promise<void> {\n  await ensureChatTables()\n  await prisma.$executeRawUnsafe(\n    'UPDATE \"InsightsChatThread\" SET \"title\" = $1, \"updatedAt\" = NOW() WHERE \"id\" = $2',\n    title,\n    threadId\n  )\n}\n\nexport async function deleteThread(threadId: string): Promise<void> {\n  await ensureChatTables()\n  await prisma.$executeRawUnsafe('DELETE FROM \"InsightsChatThread\" WHERE \"id\" = $1', threadId)\n}\n\nexport async function getOrCreateThread(userId: string, slug: string, section: string): Promise<{ id: string }> {\n  await ensureChatTables()\n  // First check if there are any existing threads for this user/slug/section\n  const existingThreads = await listThreads(userId, slug, section)\n  if (existingThreads.length > 0) {\n    // Return the most recently updated thread instead of creating a new one\n    await prisma.$executeRawUnsafe(\n      'UPDATE \"InsightsChatThread\" SET \"updatedAt\" = NOW() WHERE \"id\" = $1',\n      existingThreads[0].id\n    )\n    return { id: existingThreads[0].id }\n  }\n  // Only create a new thread if none exist\n  const id = uuid()\n  await prisma.$executeRawUnsafe(\n    'INSERT INTO \"InsightsChatThread\" (\"id\",\"userId\",\"slug\",\"section\") VALUES ($1,$2,$3,$4)',\n    id,\n    userId,\n    slug,\n    section\n  )\n  return { id }\n}\n\nexport type ChatMessage = { id: string; role: 'user' | 'assistant'; content: string; createdAt: string }\n\nexport async function listMessages(threadId: string, limit = 40): Promise<ChatMessage[]> {\n  await ensureChatTables()\n  const rows: Array<{ id: string; role: string; content: string; createdAt: Date }> = await prisma.$queryRawUnsafe(\n    'SELECT \"id\",\"role\",\"content\",\"createdAt\" FROM \"InsightsChatMessage\" WHERE \"threadId\" = $1 ORDER BY \"createdAt\" ASC LIMIT $2',\n    threadId,\n    Math.max(1, Math.min(200, limit))\n  )\n  return rows.map((r) => ({ id: r.id, role: r.role as 'user' | 'assistant', content: r.content, createdAt: r.createdAt.toISOString() }))\n}\n\nexport async function appendMessage(threadId: string, role: 'user' | 'assistant', content: string, tokenCount?: number): Promise<string> {\n  await ensureChatTables()\n  const id = uuid()\n  await prisma.$executeRawUnsafe(\n    'INSERT INTO \"InsightsChatMessage\" (\"id\",\"threadId\",\"role\",\"content\",\"tokenCount\") VALUES ($1,$2,$3,$4,$5)',\n    id,\n    threadId,\n    role,\n    content,\n    tokenCount ?? null\n  )\n  await prisma.$executeRawUnsafe('UPDATE \"InsightsChatThread\" SET \"updatedAt\" = NOW() WHERE \"id\" = $1', threadId)\n  return id\n}\n\nexport function getOpenAIClient(): OpenAI | null {\n  if (!process.env.OPENAI_API_KEY) return null\n  return new OpenAI({ apiKey: process.env.OPENAI_API_KEY })\n}\n\nexport async function buildSystemPrompt(userId: string, slug: string, section: IssueSectionKey): Promise<string> {\n  const context: IssueSectionResult | null = await getCachedIssueSection(userId, slug, section, { mode: 'latest' })\n  const summary = context?.summary ?? ''\n  const extras = context?.extras ?? {}\n  const safeExtras = (() => {\n    try {\n      // Avoid very large payloads; pick a few keys and truncate arrays\n      const keys = ['supportiveDetails', 'suggestedAdditions', 'avoidList', 'workingActivities', 'suggestedActivities', 'avoidActivities']\n      const obj: Record<string, unknown> = {}\n      for (const k of keys) {\n        const v = (extras as any)[k]\n        if (Array.isArray(v)) obj[k] = v.slice(0, 8)\n      }\n      return JSON.stringify(obj)\n    } catch {\n      return '{}'\n    }\n  })()\n\n  // Load a privacy-conscious slice of the user's health setup for better grounding\n  let profileJSON = '{}'\n  try {\n    const user = await prisma.user.findUnique({\n      where: { id: userId },\n      include: {\n        healthGoals: true,\n        supplements: true,\n        medications: true,\n        healthLogs: { orderBy: { createdAt: 'desc' }, take: 14 },\n        foodLogs: { orderBy: { createdAt: 'desc' }, take: 10 },\n      },\n    })\n    if (user) {\n      const goals = (user.healthGoals || [])\n        .filter((g: any) => typeof g?.name === 'string' && !g.name.startsWith('__'))\n        .map((g: any) => g.name)\n        .slice(0, 12)\n      const supplements = (user.supplements || [])\n        .map((s: any) => ({ name: s.name, dosage: s.dosage, timing: s.timing }))\n        .filter((s: any) => typeof s.name === 'string' && s.name)\n        .slice(0, 12)\n      const medications = (user.medications || [])\n        .map((m: any) => ({ name: m.name, dosage: m.dosage, timing: m.timing }))\n        .filter((m: any) => typeof m.name === 'string' && m.name)\n        .slice(0, 12)\n      const recentHealthLogs = (user.healthLogs || [])\n        .map((h: any) => ({ rating: h.rating, createdAt: h.createdAt }))\n        .slice(0, 14)\n      const recentFood = (user.foodLogs || [])\n        .map((f: any) => ({ name: f.name, createdAt: f.createdAt }))\n        .slice(0, 10)\n      profileJSON = JSON.stringify({\n        gender: user.gender,\n        height: user.height,\n        weight: user.weight,\n        goals,\n        supplements,\n        medications,\n        recentHealthLogs,\n        recentFood,\n      })\n    }\n  } catch (e) {\n    // eslint-disable-next-line no-console\n    console.warn('[chat] Failed to load user profile slice', e)\n  }\n\n  return [\n    'You are a careful, concise clinical assistant for the current Insights section.',\n    `Issue slug: ${slug}`,\n    `Section: ${section}`,\n    summary ? `Section summary: ${summary}` : '',\n    `Section extras (truncated): ${safeExtras}`,\n    `User profile (truncated): ${profileJSON}`,\n    section === 'supplements'\n      ? 'CRITICAL: Review profile.supplements. Analyze each supplement by understanding its active ingredient(s) and mechanism of action, but ALWAYS reference items by the exact name stored in the profile. If dosage/timing are present, include them briefly. Tie each mention to why it helps this issue.'\n      : section === 'medications'\n      ? 'CRITICAL: Review profile.medications. Analyze each medication by understanding its active ingredient(s) and therapeutic class, but ALWAYS reference items by the exact name stored in the profile. If dosage/timing are present, include them briefly. Tie each mention to why it helps this issue.'\n      : section === 'nutrition'\n      ? 'CRITICAL: Review profile.recentFood. Analyze each logged food/meal by understanding its nutritional profile and physiological effects, but ALWAYS reference items by the exact name stored in the profile. Tie each mention to why it helps this issue.'\n      : section === 'exercise'\n      ? 'CRITICAL: Review profile and any exercise-related context. For logged exercises, analyze their physiological effects but ALWAYS reference items by the exact name stored in the profile. Tie each mention to why it helps this issue.'\n      : section === 'labs'\n      ? 'CRITICAL: Review profile and any lab-related context. Analyze logged tests by understanding what biomarkers they measure, but ALWAYS reference items by the exact test name stored in the profile. Tie each mention to why it helps this issue.'\n      : '',\n    'Rules: avoid diagnosis, encourage clinician consultation for changes. Be specific with practical tips (dose/timing if appropriate).',\n    'CRITICAL: Always format responses with proper paragraphs separated by blank lines.',\n    'Use numbered lists (1. 2. 3.) or bullet points (- or *) for multiple items.',\n    'Use **bold** for emphasis on key terms or headings.',\n    'Break up long responses into clear sections with line breaks between paragraphs.',\n    'NEVER provide responses as one continuous block of text without line breaks.',\n    'Each paragraph should be separated by a blank line (double newline).',\n    'When answering follow-up questions, provide NEW information or clarification, not a repetition of previous answers.'\n  ].filter(Boolean).join('\\n')\n}\n\n\n","truncated":false,"size":10866},{"path":"lib/insights/issue-engine.ts","content":"import { cache } from 'react'\nimport { prisma } from '@/lib/prisma'\nimport { authOptions } from '@/lib/auth'\nimport { getServerSession } from 'next-auth'\nimport { generateSectionInsightsFromLLM, generateDegradedSection, generateDegradedSectionQuick, generateDegradedSectionQuickStrict, evaluateFocusItemsForIssue } from './llm'\n\nexport type IssueSectionKey =\n  | 'overview'\n  | 'exercise'\n  | 'supplements'\n  | 'medications'\n  | 'interactions'\n  | 'labs'\n  | 'nutrition'\n  | 'lifestyle'\n\n// Active sections shown/generated for insights. Overview, Exercise, Interactions, and Lifestyle are intentionally removed.\nexport const ISSUE_SECTION_ORDER: IssueSectionKey[] = ['supplements', 'medications', 'labs', 'nutrition']\n\nexport type DataNeedStatus = 'missing' | 'in-progress' | 'complete'\n\nexport interface InsightDataNeed {\n  key: string\n  title: string\n  description: string\n  actionLabel: string\n  href: string\n  status: DataNeedStatus\n}\n\nexport type IssueStatus = 'needs-data' | 'focus' | 'monitor' | 'on-track'\n\nexport interface IssueSummary {\n  id: string\n  slug: string\n  name: string\n  polarity: 'positive' | 'negative'\n  severityLabel: string\n  severityScore: number | null\n  currentRating: number | null\n  ratingScaleMax: number | null\n  trend: 'improving' | 'declining' | 'stable' | 'inconclusive'\n  trendDelta: number | null\n  lastUpdated: string | null\n  highlight: string\n  blockers: string[]\n  status: IssueStatus\n}\n\nexport type ReportMode = 'latest' | 'daily' | 'weekly' | 'custom'\n\nexport interface IssueSectionResult {\n  issue: IssueSummary\n  section: IssueSectionKey\n  generatedAt: string\n  confidence: number\n  summary: string\n  highlights: SectionHighlight[]\n  dataPoints: SectionDatum[]\n  recommendations: SectionRecommendation[]\n  mode: ReportMode\n  range?: { from?: string; to?: string }\n  extras?: Record<string, unknown>\n}\n\n// Base shape that individual section builders return. The final IssueSectionResult\n// is assembled by attaching mode/range in buildIssueSectionWithContext.\ntype BaseSectionResult = Omit<IssueSectionResult, 'mode' | 'range'>\n\nexport interface SectionHighlight {\n  title: string\n  detail: string\n  tone: 'positive' | 'neutral' | 'warning'\n}\n\nexport interface SectionDatum {\n  label: string\n  value: string\n  context?: string\n}\n\nexport interface SectionRecommendation {\n  title: string\n  description: string\n  actions: string[]\n  priority: 'now' | 'soon' | 'monitor'\n}\n\ninterface UserInsightContext {\n  userId: string\n  issues: Array<{ id: string; name: string; polarity: 'positive' | 'negative'; slug: string }>\n  healthGoals: Record<string, HealthGoalWithLogs>\n  supplements: Array<{ name: string; dosage: string; timing: string[]; updatedAt: Date }>\n  medications: Array<{ name: string; dosage: string; timing: string[]; updatedAt: Date }>\n  exerciseLogs: Array<{ type: string; duration: number; intensity: string | null; createdAt: Date }>\n  foodLogs: Array<{ name: string; description: string | null; createdAt: Date }>\n  todaysFoods: Array<{ name?: string; meal?: string; calories?: number }>\n  bloodResults: BloodResultsData | null\n  dataNeeds: InsightDataNeed[]\n  profile: {\n    gender?: string | null\n    weight?: number | null\n    height?: number | null\n    bodyType?: string | null\n    exerciseFrequency?: string | null\n    exerciseTypes?: string[] | null\n  }\n  onboardingComplete: boolean\n}\n\ninterface HealthGoalWithLogs {\n  id: string\n  name: string\n  currentRating: number | null\n  createdAt: Date\n  updatedAt: Date\n  healthLogs: Array<{ rating: number; notes: string | null; createdAt: Date }>\n}\n\ninterface BloodResultsData {\n  uploadMethod: string\n  documents: Array<{ id?: string; name?: string; url?: string; uploadedAt?: string }>\n  images: Array<{ id?: string; url?: string; uploadedAt?: string }>\n  notes: string\n  skipped: boolean\n  markers?: Array<{ name: string; value?: number; unit?: string; reference?: string }>\n}\n\nconst RATING_SCALE_DEFAULT = 6\nconst SECTION_CACHE_TTL_MS = 1000 * 60 * 15\nconst DEGRADED_CACHE_TTL_MS = 1000 * 60 * 2\nconst CURRENT_PIPELINE_VERSION = 'v11'\nconst FORCE_QUICK_FIRST = process.env.INSIGHTS_FORCE_QUICK_FIRST === 'true'\nconst PAUSE_HEAVY = process.env.INSIGHTS_PAUSE_HEAVY === 'true'\n\nconst RECENT_DATA_WINDOW_MS = 1000 * 60 * 60 * 24\n\nlet sectionCacheTableEnsured = false\n\nasync function ensureSectionCacheTable() {\n  if (sectionCacheTableEnsured) return\n  try {\n    // await prisma.$executeRawUnsafe(\n    //   'CREATE TABLE IF NOT EXISTS \"InsightsSectionCache\" (\"userId\" TEXT NOT NULL, \"slug\" TEXT NOT NULL, \"section\" TEXT NOT NULL, \"mode\" TEXT NOT NULL, \"rangeKey\" TEXT NOT NULL, \"result\" JSONB NOT NULL, \"updatedAt\" TIMESTAMPTZ NOT NULL DEFAULT NOW(), PRIMARY KEY (\"userId\",\"slug\",\"section\",\"mode\",\"rangeKey\"))'\n    // )\n    sectionCacheTableEnsured = true\n  } catch (error) {\n    console.error('[insights.cache] Failed to ensure cache table', error)\n  }\n}\n\nasync function readSectionCache(\n  userId: string,\n  slug: string,\n  section: IssueSectionKey,\n  mode: ReportMode,\n  rangeKey: string\n): Promise<{ result: IssueSectionResult; updatedAt: Date } | null> {\n  try {\n    await ensureSectionCacheTable()\n    const rows: Array<{ result: IssueSectionResult; updatedAt: Date }> = await prisma.$queryRawUnsafe(\n      'SELECT \"result\", \"updatedAt\" FROM \"InsightsSectionCache\" WHERE \"userId\" = $1 AND \"slug\" = $2 AND \"section\" = $3 AND \"mode\" = $4 AND \"rangeKey\" = $5',\n      userId,\n      slug,\n      section,\n      mode,\n      rangeKey\n    )\n    if (rows && rows[0]) {\n      return {\n        result: rows[0].result,\n        updatedAt: new Date(rows[0].updatedAt),\n      }\n    }\n  } catch (error) {\n    console.warn('[insights.cache] Failed to read section cache', error)\n  }\n  return null\n}\n\n// Lightweight exported helper: read a cached section without triggering any compute.\nexport async function getCachedIssueSection(\n  userId: string,\n  slug: string,\n  section: IssueSectionKey,\n  options: Partial<{ mode: ReportMode; range?: { from?: string; to?: string } }>\n): Promise<IssueSectionResult | null> {\n  const mode = options.mode ?? 'latest'\n  const rangeKey = encodeRange(options.range)\n  const cached = await readSectionCache(userId, slug, section, mode, rangeKey)\n  if (!cached) return null\n  \n  // CRITICAL: For exercise section, ensure intake exercises are ALWAYS present in cached results\n  // This fixes stale cached results that were generated before the fix\n  // This is especially important for SSR since getCachedIssueSection is used by layout.tsx\n  if (section === 'exercise') {\n    try {\n      const landing = await loadUserLandingContext(userId)\n      const intakeTypesArray = landing.profile.exerciseTypes ?? []\n      \n      console.log(`[exercise.getCachedIssueSection] Checking cached result. Intake exercises:`, intakeTypesArray)\n      \n      if (intakeTypesArray.length > 0) {\n        const extras = (cached.result.extras as Record<string, unknown> | undefined) ?? {}\n        const existingWorking = (extras.workingActivities as Array<{ title: string; reason?: string; summary?: string; lastLogged?: string }> | undefined) ?? []\n        const workingActivities = [...existingWorking] // Create a new array to avoid mutation issues\n        const workingTitles = new Set(workingActivities.map(w => canonical(w.title)))\n        \n        console.log(`[exercise.getCachedIssueSection] Existing workingActivities count:`, workingActivities.length)\n        \n        // Add any missing intake exercises\n        for (const exerciseType of intakeTypesArray) {\n          const exerciseTypeKey = canonical(exerciseType)\n          if (!workingTitles.has(exerciseTypeKey)) {\n            // Check fuzzy match\n            let alreadyAdded = false\n            for (const w of workingActivities) {\n              if (matchesExerciseType(w.title, exerciseType)) {\n                alreadyAdded = true\n                break\n              }\n            }\n            \n            if (!alreadyAdded) {\n              console.log(`[exercise.getCachedIssueSection] ‚úÖ Injecting intake exercise \"${exerciseType}\" into cached result`)\n              workingActivities.push({\n                title: exerciseType,\n                reason: `${exerciseType} can support this health goal through improved cardiovascular health, stress reduction, and overall physical wellbeing. Regular ${exerciseType.toLowerCase()} helps maintain optimal body function and may contribute positively to this health goal.`,\n                summary: 'Selected in health intake',\n                lastLogged: 'From your health profile',\n              })\n              workingTitles.add(exerciseTypeKey)\n            }\n          }\n        }\n        \n        console.log(`[exercise.getCachedIssueSection] Final workingActivities count:`, workingActivities.length)\n        \n        // Return modified result\n        return {\n          ...cached.result,\n          extras: {\n            ...extras,\n            workingActivities,\n          },\n        }\n      }\n    } catch (error) {\n      console.error(`[exercise.getCachedIssueSection] Error injecting intake exercises:`, error)\n      // Fall through to return cached result as-is if injection fails\n    }\n  }\n  \n  // CRITICAL: For supplements section, ensure fiber supplements are present in cached results for bowel issues\n  if (section === 'supplements') {\n    try {\n      const issueName = cached.result.issue?.name || unslugify(slug)\n      const isBowelIssue = /bowel|digestion|constipation|regularity|stool/i.test(issueName)\n      if (isBowelIssue) {\n        const extras = (cached.result.extras as Record<string, unknown> | undefined) ?? {}\n        const supportiveDetails = (extras['supportiveDetails'] as Array<{ name: string; reason?: string; dosage?: string | null; timing?: string[] | null }> | undefined) ?? []\n        const present = new Set(supportiveDetails.map((s) => canonical(s.name)))\n\n        // Fetch current supplements for the user\n        const user = await prisma.user.findUnique({\n          where: { id: userId },\n          select: { supplements: { select: { name: true, dosage: true, timing: true } } },\n        })\n        const supplements = user?.supplements ?? []\n\n        const fiberSupplements = supplements.filter((supp) => {\n          const isFiber = /fiber|fibre|psyllium|inulin|guar gum|phgg/i.test(supp.name)\n          return isFiber && !present.has(canonical(supp.name))\n        })\n\n        if (fiberSupplements.length > 0) {\n          const enriched = fiberSupplements.map((supp) => ({\n            name: supp.name,\n            reason:\n              `${supp.name} contains soluble fiber that supports bowel regularity through hydration, gel formation, and fermentation to short-chain fatty acids that normalize stool consistency.`,\n            dosage: (supp as any).dosage ?? null,\n            timing: Array.isArray((supp as any).timing) ? (supp as any).timing : [],\n          }))\n\n          return {\n            ...cached.result,\n            extras: {\n              ...extras,\n              supportiveDetails: [...supportiveDetails, ...enriched],\n            },\n          }\n        }\n      }\n    } catch (error) {\n      console.warn('[supplements.getCachedIssueSection] Error injecting fiber supplements into cached result', error)\n    }\n  }\n  \n  return cached.result\n}\n\nasync function upsertSectionCache(params: {\n  userId: string\n  slug: string\n  section: IssueSectionKey\n  mode: ReportMode\n  rangeKey: string\n  result: IssueSectionResult | null\n}) {\n  const { userId, slug, section, mode, rangeKey, result } = params\n  if (!result) return\n  try {\n    await ensureSectionCacheTable()\n    await prisma.$queryRawUnsafe(\n      'INSERT INTO \"InsightsSectionCache\" (\"userId\",\"slug\",\"section\",\"mode\",\"rangeKey\",\"result\",\"updatedAt\") VALUES ($1,$2,$3,$4,$5,$6::jsonb,NOW())\\n         ON CONFLICT (\"userId\",\"slug\",\"section\",\"mode\",\"rangeKey\") DO UPDATE SET \"result\" = EXCLUDED.\"result\", \"updatedAt\" = NOW()',\n      userId,\n      slug,\n      section,\n      mode,\n      rangeKey,\n      JSON.stringify(result)\n    )\n  } catch (error) {\n    console.error('[insights.cache] Failed to upsert section cache', error)\n  }\n}\n\nfunction isRecent(date: Date | null | undefined, windowMs = RECENT_DATA_WINDOW_MS) {\n  if (!date) return false\n  return date.getTime() >= Date.now() - windowMs\n}\n\nconst SUPPLEMENT_KEYWORDS = [\n  'supplement',\n  'capsule',\n  'powder',\n  'extract',\n  'herb',\n  'herbal',\n  'oil',\n  'tincture',\n  'tea',\n  'vitamin',\n  'magnesium',\n  'zinc',\n  'omega',\n  'ashwagandha',\n  'turmeric',\n  'probiotic',\n  'adaptogen',\n  'psyllium',\n  'fiber',\n]\n\nconst FOOD_KEYWORDS = [\n  'salad',\n  'apple',\n  'banana',\n  'pear',\n  'orange',\n  'citrus',\n  'broccoli',\n  'kale',\n  'spinach',\n  'fruit',\n  'vegetable',\n  'veg',\n  'berry',\n  'grain',\n  'oat',\n  'rice',\n  'bread',\n  'pasta',\n  'bean',\n  'lentil',\n  'fish',\n  'salmon',\n  'tuna',\n  'sardine',\n  'chicken',\n  'turkey',\n  'beef',\n  'egg',\n  'yogurt',\n  'kefir',\n  'smoothie',\n  'soup',\n  'stew',\n  'nut',\n  'seed',\n  'avocado',\n  'leafy',\n]\n\nfunction canonical(value: string) {\n  return value.trim().toLowerCase()\n}\n\n// Enhanced matching for exercise name variations\nfunction matchesExerciseType(exerciseName: string, intakeType: string): boolean {\n  const exerciseKey = canonical(exerciseName)\n  const intakeKey = canonical(intakeType)\n  \n  // Exact match\n  if (exerciseKey === intakeKey) return true\n  \n  // Common exercise name variations\n  const variations: Record<string, string[]> = {\n    'walking': ['walk', 'walking exercise', 'brisk walking', 'walking workout'],\n    'running': ['run', 'jogging', 'jog', 'running workout'],\n    'cycling': ['bike riding', 'bicycle', 'bike', 'cycling workout', 'bike ride'],\n    'swimming': ['swim', 'swimming workout'],\n    'weight training': ['weights', 'weightlifting', 'strength training', 'resistance training'],\n    'yoga': ['yoga practice', 'yoga session'],\n    'boxing': ['boxing workout', 'boxing training', 'box'],\n    'hiit': ['high intensity interval training', 'hiit workout'],\n  }\n  \n  // Check if either name is a key and the other is in its variations\n  for (const [key, vars] of Object.entries(variations)) {\n    const normalizedKey = canonical(key)\n    if (normalizedKey === exerciseKey || normalizedKey === intakeKey) {\n      const otherKey = normalizedKey === exerciseKey ? intakeKey : exerciseKey\n      if (vars.some(v => canonical(v) === otherKey)) return true\n    }\n  }\n  \n  // Partial match: check if one contains the other (for multi-word exercises)\n  const exerciseWords = exerciseKey.split(/\\s+/).filter(w => w.length >= 4)\n  const intakeWords = intakeKey.split(/\\s+/).filter(w => w.length >= 4)\n  \n  if (exerciseWords.length > 0 && intakeWords.length > 0) {\n    // Check if any significant word from one appears in the other\n    if (exerciseWords.some(w => intakeKey.includes(w)) || intakeWords.some(w => exerciseKey.includes(w))) {\n      return true\n    }\n  }\n  \n  return false\n}\n\nfunction looksSupplementLike(value: string) {\n  const lower = value.toLowerCase()\n  return SUPPLEMENT_KEYWORDS.some((keyword) => lower.includes(keyword))\n}\n\nfunction looksFoodLike(value: string) {\n  const lower = value.toLowerCase()\n  return FOOD_KEYWORDS.some((keyword) => lower.includes(keyword))\n}\n\nfunction hasRecentSupplementActivity(supplements: UserInsightContext['supplements']) {\n  return supplements.some((supp) => isRecent(supp.updatedAt))\n}\n\nfunction hasRecentMedicationActivity(medications: UserInsightContext['medications']) {\n  return medications.some((med) => isRecent(med.updatedAt))\n}\n\nfunction hasRecentExerciseLogs(exerciseLogs: UserInsightContext['exerciseLogs']) {\n  return exerciseLogs.some((log) => isRecent(log.createdAt))\n}\n\nfunction hasRecentFoodLogs(foodLogs: UserInsightContext['foodLogs']) {\n  return foodLogs.some((log) => isRecent(log.createdAt))\n}\n\nconst ISSUE_KNOWLEDGE_BASE: Record<string, {\n  aliases?: string[]\n  helpfulSupplements?: Array<{ pattern: RegExp; title?: string; why: string; suggested?: string }>\n  gapSupplements?: Array<{ title: string; why: string; suggested?: string }>\n  avoidSupplements?: Array<{ pattern: RegExp; title?: string; why: string }>\n  helpfulMedications?: Array<{ pattern: RegExp; title?: string; why: string; suggested?: string }>\n  gapMedications?: Array<{ title: string; why: string; suggested?: string }>\n  avoidMedications?: Array<{ pattern: RegExp; title?: string; why: string }>\n  supportiveExercises?: Array<{ title: string; detail: string; keywords?: string[] }>\n  avoidExercises?: Array<{ title: string; detail: string }>\n  nutritionFocus?: Array<{ title: string; detail: string; keywords?: string[] }>\n  avoidFoods?: Array<{ title: string; detail: string; keywords?: string[] }>\n  lifestyleFocus?: Array<{ title: string; detail: string }>\n  keyLabs?: Array<{ marker: string; optimal: string; cadence: string; note?: string }>\n}> = {\n  libido: {\n    aliases: ['low libido', 'sexual health', 'erectile function', 'erection quality'],\n    helpfulSupplements: [\n      { pattern: /ashwagandha/i, why: 'may improve sexual performance and stress resilience', suggested: 'KSM-66 or Sensoril, 300‚Äì600mg/day' },\n      { pattern: /tongkat|longjack/i, why: 'can support testosterone and libido metrics', suggested: 'Eurycoma longifolia extract, 200‚Äì400mg/day' },\n      { pattern: /tribulus/i, why: 'traditionally used for libido and androgen support', suggested: 'Standardized to protodioscin, 500‚Äì750mg/day' },\n      { pattern: /cistanche/i, why: 'Tonifies yang and may enhance libido and stamina', suggested: 'Cistanche tubulosa extract, 300‚Äì600mg/day' },\n      { pattern: /muira|muira\\s?puama|ptychopetalum/i, why: 'Often used for arousal and nitric oxide support', suggested: 'Muira puama extract, 250‚Äì500mg/day' },\n      { pattern: /zinc/i, why: 'supports hormonal balance when levels are low', suggested: 'Zinc bisglycinate 15‚Äì30mg with food' },\n      { pattern: /l[-\\s]?arginine/i, why: 'can aid nitric oxide availability for circulation', suggested: 'L-arginine 3‚Äì6g/day or L-citrulline 2‚Äì3g/day' },\n    ],\n    gapSupplements: [\n      { title: 'Consider adaptogens for stress-linked libido dips', why: 'Chronic stress suppresses libido; ashwagandha or rhodiola can moderate cortisol', suggested: 'Ashwagandha 600mg/day (divided)' },\n      { title: 'Evaluate zinc status', why: 'Low zinc impairs testosterone conversion and sexual health', suggested: 'Zinc bisglycinate 15‚Äì30mg with food' },\n    ],\n    avoidSupplements: [\n      { pattern: /yohim(b|)ine/i, why: 'Can spike blood pressure and anxiety; avoid unless supervised by a clinician.' },\n      { pattern: /pseudoephedrine|decongestant/i, why: 'Constriction of blood vessels can undermine erectile blood flow.' },\n      { pattern: /excessive\\s?alcohol/i, why: 'Depresses CNS and worsens erection quality and arousal.' },\n      { pattern: /nicotine|smoking/i, why: 'Impairs vascular function and nitric oxide signaling.' },\n    ],\n    helpfulMedications: [\n      {\n        pattern: /tadalafil|cialis|sildenafil|viagra|avanafil|stendra|vardenafil|levitra/i,\n        why: 'PDE5 inhibitors directly improve erection quality by enhancing blood flow.',\n      },\n    ],\n    gapMedications: [\n      { title: 'Discuss PDE5 support', why: 'Low erections or arousal could benefit from as-needed PDE5 inhibitors.', suggested: 'Tadalafil 5mg once daily' },\n    ],\n    avoidMedications: [\n      { pattern: /ssri|snri/i, why: 'Some antidepressants can blunt libido‚Äîreview dosing with your clinician.' },\n    ],\n    supportiveExercises: [\n      {\n        title: 'Progressive resistance training 3x/week',\n        detail: 'Supports testosterone, strength, and confidence metrics',\n        keywords: ['strength', 'resistance', 'weights'],\n      },\n      {\n        title: 'Short HIIT blocks',\n        detail: 'Improves endothelial function and nitric oxide availability',\n        keywords: ['hiit', 'interval', 'sprint'],\n      },\n    ],\n    avoidExercises: [\n      {\n        title: 'Excessive long slow cardio when energy is low',\n        detail: 'Very long endurance blocks can suppress testosterone‚Äîcap steady sessions at 45 minutes until resilience improves.',\n      },\n    ],\n    nutritionFocus: [\n      {\n        title: 'Prioritise omega-3 rich meals',\n        detail: 'Cardiovascular health underpins libido; aim for 2 oily fish servings/week',\n        keywords: ['salmon', 'sardine', 'mackerel', 'omega'],\n      },\n      {\n        title: 'Stabilise blood sugar',\n        detail: 'Balanced carbs + protein prevent insulin spikes that can blunt hormone signalling',\n        keywords: ['balanced', 'protein', 'fiber', 'low glycemic'],\n      },\n      {\n        title: 'Add nitrate-rich greens',\n        detail: 'Beetroot and leafy greens support nitric oxide for blood flow',\n        keywords: ['beet', 'rocket', 'arugula', 'spinach'],\n      },\n      {\n        title: 'Hydration and electrolytes',\n        detail: 'Adequate fluids support performance and vascular tone',\n        keywords: ['water', 'electrolyte', 'salt'],\n      },\n    ],\n    avoidFoods: [\n      {\n        title: 'Ultra-processed sugary foods',\n        detail: 'Rapid glucose swings can disrupt hormones linked to libido.',\n        keywords: ['soda', 'dessert', 'candy', 'pastry', 'cake'],\n      },\n      {\n        title: 'Trans-fat laden takeaways',\n        detail: 'Industrial oils impair vascular tone; swap for home-cooked meals with olive oil.',\n        keywords: ['fried', 'fast food', 'takeaway'],\n      },\n      {\n        title: 'Heavy late-night meals',\n        detail: 'Late, heavy meals impair sleep quality and next-day libido.',\n        keywords: ['late dinner', 'greasy', 'large portions'],\n      },\n      {\n        title: 'High alcohol evenings',\n        detail: 'Alcohol blunts arousal and disrupts sleep architecture.',\n        keywords: ['alcohol', 'wine', 'beer', 'spirits'],\n      },\n    ],\n    lifestyleFocus: [\n      { title: 'Sleep 7.5‚Äì8 h with consistent wake time', detail: 'Testosterone release peaks during deep sleep; maintain routine' },\n      { title: 'Stress decompression window', detail: 'Daily wind-down (breathwork, light stretching) reduces sympathetic dominance' },\n    ],\n    keyLabs: [\n      { marker: 'Total & Free Testosterone', optimal: 'Total 550‚Äì900 ng/dL, Free 15‚Äì25 pg/mL', cadence: 'Retest every 6‚Äì12 weeks if adjusting therapy', note: 'Draw between 7‚Äì10am and ensure 48h without intense training' },\n      { marker: 'SHBG & DHEA-S', optimal: 'SHBG 20‚Äì60 nmol/L, DHEA-S age-adjusted mid-range', cadence: 'Assess annually or with symptom shifts' },\n      { marker: 'Vitamin D', optimal: '40‚Äì60 ng/mL', cadence: 'Every 6 months if supplementing' },\n    ],\n  },\n  energy: {\n    aliases: ['fatigue', 'low energy'],\n    helpfulSupplements: [\n      { pattern: /b12|methylcobalamin/i, why: 'supports methylation and energy when levels are low' },\n      { pattern: /coq10|ubiquinol/i, why: 'assists mitochondrial ATP output, especially if on statins' },\n      { pattern: /magnesium/i, why: 'involved in ATP production and sleep quality' },\n      { pattern: /adaptogen|rhodiola|ginseng/i, why: 'modulates stress response and perceived fatigue' },\n    ],\n    gapSupplements: [\n      { title: 'B-complex for cellular energy', why: 'Supports mitochondrial pathways if intake is low', suggested: 'Methylated B-complex with breakfast' },\n    ],\n    avoidSupplements: [\n      { pattern: /mega\\s?dose\\s?caffeine|excessive\\s?caffeine/i, why: 'Very high stimulant loads can worsen crashes and sleep, keeping fatigue high.' },\n    ],\n    helpfulMedications: [\n      { pattern: /thyroid|levothyroxine/i, why: 'Optimised thyroid replacement can lift energy when labs are low.' },\n    ],\n    gapMedications: [\n      { title: 'Review iron status', why: 'Low ferritin sometimes calls for iron therapy‚Äîconfirm labs first.', suggested: 'Consider iron bisglycinate (practitioner guided)' },\n    ],\n    avoidMedications: [\n      { pattern: /sedative|benzodiazepine/i, why: 'Sedatives can worsen daytime fatigue‚Äîcheck in with your prescriber.' },\n    ],\n    supportiveExercises: [\n      {\n        title: 'Zone 2 cardio 2‚Äì3x/week',\n        detail: 'Builds mitochondrial density without draining reserves',\n        keywords: ['zone 2', 'steady', 'endurance', 'cardio'],\n      },\n      {\n        title: 'Mobility days',\n        detail: 'Maintains circulation and reduces stiffness-related fatigue',\n        keywords: ['mobility', 'stretch', 'yoga', 'pilates'],\n      },\n    ],\n    avoidExercises: [\n      {\n        title: 'Stacking intense HIIT on consecutive days',\n        detail: 'Back-to-back redline sessions can deepen fatigue; insert recovery between high-intensity blocks.',\n      },\n    ],\n    nutritionFocus: [\n      {\n        title: 'Anchor each meal with 25g protein',\n        detail: 'Prevents post-prandial crashes and supports recovery',\n        keywords: ['protein', 'eggs', 'chicken', 'beans', 'tofu'],\n      },\n      {\n        title: 'Strategic caffeine window',\n        detail: 'Keep caffeine before 2pm to protect sleep architecture',\n        keywords: ['coffee', 'matcha', 'caffeine'],\n      },\n    ],\n    avoidFoods: [\n      {\n        title: 'Late afternoon caffeine hits',\n        detail: 'Stimulants after 2pm can blunt sleep quality and daytime energy.',\n        keywords: ['energy drink', 'late coffee', 'espresso', 'caffeine'],\n      },\n      {\n        title: 'High-sugar breakfast pastries',\n        detail: 'Spike-and-crash breakfasts keep fatigue high‚Äîpair carbs with protein and fiber.',\n        keywords: ['donut', 'croissant', 'muffin', 'pastry'],\n      },\n    ],\n    lifestyleFocus: [\n      { title: 'Light exposure within 30 min of waking', detail: 'Entrains circadian rhythm for daytime energy' },\n      { title: 'Evening digital sunset', detail: 'Reduce blue light to support melatonin release' },\n    ],\n    keyLabs: [\n      { marker: 'CBC & Ferritin', optimal: 'Ferritin 70‚Äì120 ng/mL', cadence: 'Every 6 months if symptomatic' },\n      { marker: 'Thyroid Panel', optimal: 'TSH 0.8‚Äì2.0 ¬µIU/mL, Free T3 upper half', cadence: '6‚Äì12 months' },\n    ],\n  },\n  'bowel movements': {\n    aliases: ['constipation', 'irregular stools', 'sluggish bowels', 'bowel-movement', 'bowel-movements'],\n    helpfulSupplements: [\n      { pattern: /magnesium\\s?(citrate|glycinate|oxide)?/i, why: 'Osmotic effect draws water into stool to ease passage', suggested: 'Magnesium citrate 200‚Äì400mg in the evening' },\n      { pattern: /psyllium|husk|fiber/i, why: 'Bulk-forming fiber improves stool consistency and frequency', suggested: 'Psyllium husk 1‚Äì2 tsp with 300ml water daily' },\n      { pattern: /probiotic|bifido|lacto/i, why: 'Certain strains improve stool frequency and transit time', suggested: 'Multi‚Äëstrain probiotic providing 10‚Äì20B CFU daily' },\n      { pattern: /triphala/i, why: 'Ayurvedic blend gently supports motility without harsh stimulation', suggested: '500‚Äì1000mg before bed' },\n    ],\n    gapSupplements: [\n      { title: 'Hydration + electrolytes', why: 'Adequate fluids keep fiber effective and stool soft', suggested: 'Aim for 2‚Äì2.5L water/day; add electrolytes if training' },\n    ],\n    avoidSupplements: [\n      { pattern: /high[-\\s]?dose\\s?iron/i, why: 'Frequently constipating; review need and dose with clinician' },\n      { pattern: /calcium(\\s?carbonate)?/i, why: 'Carbonate form can slow motility and harden stools' },\n      { pattern: /aluminium|aluminum/i, why: 'Aluminium-containing antacids can cause constipation' },\n      { pattern: /excessive\\s?caffeine/i, why: 'Diuretic effect can dehydrate and harden stools for some' },\n    ],\n    helpfulMedications: [\n      { pattern: /polyethylene\\s?glycol|peg\\s?3350|macrogol/i, why: 'Osmotic laxative softens stool and increases frequency' },\n      { pattern: /lactulose/i, why: 'Osmotic agent that draws water into colon to ease passage' },\n      { pattern: /senna|sennosides/i, why: 'Stimulant laxative that increases motility (short term use)' },\n      { pattern: /docusate|stool\\s?softener/i, why: 'Reduces stool surface tension to ease passage' },\n    ],\n    gapMedications: [\n      { title: 'Consider short trial of osmotic support', why: 'If dietary measures fail, short course may help reset rhythm', suggested: 'PEG 3350 as directed by clinician' },\n    ],\n    avoidMedications: [\n      { pattern: /opioid|codeine|oxycodone|morphine/i, why: 'Strongly constipating; requires bowel regimen if continued' },\n      { pattern: /anticholinergic|amitriptyline|oxybutynin/i, why: 'Reduce gut motility and secretions‚Äîreview necessity' },\n      { pattern: /high[-\\s]?dose\\s?iron/i, why: 'Common cause of medication‚Äëinduced constipation' },\n      { pattern: /calcium\\s?channel\\s?blocker|verapamil/i, why: 'May slow intestinal transit in some people' },\n    ],\n    supportiveExercises: [\n      { title: '10‚Äì15 min brisk walk after meals', detail: 'Post‚Äëmeal movement stimulates gastrocolic reflex and motility', keywords: ['walk', 'post-meal', 'brisk'] },\n      { title: 'Deep squat holds 3√ó30‚Äì45s', detail: 'Improves pelvic floor relaxation and defecation posture', keywords: ['squat', 'deep squat', 'mobility'] },\n      { title: 'Abdominal massage clockwise 5 min', detail: 'Mechanical stimulation of colon segments can aid transit', keywords: ['massage', 'abdominal'] },\n      { title: 'Gentle yoga: wind-relieving, twists', detail: 'Twists and knee‚Äëto‚Äëchest postures can mobilize gas/stool', keywords: ['yoga', 'twist', 'pawanmuktasana'] },\n    ],\n    avoidExercises: [\n      { title: 'Heavy straining without breath control', detail: 'Valsalva increases pelvic floor tension and can worsen constipation' },\n      { title: 'Very long sedentary blocks', detail: 'Prolonged sitting reduces colonic motility‚Äîinsert movement snacks' },\n      { title: 'Dehydrating endurance without fluids', detail: 'Fluid loss hardens stool; match sweat with hydration' },\n      { title: 'Late‚Äënight vigorous training', detail: 'May disturb sleep which impairs morning bowel rhythm' },\n    ],\n    nutritionFocus: [\n      { title: '25‚Äì35g fiber with gradual build', detail: 'Mix soluble and insoluble fiber to improve stool form', keywords: ['oats', 'vegetables', 'legumes', 'fruit'] },\n      { title: '2 kiwifruit or a handful of prunes', detail: 'Both show evidence for increasing stool frequency', keywords: ['kiwi', 'prunes'] },\n      { title: 'Daily probiotic/fermented food', detail: 'Supports beneficial bacteria and short‚Äëchain fatty acids', keywords: ['yogurt', 'kefir', 'sauerkraut'] },\n      { title: 'Hydration habit (2‚Äì2.5L)', detail: 'Water keeps fiber effective and stool soft', keywords: ['water', 'electrolyte'] },\n    ],\n    avoidFoods: [\n      { title: 'Ultra‚Äëprocessed low‚Äëfiber snacks', detail: 'Lack of fiber reduces stool bulk and slows transit', keywords: ['chips', 'cookies', 'white bread'] },\n      { title: 'Excess dairy if sensitive', detail: 'For some, high cheese/ice‚Äëcream intake worsens firmness', keywords: ['cheese', 'ice cream'] },\n      { title: 'Very low‚Äëcarb with minimal vegetables', detail: 'Insufficient fiber intake commonly leads to constipation', keywords: ['keto', 'low carb'] },\n      { title: 'Dehydrating alcohol evenings', detail: 'Fluid loss overnight hardens stools next morning', keywords: ['alcohol', 'wine', 'spirits'] },\n    ],\n    lifestyleFocus: [\n      { title: 'Morning bowel routine after breakfast', detail: 'Use the gastrocolic reflex; sit unhurriedly 10‚Äì15 min' },\n      { title: 'Footstool for squat‚Äëlike posture', detail: 'Improves anorectal angle and reduces straining' },\n      { title: 'Mindful breathing to relax pelvic floor', detail: 'Down‚Äëregulates sympathetic tone that inhibits motility' },\n      { title: 'Consistent sleep and wake time', detail: 'Circadian regularity supports predictable bowel movements' },\n    ],\n  },\n}\n\nconst INTERACTION_RULES: Array<{\n  id: string\n  condition: (params: { supplements: string[]; medications: string[] }) => boolean\n  message: string\n  rationale: string\n  priority: 'now' | 'soon' | 'monitor'\n}> = [\n  {\n    id: 'iron-calcium-spacing',\n    condition: ({ supplements }) => hasMatch(supplements, /iron/) && hasMatch(supplements, /calcium/),\n    message: 'Separate iron and calcium',\n    rationale: 'Calcium blocks iron absorption; a 2-hour gap preserves efficacy.',\n    priority: 'now',\n  },\n  {\n    id: 'magnesium-thyroid-spacing',\n    condition: ({ supplements, medications }) => hasMatch(supplements, /magnesium/) && hasMatch(medications, /thyroxine|levothyroxine|eltroxin/i),\n    message: 'Space magnesium from thyroid medication',\n    rationale: 'Minerals reduce levothyroxine absorption; take thyroid dosing on empty stomach, magnesium later in the day.',\n    priority: 'now',\n  },\n  {\n    id: 'omega-anticoagulant-monitor',\n    condition: ({ supplements, medications }) => hasMatch(supplements, /(omega|fish oil|epa|dha)/i) && hasMatch(medications, /warfarin|xarelto|eliquis|apixaban|dabigatran|clopidogrel/i),\n    message: 'Check omega-3 with anticoagulants',\n    rationale: 'High-dose omega-3 can enhance anticoagulant effect; coordinate with prescribing clinician.',\n    priority: 'soon',\n  },\n]\n\nfunction hasMatch(items: string[], pattern: RegExp) {\n  return items.some(item => pattern.test(item))\n}\n\nfunction slugify(value: string) {\n  return value\n    .toLowerCase()\n    .trim()\n    .replace(/[^a-z0-9]+/g, '-')\n    .replace(/^-+|-+$/g, '')\n}\n\nfunction unslugify(value: string) {\n  const words = value.replace(/[-_]+/g, ' ').trim()\n  if (!words) return 'Issue'\n  return words\n    .split(' ')\n    .map(part => part.charAt(0).toUpperCase() + part.slice(1))\n    .join(' ')\n}\n\n// Turn a regex pattern into a readable label as a fallback when no explicit title is provided.\nfunction displayFromPattern(pattern: RegExp): string {\n  let s = pattern.source\n  s = s\n    .replace(/\\\\s\\?/g, ' ') // optional whitespace\n    .replace(/\\\\s/g, ' ')\n    .replace(/\\[.*?\\]/g, ' ') // character classes\n    .replace(/[\\\\^$*+?]/g, '') // regex operators\n    .replace(/\\(\\?:/g, '(')\n    .replace(/[()]/g, '')\n    .replace(/\\|/g, ' / ')\n    .replace(/\\s{2,}/g, ' ')\n    .trim()\n  if (!s) return 'Item'\n  return s\n    .split(' ')\n    .map(part => part ? part.charAt(0).toUpperCase() + part.slice(1) : part)\n    .join(' ')\n}\n\n// Ensure at least `min` items by topping up from a fallback list, de-duplicating by JSON identity.\nfunction ensureMin<T>(primary: T[], fallback: T[], min = 4): T[] {\n  const seen = new Set<string>()\n  const out: T[] = []\n  for (const item of primary) {\n    const key = JSON.stringify(item)\n    if (!seen.has(key)) {\n      seen.add(key)\n      out.push(item)\n    }\n    if (out.length >= min) break\n  }\n  if (out.length < min) {\n    for (const fb of fallback) {\n      const key = JSON.stringify(fb)\n      if (!seen.has(key)) {\n        seen.add(key)\n        out.push(fb)\n      }\n      if (out.length >= min) break\n    }\n  }\n  return out.slice(0, min)\n}\n\nfunction hasStructuredData(value: unknown) {\n  if (!value) return false\n  if (Array.isArray(value)) return value.length > 0\n  if (typeof value === 'object') return Object.keys(value as Record<string, unknown>).length > 0\n  return !!value\n}\n\n// Only persist successful, useful results in the DB cache. Avoid caching\n// error states or placeholder results that would mask recovery for 15 minutes.\nfunction shouldCacheSectionResult(result: IssueSectionResult | null): boolean {\n  if (!result) return false\n  // Always cache overview since it has no LLM dependency\n  if (result.section === 'overview') return true\n  const extras = (result.extras as Record<string, unknown> | undefined) ?? {}\n  const source = String(extras['source'] ?? '')\n  const pipelineVersion = String(extras['pipelineVersion'] ?? '')\n  const validated = Boolean(extras['validated'])\n  const degraded = Boolean(extras['degraded'])\n  // Known non-success sources we do not want to cache\n  const badSources = new Set(['llm-error', 'needs-data', 'needs-fresh-data'])\n  if (badSources.has(source)) return false\n  // Cache validated results from the new pipeline\n  if (validated && pipelineVersion === CURRENT_PIPELINE_VERSION) return true\n  // Additionally, cache degraded results with a short TTL to avoid repeated cold waits\n  if (!validated && degraded) return true\n  return false\n}\n\nfunction buildDataNeed(goalName: string, category: string | null | undefined): InsightDataNeed | null {\n  let parsed: any = null\n  if (category) {\n    try {\n      parsed = JSON.parse(category)\n    } catch {\n      parsed = null\n    }\n  }\n\n  switch (goalName) {\n    case '__TODAYS_FOODS_DATA__': {\n      const foods = Array.isArray(parsed?.foods) ? parsed.foods : []\n      return {\n        key: 'todays-foods',\n        title: \"Log today's meals\",\n        description: foods.length ? 'Meals saved for today ‚Äî keep logging to stay on track.' : 'Log what you ate today to unlock nutrition insights.',\n        actionLabel: foods.length ? 'Review food log' : 'Log food',\n        href: '/food',\n        status: foods.length ? 'in-progress' : 'missing',\n      }\n    }\n    case '__BLOOD_RESULTS_DATA__': {\n      const documents = Array.isArray(parsed?.documents) ? parsed.documents : []\n      const images = Array.isArray(parsed?.images) ? parsed.images : []\n      const markers = Array.isArray(parsed?.markers) ? parsed.markers : []\n      const skipped = Boolean(parsed?.skipped)\n      const hasData = documents.length > 0 || images.length > 0 || markers.length > 0\n      return {\n        key: 'blood-results',\n        title: 'Upload recent labs',\n        description: hasData\n          ? 'Lab files saved. Add markers or new results when ready.'\n          : skipped\n          ? 'You can skip for now, but labs unlock deeper tracking.'\n          : 'Add your latest bloodwork to personalise lab insights.',\n        actionLabel: hasData ? 'Update labs' : 'Add labs',\n        href: '/onboarding?step=9', // labs upload step in Health Setup\n        status: hasData ? 'in-progress' : skipped ? 'in-progress' : 'missing',\n      }\n    }\n    case '__HEALTH_SITUATIONS_DATA__': {\n      const situations = Array.isArray(parsed) ? parsed : parsed?.situations\n      const hasData = hasStructuredData(situations)\n      return {\n        key: 'health-situations',\n        title: 'Log current health situations',\n        description: hasData\n          ? 'Situations recorded. Update if something changes.'\n          : 'Tell us about recent diagnoses or treatments to tailor insights.',\n        actionLabel: hasData ? 'Review details' : 'Add situations',\n        href: '/onboarding?step=health-situations',\n        status: hasData ? 'in-progress' : 'missing',\n      }\n    }\n    case '__SUPPLEMENTS_BACKUP_DATA__': {\n      const supplements = Array.isArray(parsed?.supplements) ? parsed.supplements : []\n      const hasData = supplements.length > 0\n      return {\n        key: 'supplements-backup',\n        title: 'Confirm supplement list',\n        description: hasData\n          ? 'Supplement backup saved. Keep it updated for quick restores.'\n          : 'Save a master list of supplements so we can track changes easily.',\n        actionLabel: hasData ? 'Update list' : 'Add supplements',\n        href: '/onboarding?step=1',\n        status: hasData ? 'in-progress' : 'missing',\n      }\n    }\n    case '__SUPPLEMENTS_EMERGENCY_BACKUP__': {\n      const hasData = hasStructuredData(parsed)\n      return {\n        key: 'supplements-emergency',\n        title: 'Set an emergency supplement plan',\n        description: hasData\n          ? 'Emergency protocol saved. Revisit to keep it current.'\n          : 'Outline a go-to plan for missed doses or travel days.',\n        actionLabel: hasData ? 'Review plan' : 'Create plan',\n        href: '/onboarding?step=1',\n        status: hasData ? 'in-progress' : 'missing',\n      }\n    }\n    case '__DEVICE_INTEREST__': {\n      const selections = parsed && typeof parsed === 'object' ? Object.values(parsed).filter(Boolean) : []\n      const hasData = selections.length > 0\n      return {\n        key: 'device-sync',\n        title: 'Connect wearables',\n        description: hasData\n          ? 'Device preferences saved. Sync data when ready.'\n          : 'Tell us which devices you use so we can pull in activity and sleep.',\n        actionLabel: hasData ? 'Update devices' : 'Add device',\n        href: '/settings?section=devices',\n        status: hasData ? 'in-progress' : 'missing',\n      }\n    }\n    case '__PROFILE_INFO_DATA__': {\n      const hasData = hasStructuredData(parsed)\n      return {\n        key: 'profile-info',\n        title: 'Complete your profile',\n        description: hasData\n          ? 'Profile saved. Update it if your basics change.'\n          : 'Add basic details so recommendations can be personalised.',\n        actionLabel: hasData ? 'Edit profile' : 'Add profile info',\n        href: '/settings',\n        status: hasData ? 'in-progress' : 'missing',\n      }\n    }\n    default:\n      return null\n  }\n}\n\nfunction inferPolarityFromName(name: string): 'positive' | 'negative' {\n  const lowered = name.toLowerCase()\n  if (/(pain|ache|injury|flare|anxiety|depress|stress|insomnia|fatigue|low\\s|lack|poor|bloat|nausea|migraine|cramp|brain fog|libido|bp|blood pressure|cholesterol)/i.test(lowered)) {\n    return 'negative'\n  }\n  if (/(gain|build|improve|increase|optimi[sz]e|boost|support|focus|goal|performance|endurance|strength|muscle|energy)/i.test(lowered)) {\n    return 'positive'\n  }\n  return 'negative'\n}\n\nfunction normaliseRating(\n  rating: number | null | undefined,\n  polarity: 'positive' | 'negative',\n  hasLogs: boolean\n) : { score: number | null; label: string; status: IssueStatus } {\n  if (!hasLogs || rating === null || rating === undefined) {\n    return { score: null, label: 'Needs data', status: 'needs-data' }\n  }\n  const scaleMax = RATING_SCALE_DEFAULT\n  const bounded = Math.max(0, Math.min(scaleMax, rating))\n  const percentage = (bounded / scaleMax) * 100\n  if (polarity === 'negative') {\n    if (percentage >= 70) return { score: percentage, label: 'High impact', status: 'focus' }\n    if (percentage >= 40) return { score: percentage, label: 'Moderate impact', status: 'monitor' }\n    if (percentage > 0) return { score: percentage, label: 'Mild impact', status: 'monitor' }\n    return { score: percentage, label: 'On track', status: 'on-track' }\n  }\n  if (percentage >= 80) return { score: percentage, label: 'Excellent progress', status: 'on-track' }\n  if (percentage >= 55) return { score: percentage, label: 'On track', status: 'monitor' }\n  if (percentage >= 30) return { score: percentage, label: 'Needs support', status: 'focus' }\n  return { score: percentage, label: 'Off track', status: 'focus' }\n}\n\nfunction calculateTrend(logs: Array<{ rating: number; createdAt: Date }>, polarity: 'positive' | 'negative') {\n  if (!logs || logs.length < 2) return { trend: 'inconclusive' as const, delta: null }\n  const sorted = [...logs].sort((a, b) => a.createdAt.getTime() - b.createdAt.getTime())\n  const latest = sorted.slice(-3)\n  const previous = sorted.slice(-6, -3)\n  const avg = (items: typeof sorted) => (items.length ? items.reduce((sum, it) => sum + it.rating, 0) / items.length : null)\n  const latestAvg = avg(latest)\n  const prevAvg = avg(previous)\n  if (latestAvg === null || prevAvg === null) return { trend: 'inconclusive' as const, delta: null }\n  const delta = latestAvg - prevAvg\n  if (Math.abs(delta) < 0.25) return { trend: 'stable' as const, delta }\n  if (polarity === 'negative') {\n    if (delta < 0) return { trend: 'improving' as const, delta }\n    return { trend: 'declining' as const, delta }\n  }\n  if (delta > 0) return { trend: 'improving' as const, delta }\n  return { trend: 'declining' as const, delta }\n}\n\nfunction pickKnowledgeKey(issueName: string) {\n  const key = issueName.toLowerCase()\n  if (ISSUE_KNOWLEDGE_BASE[key]) return key\n  for (const [baseKey, value] of Object.entries(ISSUE_KNOWLEDGE_BASE)) {\n    if (value.aliases?.some(alias => alias.toLowerCase() === key)) return baseKey\n  }\n  return null\n}\n\nexport async function getIssueSummariesForCurrentUser() {\n  const session = await getServerSession(authOptions)\n  const userId = session?.user?.id\n  if (!userId) return []\n  return getIssueSummaries(userId)\n}\n\nexport async function getIssueSummaries(userId: string): Promise<IssueSummary[]> {\n  const context = await buildUserInsightContext(userId)\n  return context.issues.map((issue) => enrichIssueSummary(issue, context))\n}\n\ntype SectionOptions = {\n  mode: ReportMode\n  range?: { from?: string; to?: string }\n}\n\nexport async function getIssueSection(\n  userId: string,\n  slug: string,\n  section: IssueSectionKey,\n  options: Partial<SectionOptions> & { force?: boolean } = {}\n): Promise<IssueSectionResult | null> {\n  const mode = options.mode ?? 'latest'\n  const rangeKey = encodeRange(options.range)\n\n  if (options.force) {\n    const context = await loadUserInsightContext(userId)\n    const built = await buildIssueSectionWithContext(context, slug, section, {\n      mode,\n      range: options.range,\n      force: true,\n    })\n    if (shouldCacheSectionResult(built)) {\n      await upsertSectionCache({ userId, slug, section, mode, rangeKey, result: built })\n    }\n    return built\n  }\n\n  return computeIssueSection(userId, slug, section, mode, rangeKey)\n}\n\nexport async function getIssueLandingPayload(userId: string) {\n  // Use a lightweight context for landing to reduce DB work and latency.\n  const context = await loadUserLandingContext(userId)\n  const summaries = context.issues.map((issue) => enrichIssueSummary(issue, context))\n  return {\n    issues: summaries,\n    generatedAt: new Date().toISOString(),\n    onboardingComplete: context.onboardingComplete,\n    dataNeeds: context.dataNeeds,\n  }\n}\n\ntype PrecomputeOptions = {\n  slugs?: string[]\n  sections?: IssueSectionKey[]\n  mode?: ReportMode\n  range?: { from?: string; to?: string }\n  concurrency?: number\n  sectionsFilter?: IssueSectionKey[] // Added for selective regeneration based on data changes\n}\n\nexport async function precomputeIssueSectionsForUser(\n  userId: string,\n  options: PrecomputeOptions = {}\n) {\n  const context = await loadUserInsightContext(userId)\n  const availableSlugs = context.issues.map((issue) => issue.slug)\n\n  const targetSlugs = options.slugs && options.slugs.length\n    ? Array.from(new Set(options.slugs)).filter(Boolean)\n    : availableSlugs\n\n  if (!targetSlugs.length) return\n\n  const defaultSections = ISSUE_SECTION_ORDER\n  let targetSections = options.sections && options.sections.length\n    ? Array.from(new Set(options.sections))\n    : defaultSections\n\n  // Apply sectionsFilter if provided (for selective regeneration)\n  if (options.sectionsFilter && options.sectionsFilter.length) {\n    targetSections = targetSections.filter((section) => options.sectionsFilter!.includes(section))\n  }\n\n  if (!targetSections.length) return\n\n  const mode = options.mode ?? 'latest'\n  const range = options.range\n  const rangeKey = encodeRange(range)\n  const concurrency = Math.max(1, options.concurrency ?? 4)\n\n  const tasks = targetSlugs.flatMap((slug) =>\n    targetSections.map((section) => ({ slug, section }))\n  )\n\n  await runWithConcurrency(tasks, concurrency, async ({ slug, section }) => {\n    const built = await buildIssueSectionWithContext(context, slug, section, {\n      mode,\n      range,\n      force: true,\n    })\n    if (shouldCacheSectionResult(built)) {\n      await upsertSectionCache({ userId, slug, section, mode, rangeKey, result: built })\n    }\n  })\n}\n\nexport async function precomputeQuickSectionsForUser(\n  userId: string,\n  options: PrecomputeOptions = {}\n) {\n  const context = await loadUserInsightContext(userId)\n  const availableSlugs = context.issues.map((issue) => issue.slug)\n\n  const targetSlugs = options.slugs && options.slugs.length\n    ? Array.from(new Set(options.slugs)).filter(Boolean)\n    : availableSlugs\n\n  if (!targetSlugs.length) return\n\n  const defaultSections = ISSUE_SECTION_ORDER\n  let targetSections = options.sections && options.sections.length\n    ? Array.from(new Set(options.sections)).filter((s) => ISSUE_SECTION_ORDER.includes(s))\n    : defaultSections\n\n  if (!targetSections.length) return\n\n  const mode = options.mode ?? 'latest'\n  const range = options.range\n  const rangeKey = encodeRange(range)\n  const concurrency = Math.max(1, options.concurrency ?? 4)\n\n  type CountPair = { suggested: number; avoid: number }\n  const countBySection = (section: IssueSectionKey, extras: any): CountPair => {\n    switch (section) {\n      case 'supplements':\n      case 'medications':\n        return {\n          suggested: Array.isArray(extras?.suggestedAdditions) ? extras.suggestedAdditions.length : 0,\n          avoid: Array.isArray(extras?.avoidList) ? extras.avoidList.length : 0,\n        }\n      case 'exercise':\n        return {\n          suggested: Array.isArray(extras?.suggestedActivities) ? extras.suggestedActivities.length : 0,\n          avoid: Array.isArray(extras?.avoidActivities) ? extras.avoidActivities.length : 0,\n        }\n      case 'nutrition':\n        return {\n          suggested: Array.isArray(extras?.suggestedFocus) ? extras.suggestedFocus.length : 0,\n          avoid: Array.isArray(extras?.avoidFoods) ? extras.avoidFoods.length : 0,\n        }\n      case 'lifestyle':\n        return {\n          suggested: Array.isArray(extras?.suggestedHabits) ? extras.suggestedHabits.length : 0,\n          avoid: Array.isArray(extras?.avoidHabits) ? extras.avoidHabits.length : 0,\n        }\n      case 'labs':\n        return {\n          suggested: Array.isArray(extras?.suggestedLabs) ? extras.suggestedLabs.length : 0,\n          avoid: Array.isArray(extras?.avoidLabs) ? extras.avoidLabs.length : 0,\n        }\n      default:\n        return { suggested: 0, avoid: 0 }\n    }\n  }\n\n  const tasks = targetSlugs.flatMap((slug) => targetSections.map((section) => ({ slug, section })))\n\n  await runWithConcurrency(tasks, concurrency, async ({ slug, section }) => {\n    // Build quick once\n    let quick = await buildQuickSection(userId, slug, section, mode)\n    // Retry once with stricter quick if needed during precompute\n    try {\n      const counts = quick ? countBySection(section, (quick as any).extras) : { suggested: 0, avoid: 0 }\n      if (!quick || counts.suggested < 4 || counts.avoid < 4) {\n        const landing = await loadUserLandingContext(userId)\n        const issue = landing.issues.find((i) => i.slug === slug) || {\n          id: `temp:${slug}`,\n          name: unslugify(slug),\n          slug,\n          polarity: inferPolarityFromName(unslugify(slug)),\n        }\n        const summary = enrichIssueSummary(issue, landing)\n        // Strict quick generation per section\n        const mapStrict = async (\n          modeKey: 'supplements' | 'medications' | 'exercise' | 'nutrition' | 'lifestyle' | 'labs'\n        ) =>\n          (await generateDegradedSectionQuickStrict({\n            issueName: summary.name,\n            issueSummary: summary.highlight,\n            issueSlug: slug,\n            items: [],\n            otherItems: [],\n            profile: landing.profile,\n            userId,\n            mode: modeKey,\n          }, { minSuggested: 4, minAvoid: 4 }))\n        let strictResult: any = null\n        switch (section) {\n          case 'supplements': {\n            const r = await mapStrict('supplements')\n            if (r) {\n              strictResult = {\n                issue: summary,\n                section: 'supplements',\n                generatedAt: new Date().toISOString(),\n                confidence: 0.6,\n                summary: r.summary || 'Initial guidance while we prepare a deeper report.',\n                highlights: [],\n                dataPoints: [],\n                recommendations: [],\n                mode,\n                extras: {\n                  supportiveDetails: [],\n                  suggestedAdditions: r.suggested.map((s: any) => ({ title: s.name, reason: s.reason, suggestion: s.protocol ?? null })),\n                  avoidList: r.avoid.map((a: any) => ({ name: a.name, reason: a.reason })),\n                  source: 'quick',\n                  pipelineVersion: CURRENT_PIPELINE_VERSION,\n                  validated: false,\n                  degraded: true,\n                  cacheHit: false,\n                },\n              }\n            }\n            break\n          }\n          case 'medications': {\n            const r = await mapStrict('medications')\n            if (r) {\n              strictResult = {\n                issue: summary,\n                section: 'medications',\n                generatedAt: new Date().toISOString(),\n                confidence: 0.6,\n                summary: r.summary || 'Initial guidance while we prepare a deeper report.',\n                highlights: [],\n                dataPoints: [],\n                recommendations: [],\n                mode,\n                extras: {\n                  supportiveDetails: [],\n                  suggestedAdditions: r.suggested.map((s: any) => ({ title: s.name, reason: s.reason, suggestion: s.protocol ?? null })),\n                  avoidList: r.avoid.map((a: any) => ({ name: a.name, reason: a.reason })),\n                  source: 'quick',\n                  pipelineVersion: CURRENT_PIPELINE_VERSION,\n                  validated: false,\n                  degraded: true,\n                  cacheHit: false,\n                },\n              }\n            }\n            break\n          }\n          case 'exercise': {\n            const r = await mapStrict('exercise')\n            if (r) {\n              strictResult = {\n                issue: summary,\n                section: 'exercise',\n                generatedAt: new Date().toISOString(),\n                confidence: 0.6,\n                summary: r.summary || 'Initial guidance while we prepare a deeper report.',\n                highlights: [],\n                dataPoints: [],\n                recommendations: [],\n                mode,\n                extras: {\n                  workingActivities: [],\n                  suggestedActivities: r.suggested.map((s: any) => ({ title: s.name, reason: s.reason, detail: s.protocol ?? null })),\n                  avoidActivities: r.avoid.map((a: any) => ({ title: a.name, reason: a.reason })),\n                  source: 'quick',\n                  pipelineVersion: CURRENT_PIPELINE_VERSION,\n                  validated: false,\n                  degraded: true,\n                  cacheHit: false,\n                },\n              }\n            }\n            break\n          }\n          case 'nutrition': {\n            const r = await mapStrict('nutrition')\n            if (r) {\n              strictResult = {\n                issue: summary,\n                section: 'nutrition',\n                generatedAt: new Date().toISOString(),\n                confidence: 0.6,\n                summary: r.summary || 'Initial guidance while we prepare a deeper report.',\n                highlights: [],\n                dataPoints: [],\n                recommendations: [],\n                mode,\n                extras: {\n                  workingFocus: [],\n                  suggestedFocus: r.suggested.map((s: any) => ({ title: s.name, reason: s.reason })),\n                  avoidFoods: r.avoid.map((a: any) => ({ name: a.name, reason: a.reason })),\n                  source: 'quick',\n                  pipelineVersion: CURRENT_PIPELINE_VERSION,\n                  validated: false,\n                  degraded: true,\n                  cacheHit: false,\n                },\n              }\n            }\n            break\n          }\n          case 'lifestyle': {\n            const r = await mapStrict('lifestyle')\n            if (r) {\n              strictResult = {\n                issue: summary,\n                section: 'lifestyle',\n                generatedAt: new Date().toISOString(),\n                confidence: 0.6,\n                summary: r.summary || 'Initial guidance while we prepare a deeper report.',\n                highlights: [],\n                dataPoints: [],\n                recommendations: [],\n                mode,\n                extras: {\n                  suggestedHabits: r.suggested.map((s: any) => ({ title: s.name, reason: s.reason })),\n                  avoidHabits: r.avoid.map((a: any) => ({ title: a.name, reason: a.reason })),\n                  source: 'quick',\n                  pipelineVersion: CURRENT_PIPELINE_VERSION,\n                  validated: false,\n                  degraded: true,\n                  cacheHit: false,\n                },\n              }\n            }\n            break\n          }\n          case 'labs': {\n            const r = await mapStrict('labs')\n            if (r) {\n              strictResult = {\n                issue: summary,\n                section: 'labs',\n                generatedAt: new Date().toISOString(),\n                confidence: 0.6,\n                summary: r.summary || 'Initial guidance while we prepare a deeper report.',\n                highlights: [],\n                dataPoints: [],\n                recommendations: [],\n                mode,\n                extras: {\n                  suggestedLabs: r.suggested.map((s: any) => ({ name: s.name, reason: s.reason, detail: s.protocol ?? null })),\n                  avoidLabs: r.avoid.map((a: any) => ({ name: a.name, reason: a.reason })),\n                  source: 'quick',\n                  pipelineVersion: CURRENT_PIPELINE_VERSION,\n                  validated: false,\n                  degraded: true,\n                  cacheHit: false,\n                },\n              }\n            }\n            break\n          }\n        }\n        if (strictResult) {\n          quick = strictResult\n        }\n      }\n    } catch {}\n\n    if (quick && shouldCacheSectionResult(quick)) {\n      try {\n        await upsertSectionCache({ userId, slug, section, mode, rangeKey, result: quick })\n      } catch {}\n    }\n  })\n}\n\nconst loadUserInsightContext = cache(async (userId: string): Promise<UserInsightContext> => {\n  const [issuesRows, user] = await Promise.all([\n    prisma.$queryRawUnsafe<Array<{ id: string; name: string; polarity: string }>>(\n      'SELECT id, name, polarity FROM \"CheckinIssues\" WHERE \"userId\" = $1',\n      userId\n    ).catch(() => []),\n    prisma.user.findUnique({\n      where: { id: userId },\n      select: {\n        gender: true,\n        height: true,\n        weight: true,\n        bodyType: true,\n        exerciseFrequency: true,\n        exerciseTypes: true,\n        healthGoals: {\n          select: {\n            id: true,\n            name: true,\n            category: true,\n            currentRating: true,\n            createdAt: true,\n            updatedAt: true,\n            healthLogs: {\n              select: {\n                rating: true,\n                notes: true,\n                createdAt: true,\n              },\n              orderBy: { createdAt: 'desc' },\n              take: 12,\n            },\n          },\n        },\n        supplements: {\n          select: {\n            name: true,\n            dosage: true,\n            timing: true,\n            updatedAt: true,\n          },\n        },\n        medications: {\n          select: {\n            name: true,\n            dosage: true,\n            timing: true,\n            updatedAt: true,\n          },\n        },\n        exerciseLogs: {\n          select: {\n            type: true,\n            duration: true,\n            intensity: true,\n            createdAt: true,\n          },\n          orderBy: { createdAt: 'desc' },\n          take: 16,\n        },\n        foodLogs: {\n          select: {\n            name: true,\n            description: true,\n            createdAt: true,\n          },\n          orderBy: { createdAt: 'desc' },\n          take: 16,\n        },\n      },\n    }),\n  ])\n\n  if (!user) {\n    return {\n      userId,\n      issues: [],\n      healthGoals: {},\n      supplements: [],\n      medications: [],\n      exerciseLogs: [],\n      foodLogs: [],\n      todaysFoods: [],\n      bloodResults: null,\n      dataNeeds: [],\n      profile: {},\n      onboardingComplete: false,\n    }\n  }\n\n  const healthGoals: Record<string, HealthGoalWithLogs> = {}\n  const visibleGoals: HealthGoalWithLogs[] = []\n  const todaysFoods: Array<{ name?: string; meal?: string; calories?: number }> = []\n  let bloodResults: BloodResultsData | null = null\n  const dataNeeds: InsightDataNeed[] = []\n  const seenNeeds = new Set<string>()\n\n  for (const goal of user.healthGoals) {\n    if (goal.name.startsWith('__')) {\n      const dataNeed = buildDataNeed(goal.name, goal.category)\n      if (dataNeed && !seenNeeds.has(dataNeed.key)) {\n        seenNeeds.add(dataNeed.key)\n        dataNeeds.push(dataNeed)\n      }\n      if (goal.name === '__BLOOD_RESULTS_DATA__') {\n        try {\n          const parsed = JSON.parse(goal.category ?? '{}')\n          bloodResults = {\n            uploadMethod: parsed.uploadMethod || 'documents',\n            documents: Array.isArray(parsed.documents) ? parsed.documents : [],\n            images: Array.isArray(parsed.images) ? parsed.images : [],\n            notes: parsed.notes || '',\n            skipped: !!parsed.skipped,\n            markers: Array.isArray(parsed.markers) ? parsed.markers : undefined,\n          }\n        } catch {\n          bloodResults = bloodResults || null\n        }\n      }\n      if (goal.name === '__TODAYS_FOODS_DATA__') {\n        try {\n          const parsed = JSON.parse(goal.category ?? '{}')\n          if (Array.isArray(parsed.foods)) {\n            todaysFoods.push(...parsed.foods)\n          }\n        } catch {\n          // ignore\n        }\n      }\n      continue\n    }\n\n    const logsAsc = (goal.healthLogs || []).slice().reverse()\n    healthGoals[goal.name.toLowerCase()] = {\n      id: goal.id,\n      name: goal.name,\n      currentRating: goal.currentRating,\n      createdAt: goal.createdAt,\n      updatedAt: goal.updatedAt,\n      healthLogs: logsAsc.map(log => ({\n        rating: log.rating,\n        notes: log.notes,\n        createdAt: log.createdAt,\n      })),\n    }\n    visibleGoals.push(healthGoals[goal.name.toLowerCase()])\n  }\n\n  let selectedIssues: string[] = []\n  const selectedRecord = user.healthGoals.find((goal) => goal.name === '__SELECTED_ISSUES__')\n  const hasSelectedSnapshot = !!selectedRecord\n  if (selectedRecord?.category) {\n    try {\n      const parsed = JSON.parse(selectedRecord.category)\n      if (Array.isArray(parsed)) {\n        selectedIssues = Array.from(\n          new Set(\n            parsed\n              .map((value) => (typeof value === 'string' ? value.trim() : ''))\n              .filter(Boolean)\n          )\n        )\n      }\n    } catch {\n      selectedIssues = []\n    }\n  }\n\n  let issues = selectedIssues.length\n    ? selectedIssues\n        .map((name) => {\n          const lower = name.toLowerCase()\n          const goal = healthGoals[lower]\n          return goal\n            ? {\n                id: goal.id,\n                name: goal.name,\n                slug: slugify(goal.name),\n                polarity: inferPolarityFromName(goal.name),\n              }\n            : {\n                id: `selected:${slugify(name)}`,\n                name,\n                slug: slugify(name),\n                polarity: inferPolarityFromName(name),\n              }\n        })\n        .filter((issue) => issue.name.length > 0)\n    : !hasSelectedSnapshot\n      ? issuesRows.map((row) => {\n          const normalisedPolarity: 'positive' | 'negative' =\n            row.polarity === 'positive' || row.polarity === 'negative'\n              ? (row.polarity as 'positive' | 'negative')\n              : inferPolarityFromName(row.name)\n          return {\n            id: row.id,\n            name: row.name,\n            slug: slugify(row.name),\n            polarity: normalisedPolarity,\n          }\n        })\n      : []\n\n  if (!issues.length && visibleGoals.length && !hasSelectedSnapshot) {\n    issues = visibleGoals.map((goal) => ({\n      id: goal.id,\n      name: goal.name,\n      slug: slugify(goal.name),\n      polarity: inferPolarityFromName(goal.name),\n    }))\n  }\n\n  // Treat onboarding as \"complete\" only when the user has both:\n  // 1) basic profile data (gender, weight, height), and\n  // 2) at least one visible health goal.\n  const hasBasicProfile = !!(user.gender && user.weight && user.height)\n  const onboardingComplete = hasBasicProfile && visibleGoals.length > 0\n\n  return {\n    userId,\n    issues,\n    healthGoals,\n    supplements: user.supplements.map((supp) => ({\n      name: supp.name,\n      dosage: supp.dosage,\n      timing: supp.timing ?? [],\n      updatedAt: supp.updatedAt,\n    })),\n    medications: user.medications.map((med) => ({\n      name: med.name,\n      dosage: med.dosage,\n      timing: med.timing ?? [],\n      updatedAt: med.updatedAt,\n    })),\n    exerciseLogs: user.exerciseLogs.map((log) => ({\n      type: log.type,\n      duration: log.duration,\n      intensity: log.intensity,\n      createdAt: log.createdAt,\n    })),\n    foodLogs: user.foodLogs.map((log) => ({\n      name: log.name,\n      description: log.description,\n      createdAt: log.createdAt,\n    })),\n    todaysFoods,\n    bloodResults,\n    dataNeeds,\n    profile: {\n      gender: user.gender ?? null,\n      weight: user.weight ?? null,\n      height: user.height ?? null,\n      bodyType: user.bodyType ?? null,\n      exerciseFrequency: user.exerciseFrequency ?? null,\n      exerciseTypes: user.exerciseTypes ?? null,\n    },\n    onboardingComplete,\n  }\n})\n\n// Lighter loader for the Insights landing page: fetch only what we need to build summaries\n// and skip heavy joins (supplements, medications, logs not required for landing).\nconst loadUserLandingContext = cache(async (userId: string): Promise<UserInsightContext> => {\n  const [issuesRows, user] = await Promise.all([\n    prisma.$queryRawUnsafe<Array<{ id: string; name: string; polarity: string }>>(\n      'SELECT id, name, polarity FROM \"CheckinIssues\" WHERE \"userId\" = $1',\n      userId\n    ).catch(() => []),\n    prisma.user.findUnique({\n      where: { id: userId },\n      select: {\n        gender: true,\n        height: true,\n        weight: true,\n        bodyType: true,\n        exerciseFrequency: true,\n        exerciseTypes: true,\n        healthGoals: {\n          select: {\n            id: true,\n            name: true,\n            category: true,\n            currentRating: true,\n            createdAt: true,\n            updatedAt: true,\n            healthLogs: {\n              select: { rating: true, createdAt: true },\n              orderBy: { createdAt: 'desc' },\n              take: 12,\n            },\n          },\n        },\n      },\n    }),\n  ])\n\n  if (!user) {\n    return {\n      userId,\n      issues: [],\n      healthGoals: {},\n      supplements: [],\n      medications: [],\n      exerciseLogs: [],\n      foodLogs: [],\n      todaysFoods: [],\n      bloodResults: null,\n      dataNeeds: [],\n      profile: {},\n      onboardingComplete: false,\n    }\n  }\n\n  const healthGoals: Record<string, HealthGoalWithLogs> = {}\n  const visibleGoals: HealthGoalWithLogs[] = []\n  const dataNeeds: InsightDataNeed[] = []\n  const seenNeeds = new Set<string>()\n  for (const goal of user.healthGoals) {\n    if (goal.name.startsWith('__')) {\n      const dataNeed = buildDataNeed(goal.name, goal.category)\n      if (dataNeed && !seenNeeds.has(dataNeed.key)) {\n        seenNeeds.add(dataNeed.key)\n        dataNeeds.push(dataNeed)\n      }\n      continue\n    }\n\n  const logsAsc = (goal.healthLogs || []).slice().reverse()\n  healthGoals[goal.name.toLowerCase()] = {\n    id: goal.id,\n    name: goal.name,\n    currentRating: goal.currentRating,\n    createdAt: goal.createdAt,\n    updatedAt: goal.updatedAt,\n    healthLogs: logsAsc.map(log => ({ rating: log.rating, notes: null, createdAt: log.createdAt })),\n  }\n  visibleGoals.push(healthGoals[goal.name.toLowerCase()])\n}\n\n  let selectedIssues: string[] = []\n  const selectedRecord = user.healthGoals.find((goal) => goal.name === '__SELECTED_ISSUES__')\n  const hasSelectedSnapshotLanding = !!selectedRecord\n  if (selectedRecord?.category) {\n    try {\n      const parsed = JSON.parse(selectedRecord.category)\n      if (Array.isArray(parsed)) {\n        selectedIssues = Array.from(\n          new Set(\n            parsed\n              .map((value) => (typeof value === 'string' ? value.trim() : ''))\n              .filter(Boolean)\n          )\n        )\n      }\n    } catch {\n      selectedIssues = []\n    }\n  }\n\n  let issues = selectedIssues.length\n    ? selectedIssues\n        .map((name) => {\n          const lower = name.toLowerCase()\n          const goal = healthGoals[lower]\n          return goal\n            ? {\n                id: goal.id,\n                name: goal.name,\n                slug: slugify(goal.name),\n                polarity: inferPolarityFromName(goal.name),\n              }\n            : {\n                id: `selected:${slugify(name)}`,\n                name,\n                slug: slugify(name),\n                polarity: inferPolarityFromName(name),\n              }\n        })\n        .filter((issue) => issue.name.length > 0)\n    : !hasSelectedSnapshotLanding\n      ? issuesRows.map((row) => {\n          const normalisedPolarity: 'positive' | 'negative' =\n            row.polarity === 'positive' || row.polarity === 'negative'\n              ? (row.polarity as 'positive' | 'negative')\n              : inferPolarityFromName(row.name)\n          return {\n            id: row.id,\n            name: row.name,\n            slug: slugify(row.name),\n            polarity: normalisedPolarity,\n          }\n        })\n      : []\n\n  if (!issues.length && visibleGoals.length && !hasSelectedSnapshotLanding) {\n    issues = visibleGoals.map((goal) => ({\n      id: goal.id,\n      name: goal.name,\n      slug: slugify(goal.name),\n      polarity: inferPolarityFromName(goal.name),\n    }))\n  }\n\n  // Same onboarding completion rule as the full context loader above.\n  const hasBasicProfileLanding = !!(user.gender && user.weight && user.height)\n  const onboardingComplete = hasBasicProfileLanding && visibleGoals.length > 0\n\n  return {\n    userId,\n    issues,\n    healthGoals,\n    supplements: [],\n    medications: [],\n    exerciseLogs: [],\n    foodLogs: [],\n    todaysFoods: [],\n    bloodResults: null,\n    dataNeeds,\n    profile: {\n      gender: user.gender ?? null,\n      weight: user.weight ?? null,\n      height: user.height ?? null,\n      bodyType: (user.bodyType as any) ?? null,\n      exerciseFrequency: user.exerciseFrequency ?? null,\n      exerciseTypes: (user as any).exerciseTypes ?? null,\n    },\n    onboardingComplete,\n  }\n})\n\nasync function buildUserInsightContext(userId: string): Promise<UserInsightContext> {\n  return loadUserInsightContext(userId)\n}\n\n// Encodes an optional date range to a simple cache key\nfunction encodeRange(range?: { from?: string; to?: string }) {\n  if (!range) return ''\n  const from = range.from ? new Date(range.from).toISOString().slice(0, 10) : ''\n  const to = range.to ? new Date(range.to).toISOString().slice(0, 10) : ''\n  if (!from && !to) return ''\n  return `${from}..${to}`\n}\n\nasync function runWithConcurrency<T>(items: T[], limit: number, task: (item: T) => Promise<void>) {\n  const active = new Set<Promise<void>>()\n  for (const item of items) {\n    const promise = Promise.resolve()\n      .then(() => task(item))\n      .catch((error) => {\n        console.error('[insights.precompute] Task failed', error)\n      })\n      .finally(() => {\n        active.delete(promise)\n      })\n    active.add(promise)\n    if (active.size >= limit) {\n      await Promise.race(active)\n    }\n  }\n  if (active.size) {\n    await Promise.allSettled(Array.from(active))\n  }\n}\n\n// Builds a section with an already loaded context and attaches mode/range\nasync function buildIssueSectionWithContext(\n  context: UserInsightContext,\n  slug: string,\n  section: IssueSectionKey,\n  options: { mode: ReportMode; range?: { from?: string; to?: string }; force?: boolean }\n): Promise<IssueSectionResult | null> {\n  const issueRecord = context.issues.find(issue => issue.slug === slug) || {\n    id: `temp:${slug}`,\n    name: unslugify(slug),\n    slug,\n    polarity: inferPolarityFromName(unslugify(slug)),\n  }\n  const summary = enrichIssueSummary(issueRecord, context)\n\n  let base: BaseSectionResult | null = null\n  switch (section) {\n    case 'overview':\n      base = await buildOverviewSection(summary, context)\n      break\n    case 'exercise':\n      base = await buildExerciseSection(summary, context, { forceRefresh: options.force ?? false })\n      break\n    case 'supplements':\n      base = await buildSupplementsSection(summary, context, { forceRefresh: options.force ?? false })\n      break\n    case 'medications':\n      base = await buildMedicationsSection(summary, context, { forceRefresh: options.force ?? false })\n      break\n    case 'interactions':\n      base = await buildInteractionsSection(summary, context)\n      break\n    case 'labs':\n      base = await buildLabsSection(summary, context, { forceRefresh: options.force ?? false })\n      break\n    case 'nutrition':\n      base = await buildNutritionSection(summary, context, { forceRefresh: options.force ?? false })\n      break\n    case 'lifestyle':\n      base = await buildLifestyleSection(summary, context, { forceRefresh: options.force ?? false })\n      break\n    default:\n      base = null\n  }\n  if (!base) return null\n  return { ...base, mode: options.mode, range: options.range }\n}\n\n// Build a fast personalised starter using only existing user data, no live AI.\n\n// Placeholder that can be upgraded to add caching based on (mode, rangeKey)\nasync function computeIssueSection(\n  userId: string,\n  slug: string,\n  section: IssueSectionKey,\n  mode: ReportMode,\n  _rangeKey: string\n): Promise<IssueSectionResult | null> {\n  const t0 = Date.now()\n  const rangeKey = _rangeKey\n  const cached = await readSectionCache(userId, slug, section, mode, rangeKey)\n  if (cached) {\n    const extrasIn = (cached.result.extras as Record<string, unknown> | undefined) ?? {}\n    const pipelineVersion = String(extrasIn['pipelineVersion'] ?? '')\n    const validated = Boolean(extrasIn['validated'])\n    const degraded = Boolean(extrasIn['degraded'])\n    const ageMs = Date.now() - cached.updatedAt.getTime()\n    const ttl = degraded ? DEGRADED_CACHE_TTL_MS : SECTION_CACHE_TTL_MS\n    const ok = ageMs < ttl && (validated ? pipelineVersion === CURRENT_PIPELINE_VERSION : (degraded && pipelineVersion === CURRENT_PIPELINE_VERSION))\n    \n    // Debug logging for cache check\n    if (section === 'exercise') {\n      console.log('[exercise.cache] Checking cache:', {\n        pipelineVersion,\n        currentVersion: CURRENT_PIPELINE_VERSION,\n        validated,\n        degraded,\n        ageMs,\n        ttl,\n        ok,\n        cachedAt: cached.updatedAt.toISOString(),\n      })\n    }\n    \n    if (ok) {\n      // CRITICAL: For exercise section, ensure intake exercises are ALWAYS present in cached results\n      // This fixes stale cached results that were generated before the fix\n      if (section === 'exercise') {\n        const landing = await loadUserLandingContext(userId)\n        const intakeTypesArray = landing.profile.exerciseTypes ?? []\n        const workingActivities = (extrasIn.workingActivities as Array<{ title: string; reason?: string; summary?: string; lastLogged?: string }> | undefined) ?? []\n        const workingTitles = new Set(workingActivities.map(w => canonical(w.title)))\n        \n        // Add any missing intake exercises\n        for (const exerciseType of intakeTypesArray) {\n          const exerciseTypeKey = canonical(exerciseType)\n          if (!workingTitles.has(exerciseTypeKey)) {\n            // Check fuzzy match\n            let alreadyAdded = false\n            for (const w of workingActivities) {\n              if (matchesExerciseType(w.title, exerciseType)) {\n                alreadyAdded = true\n                break\n              }\n            }\n            \n            if (!alreadyAdded) {\n              console.log(`[exercise.cache] ‚úÖ Injecting intake exercise \"${exerciseType}\" into cached result`)\n              workingActivities.push({\n                title: exerciseType,\n                reason: `${exerciseType} can support this health goal through improved cardiovascular health, stress reduction, and overall physical wellbeing. Regular ${exerciseType.toLowerCase()} helps maintain optimal body function and may contribute positively to this health goal.`,\n                summary: 'Selected in health intake',\n                lastLogged: 'From your health profile',\n              })\n              workingTitles.add(exerciseTypeKey)\n            }\n          }\n        }\n        \n        extrasIn.workingActivities = workingActivities\n      }\n      \n      // CRITICAL: For supplements section, ensure fiber supplements are detected in cached results\n      if (section === 'supplements') {\n        const issueName = cached.result.issue?.name || unslugify(slug)\n        const isBowelIssue = /bowel|digestion|constipation|regularity|stool/i.test(issueName)\n        \n        console.log(`[supplements.cache] Injecting into cached result. Issue: \"${issueName}\", isBowelIssue: ${isBowelIssue}`)\n        \n        if (isBowelIssue) {\n          const supportiveDetails = (extrasIn.supportiveDetails as Array<{ name: string; reason?: string; dosage?: string | null; timing?: string[] | null }> | undefined) ?? []\n          const foundNames = new Set(supportiveDetails.map(s => canonical(s.name)))\n          \n          console.log(`[supplements.cache] Current supportiveDetails:`, supportiveDetails.map(s => s.name).join(', '))\n          console.log(`[supplements.cache] Found names set:`, Array.from(foundNames))\n          \n          // Fetch current supplements\n          try {\n            const user = await prisma.user.findUnique({\n              where: { id: userId },\n              select: {\n                supplements: {\n                  select: {\n                    name: true,\n                    dosage: true,\n                    timing: true,\n                  },\n                },\n              },\n            })\n            \n            console.log(`[supplements.cache] Fetched ${user?.supplements?.length ?? 0} supplements from DB`)\n            if (user?.supplements && user.supplements.length > 0) {\n              console.log(`[supplements.cache] All supplement names:`, user.supplements.map(s => s.name).join(', '))\n              const fiberSupplements = user.supplements.filter(supp => {\n                const isFiber = /fiber|fibre|psyllium|inulin|guar gum|phgg/i.test(supp.name)\n                const alreadyFound = foundNames.has(canonical(supp.name))\n                console.log(`[supplements.cache] Checking \"${supp.name}\": isFiber=${isFiber}, alreadyFound=${alreadyFound}`)\n                return isFiber && !alreadyFound\n              })\n              \n              console.log(`[supplements.cache] Filtered ${fiberSupplements.length} fiber supplements:`, fiberSupplements.map(s => s.name).join(', '))\n              \n              if (fiberSupplements.length > 0) {\n                console.log(`[supplements.cache] ‚úÖ Injecting ${fiberSupplements.length} fiber supplements into cached result: ${fiberSupplements.map(s => s.name).join(', ')}`)\n                for (const supp of fiberSupplements) {\n                  const parseTiming = (timing?: string[] | null) => {\n                    return Array.isArray(timing) ? timing : []\n                  }\n                  supportiveDetails.push({\n                    name: supp.name,\n                    reason: `${supp.name} contains soluble fiber that supports bowel regularity through hydration, gel formation, and fermentation to short-chain fatty acids that normalize stool consistency.`,\n                    dosage: supp.dosage ?? null,\n                    timing: parseTiming(supp.timing),\n                  })\n                }\n                \n                // CRITICAL: Deduplicate before assigning to cache\n                const seenCache = new Set<string>()\n                const deduplicatedCacheSupportive = supportiveDetails.filter((item) => {\n                  const key = canonical(item.name)\n                  if (seenCache.has(key)) {\n                    console.warn(`[supplements.cache] Removing duplicate supplement: \"${item.name}\" (canonical: \"${key}\")`)\n                    return false\n                  }\n                  seenCache.add(key)\n                  return true\n                })\n                if (deduplicatedCacheSupportive.length !== supportiveDetails.length) {\n                  console.log(`[supplements.cache] Deduplicated: ${supportiveDetails.length} ‚Üí ${deduplicatedCacheSupportive.length} items`)\n                }\n                \n                extrasIn.supportiveDetails = deduplicatedCacheSupportive\n                console.log(`[supplements.cache] FINAL supportiveDetails after injection:`, deduplicatedCacheSupportive.map(s => s.name).join(', '))\n              } else {\n                console.log(`[supplements.cache] No fiber supplements to inject`)\n              }\n            }\n          } catch (error) {\n            console.warn('[supplements.cache] Error injecting fiber supplements into cached result', error)\n          }\n        }\n      }\n      \n      // CRITICAL: Always deduplicate supportiveDetails from cache (even if no fiber injection happened)\n      // This fixes duplicates that existed in cached results generated before deduplication was added\n      if (section === 'supplements' && extrasIn.supportiveDetails) {\n        const cachedSupportive = (extrasIn.supportiveDetails as Array<{ name: string; reason?: string; dosage?: string | null; timing?: string[] | null }> | undefined) ?? []\n        if (cachedSupportive.length > 0) {\n          const seenCached = new Set<string>()\n          const deduplicatedCached = cachedSupportive.filter((item) => {\n            const key = canonical(item.name)\n            if (seenCached.has(key)) {\n              console.warn(`[supplements.cache] Removing duplicate from cached result: \"${item.name}\" (canonical: \"${key}\")`)\n              return false\n            }\n            seenCached.add(key)\n            return true\n          })\n          if (deduplicatedCached.length !== cachedSupportive.length) {\n            console.log(`[supplements.cache] Deduplicated cached supportiveDetails: ${cachedSupportive.length} ‚Üí ${deduplicatedCached.length} items`)\n            extrasIn.supportiveDetails = deduplicatedCached\n          }\n        }\n      }\n      \n      const enriched: IssueSectionResult = {\n        ...cached.result,\n        extras: {\n          ...extrasIn,\n          cacheHit: true,\n          degradedUsed: !!extrasIn['degraded'],\n          firstByteMs: Date.now() - t0,\n          computeMs: 0,\n        },\n      }\n      emitInsightsTimingSafe({\n        userId,\n        slug,\n        section,\n        mode,\n        cache: 'hit',\n        degradedUsed: !!extrasIn['degraded'],\n        generateMs: Number((extrasIn as any)?.generateMs ?? 0),\n        classifyMs: Number((extrasIn as any)?.classifyMs ?? 0),\n        rewriteMs: Number((extrasIn as any)?.rewriteMs ?? 0),\n        fillMs: Number((extrasIn as any)?.fillMs ?? 0),\n        totalMs: Number((extrasIn as any)?.totalMs ?? 0),\n        firstByteMs: enriched.extras?.firstByteMs as number,\n      }).catch(() => {})\n      return enriched\n    }\n  }\n\n  // Quick AI-only degraded result to avoid long waits\n  const quick = await buildQuickSection(userId, slug, section, mode)\n  if (quick) {\n    // CRITICAL: For exercise section, ensure intake exercises are ALWAYS present\n    // This handles cases where cached results are empty or LLM hasn't run yet\n    if (section === 'exercise') {\n      const landing = await loadUserLandingContext(userId)\n      const intakeTypesArray = landing.profile.exerciseTypes ?? []\n      const extrasQuick = (quick.extras as Record<string, unknown> | undefined) ?? {}\n      const workingActivities = (extrasQuick.workingActivities as Array<{ title: string; reason?: string; summary?: string; lastLogged?: string }> | undefined) ?? []\n      const workingTitles = new Set(workingActivities.map(w => canonical(w.title)))\n      \n      // Add any missing intake exercises\n      for (const exerciseType of intakeTypesArray) {\n        const exerciseTypeKey = canonical(exerciseType)\n        if (!workingTitles.has(exerciseTypeKey)) {\n          // Check fuzzy match\n          let alreadyAdded = false\n          for (const w of workingActivities) {\n            if (matchesExerciseType(w.title, exerciseType)) {\n              alreadyAdded = true\n              break\n            }\n          }\n          \n          if (!alreadyAdded) {\n            console.log(`[exercise.computeIssueSection] ‚úÖ Injecting intake exercise \"${exerciseType}\" directly into quick result`)\n            workingActivities.push({\n              title: exerciseType,\n              reason: `${exerciseType} can support ${quick.issue?.name || slug} through improved cardiovascular health, stress reduction, and overall physical wellbeing. Regular ${exerciseType.toLowerCase()} helps maintain optimal body function and may contribute positively to this health goal.`,\n              summary: 'Selected in health intake',\n              lastLogged: 'From your health profile',\n            })\n            workingTitles.add(exerciseTypeKey)\n          }\n        }\n      }\n      \n      extrasQuick.workingActivities = workingActivities\n      quick.extras = extrasQuick\n    }\n    \n    // CRITICAL: For supplements section, ensure fiber supplements are detected in quick results\n    if (section === 'supplements') {\n      const issueName = quick.issue?.name || unslugify(slug)\n      const isBowelIssue = /bowel|digestion|constipation|regularity|stool/i.test(issueName)\n      \n      console.log(`[supplements.quick.compute] Injecting into quick result. Issue: \"${issueName}\", isBowelIssue: ${isBowelIssue}`)\n      \n      if (isBowelIssue) {\n        const extrasQuick = (quick.extras as Record<string, unknown> | undefined) ?? {}\n        const supportiveDetails = (extrasQuick.supportiveDetails as Array<{ name: string; reason?: string; dosage?: string | null; timing?: string[] | null }> | undefined) ?? []\n        const foundNames = new Set(supportiveDetails.map(s => canonical(s.name)))\n        \n        console.log(`[supplements.quick.compute] Current supportiveDetails:`, supportiveDetails.map(s => s.name).join(', '))\n        \n        // Fetch current supplements\n        try {\n          const user = await prisma.user.findUnique({\n            where: { id: userId },\n            select: {\n              supplements: {\n                select: {\n                  name: true,\n                  dosage: true,\n                  timing: true,\n                },\n              },\n            },\n          })\n          \n          console.log(`[supplements.quick.compute] Fetched ${user?.supplements?.length ?? 0} supplements from DB`)\n          if (user?.supplements && user.supplements.length > 0) {\n            console.log(`[supplements.quick.compute] All supplement names:`, user.supplements.map(s => s.name).join(', '))\n            const fiberSupplements = user.supplements.filter(supp => {\n              const isFiber = /fiber|fibre|psyllium|inulin|guar gum|phgg/i.test(supp.name)\n              const alreadyFound = foundNames.has(canonical(supp.name))\n              console.log(`[supplements.quick.compute] Checking \"${supp.name}\": isFiber=${isFiber}, alreadyFound=${alreadyFound}`)\n              return isFiber && !alreadyFound\n            })\n            \n            console.log(`[supplements.quick.compute] Filtered ${fiberSupplements.length} fiber supplements:`, fiberSupplements.map(s => s.name).join(', '))\n            \n            if (fiberSupplements.length > 0) {\n              console.log(`[supplements.quick.compute] ‚úÖ Injecting ${fiberSupplements.length} fiber supplements into quick result: ${fiberSupplements.map(s => s.name).join(', ')}`)\n              for (const supp of fiberSupplements) {\n                const parseTiming = (timing?: string[] | null) => {\n                  return Array.isArray(timing) ? timing : []\n                }\n                supportiveDetails.push({\n                  name: supp.name,\n                  reason: `${supp.name} contains soluble fiber that supports bowel regularity through hydration, gel formation, and fermentation to short-chain fatty acids that normalize stool consistency.`,\n                  dosage: supp.dosage ?? null,\n                  timing: parseTiming(supp.timing),\n                })\n              }\n              \n              // CRITICAL: Deduplicate before assigning\n              const seenQuickCompute = new Set<string>()\n              const deduplicatedQuickComputeSupportive = supportiveDetails.filter((item) => {\n                const key = canonical(item.name)\n                if (seenQuickCompute.has(key)) {\n                  console.warn(`[supplements.quick.compute] Removing duplicate supplement: \"${item.name}\" (canonical: \"${key}\")`)\n                  return false\n                }\n                seenQuickCompute.add(key)\n                return true\n              })\n              if (deduplicatedQuickComputeSupportive.length !== supportiveDetails.length) {\n                console.log(`[supplements.quick.compute] Deduplicated: ${supportiveDetails.length} ‚Üí ${deduplicatedQuickComputeSupportive.length} items`)\n              }\n              \n              extrasQuick.supportiveDetails = deduplicatedQuickComputeSupportive\n              quick.extras = extrasQuick\n              console.log(`[supplements.quick.compute] FINAL supportiveDetails after injection:`, deduplicatedQuickComputeSupportive.map(s => s.name).join(', '))\n            } else {\n              console.log(`[supplements.quick.compute] No fiber supplements to inject`)\n            }\n          }\n        } catch (error) {\n          console.warn('[supplements.quick.compute] Error injecting fiber supplements into quick result', error)\n        }\n      }\n    }\n    \n    // Persist degraded with short TTL and fire background upgrade\n    try {\n      const firstByteMs = Date.now() - t0\n      const extrasQuick = (quick.extras as Record<string, unknown> | undefined) ?? {}\n      quick.extras = {\n        ...extrasQuick,\n        cacheHit: false,\n        quickUsed: true,\n        degradedUsed: true,\n        firstByteMs,\n        generateMs: (extrasQuick as any)?.generateMs ?? 0,\n        classifyMs: (extrasQuick as any)?.classifyMs ?? 0,\n        rewriteMs: (extrasQuick as any)?.rewriteMs ?? 0,\n        fillMs: (extrasQuick as any)?.fillMs ?? 0,\n        totalMs: (extrasQuick as any)?.totalMs ?? firstByteMs,\n      }\n      await upsertSectionCache({ userId, slug, section, mode, rangeKey, result: quick })\n    } catch {}\n    // Emit analytics for cache miss quick path\n    try {\n      await emitInsightsTimingSafe({\n        userId,\n        slug,\n        section,\n        mode,\n        cache: 'miss',\n        degradedUsed: true,\n        firstByteMs: (quick.extras as any)?.firstByteMs ?? Date.now() - t0,\n        generateMs: Number(((quick.extras as any)?.generateMs) ?? 0),\n        classifyMs: Number(((quick.extras as any)?.classifyMs) ?? 0),\n        rewriteMs: Number(((quick.extras as any)?.rewriteMs) ?? 0),\n        fillMs: Number(((quick.extras as any)?.fillMs) ?? 0),\n        totalMs: Number(((quick.extras as any)?.totalMs) ?? 0),\n      })\n    } catch {}\n    // Background full build (non-blocking)\n    if (!PAUSE_HEAVY) {\n      setImmediate(async () => {\n        try {\n          const context = await loadUserInsightContext(userId)\n          const full = await buildIssueSectionWithContext(context, slug, section, { mode, range: undefined, force: false })\n          if (full && shouldCacheSectionResult(full)) {\n            await upsertSectionCache({ userId, slug, section, mode, rangeKey, result: full })\n          }\n        } catch (e) {\n          console.warn('[insights.build] background upgrade failed', e)\n        }\n      })\n    }\n    return quick\n  }\n\n  // Fallback to full build if quick path failed\n  console.time(`[insights.build] ${slug}/${section}`)\n  const context = await loadUserInsightContext(userId)\n  const built = await buildIssueSectionWithContext(context, slug, section, {\n    mode,\n    range: undefined,\n    force: false,\n  })\n  console.timeEnd(`[insights.build] ${slug}/${section}`)\n  if (!built) return null\n  try {\n    const firstByteMs = Date.now() - t0\n    const extrasIn = (built.extras as Record<string, unknown> | undefined) ?? {}\n    built.extras = {\n      ...extrasIn,\n      cacheHit: false,\n      quickUsed: false,\n      degradedUsed: !!(extrasIn as any)?.degraded,\n      firstByteMs,\n      generateMs: (extrasIn as any)?.generateMs ?? 0,\n      classifyMs: (extrasIn as any)?.classifyMs ?? 0,\n      rewriteMs: (extrasIn as any)?.rewriteMs ?? 0,\n      fillMs: (extrasIn as any)?.fillMs ?? 0,\n      totalMs: (extrasIn as any)?.totalMs ?? firstByteMs,\n    }\n    await emitInsightsTimingSafe({\n      userId,\n      slug,\n      section,\n      mode,\n      cache: 'miss',\n      degradedUsed: !!(built.extras as any)?.degraded,\n      firstByteMs,\n      generateMs: Number(((built.extras as any)?.generateMs) ?? 0),\n      classifyMs: Number(((built.extras as any)?.classifyMs) ?? 0),\n      rewriteMs: Number(((built.extras as any)?.rewriteMs) ?? 0),\n      fillMs: Number(((built.extras as any)?.fillMs) ?? 0),\n      totalMs: Number(((built.extras as any)?.totalMs) ?? 0),\n    })\n  } catch {}\n  if (shouldCacheSectionResult(built)) {\n    await upsertSectionCache({ userId, slug, section, mode, rangeKey, result: built })\n  }\n  return built\n}\n\nasync function emitInsightsTimingSafe(event: {\n  userId: string\n  slug: string\n  section: IssueSectionKey\n  mode: ReportMode\n  cache: 'hit' | 'miss'\n  degradedUsed: boolean\n  generateMs?: number\n  classifyMs?: number\n  rewriteMs?: number\n  fillMs?: number\n  totalMs?: number\n  firstByteMs?: number\n}) {\n  try {\n    const base = process.env.NEXT_PUBLIC_BASE_URL || process.env.ANALYTICS_BASE_URL || ''\n    const url = base && /^https?:\\/\\//.test(base)\n      ? `${base.replace(/\\/$/, '')}/api/analytics`\n      : `${process.env.VERCEL_URL ? `https://${process.env.VERCEL_URL}` : 'https://helfi.ai'}/api/analytics`\n    await fetch(url, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        type: 'insights-timing',\n        action: 'insights',\n        userId: event.userId,\n        issueSlug: event.slug,\n        section: event.section,\n        mode: event.mode,\n        cache: event.cache,\n        degradedUsed: event.degradedUsed,\n        generateMs: event.generateMs ?? null,\n        classifyMs: event.classifyMs ?? null,\n        rewriteMs: event.rewriteMs ?? null,\n        fillMs: event.fillMs ?? null,\n        totalMs: event.totalMs ?? null,\n        firstByteMs: event.firstByteMs ?? null,\n      }),\n    })\n  } catch {\n    // best-effort only\n  }\n}\n\n// Build a minimal, AI-only quick result for fast first paint (degraded=true).\nasync function buildQuickSection(\n  userId: string,\n  slug: string,\n  section: IssueSectionKey,\n  mode: ReportMode\n): Promise<IssueSectionResult | null> {\n  try {\n    const landing = await loadUserLandingContext(userId)\n    const issue = landing.issues.find((i) => i.slug === slug) || {\n      id: `temp:${slug}`,\n      name: unslugify(slug),\n      slug,\n      polarity: inferPolarityFromName(unslugify(slug)),\n    }\n    const summary = enrichIssueSummary(issue, landing)\n    const map = async (\n      modeKey: 'supplements' | 'medications' | 'exercise' | 'nutrition' | 'lifestyle' | 'labs'\n    ) =>\n      generateDegradedSectionQuick(\n        { issueName: summary.name, issueSummary: summary.highlight, issueSlug: slug, mode: modeKey, items: [], otherItems: [], profile: landing.profile, userId },\n        { minSuggested: 4, minAvoid: 4 }\n      )\n\n    let quick: any = null\n    switch (section) {\n      case 'supplements': {\n        const r = await map('supplements')\n        if (!r) return null\n        \n        // CRITICAL FIX: Fetch supplements and run evaluator for quick path\n        // loadUserLandingContext doesn't include supplements, so fetch separately\n        let supportiveDetails: Array<{ name: string; reason: string; dosage: string | null; timing: string[] }> = []\n        try {\n          const user = await prisma.user.findUnique({\n            where: { id: userId },\n            select: {\n              supplements: {\n                select: {\n                  name: true,\n                  dosage: true,\n                  timing: true,\n                },\n              },\n            },\n          })\n          \n          if (user?.supplements && user.supplements.length > 0) {\n            const normalizedSupplements = user.supplements.map((supp) => ({\n              name: supp.name,\n              dosage: supp.dosage ?? null,\n              timing: Array.isArray(supp.timing) ? supp.timing : [],\n            }))\n            \n            console.log(`[supplements.quick] Evaluating ${normalizedSupplements.length} logged supplements for issue \"${summary.name}\"`)\n            console.log(`[supplements.quick] Supplements list:`, normalizedSupplements.map(s => s.name).join(', '))\n            console.log(`[supplements.quick] Issue slug: \"${slug}\", Issue name: \"${summary.name}\"`)\n            console.log(`[supplements.quick] ALL SUPPLEMENT NAMES:`, JSON.stringify(normalizedSupplements.map(s => s.name)))\n            \n            // Run evaluator to identify supportive supplements\n            const evaluated = await evaluateFocusItemsForIssue({\n              issueName: summary.name,\n              issueSummary: summary.highlight,\n              mode: 'supplements',\n              focusItems: normalizedSupplements,\n            })\n            \n            console.log(`[supplements.quick] Evaluator returned ${evaluated?.length ?? 0} supportive items`)\n            if (evaluated && evaluated.length > 0) {\n              console.log(`[supplements.quick] Evaluator results:`, evaluated.map(e => e.name).join(', '))\n            }\n            \n            if (evaluated && evaluated.length > 0) {\n              // Map evaluator results back to exact logged names with dosage/timing\n              const supplementMap = new Map(\n                normalizedSupplements.map((supp) => [canonical(supp.name), supp])\n              )\n              \n              const parseTiming = (timing?: string | null, fallback?: string[]) => {\n                if (timing && timing.trim().length) {\n                  return timing\n                    .split(/[,;]+/)\n                    .map((t) => t.trim())\n                    .filter(Boolean)\n                }\n                return fallback ?? []\n              }\n              \n              for (const item of evaluated) {\n                const logged = supplementMap.get(canonical(item.name))\n                if (logged) {\n                  supportiveDetails.push({\n                    name: logged.name, // Use exact logged name\n                    reason: item.reason,\n                    dosage: item.dosage ?? logged.dosage ?? null,\n                    timing: parseTiming(item.timing, logged.timing ?? []),\n                  })\n                }\n              }\n              \n              console.log(`[supplements.quick] Evaluator found ${supportiveDetails.length} supportive supplements: ${supportiveDetails.map(s => s.name).join(', ')}`)\n            } else {\n              console.log(`[supplements.quick] Evaluator found no supportive supplements`)\n            }\n            \n            // FALLBACK: If evaluator missed fiber supplements for bowel issues, explicitly check for them\n            const isBowelIssue = /bowel|digestion|constipation|regularity|stool/i.test(summary.name)\n            console.log(`[supplements.quick] Is bowel issue? ${isBowelIssue} (issue name: \"${summary.name}\")`)\n            if (isBowelIssue) {\n              const foundFiberNames = new Set(supportiveDetails.map(s => canonical(s.name)))\n              console.log(`[supplements.quick] Already found fiber names:`, Array.from(foundFiberNames))\n              const fiberSupplements = normalizedSupplements.filter(supp => {\n                const suppNameLower = supp.name.toLowerCase()\n                const isFiber = /fiber|fibre|psyllium|inulin|guar gum|phgg/i.test(supp.name)\n                const alreadyFound = foundFiberNames.has(canonical(supp.name))\n                console.log(`[supplements.quick] Checking \"${supp.name}\": isFiber=${isFiber}, alreadyFound=${alreadyFound}, canonical=\"${canonical(supp.name)}\"`)\n                return isFiber && !alreadyFound\n              })\n              \n              console.log(`[supplements.quick] Filtered fiber supplements:`, fiberSupplements.map(s => s.name).join(', '))\n              \n              if (fiberSupplements.length > 0) {\n                console.log(`[supplements.quick] Fallback: Adding ${fiberSupplements.length} fiber supplements that evaluator missed: ${fiberSupplements.map(s => s.name).join(', ')}`)\n                for (const supp of fiberSupplements) {\n                  const parseTiming = (timing?: string[] | null) => {\n                    return Array.isArray(timing) ? timing : []\n                  }\n                  supportiveDetails.push({\n                    name: supp.name,\n                    reason: `${supp.name} contains soluble fiber that supports bowel regularity through hydration, gel formation, and fermentation to short-chain fatty acids that normalize stool consistency.`,\n                    dosage: supp.dosage ?? null,\n                    timing: parseTiming(supp.timing),\n                  })\n                }\n                console.log(`[supplements.quick] FINAL supportiveDetails after fallback:`, supportiveDetails.map(s => s.name).join(', '))\n              } else {\n                console.log(`[supplements.quick] No fiber supplements found to add (all ${normalizedSupplements.length} supplements checked)`)\n              }\n            }\n          }\n        } catch (error) {\n          console.warn('[supplements.quick] Error evaluating supplements in quick path', error)\n          // Continue with empty supportiveDetails - don't fail the quick path\n        }\n        \n        // CRITICAL: Deduplicate supportiveDetails before finalizing (quick path)\n        const seenQuick = new Set<string>()\n        const deduplicatedQuickSupportive = supportiveDetails.filter((item) => {\n          const key = canonical(item.name)\n          if (seenQuick.has(key)) {\n            console.warn(`[supplements.quick] Removing duplicate supplement: \"${item.name}\" (canonical: \"${key}\")`)\n            return false\n          }\n          seenQuick.add(key)\n          return true\n        })\n        if (deduplicatedQuickSupportive.length !== supportiveDetails.length) {\n          console.log(`[supplements.quick] Deduplicated: ${supportiveDetails.length} ‚Üí ${deduplicatedQuickSupportive.length} items`)\n        }\n        \n        quick = {\n          issue: summary,\n          section: 'supplements',\n          generatedAt: new Date().toISOString(),\n          confidence: 0.6,\n          summary: r.summary || 'Initial guidance while we prepare a deeper report.',\n          highlights: [],\n          dataPoints: [],\n          recommendations: [],\n          mode,\n          extras: {\n            supportiveDetails: deduplicatedQuickSupportive, // Use deduplicated version\n            suggestedAdditions: r.suggested.map((s) => ({ title: s.name, reason: s.reason, suggestion: s.protocol ?? null })),\n            avoidList: r.avoid.map((a) => ({ name: a.name, reason: a.reason })),\n            source: 'quick',\n            pipelineVersion: CURRENT_PIPELINE_VERSION,\n            validated: false,\n            degraded: true,\n            cacheHit: false,\n          },\n        }\n        break\n      }\n      case 'medications': {\n        const r = await map('medications')\n        if (!r) return null\n        quick = {\n          issue: summary,\n          section: 'medications',\n          generatedAt: new Date().toISOString(),\n          confidence: 0.6,\n          summary: r.summary || 'Initial guidance while we prepare a deeper report.',\n          highlights: [],\n          dataPoints: [],\n          recommendations: [],\n          mode,\n          extras: {\n            supportiveDetails: [],\n            suggestedAdditions: r.suggested.map((s) => ({ title: s.name, reason: s.reason, suggestion: s.protocol ?? null })),\n            avoidList: r.avoid.map((a) => ({ name: a.name, reason: a.reason })),\n            source: 'quick',\n            pipelineVersion: CURRENT_PIPELINE_VERSION,\n            validated: false,\n            degraded: true,\n            cacheHit: false,\n          },\n        }\n        break\n      }\n      case 'exercise': {\n        const r = await map('exercise')\n        if (!r) return null\n        quick = {\n          issue: summary,\n          section: 'exercise',\n          generatedAt: new Date().toISOString(),\n          confidence: 0.6,\n          summary: r.summary || 'Initial guidance while we prepare a deeper report.',\n          highlights: [],\n          dataPoints: [],\n          recommendations: [],\n          mode,\n          extras: {\n            workingActivities: (() => {\n              // Apply same intake exerciseTypes matching logic as buildExerciseSection\n              const intakeExerciseTypes = new Set(\n                (landing.profile.exerciseTypes ?? []).map((type: string) => canonical(type))\n              )\n              \n              // Logging for debugging quick path\n              console.log('[exercise.working.quick] Raw profile.exerciseTypes:', landing.profile.exerciseTypes)\n              console.log('[exercise.working.quick] Canonicalized intakeExerciseTypes Set:', Array.from(intakeExerciseTypes))\n              console.log('[exercise.working.quick] LLM working items:', r.working ?? [])\n              console.log('[exercise.working.quick] LLM suggested items:', r.suggested.map(s => ({ name: s.name, reason: s.reason })))\n              \n              // Process working items from LLM result\n              // If LLM returned working items (including intake exercises we added), include them all\n              const working = (r.working ?? []).map((item) => {\n                const itemKey = canonical(item.name)\n                \n                // Check if it matches any intake exercise type\n                let hasIntakeMatch = intakeExerciseTypes.has(itemKey)\n                if (!hasIntakeMatch) {\n                  // Try fuzzy matching against all intake exercise types\n                  for (const intakeType of landing.profile.exerciseTypes ?? []) {\n                    if (matchesExerciseType(item.name, intakeType)) {\n                      hasIntakeMatch = true\n                      console.log(`[exercise.working.quick] Fuzzy matched \"${item.name}\" to intake type \"${intakeType}\"`)\n                      break\n                    }\n                  }\n                }\n                \n                // If it matches intake, use the intake-specific format\n                if (hasIntakeMatch) {\n                  return {\n                    title: item.name,\n                    reason: item.reason,\n                    summary: 'Selected in health intake',\n                    lastLogged: 'From your health profile',\n                  }\n                }\n                \n                // If LLM returned it as working (even without intake match), still include it\n                // This handles cases where LLM evaluates logs and finds them supportive\n                return {\n                  title: item.name,\n                  reason: item.reason,\n                  summary: item.dosage ?? '',\n                  lastLogged: item.timing ?? '',\n                }\n              }).filter(Boolean) as Array<{ title: string; reason: string; summary: string; lastLogged: string }>\n              \n              // Fallback: if LLM returns exercise in suggested bucket that matches intake exerciseTypes, promote it to working\n              const intakeTypesArray = landing.profile.exerciseTypes ?? []\n              \n              // EXTENSIVE DEBUGGING\n              console.log('[exercise.working.quick] ========== DEBUG START ==========')\n              console.log('[exercise.working.quick] landing.profile:', JSON.stringify(landing.profile, null, 2))\n              console.log('[exercise.working.quick] landing.profile.exerciseTypes:', landing.profile.exerciseTypes)\n              console.log('[exercise.working.quick] intakeTypesArray:', intakeTypesArray)\n              console.log('[exercise.working.quick] intakeTypesArray.length:', intakeTypesArray.length)\n              console.log('[exercise.working.quick] working.length BEFORE adding intake:', working.length)\n              console.log('[exercise.working.quick] working items BEFORE:', working.map(w => w.title))\n              \n              // CRITICAL FIX: Always add intake exercises if they exist, even if LLM returned some working items\n              // This ensures intake exercises ALWAYS appear in working section\n              const intakeExercisesInWorking = new Set(\n                working.map(w => canonical(w.title))\n              )\n              \n              for (const exerciseType of intakeTypesArray) {\n                const exerciseTypeKey = canonical(exerciseType)\n                if (!intakeExercisesInWorking.has(exerciseTypeKey)) {\n                  // Check if it's already in working via fuzzy match\n                  let alreadyAdded = false\n                  for (const w of working) {\n                    if (matchesExerciseType(w.title, exerciseType)) {\n                      alreadyAdded = true\n                      break\n                    }\n                  }\n                  \n                  if (!alreadyAdded) {\n                    console.log(`[exercise.working.quick] ‚úÖ Adding intake exercise \"${exerciseType}\" directly to working`)\n                    working.push({\n                      title: exerciseType,\n                      reason: `${exerciseType} can support ${summary.name} through improved cardiovascular health, stress reduction, and overall physical wellbeing. Regular ${exerciseType.toLowerCase()} helps maintain optimal body function and may contribute positively to this health goal.`,\n                      summary: 'Selected in health intake',\n                      lastLogged: 'From your health profile',\n                    })\n                  }\n                } else {\n                  console.log(`[exercise.working.quick] ‚è≠Ô∏è Skipping \"${exerciseType}\" - already in working`)\n                }\n              }\n              \n              console.log('[exercise.working.quick] working.length AFTER adding intake:', working.length)\n              console.log('[exercise.working.quick] working items AFTER:', working.map(w => w.title))\n              console.log('[exercise.working.quick] ========== DEBUG END ==========')\n              \n              const promotedFromSuggested: Array<{ title: string; reason: string; summary: string; lastLogged: string }> = []\n              \n              for (const suggestedItem of r.suggested) {\n                // Check if already in working\n                const alreadyInWorking = working.some(w => canonical(w.title) === canonical(suggestedItem.name))\n                if (alreadyInWorking) continue\n                \n                // Check if it matches any intake exercise type\n                for (const intakeType of intakeTypesArray) {\n                  if (matchesExerciseType(suggestedItem.name, intakeType)) {\n                    console.log(`[exercise.working.quick] ‚úì Promoting suggested \"${suggestedItem.name}\" to working (matches intake \"${intakeType}\")`)\n                    promotedFromSuggested.push({\n                      title: suggestedItem.name,\n                      reason: suggestedItem.reason,\n                      summary: 'Selected in health intake',\n                      lastLogged: 'From your health profile',\n                    })\n                    break\n                  }\n                }\n              }\n              \n              if (promotedFromSuggested.length > 0) {\n                working.push(...promotedFromSuggested)\n                console.log(`[exercise.working.quick] Promoted ${promotedFromSuggested.length} items from suggested to working`)\n              }\n              \n              console.log('[exercise.working.quick] Final workingActivities:', working.map(w => w.title))\n              \n              return working\n            })(),\n            suggestedActivities: r.suggested.filter((item) => {\n              // Exclude items that match intake exerciseTypes (they should be in working)\n              const intakeTypesArray = landing.profile.exerciseTypes ?? []\n              for (const intakeType of intakeTypesArray) {\n                if (matchesExerciseType(item.name, intakeType)) {\n                  return false\n                }\n              }\n              return true\n            }).map((s) => ({ title: s.name, reason: s.reason, detail: s.protocol ?? null })),\n            avoidActivities: r.avoid.map((a) => ({ title: a.name, reason: a.reason })),\n            source: 'quick',\n            pipelineVersion: CURRENT_PIPELINE_VERSION,\n            validated: false,\n            degraded: true,\n            cacheHit: false,\n          },\n        }\n        break\n      }\n      case 'nutrition': {\n        const r = await map('nutrition')\n        if (!r) return null\n        quick = {\n          issue: summary,\n          section: 'nutrition',\n          generatedAt: new Date().toISOString(),\n          confidence: 0.6,\n          summary: r.summary || 'Initial guidance while we prepare a deeper report.',\n          highlights: [],\n          dataPoints: [],\n          recommendations: [],\n          mode,\n          extras: {\n            workingFocus: [],\n            suggestedFocus: r.suggested.map((s) => ({ title: s.name, reason: s.reason })),\n            avoidFoods: r.avoid.map((a) => ({ name: a.name, reason: a.reason })),\n            source: 'quick',\n            pipelineVersion: CURRENT_PIPELINE_VERSION,\n            validated: false,\n            degraded: true,\n            cacheHit: false,\n          },\n        }\n        break\n      }\n      case 'lifestyle': {\n        const r = await map('lifestyle')\n        if (!r) return null\n        quick = {\n          issue: summary,\n          section: 'lifestyle',\n          generatedAt: new Date().toISOString(),\n          confidence: 0.6,\n          summary: r.summary || 'Initial guidance while we prepare a deeper report.',\n          highlights: [],\n          dataPoints: [],\n          recommendations: [],\n          mode,\n          extras: {\n            suggestedHabits: r.suggested.map((s) => ({ title: s.name, reason: s.reason })),\n            avoidHabits: r.avoid.map((a) => ({ title: a.name, reason: a.reason })),\n            source: 'quick',\n            pipelineVersion: CURRENT_PIPELINE_VERSION,\n            validated: false,\n            degraded: true,\n            cacheHit: false,\n          },\n        }\n        break\n      }\n      case 'labs': {\n        const r = await map('labs')\n        if (!r) return null\n        quick = {\n          issue: summary,\n          section: 'labs',\n          generatedAt: new Date().toISOString(),\n          confidence: 0.6,\n          summary: r.summary || 'Initial guidance while we prepare a deeper report.',\n          highlights: [],\n          dataPoints: [],\n          recommendations: [],\n          mode,\n          extras: {\n            suggestedLabs: r.suggested.map((s) => ({ name: s.name, reason: s.reason, detail: s.protocol ?? null })),\n            avoidLabs: r.avoid.map((a) => ({ name: a.name, reason: a.reason })),\n            source: 'quick',\n            pipelineVersion: CURRENT_PIPELINE_VERSION,\n            validated: false,\n            degraded: true,\n            cacheHit: false,\n          },\n        }\n        break\n      }\n    }\n    return quick as IssueSectionResult\n  } catch (e) {\n    console.warn('[insights.quick] failed', e)\n    return null\n  }\n}\n\nfunction enrichIssueSummary(issue: { id: string; name: string; polarity: 'positive' | 'negative'; slug: string }, context: UserInsightContext): IssueSummary {\n  const goal = context.healthGoals[issue.name.toLowerCase()]\n  const hasLogs = (goal?.healthLogs?.length ?? 0) > 0\n  const normalised = normaliseRating(goal?.currentRating ?? null, issue.polarity, hasLogs)\n  const { trend, delta } = calculateTrend(goal?.healthLogs ?? [], issue.polarity)\n  const lastLog = goal?.healthLogs?.slice(-1)[0]\n  const highlight = buildIssueHighlight(issue, normalised.label, trend, normalised.status)\n  const blockers = buildIssueBlockers(issue, context, normalised.status)\n\n  return {\n    id: issue.id,\n    slug: issue.slug,\n    name: issue.name,\n    polarity: issue.polarity,\n    severityLabel: normalised.label,\n    severityScore: normalised.score,\n    currentRating: goal?.currentRating ?? null,\n    ratingScaleMax: RATING_SCALE_DEFAULT,\n    trend,\n    trendDelta: delta,\n    lastUpdated: lastLog ? lastLog.createdAt.toISOString() : goal?.updatedAt?.toISOString() ?? null,\n    highlight,\n    blockers,\n    status: normalised.status,\n  }\n}\n\nfunction buildIssueHighlight(\n  issue: { name: string; polarity: 'positive' | 'negative' },\n  severity: string,\n  trend: IssueSummary['trend'],\n  status: IssueStatus\n) {\n  const trendText =\n    trend === 'improving' ? 'Improvements logged recently' : trend === 'declining' ? 'Recent data shows regression' : trend === 'stable' ? 'Holding steady' : 'Needs more data'\n  if (status === 'needs-data') {\n    return 'Log a fresh check-in to unlock personalised guidance.'\n  }\n  if (issue.polarity === 'negative') {\n    return `${severity} ‚Ä¢ ${trendText}`\n  }\n  return `${severity} ‚Ä¢ ${trendText}`\n}\n\nfunction buildIssueBlockers(\n  issue: { name: string; polarity: 'positive' | 'negative' },\n  context: UserInsightContext,\n  status: IssueStatus\n) {\n  const blockers: string[] = []\n  const key = pickKnowledgeKey(issue.name.toLowerCase())\n  if (key === 'libido') {\n    if (!context.exerciseLogs.some(log => /strength|resistance|weights/i.test(log.type))) {\n      blockers.push('Strength training frequency not captured')\n    }\n    if (!context.bloodResults?.markers?.some(marker => /testosterone/i.test(marker.name || ''))) {\n      blockers.push('Latest testosterone labs missing')\n    }\n  }\n  if (status !== 'needs-data' && !context.foodLogs.length && !context.todaysFoods.length) {\n    blockers.push('No recent food logs to analyse')\n  }\n  return blockers.slice(0, 3)\n}\n\nfunction buildOverviewSummary(issue: IssueSummary) {\n  const ratingText = issue.currentRating !== null ? `${issue.currentRating}/${issue.ratingScaleMax ?? RATING_SCALE_DEFAULT}` : 'No rating recorded yet'\n  if (issue.polarity === 'negative') {\n    return `${issue.name}: ${issue.severityLabel}. Current rating ${ratingText}.`\n  }\n  return `${issue.name}: ${issue.severityLabel}. Current progress ${ratingText}.`\n}\n\nfunction buildOverviewHighlights(issue: IssueSummary, context: UserInsightContext): SectionHighlight[] {\n  const highlights: SectionHighlight[] = []\n  highlights.push({\n    title: issue.highlight,\n    detail: issue.blockers.length ? `Focus: ${issue.blockers[0]}.` : 'Continue tracking key signals each week.',\n    tone: issue.trend === 'declining' ? 'warning' : 'neutral',\n  })\n  if (issue.blockers.length > 1) {\n    highlights.push({\n      title: 'Additional blockers',\n      detail: issue.blockers.slice(1).join('; '),\n      tone: 'warning',\n    })\n  }\n  if (context.supplements.length) {\n    highlights.push({\n      title: 'Supplements logged',\n      detail: context.supplements.map(supp => supp.name).join(', '),\n      tone: 'neutral',\n    })\n  }\n  return highlights\n}\n\nfunction buildOverviewDataPoints(issue: IssueSummary, context: UserInsightContext): SectionDatum[] {\n  const data: SectionDatum[] = []\n  if (issue.currentRating !== null) {\n    data.push({\n      label: 'Current rating',\n      value: `${issue.currentRating}/${issue.ratingScaleMax ?? RATING_SCALE_DEFAULT}`,\n      context: issue.trendDelta !== null ? `Recent shift ${issue.trendDelta.toFixed(1)}` : undefined,\n    })\n  }\n  if (context.exerciseLogs.length) {\n    const lastExercise = context.exerciseLogs[0]\n    data.push({\n      label: 'Last exercise',\n      value: `${lastExercise.type} ‚Ä¢ ${lastExercise.duration} min`,\n      context: relativeDays(lastExercise.createdAt),\n    })\n  }\n  if (context.foodLogs.length) {\n    const lastMeal = context.foodLogs[0]\n    data.push({\n      label: 'Last food log',\n      value: lastMeal.name,\n      context: relativeDays(lastMeal.createdAt),\n    })\n  }\n  return data\n}\n\nfunction relativeDays(date: Date) {\n  const diff = Math.round((Date.now() - date.getTime()) / (1000 * 60 * 60 * 24))\n  if (diff <= 0) return 'Today'\n  if (diff === 1) return '1 day ago'\n  return `${diff} days ago`\n}\n\nfunction buildOverviewRecommendations(issue: IssueSummary, context: UserInsightContext): SectionRecommendation[] {\n  const recs: SectionRecommendation[] = []\n  if (issue.blockers.includes('No libido-supportive supplements logged')) {\n    recs.push({\n      title: 'Introduce libido-supportive nutraceuticals',\n      description: 'Add evidence-backed supplements to support hormone balance.',\n      actions: ['Discuss ashwagandha 600mg/day or Tongkat Ali with clinician', 'Pair zinc (15‚Äì30mg) with evening meal if labs show low levels'],\n      priority: 'soon',\n    })\n  }\n  if (!context.bloodResults?.documents?.length) {\n    recs.push({\n      title: 'Upload recent labs',\n      description: 'Provide testosterone, thyroid, and metabolic labs to personalise insights.',\n      actions: ['Upload PDF or photo of recent bloodwork', 'Flag markers to monitor (testosterone, SHBG, fasting glucose)'],\n      priority: 'soon',\n    })\n  }\n  if (!context.exerciseLogs.some(log => /strength|resistance|weights/i.test(log.type))) {\n    recs.push({\n      title: 'Schedule structured resistance training',\n      description: 'Strength work 3x/week underpins libido, insulin sensitivity, and confidence.',\n      actions: ['Book two 45-min resistance sessions', 'Track perceived exertion to ensure progressive overload'],\n      priority: 'now',\n    })\n  }\n  if (!recs.length) {\n    recs.push({\n      title: 'Keep logging data weekly',\n      description: 'Consistent tracking sharpens AI insights and trend detection.',\n      actions: ['Log symptoms twice per week', 'Capture meals or supplements changes'],\n      priority: 'monitor',\n    })\n  }\n  return recs\n}\n\nasync function buildOverviewSection(issue: IssueSummary, context: UserInsightContext): Promise<BaseSectionResult> {\n  const now = new Date().toISOString()\n  return {\n    issue,\n    section: 'overview',\n    generatedAt: now,\n    confidence: 0.72,\n    summary: buildOverviewSummary(issue),\n    highlights: buildOverviewHighlights(issue, context),\n    dataPoints: buildOverviewDataPoints(issue, context),\n    recommendations: buildOverviewRecommendations(issue, context),\n  }\n}\n\nasync function buildExerciseSection(\n  issue: IssueSummary,\n  context: UserInsightContext,\n  _options: { forceRefresh: boolean }\n): Promise<BaseSectionResult> {\n  const now = new Date().toISOString()\n  const hasLogs = context.exerciseLogs.length > 0\n  const hasRecentLogs = hasRecentExerciseLogs(context.exerciseLogs)\n  const normalizedLogs = context.exerciseLogs.map((log) => ({\n    name: log.type,\n    dosage: log.duration ? `${log.duration} min` : null,\n    timing: [\n      log.intensity ? `Intensity: ${log.intensity}` : null,\n      `Logged ${relativeDays(log.createdAt)}`,\n    ].filter(Boolean) as string[],\n  }))\n\n  console.time(`[insights.llm] exercise:${issue.slug}`)\n  \n  // Set minWorking to at least 1 if user has intake exerciseTypes, even without logs\n  // But use fewer retries to avoid hanging if LLM can't find supportive exercises\n  const hasIntakeExerciseTypes = (context.profile.exerciseTypes ?? []).length > 0\n  const minWorking = normalizedLogs.length > 0 ? 1 : (hasIntakeExerciseTypes ? 1 : 0)\n  const maxRetries = hasIntakeExerciseTypes && normalizedLogs.length === 0 ? 1 : 3\n  \n  let llmResult = await generateSectionInsightsFromLLM(\n    {\n      issueName: issue.name,\n      issueSummary: issue.highlight,\n      issueSlug: issue.slug,\n      items: normalizedLogs,\n      otherItems: context.supplements.map((supp) => ({ name: supp.name, dosage: supp.dosage ?? null })),\n      profile: context.profile,\n      userId: context.userId,\n      mode: 'exercise',\n    },\n    { minWorking, minSuggested: 4, minAvoid: 4, maxRetries, disableCache: _options.forceRefresh }\n  )\n  console.timeEnd(`[insights.llm] exercise:${issue.slug}`)\n\n  if (!llmResult) {\n    // Degraded fallback\n    const degraded = await generateDegradedSection(\n      {\n        issueName: issue.name,\n        issueSummary: issue.highlight,\n        items: normalizedLogs,\n        otherItems: context.supplements.map((supp) => ({ name: supp.name, dosage: supp.dosage ?? null })),\n        profile: context.profile,\n        mode: 'exercise',\n      },\n      { minSuggested: 4, minAvoid: 4 }\n    )\n    if (degraded) {\n      llmResult = degraded\n    }\n  }\n\n  if (!llmResult) {\n    return {\n      issue,\n      section: 'exercise',\n      generatedAt: now,\n      confidence: 0.4,\n      summary: 'We couldn‚Äôt generate exercise guidance right now. Please try again shortly.',\n      highlights: [\n        {\n          title: 'Generation unavailable',\n          detail: 'The AI service did not return exercise insights. Retry in a few minutes.',\n          tone: 'warning',\n        },\n      ],\n      dataPoints: context.exerciseLogs.slice(0, 5).map((log) => ({\n        label: log.type,\n        value: `${log.duration} min`,\n        context: relativeDays(log.createdAt),\n      })),\n      recommendations: [\n        {\n          title: 'Retry insight generation',\n          description: 'Refresh this page or trigger a new report in a few minutes.',\n          actions: ['Tap Daily/Weekly report to regenerate', 'Contact support if the problem persists'],\n          priority: 'soon',\n        },\n      ],\n      extras: {\n        workingActivities: [],\n        suggestedActivities: [],\n        avoidActivities: [],\n        totalLogged: context.exerciseLogs.length,\n        source: 'llm-error',\n      },\n    }\n  }\n\n  const logMap = new Map(normalizedLogs.map((log) => [canonical(log.name), log]))\n  const kbSupportive: Array<{ title: string; detail: string; keywords?: string[] }> = []\n  const kbAvoidActivities: Array<{ title: string; detail: string }> = []\n\n  // Create map of intake exercise types for fallback when no logs exist\n  const intakeExerciseTypes = new Set(\n    (context.profile.exerciseTypes ?? []).map((type: string) => canonical(type))\n  )\n\n  // Logging for debugging intake exerciseTypes matching\n  console.log('[exercise.working] Raw profile.exerciseTypes:', context.profile.exerciseTypes)\n  console.log('[exercise.working] Canonicalized intakeExerciseTypes Set:', Array.from(intakeExerciseTypes))\n  console.log('[exercise.working] LLM working items:', llmResult.working.map(w => ({ name: w.name, reason: w.reason })))\n  console.log('[exercise.working] LLM suggested items:', llmResult.suggested.map(s => ({ name: s.name, reason: s.reason })))\n\n  const workingActivities = llmResult.working\n    .map((item) => {\n      const itemKey = canonical(item.name)\n      const match = logMap.get(itemKey)\n      \n      // Enhanced matching: check exact match first, then fuzzy match\n      let hasIntakeMatch = intakeExerciseTypes.has(itemKey)\n      if (!hasIntakeMatch) {\n        // Try fuzzy matching against all intake exercise types\n        for (const intakeType of context.profile.exerciseTypes ?? []) {\n          if (matchesExerciseType(item.name, intakeType)) {\n            hasIntakeMatch = true\n            console.log(`[exercise.working] Fuzzy matched \"${item.name}\" to intake type \"${intakeType}\"`)\n            break\n          }\n        }\n      }\n      \n      // Log matching attempt\n      console.log(`[exercise.working] Processing \"${item.name}\" (canonical: \"${itemKey}\"): logMatch=${!!match}, intakeMatch=${hasIntakeMatch}`)\n      \n      // If it matches a log, use log data\n      if (match) {\n        return {\n          title: item.name,\n          reason: item.reason,\n          summary: item.dosage ?? match?.dosage ?? '',\n          lastLogged: item.timing ?? match?.timing?.[0] ?? '',\n        }\n      }\n      \n      // If no log match but it matches intake exerciseTypes, include it with note about intake selection\n      // This allows intake selections to appear as \"working\" when LLM identifies them as helpful\n      if (hasIntakeMatch) {\n        console.log(`[exercise.working] ‚úì Matched intake exerciseType: \"${item.name}\"`)\n        return {\n          title: item.name,\n          reason: item.reason,\n          summary: 'Selected in health intake',\n          lastLogged: 'From your health profile',\n        }\n      }\n      \n      return null\n    })\n    .filter(Boolean) as Array<{ title: string; reason: string; summary: string; lastLogged: string }>\n\n  // Fallback: if LLM returns exercise in suggested bucket that matches intake exerciseTypes, promote it to working\n  const intakeTypesArray = context.profile.exerciseTypes ?? []\n  const promotedFromSuggested: Array<{ title: string; reason: string; summary: string; lastLogged: string }> = []\n  \n  console.log('[exercise.working] Checking suggested items for promotion. Intake types:', intakeTypesArray)\n  \n  for (const suggestedItem of llmResult.suggested) {\n    // Check if already in workingActivities\n    const alreadyInWorking = workingActivities.some(w => canonical(w.title) === canonical(suggestedItem.name))\n    if (alreadyInWorking) {\n      console.log(`[exercise.working] Skipping \"${suggestedItem.name}\" - already in working`)\n      continue\n    }\n    \n    // Check if it matches any intake exercise type (try multiple matching strategies)\n    let matched = false\n    let matchedIntakeType = ''\n    \n    for (const intakeType of intakeTypesArray) {\n      // Strategy 1: Fuzzy matching (handles variations)\n      if (matchesExerciseType(suggestedItem.name, intakeType)) {\n        matched = true\n        matchedIntakeType = intakeType\n        console.log(`[exercise.working] ‚úì Fuzzy matched suggested \"${suggestedItem.name}\" to intake \"${intakeType}\"`)\n        break\n      }\n      \n      // Strategy 2: Case-insensitive exact match (handles case differences)\n      if (canonical(suggestedItem.name) === canonical(intakeType)) {\n        matched = true\n        matchedIntakeType = intakeType\n        console.log(`[exercise.working] ‚úì Exact matched suggested \"${suggestedItem.name}\" to intake \"${intakeType}\"`)\n        break\n      }\n      \n      // Strategy 3: Check if one contains the other (handles \"Walking\" vs \"walking exercise\")\n      const suggestedLower = suggestedItem.name.toLowerCase()\n      const intakeLower = intakeType.toLowerCase()\n      if (suggestedLower.includes(intakeLower) || intakeLower.includes(suggestedLower)) {\n        matched = true\n        matchedIntakeType = intakeType\n        console.log(`[exercise.working] ‚úì Contains matched suggested \"${suggestedItem.name}\" to intake \"${intakeType}\"`)\n        break\n      }\n    }\n    \n    if (matched) {\n      console.log(`[exercise.working] ‚úì Promoting suggested \"${suggestedItem.name}\" to working (matched intake \"${matchedIntakeType}\")`)\n      promotedFromSuggested.push({\n        title: suggestedItem.name, // Keep LLM's name but use intake match logic\n        reason: suggestedItem.reason,\n        summary: 'Selected in health intake',\n        lastLogged: 'From your health profile',\n      })\n    } else {\n      console.log(`[exercise.working] ‚úó No match for suggested \"${suggestedItem.name}\" against intake types:`, intakeTypesArray)\n    }\n  }\n  \n  if (promotedFromSuggested.length > 0) {\n    workingActivities.push(...promotedFromSuggested)\n    console.log(`[exercise.working] ‚úÖ Promoted ${promotedFromSuggested.length} items from suggested to working:`, promotedFromSuggested.map(p => p.title))\n  } else if (intakeTypesArray.length > 0) {\n    console.log(`[exercise.working] ‚ö†Ô∏è WARNING: No suggested items matched intake types. Intake types:`, intakeTypesArray, 'Suggested items:', llmResult.suggested.map(s => s.name))\n  }\n\n  console.log('[exercise.working] Final workingActivities:', workingActivities.map(w => w.title))\n\n  // Deterministic enrichment: if AI returns zero or too few working items, top up using logs matched to KB supportive exercises\n  if (workingActivities.length < 2 && context.exerciseLogs.length > 0) {\n    if (kbSupportive.length) {\n      const seen = new Set<string>(workingActivities.map((activity) => canonical(activity.title)))\n      const enriched: Array<{ title: string; reason: string; summary: string; lastLogged: string }> = []\n      // Latest log per type\n      const latestByType = new Map<string, typeof context.exerciseLogs[number]>()\n      for (const log of [...context.exerciseLogs].sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime())) {\n        const key = canonical(log.type)\n        if (!latestByType.has(key)) latestByType.set(key, log)\n      }\n      const tryMatch = (logName: string, act: { title: string; detail: string; keywords?: string[] }) => {\n        const lname = canonical(logName)\n        const titleKey = canonical(act.title)\n        if (lname === titleKey) return true\n        if (act.keywords && act.keywords.some((kw) => lname.includes(canonical(kw)))) return true\n        const tokens = titleKey.split(/\\s+/).filter((t) => t.length >= 4)\n        return tokens.some((t) => lname.includes(t))\n      }\n      const needed = Math.max(4 - workingActivities.length, 0)\n      if (needed > 0) {\n        for (const [key, log] of Array.from(latestByType.entries())) {\n          const match = kbSupportive.find((a) => tryMatch(log.type, a))\n          if (!match || seen.has(key)) continue\n          seen.add(key)\n          const summaryParts: string[] = []\n          if (log.duration) summaryParts.push(`${log.duration} min`)\n          if (log.intensity) summaryParts.push(`Intensity: ${log.intensity}`)\n          const summary = summaryParts.join(' ‚Ä¢ ')\n          enriched.push({\n            title: log.type,\n            reason: match.detail ?? 'Logged activity aligns with supportive exercise guidance.',\n            summary,\n            lastLogged: `Logged ${relativeDays(log.createdAt)}`,\n          })\n          if (enriched.length >= needed) break\n        }\n      }\n      if (enriched.length) {\n        workingActivities.push(...enriched)\n      }\n    }\n  }\n\n  const novelSuggestedActivities = llmResult.suggested.filter((item) => {\n    // Exclude items that match logs\n    if (logMap.has(canonical(item.name))) return false\n    // Exclude items that were promoted to working\n    return !promotedFromSuggested.some(p => canonical(p.title) === canonical(item.name))\n  })\n\n  let suggestedActivities = novelSuggestedActivities.map((item) => ({\n    title: item.name,\n    reason: item.reason,\n    detail: item.protocol ?? null,\n  }))\n\n  const kbSuggestedPrimary: Array<{ title: string; reason: string; detail: string | null }> = []\n  const kbSuggestedSecondary: Array<{ title: string; reason: string; detail: string | null }> = []\n  if (kbSupportive.length) {\n    for (const act of kbSupportive) {\n      const candidate = {\n        title: act.title,\n        reason: act.detail,\n        detail: null,\n      }\n      const key = canonical(candidate.title)\n      if (!logMap.has(key)) {\n        kbSuggestedPrimary.push(candidate)\n      } else {\n        kbSuggestedSecondary.push(candidate)\n      }\n    }\n  }\n  suggestedActivities = ensureMin(suggestedActivities, [...kbSuggestedPrimary, ...kbSuggestedSecondary], 4)\n\n  const avoidFromLLM = llmResult.avoid.map((item) => ({\n    title: item.name,\n    reason: item.reason,\n  }))\n\n  const avoidFallback = kbAvoidActivities.map((item) => ({\n    title: item.title,\n    reason: item.detail,\n  }))\n\n  const avoidActivities = ensureMin(avoidFromLLM, avoidFallback, 4)\n\n  const validated = suggestedActivities.length >= 4 && avoidActivities.length >= 4\n\n  let summary: string\n  if (llmResult.summary?.trim().length) {\n    summary = llmResult.summary\n  } else if (!hasLogs) {\n    summary = 'No exercise sessions are logged yet‚Äîuse the suggestions below to build your starting plan.'\n  } else if (!hasRecentLogs) {\n    summary = 'No recent exercise entries‚Äîlog this week‚Äôs training so the AI can flag what‚Äôs truly working.'\n  } else {\n    summary = 'AI-generated exercise guidance ready below.'\n  }\n\n  const highlights: SectionHighlight[] = [\n    {\n      title: 'Training wins',\n      detail: workingActivities.length\n        ? workingActivities.map((activity) => `${activity.title}: ${activity.reason}`).join('; ')\n        : 'No activities flagged as supportive yet.',\n      tone: workingActivities.length ? 'positive' : 'neutral',\n    },\n    {\n      title: 'Next training moves',\n      detail: suggestedActivities.length\n        ? suggestedActivities.map((activity) => `${activity.title}: ${activity.reason}`).join('; ')\n        : 'Follow the suggestions below to expand your plan.',\n      tone: suggestedActivities.length ? 'neutral' : 'positive',\n    },\n    {\n      title: 'Activities to monitor',\n      detail: avoidActivities.length\n        ? avoidActivities.map((activity) => `${activity.title}: ${activity.reason}`).join('; ')\n        : 'No avoid items flagged‚Äîreview the cautions below for awareness.',\n      tone: avoidActivities.length ? 'warning' : 'neutral',\n    },\n  ]\n\n  if (!hasLogs) {\n    highlights.unshift({\n      title: 'Add your first workout',\n      detail: 'Log a strength, cardio, or recovery session so the AI can anchor future guidance.',\n      tone: 'warning',\n    })\n  } else if (!hasRecentLogs) {\n    highlights.unshift({\n      title: 'Refresh recent training data',\n      detail: 'Capture this week‚Äôs sessions to keep recommendations in sync with your actual routine.',\n      tone: 'warning',\n    })\n  }\n\n  const recommendations: SectionRecommendation[] = llmResult.recommendations.length\n    ? llmResult.recommendations.map((rec) => ({\n        title: rec.title,\n        description: rec.description,\n        actions: rec.actions.length ? rec.actions : ['Discuss with your clinician or coach'],\n        priority: rec.priority,\n      }))\n    : hasLogs\n    ? [\n        {\n          title: 'Plan next week of training',\n          description: 'Schedule supportive sessions and monitor recovery.',\n          actions: ['Block training slots', 'Log how your body responds'],\n          priority: 'soon',\n        },\n      ]\n    : [\n        {\n          title: 'Log your first session',\n          description: 'Record at least one workout this week so the AI can highlight wins and cautions.',\n          actions: ['Open Health Tracking ‚Üí Exercise', 'Add session duration and intensity'],\n          priority: 'now',\n        },\n      ]\n\n  return {\n    issue,\n    section: 'exercise',\n    generatedAt: now,\n    confidence: 0.82,\n    summary,\n    highlights,\n    dataPoints: context.exerciseLogs.slice(0, 5).map((log) => ({\n      label: log.type,\n      value: `${log.duration} min`,\n      context: relativeDays(log.createdAt),\n    })),\n    recommendations,\n    extras: {\n      workingActivities,\n      suggestedActivities,\n      avoidActivities,\n      totalLogged: context.exerciseLogs.length,\n      source: 'llm',\n      pipelineVersion: CURRENT_PIPELINE_VERSION,\n      validated,\n      degraded: !validated,\n    },\n  }\n}\n\nasync function buildSupplementsSection(\n  issue: IssueSummary,\n  context: UserInsightContext,\n  _options: { forceRefresh: boolean }\n): Promise<BaseSectionResult> {\n  const now = new Date().toISOString()\n  const supplements = context.supplements\n  const hasSupplements = supplements.length > 0\n  const hasRecentSupplements = hasRecentSupplementActivity(supplements)\n\n  const normalizedSupplements = supplements.map((supp) => ({\n    name: supp.name,\n    dosage: supp.dosage ?? null,\n    timing: Array.isArray(supp.timing) ? supp.timing : [],\n  }))\n\n  console.time(`[insights.llm] supplements:${issue.slug}`)\n  let llmResult = await generateSectionInsightsFromLLM(\n    {\n      issueName: issue.name,\n      issueSummary: issue.highlight,\n      issueSlug: issue.slug,\n      items: normalizedSupplements,\n      otherItems: context.medications.map((med) => ({ name: med.name, dosage: med.dosage ?? null })),\n      profile: context.profile,\n      userId: context.userId,\n      mode: 'supplements',\n    },\n    { minWorking: Math.min(3, Math.max(0, normalizedSupplements.length)), minSuggested: 4, minAvoid: 4, disableCache: _options.forceRefresh }\n  )\n  console.timeEnd(`[insights.llm] supplements:${issue.slug}`)\n  \n  console.log(`[supplements] LLM result:`, {\n    hasResult: !!llmResult,\n    workingCount: llmResult?.working?.length ?? 0,\n    suggestedCount: llmResult?.suggested?.length ?? 0,\n    avoidCount: llmResult?.avoid?.length ?? 0,\n  })\n\n  if (!llmResult) {\n    console.warn(`[supplements] LLM returned null, trying degraded fallback`)\n    const degraded = await generateDegradedSection(\n      {\n        issueName: issue.name,\n        issueSummary: issue.highlight,\n        issueSlug: issue.slug,\n        items: normalizedSupplements,\n        otherItems: context.medications.map((med) => ({ name: med.name, dosage: med.dosage ?? null })),\n        profile: context.profile,\n        userId: context.userId,\n        mode: 'supplements',\n      },\n      { minSuggested: 4, minAvoid: 4 }\n    )\n    if (degraded) {\n      llmResult = degraded\n      console.log(`[supplements] Degraded fallback succeeded:`, {\n        workingCount: degraded.working?.length ?? 0,\n        suggestedCount: degraded.suggested?.length ?? 0,\n        avoidCount: degraded.avoid?.length ?? 0,\n      })\n    } else {\n      console.error(`[supplements] Both LLM and degraded fallback failed`)\n    }\n  }\n  \n  // Ensure llmResult has arrays even if empty\n  if (llmResult) {\n    if (!Array.isArray(llmResult.working)) llmResult.working = []\n    if (!Array.isArray(llmResult.suggested)) llmResult.suggested = []\n    if (!Array.isArray(llmResult.avoid)) llmResult.avoid = []\n  }\n\n  if (!llmResult) {\n    return {\n      issue,\n      section: 'supplements',\n      generatedAt: now,\n      confidence: 0.4,\n      summary: 'We couldn‚Äôt generate supplement guidance right now. Please try again shortly or check with support.',\n      highlights: [\n        {\n          title: 'Generation unavailable',\n          detail: 'The AI service did not return supplement suggestions. Retry in a few minutes.',\n          tone: 'warning',\n        },\n      ],\n      dataPoints: normalizedSupplements.map((supp) => ({\n        label: supp.name,\n        value: supp.dosage || 'Dose not set',\n        context: supp.timing?.length ? `Timing: ${supp.timing.join(', ')}` : 'Add timing details',\n      })),\n      recommendations: [\n        {\n          title: 'Retry insight generation',\n          description: 'Refresh this page or trigger a new report in a few minutes.',\n          actions: ['Tap Daily/Weekly report to regenerate', 'Contact support if the problem persists'],\n          priority: 'soon',\n        },\n      ],\n      extras: {\n        supportiveDetails: [],\n        suggestedAdditions: [],\n        avoidList: [],\n        missingDose: supplements.filter((supp) => !supp.dosage).map((supp) => supp.name),\n        missingTiming: supplements.filter((supp) => !supp.timing || !supp.timing.length).map((supp) => supp.name),\n        totalLogged: supplements.length,\n        source: 'llm-error',\n      } as Record<string, unknown>,\n    }\n  }\n\n  const supplementMap = new Map(\n    normalizedSupplements.map((supp) => [canonical(supp.name), supp])\n  )\n\n  const parseTiming = (timing?: string | null, fallback?: string[]) => {\n    if (timing && timing.trim().length) {\n      return timing\n        .split(/[,;]+/)\n        .map((t) => t.trim())\n        .filter(Boolean)\n    }\n    return fallback ?? []\n  }\n\n  const kbAddLocal: Array<{ pattern: RegExp; title?: string; why: string; suggested?: string }> = []\n  const kbAvoidLocal: Array<{ pattern: RegExp; title?: string; why: string }> = []\n  // Populate KB fallbacks for this issue to guarantee 4/4\n  try {\n    const key = pickKnowledgeKey(issue.name)\n    if (key && ISSUE_KNOWLEDGE_BASE[key]) {\n      const kb = ISSUE_KNOWLEDGE_BASE[key]\n      if (Array.isArray(kb.helpfulMedications)) kbAddLocal.push(...kb.helpfulMedications)\n      if (Array.isArray(kb.avoidMedications)) kbAvoidLocal.push(...kb.avoidMedications)\n    }\n  } catch {}\n  // Populate KB fallbacks for this issue to guarantee 4/4\n  try {\n    const key = pickKnowledgeKey(issue.name)\n    if (key && ISSUE_KNOWLEDGE_BASE[key]) {\n      const kb = ISSUE_KNOWLEDGE_BASE[key]\n      if (Array.isArray(kb.helpfulSupplements)) kbAddLocal.push(...kb.helpfulSupplements)\n      if (Array.isArray(kb.avoidSupplements)) kbAvoidLocal.push(...kb.avoidSupplements)\n    }\n  } catch {}\n\n  // Safety check: ensure llmResult has arrays (it should exist at this point due to check above)\n  if (!llmResult) {\n    throw new Error(`[supplements] CRITICAL: llmResult is null after all fallbacks - this should not happen`)\n  }\n  \n  // Ensure arrays exist even if empty\n  if (!Array.isArray(llmResult.working)) llmResult.working = []\n  if (!Array.isArray(llmResult.suggested)) llmResult.suggested = []\n  if (!Array.isArray(llmResult.avoid)) llmResult.avoid = []\n\n  const supportiveDetails = llmResult.working\n    .map((item) => {\n      const match = supplementMap.get(canonical(item.name))\n      if (!match) return null\n      return {\n        name: item.name,\n        reason: item.reason,\n        dosage: item.dosage ?? match?.dosage ?? null,\n        timing: parseTiming(item.timing, match?.timing ?? []),\n      }\n    })\n    .filter(Boolean) as Array<{ name: string; reason: string; dosage: string | null; timing: string[] }>\n\n  // AI-based fallback: if LLM didn't properly match logged supplements, evaluate them directly\n  if (supportiveDetails.length === 0 && normalizedSupplements.length > 0) {\n    console.log(`[supplements] LLM didn't match logged supplements, using AI evaluator fallback for ${normalizedSupplements.length} items`)\n    const evaluated = await evaluateFocusItemsForIssue({\n      issueName: issue.name,\n      issueSummary: issue.highlight,\n      mode: 'supplements',\n      focusItems: normalizedSupplements,\n    })\n    if (evaluated && evaluated.length > 0) {\n      // Map evaluated results to exact logged names with dosage/timing\n      for (const item of evaluated) {\n        const logged = supplementMap.get(canonical(item.name))\n        if (logged) {\n          supportiveDetails.push({\n            name: logged.name, // Use exact logged name\n            reason: item.reason,\n            dosage: item.dosage ?? logged.dosage ?? null,\n            timing: parseTiming(item.timing, logged.timing ?? []),\n          })\n        }\n      }\n      console.log(`[supplements] AI evaluator found ${supportiveDetails.length} supportive supplements`)\n    }\n  }\n\n  // AI-based augmentation: if some logged supplements are still missing from working, evaluate only the missing ones\n  if (normalizedSupplements.length > 0) {\n    const present = new Set(supportiveDetails.map((s) => canonical(s.name)))\n    const missing = normalizedSupplements.filter((supp) => !present.has(canonical(supp.name)))\n    if (missing.length > 0) {\n      console.log(`[supplements] Evaluating ${missing.length} missing logged supplements for potential support`)\n      const evaluatedMissing = await evaluateFocusItemsForIssue({\n        issueName: issue.name,\n        issueSummary: issue.highlight,\n        mode: 'supplements',\n        focusItems: missing,\n      })\n      if (evaluatedMissing && evaluatedMissing.length > 0) {\n        for (const item of evaluatedMissing) {\n          const key = canonical(item.name)\n          if (present.has(key)) continue\n          const logged = supplementMap.get(key)\n          if (!logged) continue\n          supportiveDetails.push({\n            name: logged.name,\n            reason: item.reason,\n            dosage: item.dosage ?? logged.dosage ?? null,\n            timing: parseTiming(item.timing, logged.timing ?? []),\n          })\n          present.add(key)\n        }\n        console.log(`[supplements] Added ${supportiveDetails.length} total supportive supplements after augmentation`)\n      }\n    }\n  }\n\n  // FALLBACK: Ensure fiber supplements are included for bowel issues (even if evaluator missed them)\n  const isBowelIssue = /bowel|digestion|constipation|regularity|stool/i.test(issue.name)\n  if (isBowelIssue && normalizedSupplements.length > 0) {\n    const present = new Set(supportiveDetails.map((s) => canonical(s.name)))\n    const fiberSupplements = normalizedSupplements.filter(supp => {\n      const isFiber = /fiber|fibre|psyllium|inulin|guar gum|phgg/i.test(supp.name)\n      return isFiber && !present.has(canonical(supp.name))\n    })\n    \n    if (fiberSupplements.length > 0) {\n      console.log(`[supplements] Adding ${fiberSupplements.length} fiber supplements that evaluator missed: ${fiberSupplements.map(s => s.name).join(', ')}`)\n      for (const supp of fiberSupplements) {\n        supportiveDetails.push({\n          name: supp.name,\n          reason: `${supp.name} contains soluble fiber that supports bowel regularity through hydration, gel formation, and fermentation to short-chain fatty acids that normalize stool consistency.`,\n          dosage: supp.dosage ?? null,\n          timing: parseTiming(null, supp.timing ?? []),\n        })\n      }\n    }\n  }\n\n  // Legacy KB fallback (only if AI evaluator also found nothing)\n  if (supportiveDetails.length === 0 && normalizedSupplements.length > 0) {\n    const enriched = normalizedSupplements\n      .map((supp) => {\n        const match = kbAddLocal.find((k) => k.pattern.test(supp.name))\n        if (!match) return null\n        return {\n          name: supp.name,\n          reason: match.why,\n          dosage: supp.dosage ?? null,\n          timing: parseTiming(null, supp.timing ?? []),\n        }\n      })\n      .filter(Boolean) as Array<{ name: string; reason: string; dosage: string | null; timing: string[] }>\n    if (enriched.length) {\n      supportiveDetails.push(...enriched.slice(0, 4))\n    }\n  }\n\n  const novelSuggestions = (llmResult.suggested ?? []).filter((item) => !supplementMap.has(canonical(item.name)))\n\n  let suggestedAdditions = novelSuggestions.map((item) => ({\n    title: item.name,\n    reason: item.reason,\n    suggestion: item.protocol ?? null,\n    alreadyCovered: false,\n  }))\n\n  const kbSuggestionCandidates = [\n    ...kbAddLocal.map((entry) => ({\n      title: entry.title ?? displayFromPattern(entry.pattern),\n      reason: entry.why,\n      suggestion: entry.suggested ?? null,\n      alreadyCovered: normalizedSupplements.some((supp) => entry.pattern.test(supp.name)),\n    })),\n    // Include gap suggestions (non-regex) if provided for this issue\n    ...(() => {\n      const out: Array<{ title: string; reason: string; suggestion: string | null; alreadyCovered: boolean }> = []\n      try {\n        const key = pickKnowledgeKey(issue.name)\n        if (key && ISSUE_KNOWLEDGE_BASE[key]?.gapSupplements) {\n          for (const g of ISSUE_KNOWLEDGE_BASE[key]!.gapSupplements!) {\n            out.push({\n              title: g.title,\n              reason: g.why,\n              suggestion: g.suggested ?? null,\n              alreadyCovered: false,\n            })\n          }\n        }\n      } catch {}\n      return out\n    })(),\n  ]\n\n  const fallbackSuggestions = kbSuggestionCandidates.filter((item) => !item.alreadyCovered)\n  const coveredSuggestions = kbSuggestionCandidates.filter((item) => item.alreadyCovered)\n  suggestedAdditions = ensureMin(suggestedAdditions, [...fallbackSuggestions, ...coveredSuggestions], 4)\n\n  const avoidFromLLM = (llmResult.avoid ?? [])\n    .map((item) => {\n      const match = supplementMap.get(canonical(item.name))\n      return {\n        name: item.name,\n        reason: item.reason,\n        dosage: match?.dosage ?? null,\n        timing: match?.timing ?? [],\n      }\n    })\n    // Keep only true supplements (allow logged or names that look supplement-like).\n    .filter((entry) => {\n      const isLogged = supplementMap.has(canonical(entry.name))\n      return isLogged || looksSupplementLike(entry.name) || looksSupplementLike(entry.reason)\n    })\n\n  const avoidFallback = kbAvoidLocal.map((entry) => ({\n    name: entry.title ?? displayFromPattern(entry.pattern),\n    reason: entry.why,\n    dosage: null,\n    timing: [],\n  }))\n\n  const avoidList = ensureMin(avoidFromLLM, avoidFallback, 4)\n  \n  // Log final counts for debugging\n  console.log(`[supplements] Final counts before deduplication:`, {\n    supportiveDetails: supportiveDetails.length,\n    suggestedAdditions: suggestedAdditions.length,\n    avoidList: avoidList.length,\n    llmSuggestedCount: llmResult?.suggested?.length ?? 0,\n    llmAvoidCount: llmResult?.avoid?.length ?? 0,\n    kbFallbackCount: kbSuggestionCandidates.length,\n    kbAvoidFallbackCount: kbAvoidLocal.length,\n    avoidFromLLMCount: avoidFromLLM.length,\n    avoidFallbackCount: avoidFallback.length,\n  })\n\n  const validated = suggestedAdditions.length >= 4 && avoidList.length >= 4\n\n  // CRITICAL: Deduplicate supportiveDetails before finalizing\n  // This prevents duplicates that might come from LLM returning same supplement twice,\n  // or from multiple augmentation steps adding the same supplement\n  const seenSupportive = new Set<string>()\n  const deduplicatedSupportiveDetails = supportiveDetails.filter((item) => {\n    const key = canonical(item.name)\n    if (seenSupportive.has(key)) {\n      console.warn(`[supplements] Removing duplicate supplement from supportiveDetails: \"${item.name}\" (canonical: \"${key}\")`)\n      return false\n    }\n    seenSupportive.add(key)\n    return true\n  })\n  \n  if (deduplicatedSupportiveDetails.length !== supportiveDetails.length) {\n    console.log(`[supplements] Deduplicated supportiveDetails: ${supportiveDetails.length} ‚Üí ${deduplicatedSupportiveDetails.length} items`)\n  }\n\n  let summary: string\n  if (llmResult.summary?.trim().length) {\n    summary = llmResult.summary\n  } else if (!hasSupplements) {\n    summary = 'No supplements are logged yet‚Äîuse the suggested additions below to speak with your clinician about next steps.'\n  } else if (!hasRecentSupplements) {\n    summary = 'No recent supplement updates‚Äîlog dose or timing changes and review the suggestions below to keep your plan dialled in.'\n  } else if (deduplicatedSupportiveDetails.length) {\n    summary = `You have ${deduplicatedSupportiveDetails.length} supplement${deduplicatedSupportiveDetails.length === 1 ? '' : 's'} supporting ${issue.name}.`\n  } else {\n    summary = 'AI-generated guidance ready below.'\n  }\n\n  const recommendations: SectionRecommendation[] = llmResult.recommendations.length\n    ? llmResult.recommendations.map((rec) => ({\n        title: rec.title,\n        description: rec.description,\n        actions: rec.actions.length ? rec.actions : ['Discuss with your clinician'],\n        priority: rec.priority,\n      }))\n    : hasSupplements\n    ? [\n        {\n          title: 'Review supplement plan with your clinician',\n          description: 'Discuss current regimen and adjust based on response and labs.',\n          actions: ['Bring this summary to your next consult', 'Track symptom response weekly'],\n          priority: 'soon',\n        },\n      ]\n    : [\n        {\n          title: 'Log your current supplements',\n          description: 'Capture the products you‚Äôre already taking so we can highlight what is working.',\n          actions: ['Open Health Setup ‚Üí Supplements', 'Add each supplement with dose and timing'],\n          priority: 'now',\n        },\n      ]\n\n  const highlights: SectionHighlight[] = [\n    {\n      title: \"What's working\",\n      detail: deduplicatedSupportiveDetails.length\n        ? deduplicatedSupportiveDetails.map((item) => `${item.name}: ${item.reason}`).join('; ')\n        : 'No supplements clearly supporting this issue yet.',\n      tone: deduplicatedSupportiveDetails.length ? 'positive' : 'neutral',\n    },\n    {\n      title: 'Opportunities',\n      detail: suggestedAdditions.length\n        ? suggestedAdditions.map((item) => `${item.title}: ${item.reason}`).join('; ')\n        : 'Leverage the AI suggestions below to discuss next steps.',\n      tone: suggestedAdditions.length ? 'neutral' : 'positive',\n    },\n    {\n      title: 'Cautions',\n      detail: avoidList.length\n        ? avoidList.map((item) => `${item.name}: ${item.reason}`).join('; ')\n        : 'No avoid items flagged‚Äîreview suggestions below for future awareness.',\n      tone: avoidList.length ? 'warning' : 'neutral',\n    },\n  ]\n\n  if (!hasSupplements) {\n    highlights.unshift({\n      title: 'Log your current supplements',\n      detail: 'Recording each product with dose and timing unlocks ‚ÄúWhat‚Äôs Working‚Äù tracking.',\n      tone: 'warning',\n    })\n  } else if (!hasRecentSupplements) {\n    highlights.unshift({\n      title: 'Update recent supplement changes',\n      detail: 'Add any new products or dose adjustments so guidance reflects your current stack.',\n      tone: 'warning',\n    })\n  }\n\n  return {\n    issue,\n    section: 'supplements',\n    generatedAt: now,\n    confidence: 0.82,\n    summary,\n    highlights,\n    dataPoints: supplements.slice(0, 6).map((supp) => ({\n      label: supp.name,\n      value: supp.dosage || 'Dose not set',\n      context: supp.timing?.length ? `Timing: ${supp.timing.join(', ')}` : 'Add timing details',\n    })),\n    recommendations,\n    extras: {\n      supportiveDetails: deduplicatedSupportiveDetails, // Use deduplicated version to prevent duplicates\n      suggestedAdditions,\n      avoidList,\n      missingDose: supplements.filter((supp) => !supp.dosage).map((supp) => supp.name),\n      missingTiming: supplements.filter((supp) => !supp.timing || !supp.timing.length).map((supp) => supp.name),\n      totalLogged: supplements.length,\n      hasLogged: hasSupplements,\n      hasRecentUpdates: hasRecentSupplements,\n      source: 'llm',\n      pipelineVersion: CURRENT_PIPELINE_VERSION,\n      validated,\n      degraded: !validated,\n    } as Record<string, unknown>,\n  }\n}\n\nasync function buildMedicationsSection(\n  issue: IssueSummary,\n  context: UserInsightContext,\n  _options: { forceRefresh: boolean }\n): Promise<BaseSectionResult> {\n  const now = new Date().toISOString()\n  const medications = context.medications\n  const hasMedications = medications.length > 0\n  const hasRecentMedicationUpdates = hasRecentMedicationActivity(medications)\n\n  const normalizedMeds = medications.map((med) => ({\n    name: med.name,\n    dosage: med.dosage ?? null,\n    timing: Array.isArray(med.timing) ? med.timing : [],\n  }))\n\n  console.time(`[insights.llm] medications:${issue.slug}`)\n  let llmResult = await generateSectionInsightsFromLLM(\n    {\n      issueName: issue.name,\n      issueSummary: issue.highlight,\n      issueSlug: issue.slug,\n      items: normalizedMeds,\n      otherItems: context.supplements.map((supp) => ({ name: supp.name, dosage: supp.dosage ?? null })),\n      profile: context.profile,\n      userId: context.userId,\n      mode: 'medications',\n    },\n    { minWorking: normalizedMeds.length > 0 ? 1 : 0, minSuggested: 4, minAvoid: 4, disableCache: _options.forceRefresh }\n  )\n  console.timeEnd(`[insights.llm] medications:${issue.slug}`)\n\n  if (!llmResult) {\n    const degraded = await generateDegradedSection(\n      {\n        issueName: issue.name,\n        issueSummary: issue.highlight,\n        issueSlug: issue.slug,\n        items: normalizedMeds,\n        otherItems: context.supplements.map((supp) => ({ name: supp.name, dosage: supp.dosage ?? null })),\n        profile: context.profile,\n        userId: context.userId,\n        mode: 'medications',\n      },\n      { minSuggested: 4, minAvoid: 4 }\n    )\n    if (degraded) llmResult = degraded\n  }\n\n  if (!llmResult) {\n    return {\n      issue,\n      section: 'medications',\n      generatedAt: now,\n      confidence: 0.4,\n      summary: 'We couldn‚Äôt generate medication guidance right now. Please try again shortly.',\n      highlights: [\n        {\n          title: 'Generation unavailable',\n          detail: 'The AI service did not return medication suggestions. Retry in a few minutes.',\n          tone: 'warning',\n        },\n      ],\n      dataPoints: normalizedMeds.map((med) => ({\n        label: med.name,\n        value: med.dosage || 'Dose not set',\n        context: med.timing?.length ? `Timing: ${med.timing.join(', ')}` : 'Add timing details',\n      })),\n      recommendations: [\n        {\n          title: 'Retry insight generation',\n          description: 'Refresh this page or trigger a new report in a few minutes.',\n          actions: ['Tap Daily/Weekly report to regenerate', 'Contact support if the problem persists'],\n          priority: 'soon',\n        },\n      ],\n      extras: {\n        supportiveDetails: [],\n        suggestedAdditions: [],\n        avoidList: [],\n        missingDose: medications.filter((med) => !med.dosage).map((med) => med.name),\n        missingTiming: medications.filter((med) => !med.timing || !med.timing.length).map((med) => med.name),\n        totalLogged: medications.length,\n        source: 'llm-error',\n      } as Record<string, unknown>,\n    }\n  }\n\n  const medMap = new Map(normalizedMeds.map((med) => [canonical(med.name), med]))\n  const supplementNameSet = new Set(\n    context.supplements.map((supp) => canonical(supp.name))\n  )\n\n  const parseTiming = (timing?: string | null, fallback?: string[]) => {\n    if (timing && timing.trim().length) {\n      return timing\n        .split(/[,;]+/)\n        .map((t) => t.trim())\n        .filter(Boolean)\n    }\n    return fallback ?? []\n  }\n\n  const kbAddLocal: Array<{ pattern: RegExp; title?: string; why: string; suggested?: string }> = []\n  const kbAvoidLocal: Array<{ pattern: RegExp; title?: string; why: string }> = []\n\n  const supportiveDetails = llmResult.working\n    .map((item) => {\n      const nameKey = canonical(item.name)\n      if (supplementNameSet.has(nameKey) || looksSupplementLike(item.name) || looksSupplementLike(item.reason)) {\n        return null\n      }\n      const match = medMap.get(nameKey)\n      if (!match) return null\n      return {\n        name: item.name,\n        reason: item.reason,\n        dosage: item.dosage ?? match?.dosage ?? null,\n        timing: parseTiming(item.timing, match?.timing ?? []),\n      }\n    })\n    .filter(Boolean) as Array<{ name: string; reason: string; dosage: string | null; timing: string[] }>\n\n  // AI-based fallback: if LLM didn't properly match logged medications, evaluate them directly\n  if (supportiveDetails.length === 0 && normalizedMeds.length > 0) {\n    console.log(`[medications] LLM didn't match logged medications, using AI evaluator fallback for ${normalizedMeds.length} items`)\n    const evaluated = await evaluateFocusItemsForIssue({\n      issueName: issue.name,\n      issueSummary: issue.highlight,\n      mode: 'medications',\n      focusItems: normalizedMeds,\n    })\n    if (evaluated && evaluated.length > 0) {\n      // Map evaluated results to exact logged names with dosage/timing, filtering out supplements\n      for (const item of evaluated) {\n        const nameKey = canonical(item.name)\n        if (supplementNameSet.has(nameKey) || looksSupplementLike(item.name)) continue\n        const logged = medMap.get(nameKey)\n        if (logged) {\n          supportiveDetails.push({\n            name: logged.name, // Use exact logged name\n            reason: item.reason,\n            dosage: item.dosage ?? logged.dosage ?? null,\n            timing: parseTiming(item.timing, logged.timing ?? []),\n          })\n        }\n      }\n      console.log(`[medications] AI evaluator found ${supportiveDetails.length} supportive medications`)\n    }\n  }\n\n  // AI-based augmentation: if some logged medications are still missing from working, evaluate only the missing ones\n  if (normalizedMeds.length > 0) {\n    const present = new Set(supportiveDetails.map((s) => canonical(s.name)))\n    const missing = normalizedMeds.filter((med) => !present.has(canonical(med.name)))\n    if (missing.length > 0) {\n      console.log(`[medications] Evaluating ${missing.length} missing logged medications for potential support`)\n      const evaluatedMissing = await evaluateFocusItemsForIssue({\n        issueName: issue.name,\n        issueSummary: issue.highlight,\n        mode: 'medications',\n        focusItems: missing,\n      })\n      if (evaluatedMissing && evaluatedMissing.length > 0) {\n        for (const item of evaluatedMissing) {\n          const key = canonical(item.name)\n          if (present.has(key)) continue\n          if (supplementNameSet.has(key) || looksSupplementLike(item.name)) continue\n          const logged = medMap.get(key)\n          if (!logged) continue\n          supportiveDetails.push({\n            name: logged.name,\n            reason: item.reason,\n            dosage: item.dosage ?? logged.dosage ?? null,\n            timing: parseTiming(item.timing, logged.timing ?? []),\n          })\n          present.add(key)\n        }\n        console.log(`[medications] Added ${supportiveDetails.length} total supportive medications after augmentation`)\n      }\n    }\n  }\n\n  // Legacy KB fallback (only if AI evaluator also found nothing)\n  if (supportiveDetails.length === 0 && normalizedMeds.length > 0) {\n    if (kbAddLocal.length) {\n      const seen = new Set<string>()\n      const enriched = normalizedMeds\n        .map((med) => {\n          const key = canonical(med.name)\n          if (supplementNameSet.has(key) || looksSupplementLike(med.name)) return null\n          const match = kbAddLocal.find((k) => k.pattern.test(med.name))\n          if (!match || seen.has(key)) return null\n          seen.add(key)\n          return {\n            name: med.name,\n            reason: match.why,\n            dosage: med.dosage ?? null,\n            timing: parseTiming(null, med.timing ?? []),\n          }\n        })\n        .filter(Boolean) as Array<{ name: string; reason: string; dosage: string | null; timing: string[] }>\n      if (enriched.length) {\n        supportiveDetails.push(...enriched.slice(0, 4))\n      }\n    }\n  }\n\n  const novelSuggestions = llmResult.suggested.filter((item) => {\n    const nameKey = canonical(item.name)\n    if (supplementNameSet.has(nameKey)) return false\n    if (looksSupplementLike(item.name) || looksSupplementLike(item.reason)) return false\n    return !medMap.has(nameKey)\n  })\n\n  let suggestedAdditions = novelSuggestions.map((item) => ({\n    title: item.name,\n    reason: item.reason,\n    suggestion: item.protocol ?? null,\n    alreadyCovered: false,\n  }))\n\n  const kbSuggestionCandidates = [\n    ...kbAddLocal.map((entry) => ({\n      title: entry.title ?? displayFromPattern(entry.pattern),\n      reason: entry.why,\n      suggestion: entry.suggested ?? null,\n      alreadyCovered: normalizedMeds.some((med) => entry.pattern.test(med.name)),\n    })),\n    // Include gap medication suggestions when present\n    ...(() => {\n      const out: Array<{ title: string; reason: string; suggestion: string | null; alreadyCovered: boolean }> = []\n      try {\n        const key = pickKnowledgeKey(issue.name)\n        if (key && ISSUE_KNOWLEDGE_BASE[key]?.gapMedications) {\n          for (const g of ISSUE_KNOWLEDGE_BASE[key]!.gapMedications!) {\n            out.push({ title: g.title, reason: g.why, suggestion: g.suggested ?? null, alreadyCovered: false })\n          }\n        }\n      } catch {}\n      return out\n    })(),\n  ]\n\n  const fallbackSuggestions = kbSuggestionCandidates.filter((item) => !item.alreadyCovered)\n  const coveredSuggestions = kbSuggestionCandidates.filter((item) => item.alreadyCovered)\n  suggestedAdditions = ensureMin(suggestedAdditions, [...fallbackSuggestions, ...coveredSuggestions], 4)\n\n  const avoidFromLLM = llmResult.avoid\n    .map((item) => {\n      const nameKey = canonical(item.name)\n      if (supplementNameSet.has(nameKey) || looksSupplementLike(item.name) || looksSupplementLike(item.reason)) {\n        return null\n      }\n      const match = medMap.get(nameKey)\n      return {\n        name: item.name,\n        reason: item.reason,\n        dosage: match?.dosage ?? null,\n        timing: match?.timing ?? [],\n      }\n    })\n    .filter(Boolean) as Array<{ name: string; reason: string; dosage: string | null; timing: string[] }>\n\n  const avoidFallback = kbAvoidLocal.map((entry) => ({\n    name: entry.title ?? displayFromPattern(entry.pattern),\n    reason: entry.why,\n    dosage: null,\n    timing: [],\n  }))\n\n  const avoidList = ensureMin(avoidFromLLM, avoidFallback, 4)\n\n  const hasAnyMedicationGuidance =\n    supportiveDetails.length + suggestedAdditions.length + avoidList.length > 0\n\n  const validated = suggestedAdditions.length >= 4 && avoidList.length >= 4\n\n  let summary: string\n  if (llmResult.summary?.trim().length) {\n    summary = llmResult.summary\n  } else if (!hasMedications) {\n    summary = 'No medications are logged yet‚Äîuse the suggestions below to discuss options with your prescriber.'\n  } else if (!hasRecentMedicationUpdates) {\n    summary = 'No recent medication updates‚Äîlog new prescriptions or dose changes and review the suggestions below.'\n  } else if (supportiveDetails.length) {\n    summary = `You have ${supportiveDetails.length} medication${supportiveDetails.length === 1 ? '' : 's'} aligned with ${issue.name}.`\n  } else if (!hasAnyMedicationGuidance) {\n    summary = 'No medication-specific guidance is available‚Äîlog new prescriptions or consult your clinician.'\n  } else {\n    summary = 'AI-generated medication guidance ready below.'\n  }\n\n  const recommendations: SectionRecommendation[] = llmResult.recommendations.length\n    ? llmResult.recommendations.map((rec) => ({\n        title: rec.title,\n        description: rec.description,\n        actions: rec.actions.length ? rec.actions : ['Coordinate changes with your clinician'],\n        priority: rec.priority,\n      }))\n    : hasMedications\n    ? [\n        {\n          title: 'Review therapy plan',\n          description: 'Align dosing and timing with symptom response and labs.',\n          actions: ['Discuss adjustments with your clinician', 'Track response weekly'],\n          priority: 'soon',\n        },\n      ]\n    : [\n        {\n          title: 'Log active prescriptions',\n          description: 'Add medications with dose and timing so we can monitor what is supporting this issue.',\n          actions: ['Open Health Setup ‚Üí Medications', 'Add prescription and OTC therapies'],\n          priority: 'now',\n        },\n      ]\n\n  const highlights: SectionHighlight[] = [\n    {\n      title: \"What's working\",\n      detail: supportiveDetails.length\n        ? supportiveDetails.map((item) => `${item.name}: ${item.reason}`).join('; ')\n        : 'No medications in your log are clearly supporting this issue yet.',\n      tone: supportiveDetails.length ? 'positive' : 'neutral',\n    },\n    {\n      title: 'Opportunities',\n      detail: suggestedAdditions.length\n        ? suggestedAdditions.map((item) => `${item.title}: ${item.reason}`).join('; ')\n        : medications.length\n        ? 'No additional medications to suggest‚Äîdiscuss options with your clinician if symptoms persist.'\n        : 'Add prescribed or OTC medications to your log so the AI can surface targeted options.',\n      tone: suggestedAdditions.length ? 'neutral' : 'positive',\n    },\n    {\n      title: 'Cautions',\n      detail: avoidList.length\n        ? avoidList.map((item) => `${item.name}: ${item.reason}`).join('; ')\n        : medications.length\n        ? 'No medications flagged for caution right now‚Äîcontinue monitoring with your clinician.'\n        : 'Once medications are logged, cautions will show here.',\n      tone: avoidList.length ? 'warning' : 'neutral',\n    },\n  ]\n\n  return {\n    issue,\n    section: 'medications',\n    generatedAt: now,\n    confidence: 0.82,\n    summary,\n    highlights,\n    dataPoints: medications.slice(0, 6).map((med) => ({\n      label: med.name,\n      value: med.dosage || 'Dose not set',\n      context: med.timing?.length ? `Timing: ${med.timing.join(', ')}` : 'Add timing details',\n    })),\n    recommendations,\n    extras: {\n      supportiveDetails,\n      suggestedAdditions,\n      avoidList,\n      missingDose: medications.filter((med) => !med.dosage).map((med) => med.name),\n      missingTiming: medications.filter((med) => !med.timing || !med.timing.length).map((med) => med.name),\n      totalLogged: medications.length,\n      hasLogged: hasMedications,\n      hasRecentUpdates: hasRecentMedicationUpdates,\n      source: 'llm',\n      pipelineVersion: CURRENT_PIPELINE_VERSION,\n      validated,\n      degraded: !validated,\n    } as Record<string, unknown>,\n  }\n}\n\nasync function buildInteractionsSection(issue: IssueSummary, context: UserInsightContext): Promise<BaseSectionResult> {\n  const now = new Date().toISOString()\n  const supplementNames = context.supplements.map((supp) => supp.name)\n  const medicationNames = context.medications.map((med) => med.name)\n  const flags = INTERACTION_RULES.filter(rule => rule.condition({ supplements: supplementNames, medications: medicationNames }))\n  const highlights: SectionHighlight[] = []\n\n  if (flags.length) {\n    flags.forEach(flag => {\n      highlights.push({\n        title: flag.message,\n        detail: flag.rationale,\n        tone: 'warning',\n      })\n    })\n  } else if (!supplementNames.length && !medicationNames.length) {\n    highlights.push({\n      title: 'No data to cross-check yet',\n      detail: 'Add supplements and medications to evaluate interactions.',\n      tone: 'neutral',\n    })\n  } else {\n    highlights.push({\n      title: 'No conflicts detected',\n      detail: 'Current regimen shows no common spacing or interaction flags.',\n      tone: 'positive',\n    })\n  }\n\n  const recommendations: SectionRecommendation[] = []\n  if (flags.length) {\n    flags.forEach(flag => {\n      recommendations.push({\n        title: flag.message,\n        description: flag.rationale,\n        actions: ['Confirm timing with clinician', 'Update supplement log after any change'],\n        priority: flag.priority,\n      })\n    })\n  }\n  if (!recommendations.length) {\n    recommendations.push({\n      title: 'Keep regimen audit-ready',\n      description: 'Ensure medications and supplements remain up-to-date for safe AI insights.',\n      actions: ['Review list monthly', 'Log any new prescriptions within 24h'],\n      priority: 'monitor',\n    })\n  }\n\n  const dataPoints: SectionDatum[] = []\n  if (supplementNames.length) {\n    dataPoints.push({ label: 'Supplements logged', value: supplementNames.join(', ') })\n  }\n  if (medicationNames.length) {\n    dataPoints.push({ label: 'Medications logged', value: medicationNames.join(', ') })\n  }\n\n  return {\n    issue,\n    section: 'interactions',\n    generatedAt: now,\n    confidence: 0.65,\n    summary: flags.length ? `${flags.length} interaction flag${flags.length > 1 ? 's' : ''} found.` : 'No common conflicts detected.',\n    highlights,\n    dataPoints,\n    recommendations,\n  }\n}\n\nasync function buildLabsSection(\n  issue: IssueSummary,\n  context: UserInsightContext,\n  _options: { forceRefresh: boolean }\n): Promise<BaseSectionResult> {\n  const now = new Date().toISOString()\n  const blood = context.bloodResults\n\n  const labItems = (blood?.markers ?? []).map((marker) => ({\n    name: marker.name,\n    dosage: marker.value !== undefined ? `${marker.value}${marker.unit ? ` ${marker.unit}` : ''}` : null,\n    timing: marker.reference ? [marker.reference] : [],\n  }))\n\n  // CRITICAL: If user has no bloodwork data, return early with a clear message\n  // DO NOT generate content - this causes irrelevant environmental/energy content to appear\n  if (!labItems.length) {\n    return {\n      issue,\n      section: 'labs',\n      generatedAt: now,\n      confidence: 0.8,\n      summary: 'There is no labs or bloodwork currently in your health information data. Upload your blood test results in Health Setup to receive personalized lab insights and recommendations.',\n      highlights: [\n        {\n          title: 'Upload recent labs',\n          detail: 'Add PDFs or enter markers so we can track progress and flag gaps.',\n          tone: 'warning',\n        },\n      ],\n      dataPoints: [],\n      recommendations: [\n        {\n          title: 'Add your latest labs',\n          description: 'Upload lab PDFs or enter key markers so we can track trends for this issue.',\n          actions: ['Open Labs workspace', 'Upload PDF or enter markers manually'],\n          priority: 'now',\n        },\n      ],\n      extras: {\n        suggestedLabs: [],\n        avoidLabs: [],\n        source: 'empty',\n        pipelineVersion: CURRENT_PIPELINE_VERSION,\n        validated: false,\n        degraded: false,\n        cacheHit: false,\n      },\n    }\n  }\n\n  console.time(`[insights.llm] labs:${issue.slug}`)\n  let llmResult = await generateSectionInsightsFromLLM(\n    {\n      issueName: issue.name,\n      issueSummary: issue.highlight,\n      issueSlug: issue.slug,\n      items: labItems,\n      otherItems: context.supplements.map((supp) => ({ name: supp.name, dosage: supp.dosage ?? null })),\n      profile: context.profile,\n      userId: context.userId,\n      mode: 'labs',\n    },\n    { minWorking: labItems.length > 0 ? 1 : 0, minSuggested: 4, minAvoid: 4, disableCache: _options.forceRefresh }\n  )\n  console.timeEnd(`[insights.llm] labs:${issue.slug}`)\n\n  if (!llmResult) {\n    const degraded = await generateDegradedSection(\n      {\n        issueName: issue.name,\n        issueSummary: issue.highlight,\n        issueSlug: issue.slug,\n        items: labItems,\n        otherItems: context.supplements.map((supp) => ({ name: supp.name, dosage: supp.dosage ?? null })),\n        profile: context.profile,\n        userId: context.userId,\n        mode: 'labs',\n      },\n      { minSuggested: 4, minAvoid: 4 }\n    )\n    if (degraded) llmResult = degraded\n  }\n\n  if (!llmResult) {\n    return {\n      issue,\n      section: 'labs',\n      generatedAt: now,\n      confidence: 0.4,\n      summary: 'We couldn‚Äôt generate lab guidance right now. Please try again shortly.',\n      highlights: [\n        {\n          title: 'Generation unavailable',\n          detail: 'The AI service did not return lab insights. Retry in a few minutes.',\n          tone: 'warning',\n        },\n      ],\n      dataPoints: labItems.map((item) => ({\n        label: item.name,\n        value: item.dosage ?? 'Value not supplied',\n        context: item.timing?.[0],\n      })),\n      recommendations: [\n        {\n          title: 'Retry insight generation',\n          description: 'Refresh this page or trigger a new report in a few minutes.',\n          actions: ['Tap Daily/Weekly report to regenerate', 'Contact support if the problem persists'],\n          priority: 'soon',\n        },\n      ],\n    }\n  }\n\n  const workingLabs = llmResult.working.map((item) => ({\n    name: item.name,\n    reason: item.reason,\n    detail: item.dosage ?? item.timing ?? '',\n  }))\n\n  const suggestedLabs = llmResult.suggested.map((item) => ({\n    name: item.name,\n    reason: item.reason,\n    detail: item.protocol ?? null,\n  }))\n\n  const avoidLabs = llmResult.avoid.map((item) => ({\n    name: item.name,\n    reason: item.reason,\n  }))\n\n  const validated = suggestedLabs.length >= 4 && avoidLabs.length >= 4\n\n  let summary: string\n  if (llmResult.summary?.trim().length) {\n    summary = llmResult.summary\n  } else if (!labItems.length) {\n    summary = 'No lab markers are logged yet‚Äîuse the suggestions below to decide which tests to order next.'\n  } else {\n    summary = 'AI-generated lab guidance ready below.'\n  }\n\n  const highlights: SectionHighlight[] = [\n    {\n      title: 'Labs on track',\n      detail: workingLabs.length\n        ? workingLabs.map((lab) => `${lab.name}: ${lab.reason}`).join('; ')\n        : 'No supportive labs identified yet.',\n      tone: workingLabs.length ? 'positive' : 'neutral',\n    },\n    {\n      title: 'Labs to order or adjust',\n      detail: suggestedLabs.length\n        ? suggestedLabs.map((lab) => `${lab.name}: ${lab.reason}`).join('; ')\n        : 'Review the suggestions below with your clinician.',\n      tone: suggestedLabs.length ? 'neutral' : 'positive',\n    },\n    {\n      title: 'Labs to monitor carefully',\n      detail: avoidLabs.length\n        ? avoidLabs.map((lab) => `${lab.name}: ${lab.reason}`).join('; ')\n        : 'No avoid items flagged‚Äîsee cautions below for awareness.',\n      tone: avoidLabs.length ? 'warning' : 'neutral',\n    },\n  ]\n\n  if (!labItems.length) {\n    highlights.unshift({\n      title: 'Upload recent labs',\n      detail: 'Add PDFs or enter markers so we can track progress and flag gaps.',\n      tone: 'warning',\n    })\n  }\n\n  const recommendations: SectionRecommendation[] = llmResult.recommendations.length\n    ? llmResult.recommendations.map((rec) => ({\n        title: rec.title,\n        description: rec.description,\n        actions: rec.actions.length ? rec.actions : ['Discuss with your clinician'],\n        priority: rec.priority,\n      }))\n    : labItems.length\n    ? [\n        {\n          title: 'Coordinate lab follow-up',\n          description: 'Use the suggested labs to plan your next panel.',\n          actions: ['Schedule tests with your clinician', 'Log results once available'],\n          priority: 'soon',\n        },\n      ]\n    : [\n        {\n          title: 'Add your latest labs',\n          description: 'Upload lab PDFs or enter key markers so we can track trends for this issue.',\n          actions: ['Open Labs workspace', 'Upload PDF or enter markers manually'],\n          priority: 'now',\n        },\n      ]\n\n  const dataPoints: SectionDatum[] = labItems.map((item) => ({\n    label: item.name,\n    value: item.dosage ?? 'Value not supplied',\n    context: item.timing?.[0],\n  }))\n\n  return {\n    issue,\n    section: 'labs',\n    generatedAt: now,\n    confidence: 0.8,\n    summary,\n    highlights,\n    dataPoints,\n    recommendations,\n    extras: {\n      workingLabs,\n      suggestedLabs,\n      avoidLabs,\n      hasLoggedLabs: labItems.length > 0,\n      source: 'llm',\n      pipelineVersion: CURRENT_PIPELINE_VERSION,\n      validated,\n      degraded: !validated,\n    },\n  }\n}\n\nasync function buildNutritionSection(\n  issue: IssueSummary,\n  context: UserInsightContext,\n  _options: { forceRefresh: boolean }\n): Promise<BaseSectionResult> {\n  const now = new Date().toISOString()\n  const foods: Array<{ name?: string; meal?: string; calories?: number }> = context.todaysFoods.length\n    ? context.todaysFoods\n    : context.foodLogs.slice(0, 10).map((log) => ({\n        name: log.name,\n        meal: log.description ?? undefined,\n        calories: undefined,\n      }))\n\n  const hasRecentFoodData = hasRecentFoodLogs(context.foodLogs) || Boolean(context.todaysFoods.length)\n  const hasLoggedFoods = foods.length > 0\n\n  const normalizedFoods = foods.map((food, idx) => ({\n    name: food.name || food.meal || `Entry ${idx + 1}`,\n    dosage: food.calories ? `${food.calories} kcal` : food.meal ?? null,\n    timing: food.meal ? [food.meal] : [],\n  }))\n\n  const nonFoodNameSet = new Set(\n    [\n      ...context.supplements.map((supp) => canonical(supp.name)),\n      ...context.medications.map((med) => canonical(med.name)),\n    ]\n  )\n\n  console.time(`[insights.llm] nutrition:${issue.slug}`)\n  let llmResult = await generateSectionInsightsFromLLM(\n    {\n      issueName: issue.name,\n      issueSummary: issue.highlight,\n      issueSlug: issue.slug,\n      items: normalizedFoods,\n      otherItems: context.supplements.map((supp) => ({ name: supp.name, dosage: supp.dosage ?? null })),\n      profile: context.profile,\n      userId: context.userId,\n      mode: 'nutrition',\n    },\n    { minWorking: hasLoggedFoods ? 1 : 0, minSuggested: 4, minAvoid: 4, disableCache: _options.forceRefresh }\n  )\n  console.timeEnd(`[insights.llm] nutrition:${issue.slug}`)\n\n  if (!llmResult) {\n    const degraded = await generateDegradedSection(\n      {\n        issueName: issue.name,\n        issueSummary: issue.highlight,\n        issueSlug: issue.slug,\n        items: normalizedFoods,\n        otherItems: context.supplements.map((supp) => ({ name: supp.name, dosage: supp.dosage ?? null })),\n        profile: context.profile,\n        userId: context.userId,\n        mode: 'nutrition',\n      },\n      { minSuggested: 4, minAvoid: 4 }\n    )\n    if (degraded) llmResult = degraded\n  }\n\n  if (!llmResult) {\n    return {\n      issue,\n      section: 'nutrition',\n      generatedAt: now,\n      confidence: 0.4,\n      summary: 'We couldn‚Äôt generate nutrition guidance right now. Please try again shortly.',\n      highlights: [\n        {\n          title: 'Generation unavailable',\n          detail: 'The AI service did not return nutrition insights. Retry in a few minutes.',\n          tone: 'warning',\n        },\n      ],\n      dataPoints: foods.map((item, idx) => ({\n        label: item.meal ? `${item.meal}` : `Meal ${idx + 1}`,\n        value: item.name ?? 'Food logged',\n        context: item.calories ? `${item.calories} kcal` : undefined,\n      })),\n      recommendations: [\n        {\n          title: 'Retry insight generation',\n          description: 'Refresh this page or trigger a new report in a few minutes.',\n          actions: ['Tap Daily/Weekly report to regenerate', 'Contact support if the problem persists'],\n          priority: 'soon',\n        },\n      ],\n      extras: {\n        workingFocus: [],\n        suggestedFocus: [],\n        avoidFoods: [],\n        totalLogged: foods.length,\n        source: 'llm-error',\n      },\n    }\n  }\n\n  const allowFoodName = (name: string, reason: string) => {\n    const nameKey = canonical(name)\n    if (nonFoodNameSet.has(nameKey)) return false\n    if (looksSupplementLike(name) || looksSupplementLike(reason)) return false\n    if (looksFoodLike(name)) return true\n    return name.split(' ').length >= 1 && !looksSupplementLike(name)\n  }\n\n  const foodNameSet = new Set(normalizedFoods.map((f) => canonical(f.name)))\n  let workingFocus = llmResult.working\n    .map((item) => ({\n      title: item.name,\n      reason: item.reason,\n      example: item.dosage ?? item.timing ?? '',\n    }))\n    // Only show foods the user actually logged as \"working\".\n    .filter((item) => allowFoodName(item.title, item.reason) && foodNameSet.has(canonical(item.title)))\n\n  // AI-based fallback: if LLM didn't properly match logged foods, evaluate them directly\n  if (workingFocus.length === 0 && normalizedFoods.length > 0 && hasLoggedFoods) {\n    console.log(`[nutrition] LLM didn't match logged foods, using AI evaluator fallback for ${normalizedFoods.length} items`)\n    const evaluated = await evaluateFocusItemsForIssue({\n      issueName: issue.name,\n      issueSummary: issue.highlight,\n      mode: 'nutrition',\n      focusItems: normalizedFoods,\n    })\n    if (evaluated && evaluated.length > 0) {\n      // Map evaluated results to exact logged food names\n      for (const item of evaluated) {\n        const nameKey = canonical(item.name)\n        if (!allowFoodName(item.name, item.reason)) continue\n        if (foodNameSet.has(nameKey)) {\n          const logged = normalizedFoods.find((f) => canonical(f.name) === nameKey)\n          if (logged) {\n            workingFocus.push({\n              title: logged.name, // Use exact logged name\n              reason: item.reason,\n              example: item.dosage ?? item.timing ?? logged.dosage ?? '',\n            })\n          }\n        }\n      }\n      console.log(`[nutrition] AI evaluator found ${workingFocus.length} supportive foods`)\n    }\n  }\n\n  // AI-based augmentation: evaluate any remaining logged foods not yet included\n  if (normalizedFoods.length > 0 && hasLoggedFoods) {\n    const present = new Set(workingFocus.map((w) => canonical(w.title)))\n    const missing = normalizedFoods.filter((f) => !present.has(canonical(f.name)))\n    if (missing.length > 0) {\n      console.log(`[nutrition] Evaluating ${missing.length} missing logged foods for potential support`)\n      const evaluatedMissing = await evaluateFocusItemsForIssue({\n        issueName: issue.name,\n        issueSummary: issue.highlight,\n        mode: 'nutrition',\n        focusItems: missing,\n      })\n      if (evaluatedMissing && evaluatedMissing.length > 0) {\n        for (const item of evaluatedMissing) {\n          const key = canonical(item.name)\n          if (present.has(key)) continue\n          if (!allowFoodName(item.name, item.reason)) continue\n          const logged = normalizedFoods.find((f) => canonical(f.name) === key)\n          if (!logged) continue\n          workingFocus.push({\n            title: logged.name,\n            reason: item.reason,\n            example: item.dosage ?? item.timing ?? logged.dosage ?? '',\n          })\n          present.add(key)\n        }\n        console.log(`[nutrition] Added ${workingFocus.length} total working foods after augmentation`)\n      }\n    }\n  }\n\n  const suggestedFocus = llmResult.suggested\n    .map((item) => ({ title: item.name, reason: item.reason, detail: item.protocol ?? null }))\n    .filter((item) => allowFoodName(item.title, item.reason))\n  let avoidFoods = llmResult.avoid\n    .map((item) => ({ name: item.name, reason: item.reason }))\n    .filter((item) => allowFoodName(item.name, item.reason))\n\n  // Deterministic top-ups to guarantee 4/4 after domain filtering\n  try {\n    const kbKey = pickKnowledgeKey(issue.name)\n    const kbBase = kbKey ? ISSUE_KNOWLEDGE_BASE[kbKey] : undefined\n    const kbNutrition = (kbBase?.nutritionFocus ?? [])\n      .map((n) => ({ title: n.title, reason: n.detail, detail: null as string | null }))\n    const kbAvoidFoods = (kbBase?.avoidFoods ?? [])\n      .map((n) => ({ name: n.title, reason: n.detail }))\n\n    // Only foods; ensure we keep any LLM items first, then top-up from KB\n    const fbSuggested = kbNutrition.filter((n) => allowFoodName(n.title, n.reason))\n    const fbAvoid = kbAvoidFoods.filter((n) => allowFoodName(n.name, n.reason))\n\n    const suggestedFocusTopped = ensureMin(suggestedFocus, fbSuggested, 4)\n    const avoidFoodsTopped = ensureMin(avoidFoods, fbAvoid, 4)\n\n    // Reassign to maintain references used below\n    ;(suggestedFocus as any) = suggestedFocusTopped\n    avoidFoods = avoidFoodsTopped\n  } catch {}\n\n  const validated = suggestedFocus.length >= 4 && avoidFoods.length >= 4\n\n  let summary: string\n  if (llmResult.summary?.trim().length) {\n    summary = llmResult.summary\n  } else if (!hasLoggedFoods) {\n    summary = 'No meals are logged yet‚Äîuse the suggested foods below to build your first grocery list.'\n  } else if (!hasRecentFoodData) {\n    summary = 'No recent food entries‚Äîlog today‚Äôs meals so we can track what is working while you try the suggestions below.'\n  } else if (!workingFocus.length && !suggestedFocus.length && !avoidFoods.length) {\n    summary = 'Current food logs do not show clear support for this issue. Consider logging fresh meals for better guidance.'\n  } else {\n    summary = 'AI-generated nutrition guidance ready below.'\n  }\n\n  const highlights: SectionHighlight[] = [\n    {\n      title: 'Nutrition wins',\n      detail: workingFocus.length\n        ? workingFocus.map((focus) => `${focus.title}: ${focus.reason}`).join('; ')\n        : hasLoggedFoods\n        ? 'None of the foods you are currently eating are clearly helping this issue.'\n        : 'Log meals so we can highlight what is already working.',\n      tone: workingFocus.length ? 'positive' : hasLoggedFoods ? 'neutral' : 'warning',\n    },\n    {\n      title: 'Add to your plan',\n      detail: suggestedFocus.length\n        ? suggestedFocus.map((focus) => `${focus.title}: ${focus.reason}`).join('; ')\n        : hasLoggedFoods\n        ? 'No new foods to suggest‚Äîlog additional meals or discuss options with a clinician.'\n        : 'Add meals to your diary so the AI can recommend supportive foods.',\n      tone: suggestedFocus.length ? 'neutral' : hasLoggedFoods ? 'neutral' : 'warning',\n    },\n    {\n      title: 'Foods to monitor',\n      detail: avoidFoods.length\n        ? avoidFoods.map((food) => `${food.name}: ${food.reason}`).join('; ')\n        : hasLoggedFoods\n        ? 'No foods flagged as problematic right now‚Äîkeep logging meals.'\n        : 'Problem foods will appear here once meals are logged.',\n      tone: avoidFoods.length ? 'warning' : hasLoggedFoods ? 'neutral' : 'warning',\n    },\n  ]\n\n  if (!hasLoggedFoods) {\n    highlights.unshift({\n      title: 'Log your meals',\n      detail: 'Record breakfast, lunch, dinner, and snacks so the AI can evaluate your baseline nutrition.',\n      tone: 'warning',\n    })\n  } else if (!hasRecentFoodData) {\n    highlights.unshift({\n      title: 'Update today‚Äôs meals',\n      detail: 'Fresh meal logs keep ‚ÄúWhat‚Äôs Working‚Äù accurate while you trial the suggested foods.',\n      tone: 'warning',\n    })\n  }\n\n  const recommendations: SectionRecommendation[] = llmResult.recommendations.length\n    ? llmResult.recommendations.map((rec) => ({\n        title: rec.title,\n        description: rec.description,\n        actions: rec.actions.length ? rec.actions : ['Discuss with your clinician or dietitian'],\n        priority: rec.priority,\n      }))\n    : hasLoggedFoods\n    ? [\n        {\n          title: 'Plan upcoming meals',\n          description: 'Use the suggested foods to balance your next grocery list.',\n          actions: ['Add suggested foods to your meal plan', 'Track symptom response weekly'],\n          priority: 'soon',\n        },\n      ]\n    : [\n        {\n          title: 'Start a food log',\n          description: 'Capture at least one full day of eating so the AI can track what is supporting this issue.',\n          actions: ['Open Food Diary', 'Log breakfast, lunch, dinner, and snacks'],\n          priority: 'now',\n        },\n      ]\n\n  // Preserve prior nutrition suggestions instead of overwriting.\n  // Read cached nutrition result (latest mode) and merge runs by timestamp.\n  let previousRuns: Array<{ generatedAt: string; suggestedFocus: typeof suggestedFocus; avoidFoods: typeof avoidFoods }> = []\n  try {\n    const cached = await readSectionCache(context.userId, issue.slug, 'nutrition', 'latest', encodeRange(undefined))\n    if (cached?.result?.extras) {\n      const extras = cached.result.extras as Record<string, unknown>\n      const cachedRuns = extras['suggestionRuns'] as typeof previousRuns | undefined\n      if (Array.isArray(cachedRuns) && cachedRuns.length) {\n        previousRuns = cachedRuns\n      } else {\n        // Seed from legacy fields if runs array not present\n        const legacySuggested = (extras['suggestedFocus'] as typeof suggestedFocus | undefined) ?? []\n        const legacyAvoid = (extras['avoidFoods'] as typeof avoidFoods | undefined) ?? []\n        if (legacySuggested.length || legacyAvoid.length) {\n          previousRuns = [\n            {\n              generatedAt: cached.result.generatedAt ?? new Date().toISOString(),\n              suggestedFocus: legacySuggested,\n              avoidFoods: legacyAvoid,\n            },\n          ]\n        }\n      }\n    }\n  } catch {\n    // Non-blocking: if cache read fails, we still return new run\n  }\n\n  const newRun = { generatedAt: now, suggestedFocus, avoidFoods }\n  const suggestionRuns = [newRun, ...previousRuns]\n  const flattenedSuggested = suggestionRuns.flatMap((r) => r.suggestedFocus)\n  const flattenedAvoid = suggestionRuns.flatMap((r) => r.avoidFoods)\n\n  return {\n    issue,\n    section: 'nutrition',\n    generatedAt: now,\n    confidence: 0.82,\n    summary,\n    highlights,\n    dataPoints: foods.map((item, idx) => ({\n      label: item.meal ? `${item.meal}` : `Meal ${idx + 1}`,\n      value: item.name ?? 'Food logged',\n      context: item.calories ? `${item.calories} kcal` : undefined,\n    })),\n    recommendations,\n    extras: {\n      workingFocus,\n      // Keep legacy flat arrays for backward compatibility\n      suggestedFocus: flattenedSuggested,\n      avoidFoods: flattenedAvoid,\n      // New: grouped runs with timestamps to avoid losing history\n      suggestionRuns,\n      totalLogged: foods.length,\n      hasLoggedFoods,\n      hasRecentFoodData,\n      source: 'llm',\n      pipelineVersion: CURRENT_PIPELINE_VERSION,\n      validated,\n      degraded: !validated,\n    },\n  }\n}\n\nasync function buildLifestyleSection(\n  issue: IssueSummary,\n  context: UserInsightContext,\n  _options: { forceRefresh: boolean }\n): Promise<BaseSectionResult> {\n  const now = new Date().toISOString()\n  const lifestyleItems: Array<{ name: string; dosage?: string | null; timing?: string[] | null }> = []\n\n  if (context.profile.exerciseFrequency) {\n    lifestyleItems.push({ name: 'Exercise frequency', dosage: context.profile.exerciseFrequency, timing: null })\n  }\n  if (context.profile.bodyType) {\n    lifestyleItems.push({ name: 'Body type', dosage: context.profile.bodyType, timing: null })\n  }\n  if (context.profile.gender) {\n    lifestyleItems.push({ name: 'Gender', dosage: context.profile.gender, timing: null })\n  }\n  if (context.profile.weight) {\n    lifestyleItems.push({ name: 'Weight', dosage: `${context.profile.weight} kg`, timing: null })\n  }\n  if (context.profile.height) {\n    lifestyleItems.push({ name: 'Height', dosage: `${context.profile.height} cm`, timing: null })\n  }\n\n  const hasLifestyleSignals = lifestyleItems.length > 0\n  console.time(`[insights.llm] lifestyle:${issue.slug}`)\n  let llmResult = await generateSectionInsightsFromLLM(\n    {\n      issueName: issue.name,\n      issueSummary: issue.highlight,\n      issueSlug: issue.slug,\n      items: lifestyleItems,\n      otherItems: context.supplements.map((supp) => ({ name: supp.name, dosage: supp.dosage ?? null })),\n      profile: context.profile,\n      userId: context.userId,\n      mode: 'lifestyle',\n    },\n    { minWorking: lifestyleItems.length > 0 ? 1 : 0, minSuggested: 4, minAvoid: 4, disableCache: _options.forceRefresh }\n  )\n  console.timeEnd(`[insights.llm] lifestyle:${issue.slug}`)\n\n  if (!llmResult) {\n    const degraded = await generateDegradedSection(\n      {\n        issueName: issue.name,\n        issueSummary: issue.highlight,\n        issueSlug: issue.slug,\n        items: lifestyleItems,\n        otherItems: context.supplements.map((supp) => ({ name: supp.name, dosage: supp.dosage ?? null })),\n        profile: context.profile,\n        userId: context.userId,\n        mode: 'lifestyle',\n      },\n      { minSuggested: 4, minAvoid: 4 }\n    )\n    if (degraded) llmResult = degraded\n  }\n\n  if (!llmResult) {\n    return {\n      issue,\n      section: 'lifestyle',\n      generatedAt: now,\n      confidence: 0.4,\n      summary: 'We couldn‚Äôt generate lifestyle guidance right now. Please try again shortly.',\n      highlights: [\n        {\n          title: 'Generation unavailable',\n          detail: 'The AI service did not return lifestyle insights. Retry in a few minutes.',\n          tone: 'warning',\n        },\n      ],\n      dataPoints: [],\n      recommendations: [\n        {\n          title: 'Retry insight generation',\n          description: 'Refresh this page or trigger a new report in a few minutes.',\n          actions: ['Tap Daily/Weekly report to regenerate', 'Contact support if the problem persists'],\n          priority: 'soon',\n        },\n      ],\n      extras: {\n        workingHabits: [],\n        suggestedHabits: [],\n        avoidHabits: [],\n        source: 'llm-error',\n      },\n    }\n  }\n\n  // \"What's Working\" must only come from real logs; lifestyle has no logs ‚Üí keep empty\n  let workingHabits: Array<{ title: string; reason: string; detail: string }> = []\n\n  let suggestedHabits = llmResult.suggested.map((item) => ({\n    title: item.name,\n    reason: item.reason,\n    detail: item.protocol ?? null,\n  }))\n\n  let avoidHabits = llmResult.avoid.map((item) => ({\n    title: item.name,\n    reason: item.reason,\n  }))\n\n  // Deterministic top-ups from KB to guarantee 4/4 after filtering\n  try {\n    const kbKey = pickKnowledgeKey(issue.name)\n    const kbBase = kbKey ? ISSUE_KNOWLEDGE_BASE[kbKey] : undefined\n    const kbLifestyle = (kbBase?.lifestyleFocus ?? [])\n      .map((n) => ({ title: n.title, reason: n.detail, detail: null as string | null }))\n    // For lifestyle \"avoid\", use avoidExercises plus any avoidFoods phrased as habits\n    const kbAvoidFromExercises = (kbBase?.avoidExercises ?? []).map((n) => ({ title: n.title, reason: n.detail }))\n    const kbAvoidFromFoods = (kbBase?.avoidFoods ?? []).map((n) => ({ title: n.title, reason: n.detail }))\n\n    const suggestedHabitsTopped = ensureMin(suggestedHabits, kbLifestyle, 4)\n    const avoidHabitsTopped = ensureMin(avoidHabits, [...kbAvoidFromExercises, ...kbAvoidFromFoods], 4)\n\n    ;(suggestedHabits as any) = suggestedHabitsTopped\n    avoidHabits = avoidHabitsTopped\n  } catch {}\n\n  const validated = suggestedHabits.length >= 4 && avoidHabits.length >= 4\n\n  let summary: string\n  if (llmResult.summary?.trim().length) {\n    summary = llmResult.summary\n  } else if (!hasLifestyleSignals) {\n    summary = 'No lifestyle data is logged yet‚Äîcomplete your profile so we can track sleep, stress, and routines while you trial the suggestions below.'\n  } else {\n    summary = 'AI-generated lifestyle coaching ready below.'\n  }\n\n  const highlights: SectionHighlight[] = [\n    {\n      title: 'Lifestyle foundations',\n      detail: workingHabits.length\n        ? workingHabits.map((habit) => `${habit.title}: ${habit.reason}`).join('; ')\n        : 'No lifestyle habits flagged as supportive yet.',\n      tone: workingHabits.length ? 'positive' : hasLifestyleSignals ? 'neutral' : 'warning',\n    },\n    {\n      title: 'Habits to add',\n      detail: suggestedHabits.length\n        ? suggestedHabits.map((habit) => `${habit.title}: ${habit.reason}`).join('; ')\n        : 'Review the suggested habits below to evolve your plan.',\n      tone: suggestedHabits.length ? 'neutral' : 'positive',\n    },\n    {\n      title: 'Habits to avoid',\n      detail: avoidHabits.length\n        ? avoidHabits.map((habit) => `${habit.title}: ${habit.reason}`).join('; ')\n        : 'No avoid items flagged‚Äîsee cautions below for awareness.',\n      tone: avoidHabits.length ? 'warning' : 'neutral',\n    },\n  ]\n\n  if (!hasLifestyleSignals) {\n    highlights.unshift({\n      title: 'Complete lifestyle profile',\n      detail: 'Add sleep, stress, and exercise frequency details so we can track habit wins over time.',\n      tone: 'warning',\n    })\n  }\n\n  const recommendations: SectionRecommendation[] = llmResult.recommendations.length\n    ? llmResult.recommendations.map((rec) => ({\n        title: rec.title,\n        description: rec.description,\n        actions: rec.actions.length ? rec.actions : ['Discuss with your clinician or coach'],\n        priority: rec.priority,\n      }))\n    : hasLifestyleSignals\n    ? [\n        {\n          title: 'Plan daily routine updates',\n          description: 'Use the suggested habits to refine your schedule.',\n          actions: ['Add habits to your calendar', 'Track adherence for 14 days'],\n          priority: 'soon',\n        },\n      ]\n    : [\n        {\n          title: 'Complete lifestyle profile',\n          description: 'Add sleep, stress, and routine details so the AI can track habit wins and risks.',\n          actions: ['Open Profile ‚Üí Lifestyle', 'Log bedtime, wake time, and stress routines'],\n          priority: 'now',\n        },\n      ]\n\n  return {\n    issue,\n    section: 'lifestyle',\n    generatedAt: now,\n    confidence: 0.8,\n    summary,\n    highlights,\n    dataPoints: [],\n    recommendations,\n    extras: {\n      workingHabits,\n      suggestedHabits,\n      avoidHabits,\n      hasLifestyleSignals,\n      source: 'llm',\n      pipelineVersion: CURRENT_PIPELINE_VERSION,\n      validated,\n      degraded: !validated,\n    },\n  }\n}\n","truncated":false,"size":203182},{"path":"lib/insights/llm.ts","content":"import { z } from 'zod'\nimport { runChatCompletionWithLogging } from '../ai-usage-logger'\nimport { getRunContext } from '../run-context'\n\nconst CACHE_TTL_MS = 1000 * 60 * 30\nconst INSIGHTS_LLM_ENABLED = (() => {\n  const raw = (process.env.ENABLE_INSIGHTS_LLM || '').toLowerCase().trim()\n  return raw === 'true' || raw === '1' || raw === 'yes'\n})()\n\nconst insightCache = new Map<\n  string,\n  { expiresAt: number; result: SectionLLMResult }\n>()\n\n// Lazy import to avoid bundling OpenAI client when not configured\nlet _openai: any = null\n\nfunction getOpenAIClient() {\n  if (!INSIGHTS_LLM_ENABLED) {\n    console.warn('[insights.llm] LLM disabled via ENABLE_INSIGHTS_LLM flag')\n    return null\n  }\n  if (_openai) return _openai\n  const apiKey = process.env.OPENAI_API_KEY\n  if (!apiKey) {\n    console.warn('[insights.llm] Missing OPENAI_API_KEY; LLM calls will be skipped')\n    return null\n  }\n\n  const OpenAI = require('openai').default\n  _openai = new OpenAI({ apiKey })\n  return _openai\n}\n\nexport function getInsightsLlmStatus() {\n  const raw = (process.env.ENABLE_INSIGHTS_LLM || '').toLowerCase().trim()\n  const enabled = raw === 'true' || raw === '1' || raw === 'yes'\n  const apiKeyPresent = typeof process.env.OPENAI_API_KEY === 'string' && process.env.OPENAI_API_KEY.trim().length > 0\n  return {\n    enabled,\n    apiKeyPresent,\n    model: DEFAULT_INSIGHTS_MODEL,\n  }\n}\n\nfunction logLlmEvent(reason: string, extra: Record<string, unknown> = {}) {\n  const ctx = getRunContext()\n  const meta = ctx?.meta\n  const payload = {\n    runId: ctx?.runId ?? null,\n    feature: ctx?.feature ?? 'insights:unknown',\n    userId: meta?.userId ?? extra.userId ?? null,\n    changeTypes: meta?.changeTypes,\n    sections: meta?.sections,\n    phase: meta?.phase ?? 'full',\n    ...extra,\n  }\n  console.log('[insights.llm]', reason, payload)\n}\n\nasync function createCompletion(\n  params: any,\n  context: { feature: string; userId?: string | null; issueSlug?: string | null; runId?: string | null } = {\n    feature: 'insights:unknown',\n  }\n) {\n  const openai = getOpenAIClient()\n  const runCtx = getRunContext()\n  const runId = runCtx?.runId ?? null\n  if (!openai) {\n    logLlmEvent('skipped:llm-unavailable', {\n      userId: context.userId ?? runCtx?.meta?.userId ?? null,\n      issueSlug: context.issueSlug ?? null,\n      reason: 'missing-openai-or-flag-disabled',\n    })\n    return null\n  }\n\n  logLlmEvent('llm-call:start', {\n    userId: context.userId ?? runCtx?.meta?.userId ?? null,\n    issueSlug: context.issueSlug ?? null,\n    model: params?.model,\n  })\n  return runChatCompletionWithLogging(\n    openai,\n    params,\n    { ...context, runId },\n    { callDetail: `${context.feature || 'insights:unknown'}:${params?.model || ''}` }\n  )\n}\n\nconst DEFAULT_INSIGHTS_MODEL = process.env.OPENAI_INSIGHTS_MODEL ?? 'gpt-4o-mini'\n\nconst llmSectionSchema = z.object({\n  summary: z.string().optional(),\n  working: z\n    .array(\n      z.object({\n        name: z.string(),\n        reason: z.string().min(1),\n        dosage: z.string().optional().nullable(),\n        timing: z.string().optional().nullable(),\n      })\n    )\n    .default([]),\n  suggested: z\n    .array(\n      z.object({\n        name: z.string(),\n        reason: z.string().min(1),\n        protocol: z.string().optional().nullable(),\n      })\n    )\n    .default([]),\n  avoid: z\n    .array(\n      z.object({\n        name: z.string(),\n        reason: z.string().min(1),\n      })\n    )\n    .default([]),\n  recommendations: z\n    .array(\n      z.object({\n        title: z.string(),\n        description: z.string(),\n        actions: z.array(z.string()).default([]),\n        priority: z.enum(['now', 'soon', 'monitor']).default('monitor'),\n      })\n    )\n    .default([]),\n})\n\nexport type SectionLLMResult = z.infer<typeof llmSectionSchema>\n\ntype SectionMode =\n  | 'supplements'\n  | 'medications'\n  | 'exercise'\n  | 'nutrition'\n  | 'lifestyle'\n  | 'labs'\n\ninterface LLMInputData {\n  issueName: string\n  issueSummary?: string | null\n  issueSlug?: string | null\n  items?: Array<{ name: string; dosage?: string | null; timing?: string[] | null }>\n  otherItems?: Array<{ name: string; dosage?: string | null }>\n  profile?: {\n    gender?: string | null\n    weight?: number | null\n    height?: number | null\n    bodyType?: string | null\n    exerciseFrequency?: string | null\n    exerciseTypes?: string[] | null\n  }\n  userId?: string | null\n  mode: SectionMode\n}\n\ninterface LLMOptions {\n  minWorking?: number\n  minSuggested?: number\n  minAvoid?: number\n  maxRetries?: number\n  disableCache?: boolean\n}\n\ntype CanonicalType = 'food' | 'supplement' | 'exercise' | 'medication' | 'other'\n\ninterface ClassificationEntry {\n  name: string\n  reason?: string | null\n}\n\ninterface ClassifiedItem {\n  name: string\n  canonicalType: CanonicalType\n  inDomain: boolean\n  explanation?: string\n}\n\nexport interface GeneratedCandidateItem {\n  name: string\n  candidateType: CanonicalType\n  bucket: 'suggested' | 'avoid'\n  reason: string\n  protocol?: string | null\n}\n\nexport async function generateSectionCandidates(params: {\n  issueName: string\n  issueSummary?: string | null\n  profile?: LLMInputData['profile']\n  mode: SectionMode\n  count?: { suggested?: number; avoid?: number }\n  userId?: string | null\n  issueSlug?: string | null\n}): Promise<GeneratedCandidateItem[] | null> {\n  const openai = getOpenAIClient()\n  if (!openai) return null\n  const suggested = Math.max(4, params.count?.suggested ?? 6)\n  const avoid = Math.max(4, params.count?.avoid ?? 6)\n  \n  // Add exercise-specific guidance for intake exerciseTypes\n  const exerciseGuidance = params.mode === 'exercise' && params.profile?.exerciseTypes?.length\n    ? `\\n\\nCRITICAL FOR EXERCISE MODE: The user has selected these exercise types in their health intake: ${JSON.stringify(params.profile.exerciseTypes)}. Evaluate each exercise against \"${params.issueName}\" - if supportive, consider including them in suggested (they will be promoted to working if they match intake selections).`\n    : ''\n  \n    const user = `Write SECTION: ${params.mode} for issue \"${params.issueName}\".\nGenerate only two arrays: suggested and avoid. Each item must include: name, candidateType guess ‚àà {food,supplement,exercise,medication,other}, reason (two sentences: mechanism + direct relevance), and optional protocol.\nCounts: suggested‚â•${suggested}, avoid‚â•${avoid}.\nProfile: ${JSON.stringify(params.profile ?? {}, null, 2)}${exerciseGuidance}\nReturn strict JSON {\"suggested\": [...], \"avoid\": [...]}`\n  try {\n    console.time(`[insights.genCandidates:${params.mode}]`)\n    const response: any = await createCompletion({\n      model: DEFAULT_INSIGHTS_MODEL,\n      temperature: 0.2,\n      max_tokens: 700,\n      response_format: { type: 'json_object' },\n      messages: [\n        { role: 'system', content: 'You propose domain-appropriate items with concise clinical reasons. Output JSON only.' },\n        { role: 'user', content: user },\n      ],\n    }, { feature: `insights:generate-section-candidates:${params.mode}`, userId: params.userId, issueSlug: params.issueSlug ?? null })\n    console.timeEnd(`[insights.genCandidates:${params.mode}]`)\n    const content = response.choices?.[0]?.message?.content\n    if (!content) return null\n    let json: any\n    try {\n      json = JSON.parse(content)\n    } catch {\n      const stripped = content.replace(/```[a-zA-Z]*\\n?|```/g, '').trim()\n      const objMatch = stripped.match(/\\{[\\s\\S]*\\}/)\n      if (!objMatch) return null\n      json = JSON.parse(objMatch[0])\n    }\n    const all: GeneratedCandidateItem[] = []\n    const pushItems = (arr: any[], bucket: 'suggested' | 'avoid') => {\n      for (const it of Array.isArray(arr) ? arr : []) {\n        if (!it || typeof it.name !== 'string' || typeof it.reason !== 'string') continue\n        const ct = typeof it.candidateType === 'string' ? String(it.candidateType).toLowerCase() : 'other'\n        const canonicalType: CanonicalType =\n          ct === 'food' || ct === 'supplement' || ct === 'exercise' || ct === 'medication' ? (ct as CanonicalType) : 'other'\n        all.push({\n          name: it.name,\n          candidateType: canonicalType,\n          bucket,\n          reason: it.reason,\n          protocol: typeof it.protocol === 'string' ? it.protocol : null,\n        })\n      }\n    }\n    pushItems(json?.suggested, 'suggested')\n    pushItems(json?.avoid, 'avoid')\n    return all\n  } catch (error) {\n    console.warn('[insights.llm] generateSectionCandidates error', error)\n    return null\n  }\n}\n\nfunction allowedCanonicalTypesForMode(mode: SectionMode): Set<CanonicalType> | null {\n  switch (mode) {\n    case 'nutrition':\n      return new Set<CanonicalType>(['food'])\n    case 'exercise':\n      return new Set<CanonicalType>(['exercise'])\n    case 'supplements':\n      return new Set<CanonicalType>(['supplement'])\n    case 'medications':\n      return new Set<CanonicalType>(['medication'])\n    default:\n      return null // no strict filtering for lifestyle/labs\n  }\n}\n\nfunction meetsMinimums(\n  data: SectionLLMResult,\n  { minWorking, minSuggested, minAvoid }: { minWorking: number; minSuggested: number; minAvoid: number }\n) {\n  const workingOk = minWorking === 0 || data.working.length >= minWorking\n  const suggestedOk = data.suggested.length >= minSuggested\n  const avoidOk = data.avoid.length >= minAvoid\n  return workingOk && suggestedOk && avoidOk\n}\n\nfunction scoreCandidate(data: SectionLLMResult) {\n  // Weight suggested/avoid slightly higher because they matter most for actionability.\n  return data.working.length * 2 + data.suggested.length * 3 + data.avoid.length * 3 + data.recommendations.length\n}\n\ninterface RepairArgs {\n  mode: SectionMode\n  issueName: string\n  issueSummary?: string | null\n  minWorking: number\n  minSuggested: number\n  minAvoid: number\n  focusItems: Array<{ name: string; dosage?: string | null; timing?: string[] | null }>\n  otherItems: Array<{ name: string; dosage?: string | null }>\n  profile?: LLMInputData['profile']\n  previous: SectionLLMResult\n}\n\nasync function repairLLMOutput({\n  mode,\n  issueName,\n  issueSummary,\n  minWorking,\n  minSuggested,\n  minAvoid,\n  focusItems,\n  otherItems,\n  profile,\n  previous,\n}: RepairArgs): Promise<SectionLLMResult | null> {\n  try {\n    const repairPrompt = `\nYou produced the following JSON guidance for \"${issueName}\" but it failed minimum coverage requirements. Revise it so every bucket meets the minimum counts.\n\nPrevious JSON:\n${JSON.stringify(previous, null, 2)}\n\nContext (focus items, other items, profile):\n${JSON.stringify({ focusItems, otherItems, profile: profile ?? {} }, null, 2)}\n\nMode guidance:\n${modeGuidance(mode)}\n\nIssue summary:\n${issueSummary ?? 'Not supplied.'}\n\nRequirements:\n- Suggested must contain at least ${minSuggested} unique items (not in focusItems unless altering protocol).\n- Avoid must contain at least ${minAvoid} items relevant to ${issueName}.\n- ${minWorking === 0 ? 'Working can remain empty if no focusItems support the issue, but explain why in the summary.' : `Working must contain at least ${minWorking} logged items when appropriate.`}\n- Every reason must be two sentences: first sentence = mechanism; second sentence = direct relevance/action (include dose/timing when useful).\n- Keep strictly to the JSON schema used previously (no additional keys).\n- If data is sparse, rely on best-practice clinician guidance for ${issueName}; do not fabricate patient-specific logs.\n`\n\n    const response: any = await createCompletion({\n      model: DEFAULT_INSIGHTS_MODEL,\n      temperature: 0.05,\n      max_tokens: 600,\n      response_format: { type: 'json_object' },\n      messages: [\n        {\n          role: 'system',\n          content:\n            'You are a careful clinical decision support assistant. Adjust prior guidance to meet explicit minimum requirements without omitting important safety details.',\n        },\n        {\n          role: 'user',\n          content: repairPrompt,\n        },\n      ],\n    }, { feature: `insights:repair:${mode}` })\n    const content = response.choices?.[0]?.message?.content\n    if (!content) return null\n\n    let json: unknown\n    try {\n      json = JSON.parse(content)\n    } catch {\n      const stripped = content.replace(/```[a-zA-Z]*\\n?|```/g, '').trim()\n      const objMatch = stripped.match(/\\{[\\s\\S]*\\}/)\n      if (!objMatch) {\n        console.warn('[insights.llm] Repair pass failed to locate JSON object', { content })\n        return null\n      }\n      try {\n        json = JSON.parse(objMatch[0])\n      } catch (parseError) {\n        console.warn('[insights.llm] Repair pass JSON parse failed', { content })\n        return null\n      }\n    }\n\n    const parsed = llmSectionSchema.safeParse(json)\n    if (!parsed.success) {\n      console.warn('[insights.llm] Repair pass produced invalid JSON', { issues: parsed.error.issues, content })\n      return null\n    }\n    return parsed.data\n  } catch (error) {\n    console.error('[insights.llm] Repair pass failed', error)\n    return null\n  }\n}\n\nfunction modeGuidance(mode: SectionMode) {\n  switch (mode) {\n    case 'supplements':\n      return 'Evaluate supplements only (herbs, vitamins, nutraceuticals). CRITICAL: You MUST analyze each logged supplement in focusItems by understanding its active ingredient(s) and mechanism of action. For brand-name supplements (e.g., \"Super Miraforte\", \"Life Extension products\"), you MUST research or recognize the product formulation and analyze it by its key ingredients. For example, if a user logs \"Sunfiber\", recognize it contains partially hydrolyzed guar gum (PHGG) and evaluate its impact on the issue. If a user logs a testosterone/libido supplement (e.g., products marketed for \"men\\'s health\", \"testosterone support\", \"libido\"), analyze it by its key ingredients (zinc, chrysin, muira puama, maca, stinging nettle, lignans, etc.) and include it in \"working\" if those ingredients are supportive for the issue. However, ALWAYS output the exact logged name from focusItems (e.g., \"Super Miraforte\", not \"Zinc\" or \"Muira Puama\"). Identify which logged supplements are truly helpful for the issue, which novel additions to discuss with a clinician, and which supplements people with this issue should avoid or monitor. Never include alcohol, foods, or lifestyle items in this section.'\n    case 'medications':\n      return 'Evaluate prescription and OTC pharmaceutical therapies only (no supplements, herbs, nutraceuticals, or vitamins). CRITICAL: You MUST analyze each logged medication in focusItems by understanding its active ingredient(s), mechanism of action, and therapeutic class. For brand-name medications, recognize the generic/active ingredient but ALWAYS output the exact logged name from focusItems. Highlight medications that are supporting the issue, medication additions to discuss with a prescriber, and medications that warrant caution or avoidance.'\n    case 'exercise':\n      return 'Evaluate exercise and movement patterns. CRITICAL: You MUST check profile.exerciseTypes in the user context. If any exercises from profile.exerciseTypes are supportive for this issue, you MUST include them in the \"working\" bucket with a mechanism-based reason, even if no formal exercise logs exist. For logged exercises in focusItems, analyze their physiological effects and movement patterns. Highlight the training that supports this issue, recommended additions, and activities/protocols to limit or avoid. Always use the exact logged name from focusItems.'\n    case 'nutrition':\n      return 'Evaluate nutrition patterns using foods, meals, or dietary patterns only. Do not mention supplements or pills. CRITICAL: Analyze each logged food/meal in focusItems by understanding its macronutrient profile, micronutrients, and physiological effects. Recognize variations (e.g., \"Chicken breast\" vs \"Grilled chicken\") but ALWAYS output the exact logged name from focusItems. Highlight foods/meals that help, additions to include, and foods or dietary approaches to avoid for this issue. Only mark \"working\" foods that are present in focusItems.'\n    case 'lifestyle':\n      return 'Evaluate lifestyle habits (sleep, stress, routines). CRITICAL: Analyze each logged habit or pattern in focusItems by understanding its physiological and psychological mechanisms. Always use the exact logged name/description from focusItems. Highlight habits that are helping, habits to add, and habits/behaviours to avoid for this issue.'\n    case 'labs':\n      return `Evaluate labs and biomarker monitoring for PERSONAL HEALTH. CRITICAL: The issue name refers to a PERSONAL HEALTH CONDITION (e.g., \"Energy\" means personal energy/fatigue levels, NOT environmental energy efficiency). Analyze each logged lab result in focusItems by understanding what the biomarker measures and its relationship to the PERSONAL HEALTH issue. Always use the exact logged test name from focusItems. ONLY suggest health-related lab tests (blood tests, biomarkers, medical diagnostics). NEVER suggest environmental audits, energy efficiency tests, or any non-medical tests. Highlight labs already supporting the issue, labs to order or review, and labs/testing patterns that require caution.`\n    default:\n      return ''\n  }\n}\n\nfunction buildPrompt(\n  {\n    issueName,\n    issueSummary,\n    userContext,\n    mode,\n    minWorking,\n    minSuggested,\n    minAvoid,\n    force,\n  }: {\n    issueName: string\n    issueSummary?: string | null\n    userContext: string\n    mode: SectionMode\n    minWorking: number\n    minSuggested: number\n    minAvoid: number\n    force: boolean\n  }\n) {\n  const guidanceFocus = modeGuidance(mode)\n  // CRITICAL: Clarify that issue names refer to PERSONAL HEALTH, not environmental topics\n  const issueClarification = mode === 'labs' \n    ? `\\n\\n‚ö†Ô∏è CRITICAL CONTEXT: The issue \"${issueName}\" refers to a PERSONAL HEALTH CONDITION. For example:\\n- \"Energy\" means personal energy levels/fatigue, NOT environmental energy efficiency\\n- \"Sleep\" means personal sleep quality, NOT sleep systems or sleep technology\\n- \"Libido\" means personal sexual health, NOT libido in other contexts\\n\\nYou MUST ONLY generate health-related lab test recommendations (blood tests, biomarkers, medical diagnostics). NEVER suggest environmental audits, energy efficiency tests, sustainability assessments, or any non-medical tests.\\n\\n`\n    : ''\n  \n  const header = `You are a clinician-grade health assistant helping with the PERSONAL HEALTH issue \"${issueName}\".${issueClarification}`\n\n  // CRITICAL: Explicit instruction for exercise mode - must appear early in prompt\n  const exerciseTypesInstruction = mode === 'exercise'\n    ? `\n\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\nüö® EXERCISE MODE - CRITICAL INSTRUCTION: profile.exerciseTypes ‚Üí \"working\" ONLY üö®\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\nBEFORE generating your response, you MUST:\n\n1. Look at the user context JSON above\n2. Find the \"profile\" object ‚Üí locate the \"exerciseTypes\" array (e.g., [\"Walking\", \"Bike riding\", \"Boxing\"])\n3. For EVERY exercise in profile.exerciseTypes:\n   a) Evaluate: \"Is this exercise supportive for \"${issueName}\"?\"\n   b) If YES ‚Üí Add it to the \"working\" array (NOT suggested, NOT avoid - WORKING ONLY)\n   c) Use the EXACT name from profile.exerciseTypes (preserve capitalization exactly)\n   d) Provide a mechanism-based reason\n\nüö® CRITICAL RULE: Exercises from profile.exerciseTypes that are supportive MUST go in \"working\"\n   - DO NOT put them in \"suggested\" \n   - DO NOT put them in \"avoid\"\n   - They belong in \"working\" because the user has already selected them in their health intake\n\nEXAMPLE: If profile.exerciseTypes = [\"Walking\", \"Bike riding\", \"Boxing\"] and issue = \"Bowel Movements\":\n- Walking ‚Üí Supportive (digestive stimulation) ‚Üí MUST go in \"working\" array\n- Bike riding ‚Üí Evaluate ‚Üí If supportive, MUST go in \"working\" array\n- Boxing ‚Üí Evaluate ‚Üí If supportive, MUST go in \"working\" array\n\nIf profile.exerciseTypes = [\"Walking\"] and issue = \"Libido\":\n- Walking ‚Üí Supportive (cardiovascular, stress reduction) ‚Üí MUST go in \"working\" array\n\nThe \"suggested\" array is ONLY for exercises NOT already in profile.exerciseTypes.\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n`\n    : ''\n\n  const baseGuidance = `\nProvide precise, evidence-aligned guidance. Use the user context plus widely accepted best practice. If data is insufficient, state that but still offer clinician-ready suggestions.\n\nCRITICAL: You MUST thoroughly analyze every item in focusItems (the user's logged items). For each item:\n- Understand what it is at a fundamental level (ingredients, active compounds, mechanisms, nutritional profile, physiological effects)\n- Evaluate how it impacts the current issue based on evidence-based mechanisms\n- If it supports the issue, include it in \"working\" with a mechanism-based reason and optional dose/timing\n- If it warrants caution for this issue, include it in \"avoid\" with a short clinical rationale\n- If it is neutral/irrelevant, you may omit it (do not put in suggested)\n- ALWAYS use the EXACT name from focusItems - never substitute with generic names, ingredient names, or alternative terminology\n\nSTRICT RULES:\n- Prioritise logged items: if a focusItem is plausibly supportive for the issue, include it in \"working\" using the exact name from focusItems and provide rationale.\n- Supplements mode: Analyze by active ingredient(s) but output exact logged name. Only include supplements/herbs/nutraceuticals. Never include alcohol, foods, or lifestyle items in any bucket.\n- Medications mode: Analyze by active ingredient(s) and therapeutic class but output exact logged name (brand or generic as logged).\n- Nutrition mode: Analyze by nutritional profile and physiological effects but output exact logged name. Only mark foods as \"working\" if they appear in focusItems. Use suggested/avoid for novel foods.\n- Exercise mode: CRITICAL - You MUST check profile.exerciseTypes in the user context. If any exercises listed in profile.exerciseTypes are supportive for this issue, you MUST include them in the \"working\" bucket even if they don't appear in focusItems. Use the exact exercise name from profile.exerciseTypes and provide a mechanism-based reason explaining how it supports the issue. This is required when focusItems is empty or when intake exercises are relevant. For logged exercises, analyze physiological effects but use exact logged name.\n- Lifestyle mode: Analyze mechanisms but use exact logged habit/pattern name.\n- Labs mode: CRITICAL - ONLY generate health-related lab test recommendations (blood tests, biomarkers, medical diagnostics). The issue name refers to PERSONAL HEALTH (e.g., \"Energy\" = personal energy/fatigue, NOT environmental energy). NEVER suggest environmental audits, energy efficiency tests, or non-medical tests. Analyze biomarker significance but use exact logged test name.\n- Reasons must include mechanism + relevance; add dose/timing or execution guidance where appropriate.\n- If focusItems is empty but profile.exerciseTypes contains supportive exercises, those exercises MUST appear in \"working\" - do not leave working empty.\n- Even if user data is sparse, you MUST still populate \"suggested\" and \"avoid\" to the minimum counts using widely accepted best practice for ${issueName}. Never respond with \"everything covered.\"\n\nClassify findings into three buckets: working (helpful/supportive today), suggested (worth discussing with clinician to add), avoid (risky or counterproductive). Always provide detailed clinical reasons (two sentences: mechanism + direct issue relevance/action). ${guidanceFocus}\nEnsure the suggested array contains at least ${minSuggested} unique entries that are not already in the focusItems list, and avoid duplicating any names from focusItems unless you are recommending a changed protocol. Provide concise but specific reasons (mechanism + relevance) and include dosing/timing where appropriate.\n\nReturn JSON exactly matching this schema (no extra keys, no missing keys, do not rename fields):\n{\n  \"summary\": string,\n  \"working\": Array<{\"name\": string, \"reason\": string, \"dosage\"?: string | null, \"timing\"?: string | null}>,\n  \"suggested\": Array<{\"name\": string, \"reason\": string, \"protocol\"?: string | null}>,\n  \"avoid\": Array<{\"name\": string, \"reason\": string}>,\n  \"recommendations\": Array<{\"title\": string, \"description\": string, \"actions\": string[], \"priority\": \"now\" | \"soon\" | \"monitor\"}>\n}\nAll strings must be non-empty and plain text. Use null when optional fields are unknown. Do not include title/description keys inside working/suggested/avoid items‚Äîuse name/reason exactly. Suggestions must be novel relative to the focusItems and otherItems lists (case-insensitive) unless you are recommending a changed protocol.\nClose every array/object and ensure the JSON is syntactically valid‚Äînever truncate or omit closing braces.\n  `\n\n  const forceNote = force\n    ? `You must output at least ${minWorking} working item(s)${minWorking === 0 ? ' (it is acceptable for working to stay empty only if no focusItems are supportive AND no profile.exerciseTypes are supportive)' : ''}, ${minSuggested} suggested item(s), and ${minAvoid} avoid item(s). Suggested items must not duplicate any names already present in focusItems or otherItems. If logged data is sparse, rely on clinician-grade best-practice guidance for ${issueName} rather than saying everything is covered. Keep every reason to exactly two sentences (mechanism + actionable relevance with dose/timing when helpful).`\n    : ''\n\n  // Add targeted domain rules for specific issues\n  const loweredIssue = issueName.toLowerCase()\n  const libidoRules = loweredIssue.includes('libido') || loweredIssue.includes('erection')\n    ? `\\nIssue-specific rules for libido/erection quality:\\n- Consider sex, age, weight/height, and training frequency when assessing androgen status and arousal.\\n- Evaluate mechanisms: testosterone/DHT, nitric oxide/endothelial function, SHBG, stress/cortisol, sleep.\\n- When focusItems include botanicals commonly discussed for libido (e.g., Tongkat Ali, Cistanche, Muira Puama), assess them and include in \"working\" if supportive with rationale; otherwise omit without moving them to suggested.\\n- CRITICAL FOR BRAND-NAME SUPPLEMENTS: If a supplement name suggests testosterone/libido support (e.g., products with \"testosterone\", \"libido\", \"men's health\", \"erection\", \"virility\", \"Miraforte\", or similar marketing), analyze it by its key ingredients (zinc, chrysin, muira puama, maca, stinging nettle, lignans, tribulus, tongkat ali, etc.) and include it in \"working\" if those ingredients are supportive, even if you don't recognize the exact brand name. Use the exact logged name but explain the mechanism based on its ingredient profile.\\n- For males, flag 5-alpha-reductase inhibitors (e.g., saw palmetto) as potential libido-reducing; explain the DHT rationale and advise clinician discussion.\\n- Provide concrete protocols where possible (e.g., dosing ranges/timing windows).\\n`\n    : ''\n\n  return `${header}\\n\\nIssue summary: ${issueSummary ?? 'Not supplied.'}\\n\\nUser context (JSON):\\n${userContext}\\n${exerciseTypesInstruction}\\n${baseGuidance}\\n${libidoRules}${forceNote}`\n}\n\nfunction uniqueByName<T extends { name: string }>(items: T[]): T[] {\n  const seen = new Set<string>()\n  const out: T[] = []\n  for (const it of items) {\n    const key = it.name.trim().toLowerCase()\n    if (seen.has(key)) continue\n    seen.add(key)\n    out.push(it)\n  }\n  return out\n}\n\nasync function classifyCandidatesForSection(params: {\n  issueName: string\n  mode: SectionMode\n  items: ClassificationEntry[]\n  trace: string\n  userId?: string | null\n  issueSlug?: string | null\n  runId?: string | null\n}): Promise<ClassifiedItem[] | null> {\n  const { issueName, mode, items, trace, userId, issueSlug, runId } = params\n  if (!items.length) return []\n  try {\n    const system = 'You are a precise classifier. For each item, assign a canonicalType and whether it is in-domain for the requested section. Output strict JSON.'\n    const user = `Classify the following items for issue \"${issueName}\" in SECTION: ${mode}.\n\nReturn JSON with an array under key \"items\"; each element: {\"name\": string, \"canonicalType\": one of [food,supplement,exercise,medication,other], \"inDomain\": boolean, \"explanation\": string}.\n\nItems:\\n${JSON.stringify(items, null, 2)}`\n\n    console.time(`${trace}:classify`)\n    const response: any = await createCompletion({\n      model: DEFAULT_INSIGHTS_MODEL,\n      temperature: 0,\n      max_tokens: 500,\n      response_format: { type: 'json_object' },\n      messages: [\n        { role: 'system', content: system },\n        { role: 'user', content: user },\n      ],\n    }, { feature: `insights:classify:${mode}`, userId, issueSlug, runId })\n    console.timeEnd(`${trace}:classify`)\n\n    const content = response.choices?.[0]?.message?.content\n    if (!content) return null\n    let json: any\n    try {\n      json = JSON.parse(content)\n    } catch {\n      const stripped = content.replace(/```[a-zA-Z]*\\n?|```/g, '').trim()\n      const objMatch = stripped.match(/\\{[\\s\\S]*\\}/)\n      if (!objMatch) return null\n      json = JSON.parse(objMatch[0])\n    }\n    const out = Array.isArray(json?.items) ? json.items : []\n    return out\n      .filter((it: any) => it && typeof it.name === 'string')\n      .map((it: any) => ({\n        name: String(it.name),\n        canonicalType: (it.canonicalType as CanonicalType) ?? 'other',\n        inDomain: Boolean(it.inDomain),\n        explanation: typeof it.explanation === 'string' ? it.explanation : undefined,\n      }))\n  } catch (error) {\n    console.warn('[insights.llm] classifyCandidatesForSection error', error)\n    return null\n  }\n}\n\nasync function rewriteCandidatesToDomain(params: {\n  issueName: string\n  mode: SectionMode\n  bucket: 'suggested' | 'avoid'\n  expectedType: CanonicalType | null\n  items: Array<{ name: string; reason: string }>\n  attempts?: number\n  trace: string\n  userId?: string | null\n  issueSlug?: string | null\n  runId?: string | null\n}): Promise<Array<{ name: string; reason: string }> | null> {\n  const { issueName, mode, bucket, expectedType, items, attempts = 2, trace, userId, issueSlug, runId } = params\n  if (!items.length) return []\n  const openai = getOpenAIClient()\n  if (!openai) return null\n  const typeText = expectedType ? `${expectedType}` : 'the section domain'\n  let tries = 0\n  while (tries < attempts) {\n    tries += 1\n    try {\n      console.time(`${trace}:rewrite-${bucket}#${tries}`)\n      const response: any = await runChatCompletionWithLogging(openai, {\n        model: DEFAULT_INSIGHTS_MODEL,\n        temperature: 0.2,\n        max_tokens: 600,\n        response_format: { type: 'json_object' },\n        messages: [\n        { role: 'system', content: 'Rewrite items into the requested domain. Output strict JSON only.' },\n        {\n          role: 'user',\n          content:\n            `For issue \"${issueName}\", SECTION: ${mode}. Some ${bucket} items are out-of-domain. Rewrite each into domain-conforming items that are strictly of type ${typeText}. Keep mechanisms relevant to ${issueName}. Return JSON {\"items\": Array<{\"name\": string, \"reason\": string}>}.\n\nItems to rewrite:\\n${JSON.stringify(items, null, 2)}`,\n        },\n      ],\n      }, { feature: `insights:rewrite:${mode}`, userId, issueSlug, runId })\n      console.timeEnd(`${trace}:rewrite-${bucket}#${tries}`)\n      const content = response.choices?.[0]?.message?.content\n      if (!content) continue\n      let json: any\n      try {\n        json = JSON.parse(content)\n      } catch {\n        const stripped = content.replace(/```[a-zA-Z]*\\n?|```/g, '').trim()\n        const objMatch = stripped.match(/\\{[\\s\\S]*\\}/)\n        if (!objMatch) continue\n        json = JSON.parse(objMatch[0])\n      }\n      const out = Array.isArray(json?.items) ? json.items : []\n      const cleaned = out\n        .filter((it: any) => it && typeof it.name === 'string' && typeof it.reason === 'string')\n        .map((it: any) => ({ name: it.name, reason: it.reason }))\n      return cleaned\n    } catch (error) {\n      console.warn('[insights.llm] rewriteCandidatesToDomain error', error)\n    }\n  }\n  return null\n}\n\nasync function fillMissingItemsForSection(params: {\n  issueName: string\n  mode: SectionMode\n  bucket: 'suggested' | 'avoid'\n  expectedType: CanonicalType | null\n  needed: number\n  disallowNames: string[]\n  trace: string\n  userId?: string | null\n  issueSlug?: string | null\n  runId?: string | null\n}): Promise<Array<{ name: string; reason: string; protocol?: string | null }> | null> {\n  const { issueName, mode, bucket, expectedType, needed, disallowNames, trace, userId, issueSlug, runId } = params\n  if (needed <= 0) return []\n  const openai = getOpenAIClient()\n  if (!openai) return null\n  const typeText = expectedType ? `that are strictly of type ${expectedType}` : 'that fit the section domain'\n  const diversityHint = (() => {\n    switch (mode) {\n      case 'nutrition':\n        return 'Ensure diversity across macro groups (protein sources, high-fiber foods, low-sugar options, low-sodium choices).'\n      case 'exercise':\n        return 'Ensure diversity across modalities (aerobic, strength, mobility/rehab).'\n      case 'supplements':\n      case 'medications':\n        return 'Ensure diversity across compound classes and include appropriate safety considerations.'\n      default:\n        return ''\n    }\n  })()\n  const prompt = `We need ${needed} more items for SECTION: ${mode}, bucket: ${bucket}, for issue \"${issueName}\" ${typeText}.\nReturn JSON: {\"items\": Array<{\"name\": string, \"reason\": string, \"protocol\"?: string|null}>}.\nAvoid any of these names (case-insensitive): ${disallowNames.join(', ') || 'None'}.\nEach reason must be two sentences: mechanism + direct relevance/action.\n${diversityHint}`\n\n  try {\n    console.time(`${trace}:fill-${bucket}`)\n    const response: any = await runChatCompletionWithLogging(openai, {\n      model: DEFAULT_INSIGHTS_MODEL,\n      temperature: 0.2,\n      max_tokens: 500,\n      response_format: { type: 'json_object' },\n      messages: [\n        { role: 'system', content: 'You generate concise, clinically-relevant items. Output strict JSON only.' },\n        { role: 'user', content: prompt },\n      ],\n    }, { feature: `insights:fill-missing:${mode}`, userId, issueSlug, runId })\n    console.timeEnd(`${trace}:fill-${bucket}`)\n    const content = response.choices?.[0]?.message?.content\n    if (!content) return null\n    let json: any\n    try {\n      json = JSON.parse(content)\n    } catch {\n      const stripped = content.replace(/```[a-zA-Z]*\\n?|```/g, '').trim()\n      const objMatch = stripped.match(/\\{[\\s\\S]*\\}/)\n      if (!objMatch) return null\n      json = JSON.parse(objMatch[0])\n    }\n    const items = Array.isArray(json?.items) ? json.items : []\n    return items\n      .filter((it: any) => it && typeof it.name === 'string' && typeof it.reason === 'string')\n      .map((it: any) => ({ name: it.name, reason: it.reason, protocol: it.protocol ?? null }))\n  } catch (error) {\n    console.warn('[insights.llm] fillMissingItemsForSection error', error)\n    return null\n  }\n}\n\n/**\n * Evaluates user's logged items (focusItems) to identify which are supportive for the issue.\n * This is a fallback when the main LLM doesn't properly match logged names.\n * Analyzes items at ingredient/mechanism level but ALWAYS returns exact logged names.\n */\nexport async function evaluateFocusItemsForIssue(params: {\n  issueName: string\n  issueSummary?: string | null\n  mode: SectionMode\n  focusItems: Array<{ name: string; dosage?: string | null; timing?: string[] | null }>\n}): Promise<Array<{ name: string; reason: string; dosage?: string | null; timing?: string | null }> | null> {\n  const { issueName, issueSummary, mode, focusItems } = params\n  if (!focusItems.length) return []\n\n  const openai = getOpenAIClient()\n  if (!openai) return null\n\n  const modeGuidanceText = modeGuidance(mode)\n  const prompt = `For issue \"${issueName}\"${issueSummary ? ` (${issueSummary})` : ''}, SECTION: ${mode}.\n\n${modeGuidanceText}\n\nThe user has logged these items:\n${JSON.stringify(focusItems, null, 2)}\n\nCRITICAL INSTRUCTIONS:\n1. Analyze each logged item by understanding its active ingredients, compounds, mechanisms, or physiological effects\n2. For brand-name supplements you don't recognize, research or infer their formulation based on the product name, marketing claims, or common formulations in that category\n3. For libido/erection issues: If a supplement name suggests testosterone/libido support (contains words like \"testosterone\", \"libido\", \"men's health\", \"erection\", \"virility\", \"Miraforte\", or similar), analyze it by its typical ingredient profile (zinc, chrysin, muira puama, maca, stinging nettle, lignans, etc.) and include it in \"working\" if those ingredients are supportive\n4. Evaluate whether each item is supportive for \"${issueName}\" based on evidence-based mechanisms\n5. Output matches by INDEX back to the provided array (0-based). Do NOT invent new items.\n6. For each supportive item, return its {index, reason, dosage?, timing?}. You may also include name, but index is REQUIRED.\n7. FIBER SUPPLEMENTS FOR BOWEL HEALTH: If the issue relates to bowel movements, digestion, constipation, regularity, or stool quality (check case-insensitively), treat clinically supported soluble/prebiotic fibers as supportive. This includes:\n   - Partially hydrolyzed guar gum (PHGG) - includes products like \"Sunfiber\"\n   - Psyllium husk\n   - Inulin, acacia/arabic gum, methylcellulose, glucomannan, wheat dextrin, pectin\n   - ANY product name containing the word \"fiber\" (e.g., \"Sunfiber\", \"FiberChoice\", \"Benefiber\")\n   Explain the mechanism (hydration/gel formation, fermentation to SCFAs, stool normalization). Use the logged dose/timing when provided.\n6. Return ONLY items that are plausibly supportive for this issue\n\nReturn JSON:\n  {\n    \"supportive\": Array<{\n      \"index\": number (0-based index into the provided items),\n      \"name\"?: string (optional, should be EXACT logged name),\n      \"reason\": string (two sentences: mechanism + direct relevance),\n      \"dosage\": string | null,\n      \"timing\": string | null\n    }>\n  }`\n\n  try {\n    const response: any = await runChatCompletionWithLogging(openai, {\n      model: DEFAULT_INSIGHTS_MODEL,\n      temperature: 0.1,\n      max_tokens: 600,\n      response_format: { type: 'json_object' },\n      messages: [\n        {\n          role: 'system',\n          content: 'You are a clinical decision support assistant. Analyze logged items by their mechanisms but ALWAYS output exact logged names. Output strict JSON only.',\n        },\n        { role: 'user', content: prompt },\n      ],\n    }, { feature: `insights:evaluate-focus:${mode}` })\n\n    const content = response.choices?.[0]?.message?.content\n    if (!content) return null\n\n    let json: any\n    try {\n      json = JSON.parse(content)\n    } catch {\n      const stripped = content.replace(/```[a-zA-Z]*\\n?|```/g, '').trim()\n      const objMatch = stripped.match(/\\{[\\s\\S]*\\}/)\n      if (!objMatch) return null\n      json = JSON.parse(objMatch[0])\n    }\n\n    const supportive = Array.isArray(json?.supportive) ? json.supportive : []\n    \n    // Map results back to exact logged names, preserving dosage/timing from logs\n    const loggedMap = new Map<string, { name: string; dosage?: string | null; timing?: string[] | null }>()\n    for (const item of focusItems) {\n      const key = item.name.trim().toLowerCase()\n      loggedMap.set(key, item)\n    }\n\n    const out: Array<{ name: string; reason: string; dosage?: string | null; timing?: string | null }> = []\n    for (const it of supportive) {\n      if (!it || typeof it.reason !== 'string') continue\n      let logged: { name: string; dosage?: string | null; timing?: string[] | null } | undefined\n      if (typeof it.index === 'number' && it.index >= 0 && it.index < focusItems.length) {\n        logged = focusItems[it.index]\n      } else if (typeof it.name === 'string') {\n        const key = it.name.trim().toLowerCase()\n        logged = loggedMap.get(key)\n      }\n      if (!logged) continue\n      out.push({\n        name: logged.name,\n        reason: it.reason,\n        dosage: logged.dosage ?? (typeof it.dosage === 'string' ? it.dosage : null),\n        timing: Array.isArray(logged.timing) ? (typeof it.timing === 'string' ? it.timing : (logged.timing?.[0] ?? null)) : (typeof it.timing === 'string' ? it.timing : null),\n      })\n    }\n    return out\n  } catch (error) {\n    console.warn('[insights.llm] evaluateFocusItemsForIssue error', error)\n    return null\n  }\n}\n\nexport async function generateDegradedSection(\n  input: LLMInputData,\n  options: { minSuggested?: number; minAvoid?: number } = {}\n): Promise<SectionLLMResult | null> {\n  const openai = getOpenAIClient()\n  if (!openai) return null\n  const userId = input.userId ?? null\n  const issueSlug = input.issueSlug ?? null\n  const minSuggested = Math.max(4, options.minSuggested ?? 4)\n  const minAvoid = Math.max(4, options.minAvoid ?? 4)\n  const typeSet = allowedCanonicalTypesForMode(input.mode)\n  const expected: CanonicalType | null = typeSet ? Array.from(typeSet)[0] : null\n  const trace = `[insights:degraded:${input.mode}:${Math.random().toString(36).slice(2, 8)}]`\n  let generateMs = 0\n  let classifyMs = 0\n  let fillMs = 0\n  let rewriteMs = 0\n\n  try {\n    const user = `For issue \"${input.issueName}\", SECTION: ${input.mode}. Data may be sparse.\nGenerate minimally valid guidance with ONLY in-domain items. Output JSON with keys suggested and avoid only; working may be empty. Each item: name, reason (two sentences), optional protocol.\nCounts: suggested‚â•${minSuggested}, avoid‚â•${minAvoid}.`\n    const g0 = Date.now()\n    console.time(`${trace}:generate`)\n    const resp: any = await runChatCompletionWithLogging(openai, {\n      model: DEFAULT_INSIGHTS_MODEL,\n      temperature: 0.2,\n      max_tokens: 700,\n      response_format: { type: 'json_object' },\n      messages: [\n        { role: 'system', content: 'Produce domain-correct, concise items. Output JSON only.' },\n        { role: 'user', content: user },\n      ],\n    }, { feature: `insights:degraded:${input.mode}`, userId, issueSlug })\n    console.timeEnd(`${trace}:generate`)\n    generateMs += Date.now() - g0\n    const content = resp.choices?.[0]?.message?.content\n    if (!content) return null\n    let json: any\n    try {\n      json = JSON.parse(content)\n    } catch {\n      const stripped = content.replace(/```[a-zA-Z]*\\n?|```/g, '').trim()\n      const objMatch = stripped.match(/\\{[\\s\\S]*\\}/)\n      if (!objMatch) return null\n      json = JSON.parse(objMatch[0])\n    }\n    const base: SectionLLMResult = {\n      summary: 'Initial guidance generated while we prepare a deeper report.',\n      working: [],\n      suggested: Array.isArray(json?.suggested) ? json.suggested : [],\n      avoid: Array.isArray(json?.avoid) ? json.avoid : [],\n      recommendations: [],\n    }\n    // Classify and keep only expected domain\n    const itemsForClassification: ClassificationEntry[] = [\n      ...base.suggested.map((s) => ({ name: s.name, reason: s.reason })),\n      ...base.avoid.map((a) => ({ name: a.name, reason: a.reason })),\n    ]\n    const c0 = Date.now()\n    const classified = await classifyCandidatesForSection({\n      issueName: input.issueName,\n      mode: input.mode,\n      items: itemsForClassification,\n      trace,\n      userId,\n      issueSlug,\n    })\n    classifyMs += Date.now() - c0\n    const typeMap = new Map<string, CanonicalType>()\n    for (const it of classified ?? []) {\n      typeMap.set(it.name.trim().toLowerCase(), it.canonicalType)\n    }\n    const keep = (name: string) => {\n      const t = typeMap.get(name.trim().toLowerCase())\n      return expected ? t === expected : true\n    }\n    let suggested = base.suggested.filter((s) => keep(s.name))\n    let avoid = base.avoid.filter((a) => keep(a.name))\n    // Top up if still short\n    const disallow = [\n      ...suggested.map((s) => s.name),\n      ...avoid.map((a) => a.name),\n    ]\n    const needSuggested = Math.max(0, minSuggested - suggested.length)\n    if (needSuggested > 0) {\n      const f0 = Date.now()\n      const more = await fillMissingItemsForSection({\n        issueName: input.issueName,\n        mode: input.mode,\n        bucket: 'suggested',\n        expectedType: expected,\n        needed: needSuggested,\n        disallowNames: disallow,\n        trace,\n        userId,\n        issueSlug,\n      })\n      fillMs += Date.now() - f0\n      suggested = uniqueByName([...suggested, ...(more ?? [])])\n    }\n    const needAvoid = Math.max(0, minAvoid - avoid.length)\n    if (needAvoid > 0) {\n      const f1 = Date.now()\n      const more = await fillMissingItemsForSection({\n        issueName: input.issueName,\n        mode: input.mode,\n        bucket: 'avoid',\n        expectedType: expected,\n        needed: needAvoid,\n        disallowNames: [\n          ...suggested.map((s) => s.name),\n          ...avoid.map((a) => a.name),\n        ],\n        trace,\n        userId,\n        issueSlug,\n      })\n      fillMs += Date.now() - f1\n      avoid = uniqueByName([...avoid, ...(more ?? [])])\n    }\n    const out: SectionLLMResult = {\n      summary: base.summary,\n      working: [],\n      suggested,\n      avoid,\n      recommendations: [],\n    }\n    ;(out as any)._timings = {\n      generateMs,\n      classifyMs,\n      rewriteMs,\n      fillMs,\n      totalMs: generateMs + classifyMs + rewriteMs + fillMs,\n    }\n    return out\n  } catch (error) {\n    console.warn('[insights.llm] generateDegradedSection error', error)\n    return null\n  }\n}\n\n// Quick degraded generator: single-pass candidate generation filtered to the expected domain.\n// Designed for fast first-paint. Uses only one LLM call and avoids repair/classify loops.\nexport async function generateDegradedSectionQuick(\n  input: LLMInputData,\n  options: { minSuggested?: number; minAvoid?: number } = {}\n): Promise<SectionLLMResult | null> {\n  const minSuggested = Math.max(4, options.minSuggested ?? 4)\n  const minAvoid = Math.max(4, options.minAvoid ?? 4)\n\n  try {\n    const expectedSet = allowedCanonicalTypesForMode(input.mode)\n    const expected: CanonicalType | null = expectedSet ? Array.from(expectedSet)[0] : null\n    const candidates = await generateSectionCandidates({\n      issueName: input.issueName,\n      issueSummary: input.issueSummary,\n      profile: input.profile,\n      mode: input.mode,\n      count: { suggested: Math.max(6, minSuggested), avoid: Math.max(6, minAvoid) },\n      userId: input.userId ?? null,\n      issueSlug: input.issueSlug ?? null,\n    })\n    if (!candidates) return null\n\n    const keep = (ct: CanonicalType) => (expected ? ct === expected : true)\n    const suggested = candidates\n      .filter((c) => c.bucket === 'suggested' && keep(c.candidateType))\n      .slice(0, Math.max(minSuggested, 6))\n      .map((c) => ({ name: c.name, reason: c.reason, protocol: c.protocol ?? null }))\n    const avoid = candidates\n      .filter((c) => c.bucket === 'avoid' && keep(c.candidateType))\n      .slice(0, Math.max(minAvoid, 6))\n      .map((c) => ({ name: c.name, reason: c.reason }))\n\n    // Ensure minimum counts by truncation fallback (should already meet due to counts above)\n    const finalSuggested = suggested.slice(0, Math.max(minSuggested, 4))\n    const finalAvoid = avoid.slice(0, Math.max(minAvoid, 4))\n\n    // For exercise mode, check intake exerciseTypes and add supportive ones to working\n    let working: Array<{ name: string; reason: string; dosage?: string | null; timing?: string | null }> = []\n    if (input.mode === 'exercise' && input.profile?.exerciseTypes?.length) {\n      // For quick path, we'll add intake exercises that are likely supportive\n      // The full path will do a proper LLM evaluation\n      const intakeTypes = input.profile.exerciseTypes\n      console.log('[exercise.quick] Checking intake exerciseTypes for working:', intakeTypes)\n      \n      // Add intake exercises to working with a generic supportive reason\n      // The full path will refine these with proper LLM evaluation\n      for (const exerciseType of intakeTypes) {\n        working.push({\n          name: exerciseType,\n          reason: `${exerciseType} can support ${input.issueName} through improved cardiovascular health, stress reduction, and overall physical wellbeing. Regular ${exerciseType.toLowerCase()} helps maintain optimal body function and may contribute positively to this health goal.`,\n          dosage: null,\n          timing: null,\n        })\n      }\n      console.log('[exercise.quick] Added intake exercises to working:', working.map(w => w.name))\n    }\n\n    return {\n      summary: 'Initial guidance generated while we prepare a deeper report.',\n      working,\n      suggested: finalSuggested,\n      avoid: finalAvoid,\n      recommendations: [],\n    }\n  } catch (error) {\n    console.warn('[insights.llm] generateDegradedSectionQuick error', error)\n    return null\n  }\n}\n\n// Strict quick degraded generator: larger candidate request with tighter domain guardrails.\nexport async function generateDegradedSectionQuickStrict(\n  input: LLMInputData,\n  options: { minSuggested?: number; minAvoid?: number } = {}\n): Promise<SectionLLMResult | null> {\n  const minSuggested = Math.max(4, options.minSuggested ?? 4)\n  const minAvoid = Math.max(4, options.minAvoid ?? 4)\n  try {\n    const expectedSet = allowedCanonicalTypesForMode(input.mode)\n    const expected: CanonicalType | null = expectedSet ? Array.from(expectedSet)[0] : null\n    const candidates = await generateSectionCandidates({\n      issueName: input.issueName,\n      issueSummary: input.issueSummary,\n      profile: input.profile,\n      mode: input.mode,\n      count: { suggested: Math.max(10, minSuggested), avoid: Math.max(10, minAvoid) },\n      userId: input.userId ?? null,\n      issueSlug: input.issueSlug ?? null,\n    })\n    if (!candidates) return null\n    const keep = (ct: CanonicalType) => (expected ? ct === expected : true)\n    const suggested = candidates\n      .filter((c) => c.bucket === 'suggested' && keep(c.candidateType))\n      .slice(0, Math.max(minSuggested, 10))\n      .map((c) => ({ name: c.name, reason: c.reason, protocol: c.protocol ?? null }))\n    const avoid = candidates\n      .filter((c) => c.bucket === 'avoid' && keep(c.candidateType))\n      .slice(0, Math.max(minAvoid, 10))\n      .map((c) => ({ name: c.name, reason: c.reason }))\n    const finalSuggested = suggested.slice(0, Math.max(minSuggested, 4))\n    const finalAvoid = avoid.slice(0, Math.max(minAvoid, 4))\n    \n    // For exercise mode, check intake exerciseTypes and add supportive ones to working\n    let working: Array<{ name: string; reason: string; dosage?: string | null; timing?: string | null }> = []\n    if (input.mode === 'exercise' && input.profile?.exerciseTypes?.length) {\n      const intakeTypes = input.profile.exerciseTypes\n      console.log('[exercise.quick.strict] Checking intake exerciseTypes for working:', intakeTypes)\n      for (const exerciseType of intakeTypes) {\n        working.push({\n          name: exerciseType,\n          reason: `${exerciseType} can support ${input.issueName} through improved cardiovascular health, stress reduction, and overall physical wellbeing. Regular ${exerciseType.toLowerCase()} helps maintain optimal body function and may contribute positively to this health goal.`,\n          dosage: null,\n          timing: null,\n        })\n      }\n      console.log('[exercise.quick.strict] Added intake exercises to working:', working.map(w => w.name))\n    }\n    \n    return {\n      summary: 'Initial guidance generated while we prepare a deeper report.',\n      working,\n      suggested: finalSuggested,\n      avoid: finalAvoid,\n      recommendations: [],\n    }\n  } catch (error) {\n    console.warn('[insights.llm] generateDegradedSectionQuickStrict error', error)\n    return null\n  }\n}\n\nexport async function generateSectionInsightsFromLLM(\n  input: LLMInputData,\n  options: LLMOptions = {}\n): Promise<SectionLLMResult | null> {\n  const openai = getOpenAIClient()\n  if (!openai) {\n    return null\n  }\n\n  const userId = input.userId ?? null\n  const issueSlug = input.issueSlug ?? null\n  const focusItems = (input.items ?? []).slice(0, 8)\n  const otherItems = (input.otherItems ?? []).slice(0, 6)\n  const minWorking = options.minWorking ?? (focusItems.length > 0 ? 1 : 0)\n  const minSuggested = options.minSuggested ?? 4\n  const minAvoid = options.minAvoid ?? 4\n  const costSaver = getRunContext()?.feature === 'insights:targeted'\n  const maxRetries = costSaver ? 1 : options.maxRetries ?? 3\n  const maxTokens = costSaver ? 200 : 650\n  const disableCache = options.disableCache ?? false\n  const runId = getRunContext()?.runId ?? null\n\n  const userContext = JSON.stringify(\n    {\n      focusItems,\n      otherItems,\n      profile: input.profile ?? {},\n    },\n    null,\n    2\n  )\n\n  // Debug logging for exercise mode\n  if (input.mode === 'exercise') {\n    console.log('[exercise.llm] Input profile:', JSON.stringify(input.profile, null, 2))\n    console.log('[exercise.llm] exerciseTypes in profile:', input.profile?.exerciseTypes)\n    console.log('[exercise.llm] focusItems (normalized logs):', focusItems)\n  }\n\n  const cacheKey = JSON.stringify({\n    issueName: input.issueName,\n    issueSummary: input.issueSummary ?? '',\n    mode: input.mode,\n    userContext,\n    minWorking,\n    minSuggested,\n    minAvoid,\n  })\n\n  const cached = disableCache ? null : insightCache.get(cacheKey)\n  const nowTs = Date.now()\n  if (!disableCache && cached && cached.expiresAt > nowTs) {\n    logLlmEvent('cache-hit', {\n      userId,\n      issueSlug,\n      mode: input.mode,\n      cacheExpiresAt: new Date(cached.expiresAt).toISOString(),\n    })\n    return cached.result\n  }\n  logLlmEvent('cache-miss', { userId, issueSlug, mode: input.mode })\n\n  let generateMs = 0\n  let classifyMs = 0\n  let rewriteMs = 0\n  let fillMs = 0\n  let generateAttempts = 0\n  let bestCandidate: { result: SectionLLMResult; score: number; metMinimums: boolean } | null = null\n  for (let attempt = 0; attempt < maxRetries; attempt += 1) {\n    const force = attempt > 0\n    const prompt = buildPrompt({\n      issueName: input.issueName,\n      issueSummary: input.issueSummary,\n      userContext,\n      mode: input.mode,\n      minWorking,\n      minSuggested,\n      minAvoid,\n      force,\n    })\n\n    try {\n      const g0 = Date.now()\n      console.time(`[insights.gen:${input.mode}]`)\n      const response: any = await runChatCompletionWithLogging(openai, {\n        model: DEFAULT_INSIGHTS_MODEL,\n        temperature: 0.05,\n        max_tokens: maxTokens,\n        response_format: { type: 'json_object' },\n        messages: [\n          {\n            role: 'system',\n            content:\n              'You are a careful clinical decision support assistant. Follow instructions precisely, remain evidence-aligned, and never fabricate data.',\n          },\n          { role: 'user', content: prompt },\n        ],\n      }, { feature: `insights:generate:${input.mode}`, userId, issueSlug, runId })\n      console.timeEnd(`[insights.gen:${input.mode}]`)\n      const elapsed = Date.now() - g0\n      generateMs += elapsed\n      generateAttempts = attempt + 1\n\n      const content = response.choices?.[0]?.message?.content\n      if (!content) {\n        continue\n      }\n\n      let json: unknown\n      try {\n        json = JSON.parse(content)\n      } catch (parseError) {\n        // Attempt a salvage parse: strip code fences and extract the first JSON object\n        const stripped = content.replace(/```[a-zA-Z]*\\n?|```/g, '').trim()\n        const objMatch = stripped.match(/\\{[\\s\\S]*\\}/)\n        if (objMatch) {\n          try {\n            json = JSON.parse(objMatch[0])\n          } catch (e) {\n            console.warn('[insights.llm] Salvage parse failed', { content })\n            throw parseError\n          }\n        } else {\n          console.warn('[insights.llm] Failed to parse JSON content', { content })\n          throw parseError\n        }\n      }\n\n      const parsed = llmSectionSchema.safeParse(json)\n      if (!parsed.success) {\n        console.warn('[insights.llm] Invalid LLM JSON', {\n          issues: parsed.error.issues,\n          content,\n        })\n        continue\n      }\n\n      const data = parsed.data\n      const meets = meetsMinimums(data, { minWorking, minSuggested, minAvoid })\n      const score = scoreCandidate(data)\n      if (!bestCandidate || score > bestCandidate.score) {\n        bestCandidate = { result: data, score, metMinimums: meets }\n      }\n      if (meets || costSaver) {\n        break\n      }\n      \n      // If minWorking is set due to intake exercises (not logs), be more lenient\n      // Accept best candidate if we have at least some working items, even if not meeting strict minimums\n      if (minWorking === 1 && focusItems.length === 0 && data.working.length > 0) {\n        console.log('[insights.llm] Accepting result with working items despite not meeting strict minimums')\n        break\n      }\n    } catch (error) {\n      console.error('[insights.llm] Failed to fetch LLM output', error)\n    }\n  }\n\n  // Stage 2: classification + fill-missing over the best candidate (with one repair attempt if needed)\n  const trace = `[insights:${input.mode}:${Math.random().toString(36).slice(2, 8)}]`\n  let base: SectionLLMResult | null = bestCandidate?.result ?? null\n  if (base && !bestCandidate?.metMinimums && !costSaver) {\n    const r0 = Date.now()\n    const repaired = await repairLLMOutput({\n      mode: input.mode,\n      issueName: input.issueName,\n      issueSummary: input.issueSummary,\n      minWorking,\n      minSuggested,\n      minAvoid,\n      focusItems,\n      otherItems,\n      profile: input.profile,\n      previous: base,\n    })\n    generateMs += Date.now() - r0\n    if (repaired) base = repaired\n  }\n\n  if (!base) return null\n\n  const allowed = allowedCanonicalTypesForMode(input.mode)\n  let working = base.working.slice()\n  let suggested = base.suggested.slice()\n  let avoid = base.avoid.slice()\n\n  console.log('[insights.llm] pre-classify counts', {\n    mode: input.mode,\n    working: working.length,\n    suggested: suggested.length,\n    avoid: avoid.length,\n  })\n\n  if (allowed) {\n    const itemsForClassification: ClassificationEntry[] = [\n      ...working.map((w) => ({ name: w.name, reason: w.reason })),\n      ...suggested.map((s) => ({ name: s.name, reason: s.reason })),\n      ...avoid.map((a) => ({ name: a.name, reason: a.reason })),\n    ]\n    const c0 = Date.now()\n    const classified = await classifyCandidatesForSection({\n      issueName: input.issueName,\n      mode: input.mode,\n      items: itemsForClassification,\n      trace,\n      runId,\n      userId,\n      issueSlug,\n    })\n    classifyMs += Date.now() - c0\n    const typeMap = new Map<string, CanonicalType>()\n    for (const it of classified ?? []) {\n      typeMap.set(it.name.trim().toLowerCase(), it.canonicalType)\n    }\n\n    const keep = (name: string) => {\n      const key = name.trim().toLowerCase()\n      const t = typeMap.get(key)\n      if (!t) return false\n      return allowed.has(t)\n    }\n\n    const droppedWorking = working.filter((w) => !keep(w.name))\n    const droppedSuggested = suggested.filter((s) => !keep(s.name))\n    const droppedAvoid = avoid.filter((a) => !keep(a.name))\n    working = working.filter((w) => keep(w.name))\n    suggested = suggested.filter((s) => keep(s.name))\n    avoid = avoid.filter((a) => keep(a.name))\n\n    console.log('[insights.llm] post-classify counts', {\n      mode: input.mode,\n      working: working.length,\n      suggested: suggested.length,\n      avoid: avoid.length,\n    })\n\n    // Rewrite out-of-domain candidates into the correct domain, then re-classify\n    if (droppedSuggested.length && !costSaver) {\n      const rw0 = Date.now()\n      const rewritten = await rewriteCandidatesToDomain({\n        issueName: input.issueName,\n        mode: input.mode,\n        bucket: 'suggested',\n        expectedType: Array.from(allowed)[0] ?? null,\n        items: droppedSuggested.map((it) => ({ name: it.name, reason: it.reason })),\n        attempts: 2,\n        trace,\n        userId,\n        issueSlug,\n        runId,\n      })\n      rewriteMs += Date.now() - rw0\n      if (rewritten?.length) {\n        const cc0 = Date.now()\n        const reClassified = await classifyCandidatesForSection({\n          issueName: input.issueName,\n          mode: input.mode,\n          items: rewritten.map((m) => ({ name: m.name, reason: m.reason })),\n          trace,\n          runId,\n          userId,\n          issueSlug,\n        })\n      classifyMs += Date.now() - cc0\n        const filtered = (reClassified ?? [])\n          .filter((it) => allowed.has(it.canonicalType))\n          .map((it) => {\n            const src = rewritten.find((m) => m.name.trim().toLowerCase() === it.name.trim().toLowerCase())!\n            return { name: src.name, reason: src.reason, protocol: null as string | null }\n          })\n        suggested = uniqueByName([...suggested, ...filtered])\n      }\n    }\n    if (droppedAvoid.length && !costSaver) {\n      const rw1 = Date.now()\n      const rewritten = await rewriteCandidatesToDomain({\n        issueName: input.issueName,\n        mode: input.mode,\n        bucket: 'avoid',\n        expectedType: Array.from(allowed)[0] ?? null,\n        items: droppedAvoid.map((it) => ({ name: it.name, reason: it.reason })),\n        attempts: 2,\n        trace,\n        userId,\n        issueSlug,\n        runId,\n      })\n      rewriteMs += Date.now() - rw1\n      if (rewritten?.length) {\n        const cc1 = Date.now()\n        const reClassified = await classifyCandidatesForSection({\n          issueName: input.issueName,\n          mode: input.mode,\n          items: rewritten.map((m) => ({ name: m.name, reason: m.reason })),\n          trace,\n          runId,\n          userId,\n          issueSlug,\n        })\n        classifyMs += Date.now() - cc1\n        const filtered = (reClassified ?? [])\n          .filter((it) => allowed.has(it.canonicalType))\n          .map((it) => {\n            const src = rewritten.find((m) => m.name.trim().toLowerCase() === it.name.trim().toLowerCase())!\n            return { name: src.name, reason: src.reason, protocol: null as string | null }\n          })\n        avoid = uniqueByName([...avoid, ...filtered])\n      }\n    }\n\n    // Fill-missing up to 3 retries per bucket\n    for (const bucket of ['suggested', 'avoid'] as const) {\n      let attempts = 0\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        const need = bucket === 'suggested' ? Math.max(0, minSuggested - suggested.length) : Math.max(0, minAvoid - avoid.length)\n        if (need <= 0 || attempts >= (costSaver ? 1 : 3)) break\n        const disallow = [\n          ...suggested.map((s) => s.name),\n          ...avoid.map((a) => a.name),\n          ...working.map((w) => w.name),\n        ]\n        const expected: CanonicalType | null = Array.from(allowed)[0] ?? null\n        const f0 = Date.now()\n        const more = await fillMissingItemsForSection({\n          issueName: input.issueName,\n          mode: input.mode,\n          bucket,\n          expectedType: expected,\n          needed: need,\n          disallowNames: disallow,\n          trace,\n          userId,\n          issueSlug,\n          runId,\n        })\n        fillMs += Date.now() - f0\n        attempts += 1\n        if (!more || !more.length) break\n        // classify the new items\n        const c1 = Date.now()\n        const moreClassified = await classifyCandidatesForSection({\n          issueName: input.issueName,\n          mode: input.mode,\n          items: more.map((m) => ({ name: m.name, reason: m.reason })),\n          trace,\n          runId,\n          userId,\n          issueSlug,\n        })\n        classifyMs += Date.now() - c1\n        const filtered = (moreClassified ?? [])\n          .filter((it) => allowed.has(it.canonicalType))\n          .map((it) => {\n            const src = more.find((m) => m.name.trim().toLowerCase() === it.name.trim().toLowerCase())!\n            return { name: src.name, reason: src.reason, protocol: src.protocol ?? null }\n          })\n        if (bucket === 'suggested') {\n          suggested = uniqueByName([...suggested, ...filtered])\n        } else {\n          avoid = uniqueByName([...avoid, ...filtered])\n        }\n        console.log('[insights.llm] fill-missing iteration', {\n          mode: input.mode,\n          bucket,\n          added: filtered.length,\n          suggested: suggested.length,\n          avoid: avoid.length,\n        })\n      }\n    }\n  }\n\n  const validated = suggested.length >= minSuggested && avoid.length >= minAvoid\n  const final: SectionLLMResult = {\n    summary: base.summary,\n    working,\n    suggested,\n    avoid,\n    recommendations: base.recommendations ?? [],\n  }\n\n  console.log('[insights.llm] final counts', {\n    mode: input.mode,\n    validated,\n    working: final.working.length,\n    suggested: final.suggested.length,\n    avoid: final.avoid.length,\n  })\n\n  if (validated && !disableCache) {\n    insightCache.set(cacheKey, {\n      expiresAt: Date.now() + CACHE_TTL_MS,\n      result: final,\n    })\n  }\n  // Attach timings for observability\n  ;(final as any)._timings = {\n    generateMs,\n    classifyMs,\n    rewriteMs,\n    fillMs,\n    totalMs: generateMs + classifyMs + rewriteMs + fillMs,\n    attempts: {\n      generate: generateAttempts,\n    },\n  }\n  return final\n}\n","truncated":false,"size":65682},{"path":"lib/insights/regeneration-service.ts","content":"/**\n * Insights Regeneration Service\n * \n * This service provides automatic background regeneration of insights when health data changes.\n * Unlike previous attempts that generated insights on-demand (causing 20-60s waits), this system:\n * \n * 1. Tracks what data each insight was based on (data fingerprints)\n * 2. Detects when relevant health data actually changes\n * 3. Automatically regenerates affected sections in the background\n * 4. Allows instant display of cached insights while updates happen\n * \n * Key Difference from Previous Agents:\n * - Previous: Generate on click ‚Üí user waits 20-60s\n * - This: Generate on data change ‚Üí user sees instant cached result (<2s)\n */\n\nimport { prisma } from '@/lib/prisma'\nimport { precomputeIssueSectionsForUser, precomputeQuickSectionsForUser } from './issue-engine'\nimport { withRunContext, type RunContext } from '../run-context'\nimport type { IssueSectionKey } from './issue-engine'\n\nexport interface InsightMetadata {\n  userId: string\n  issueSlug: string\n  section: IssueSectionKey\n  lastGeneratedAt: Date\n  dataFingerprint: string // Hash of source data used for generation\n  status: 'fresh' | 'stale' | 'generating'\n}\n\nexport interface DataChangeEvent {\n  userId: string\n  changeType:\n    | 'supplements'\n    | 'medications'\n    | 'food'\n    | 'exercise'\n    | 'health_goals'\n    | 'health_situations'\n    | 'profile'\n    | 'blood_results'\n  timestamp: Date\n}\n\n/**\n * Creates a fingerprint (hash) of the data to detect real changes\n */\nfunction createDataFingerprint(data: any): string {\n  const json = JSON.stringify(data)\n  // Simple hash function (for production, consider using crypto.subtle or a library)\n  let hash = 0\n  for (let i = 0; i < json.length; i++) {\n    const char = json.charCodeAt(i)\n    hash = (hash << 5) - hash + char\n    hash = hash & hash // Convert to 32bit integer\n  }\n  return hash.toString(36)\n}\n\n/**\n * Map change types to affected insight sections\n */\nexport function getAffectedSections(changeType: DataChangeEvent['changeType']): IssueSectionKey[] {\n  const mapping: Record<DataChangeEvent['changeType'], IssueSectionKey[]> = {\n    // Narrowed to just the sections a user expects to change, to keep runtime fast and scoped.\n    supplements: ['supplements'], // only when supplements change\n    medications: ['medications'], // interactions disabled per user request\n    food: ['nutrition'], // nutrition only runs via food diary changes\n    exercise: [], // exercise insights removed\n    // Goals/situations no longer fan out to lifestyle (section removed)\n    health_goals: [],\n    health_situations: [],\n    // Profile changes should not fan out across goals; no sections triggered\n    profile: [],\n    // Labs stay isolated and only run when labs are uploaded/changed\n    blood_results: ['labs'],\n  }\n  return mapping[changeType] || []\n}\n\n/**\n * Ensure the insights metadata tracking table exists\n */\nasync function ensureMetadataTable() {\n  try {\n    // await prisma.$executeRawUnsafe(`\n    //   CREATE TABLE IF NOT EXISTS \"InsightsMetadata\" (\n    //     \"userId\" TEXT NOT NULL,\n    //     \"issueSlug\" TEXT NOT NULL,\n    //     \"section\" TEXT NOT NULL,\n    //     \"lastGeneratedAt\" TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n    //     \"dataFingerprint\" TEXT NOT NULL,\n    //     \"status\" TEXT NOT NULL DEFAULT 'fresh',\n    //     \"updatedAt\" TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n    //     PRIMARY KEY (\"userId\", \"issueSlug\", \"section\")\n    //   )\n    // `)\n  } catch (error) {\n    console.warn('[regeneration-service] Failed to ensure metadata table', error)\n  }\n}\n\n/**\n * Get current data fingerprint for a user\n */\nasync function getCurrentDataFingerprint(userId: string): Promise<string> {\n  try {\n    const user = await prisma.user.findUnique({\n      where: { id: userId },\n      include: {\n        healthGoals: { select: { name: true, currentRating: true } },\n        supplements: { select: { name: true, dosage: true, timing: true } },\n        medications: { select: { name: true, dosage: true, timing: true } },\n        foodLogs: {\n          where: {\n            createdAt: {\n              gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000), // Last 7 days\n            },\n          },\n          select: { name: true, nutrients: true },\n        },\n        exerciseLogs: {\n          where: {\n            createdAt: {\n              gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000),\n            },\n          },\n          select: { type: true, duration: true },\n        },\n      },\n    })\n\n    if (!user) return ''\n\n    const relevantData = {\n      profile: {\n        gender: user.gender,\n        weight: user.weight,\n        height: user.height,\n        bodyType: user.bodyType,\n        exerciseFrequency: user.exerciseFrequency,\n      },\n      goals: user.healthGoals.map((g) => ({ name: g.name, rating: g.currentRating })),\n      supplements: user.supplements.map((s) => ({ name: s.name, dosage: s.dosage, timing: s.timing })),\n      medications: user.medications.map((m) => ({ name: m.name, dosage: m.dosage, timing: m.timing })),\n      recentFoods: user.foodLogs.length,\n      recentExercise: user.exerciseLogs.length,\n    }\n\n    return createDataFingerprint(relevantData)\n  } catch (error) {\n    console.warn('[regeneration-service] Error creating fingerprint', error)\n    return ''\n  }\n}\n\n/**\n * Check if insights are stale (need regeneration)\n */\nexport async function checkInsightsStatus(\n  userId: string,\n  issueSlug: string,\n  section: IssueSectionKey\n): Promise<{ status: 'fresh' | 'stale' | 'missing' | 'generating'; lastGenerated: Date | null; needsUpdate: boolean }> {\n  try {\n    await ensureMetadataTable()\n\n    const rows: any[] = await prisma.$queryRawUnsafe(\n      'SELECT \"lastGeneratedAt\", \"dataFingerprint\", \"status\" FROM \"InsightsMetadata\" WHERE \"userId\" = $1 AND \"issueSlug\" = $2 AND \"section\" = $3',\n      userId,\n      issueSlug,\n      section\n    )\n\n    if (!rows || !rows[0]) {\n      return { status: 'missing', lastGenerated: null, needsUpdate: true }\n    }\n\n    const metadata = rows[0]\n    const currentFingerprint = await getCurrentDataFingerprint(userId)\n\n    // If fingerprints don't match, data has changed\n    const needsUpdate = metadata.dataFingerprint !== currentFingerprint\n\n    return {\n      status: needsUpdate ? 'stale' : (metadata.status as 'fresh' | 'stale' | 'generating'),\n      lastGenerated: metadata.lastGeneratedAt ? new Date(metadata.lastGeneratedAt) : null,\n      needsUpdate,\n    }\n  } catch (error) {\n    console.warn('[regeneration-service] Error checking status', error)\n    return { status: 'missing', lastGenerated: null, needsUpdate: true }\n  }\n}\n\n/**\n * Mark sections as stale when data changes\n */\nasync function markSectionsStale(userId: string, sections: IssueSectionKey[]): Promise<void> {\n  try {\n    await ensureMetadataTable()\n\n    // Get all issues for this user\n    const user = await prisma.user.findUnique({\n      where: { id: userId },\n      include: { healthGoals: true },\n    })\n\n    if (!user) return\n\n    // Extract issue slugs from health goals (simplified - in real system would be more robust)\n    let issueNames = user.healthGoals\n      .filter((g) => !g.name.startsWith('__'))\n      .map((g) => g.name.toLowerCase().replace(/[^a-z0-9]+/g, '-'))\n\n    // Fallback: if no healthGoals on the user record, try CheckinIssues (selected issues)\n    if (!issueNames.length) {\n      try {\n        const rows: Array<{ name: string }> = await prisma.$queryRawUnsafe(\n          'SELECT name FROM \"CheckinIssues\" WHERE \"userId\" = $1',\n          userId\n        )\n        issueNames = rows\n          .map((r) => r.name || '')\n          .filter((name) => name && !name.startsWith('__'))\n          .map((name) => name.toLowerCase().replace(/[^a-z0-9]+/g, '-'))\n      } catch (e) {\n        console.warn('[manual-regeneration] fallback issues lookup failed', { userId, error: e })\n      }\n    }\n\n    // If still no issues, bail early to avoid a no-op regen that never charges\n    if (!issueNames.length) {\n      console.warn('[manual-regeneration] no issues/goals to regenerate for user', { userId })\n      return\n    }\n\n    // Mark each section for each issue as stale\n    for (const issueSlug of issueNames) {\n      for (const section of sections) {\n        await prisma.$queryRawUnsafe(\n          `INSERT INTO \"InsightsMetadata\" (\"userId\", \"issueSlug\", \"section\", \"status\", \"dataFingerprint\", \"updatedAt\") \n           VALUES ($1, $2, $3, 'stale', '', NOW())\n           ON CONFLICT (\"userId\", \"issueSlug\", \"section\") \n           DO UPDATE SET \"status\" = 'stale', \"updatedAt\" = NOW()`,\n          userId,\n          issueSlug,\n          section\n        )\n      }\n    }\n\n    console.log(`[regeneration-service] Marked ${sections.length} sections as stale for user ${userId}`)\n  } catch (error) {\n    console.warn('[regeneration-service] Error marking sections stale', error)\n  }\n}\n\n/**\n * Update metadata after successful generation\n */\nasync function updateMetadataAfterGeneration(\n  userId: string,\n  issueSlug: string,\n  section: IssueSectionKey\n): Promise<void> {\n  try {\n    await ensureMetadataTable()\n    const fingerprint = await getCurrentDataFingerprint(userId)\n\n    await prisma.$queryRawUnsafe(\n      `INSERT INTO \"InsightsMetadata\" (\"userId\", \"issueSlug\", \"section\", \"lastGeneratedAt\", \"dataFingerprint\", \"status\", \"updatedAt\")\n       VALUES ($1, $2, $3, NOW(), $4, 'fresh', NOW())\n       ON CONFLICT (\"userId\", \"issueSlug\", \"section\")\n       DO UPDATE SET \"lastGeneratedAt\" = NOW(), \"dataFingerprint\" = $4, \"status\" = 'fresh', \"updatedAt\" = NOW()`,\n      userId,\n      issueSlug,\n      section,\n      fingerprint\n    )\n  } catch (error) {\n    console.warn('[regeneration-service] Error updating metadata', error)\n  }\n}\n\n/**\n * Trigger background regeneration for affected sections.\n * Temporarily paused unless explicitly enabled to stop runaway background calls.\n */\nconst BACKGROUND_REGEN_ENABLED = process.env.ENABLE_INSIGHTS_BACKGROUND_REGEN === 'true'\n\nexport async function triggerBackgroundRegeneration(event: DataChangeEvent): Promise<void> {\n  if (!BACKGROUND_REGEN_ENABLED) {\n    console.log('[regeneration-service] Background regeneration is disabled; skipping trigger.', event)\n    return\n  }\n\n  const { userId, changeType } = event\n\n  try {\n    console.log(`[regeneration-service] Data change detected: ${changeType} for user ${userId}`)\n\n    // 1. Determine which sections are affected by this change\n    const affectedSections = getAffectedSections(changeType)\n\n    if (affectedSections.length === 0) {\n      console.log('[regeneration-service] No affected sections for this change type')\n      return\n    }\n\n    // 2. Mark affected sections as stale\n    await markSectionsStale(userId, affectedSections)\n\n    // 3. Kick off background regeneration (non-blocking!)\n    // This runs asynchronously - the user doesn't wait for it\n    setImmediate(async () => {\n      try {\n        console.log(`[regeneration-service] Starting background regeneration for sections: ${affectedSections.join(', ')}`)\n\n        // Mark as generating\n        await ensureMetadataTable()\n        const user = await prisma.user.findUnique({\n          where: { id: userId },\n          include: { healthGoals: true },\n        })\n\n        if (!user) return\n\n        const issueNames = user.healthGoals\n          .filter((g) => !g.name.startsWith('__'))\n          .map((g) => g.name.toLowerCase().replace(/[^a-z0-9]+/g, '-'))\n\n        for (const issueSlug of issueNames) {\n          for (const section of affectedSections) {\n            await prisma.$queryRawUnsafe(\n              `UPDATE \"InsightsMetadata\" SET \"status\" = 'generating', \"updatedAt\" = NOW() \n               WHERE \"userId\" = $1 AND \"issueSlug\" = $2 AND \"section\" = $3`,\n              userId,\n              issueSlug,\n              section\n            )\n          }\n        }\n\n        // Run precomputation with concurrency control\n        await precomputeIssueSectionsForUser(userId, { concurrency: 4, sectionsFilter: affectedSections })\n\n        // Update metadata to mark as fresh\n        for (const issueSlug of issueNames) {\n          for (const section of affectedSections) {\n            await updateMetadataAfterGeneration(userId, issueSlug, section)\n          }\n        }\n\n        console.log(`[regeneration-service] Background regeneration complete for user ${userId}`)\n      } catch (error) {\n        console.error('[regeneration-service] Background regeneration failed', error)\n\n        // Mark as stale again so it can retry later\n        await markSectionsStale(userId, affectedSections)\n      }\n    })\n\n    console.log('[regeneration-service] Background regeneration triggered (non-blocking)')\n  } catch (error) {\n    console.error('[regeneration-service] Error triggering regeneration', error)\n  }\n}\n\n/**\n * Manually trigger regeneration for selected change types, even when background\n * regeneration is disabled. This is used for explicit \"Update Insights\" clicks\n * so we only regenerate the affected sections.\n */\nexport async function triggerManualSectionRegeneration(\n  userId: string,\n  changeTypes: DataChangeEvent['changeType'][],\n  options: { inline?: boolean; runContext?: RunContext | null; preferQuick?: boolean; slugs?: string[] } = {}\n): Promise<IssueSectionKey[]> {\n  const requestedTypes = Array.isArray(changeTypes) ? changeTypes : []\n  const changeTypesForLog = requestedTypes\n  const affectedSections = Array.from(\n    new Set(\n      requestedTypes.flatMap((type) => getAffectedSections(type)).filter(Boolean)\n    )\n  )\n\n  if (!userId || affectedSections.length === 0) {\n    return []\n  }\n\n  const runTask = async () => {\n    await markSectionsStale(userId, affectedSections)\n    try {\n      await ensureMetadataTable()\n      const user = await prisma.user.findUnique({\n        where: { id: userId },\n        include: { healthGoals: true },\n      })\n\n      if (!user) return\n\n      const issueNames = user.healthGoals\n        .filter((g) => !g.name.startsWith('__'))\n        .map((g) => g.name.toLowerCase().replace(/[^a-z0-9]+/g, '-'))\n\n      console.log('[manual-regeneration] start', {\n        userId,\n        changeTypes: requestedTypes,\n        affectedSections,\n        issues: issueNames,\n        inline: options.inline === true,\n        preferQuick: options.preferQuick === true,\n        runContext: options.runContext,\n      })\n\n      const providedSlugs =\n        Array.isArray(options.slugs) && options.slugs.length\n          ? Array.from(new Set(options.slugs.map((s) => String(s || '').trim()).filter(Boolean)))\n          : []\n      const targetSlugs = providedSlugs.length ? providedSlugs : issueNames.length ? issueNames : ['general-health']\n\n      const buildContextForPhase = (phase: 'quick' | 'full'): RunContext | null => {\n        if (!options.runContext) return null\n        return {\n          ...options.runContext,\n          meta: {\n            ...(options.runContext.meta || {}),\n            userId,\n            changeTypes: requestedTypes,\n            sections: affectedSections,\n            phase,\n          },\n        }\n      }\n\n      const runWithScopedContext = async (phase: 'quick' | 'full', runner: () => Promise<void>) => {\n        const ctx = buildContextForPhase(phase)\n        if (ctx) {\n          await withRunContext(ctx, runner)\n        } else {\n          await runner()\n        }\n      }\n\n      // Mark as generating (best-effort; fallback slug may not exist in DB)\n      for (const issueSlug of targetSlugs) {\n        for (const section of affectedSections) {\n          await prisma.$queryRawUnsafe(\n            `UPDATE \"InsightsMetadata\" SET \"status\" = 'generating', \"updatedAt\" = NOW() \n             WHERE \"userId\" = $1 AND \"issueSlug\" = $2 AND \"section\" = $3`,\n            userId,\n            issueSlug,\n            section\n          )\n        }\n      }\n\n      // IMPORTANT: When a runContext is provided (manual/targeted regen),\n      // avoid double LLM passes. Skip the quick pass and run the full pass once.\n      const shouldSkipQuick = Boolean(options.runContext)\n      if (options.preferQuick && !shouldSkipQuick) {\n        console.log('[manual-regeneration] quick precompute start', {\n          userId,\n          changeTypes: requestedTypes,\n          sections: affectedSections,\n          issues: targetSlugs,\n        })\n        await runWithScopedContext('quick', () =>\n          precomputeQuickSectionsForUser(userId, {\n            concurrency: 4,\n            sectionsFilter: affectedSections,\n            slugs: targetSlugs,\n          })\n        )\n        console.log('[manual-regeneration] quick precompute complete', {\n          userId,\n          changeTypes: requestedTypes,\n          sections: affectedSections,\n          issues: targetSlugs,\n        })\n      } else if (options.preferQuick && shouldSkipQuick) {\n        console.log('[manual-regeneration] quick precompute skipped (runContext present to avoid double charges)', {\n          userId,\n          changeTypes: requestedTypes,\n          sections: affectedSections,\n          issues: targetSlugs,\n        })\n      }\n\n      console.log('[manual-regeneration] full precompute start', {\n        userId,\n        changeTypes: requestedTypes,\n        sections: affectedSections,\n        issues: targetSlugs,\n      })\n      await runWithScopedContext('full', () =>\n        precomputeIssueSectionsForUser(userId, {\n          concurrency: 4,\n          sectionsFilter: affectedSections,\n          slugs: targetSlugs,\n        })\n      )\n      console.log('[manual-regeneration] full precompute complete', {\n        userId,\n        changeTypes: requestedTypes,\n        sections: affectedSections,\n        issues: targetSlugs,\n      })\n\n      for (const issueSlug of targetSlugs) {\n        for (const section of affectedSections) {\n          await updateMetadataAfterGeneration(userId, issueSlug, section)\n        }\n      }\n      console.log('[manual-regeneration] complete', {\n        userId,\n        changeTypes: requestedTypes,\n        affectedSections,\n        issues: issueNames,\n        inline: options.inline === true,\n        preferQuick: options.preferQuick === true,\n        runContext: options.runContext,\n      })\n    } catch (error) {\n      console.error('[manual-regeneration] Failed to regenerate sections', {\n        userId,\n        changeTypes: requestedTypes,\n        affectedSections,\n        inline: options.inline === true,\n        preferQuick: options.preferQuick === true,\n        runContext: options.runContext,\n        error,\n      })\n      try {\n        await markSectionsStale(userId, affectedSections)\n      } catch {}\n      throw error\n    }\n  }\n\n  try {\n    if (options.inline) {\n      if (options.runContext) {\n        await withRunContext(options.runContext, runTask)\n      } else {\n        await runTask()\n      }\n    } else {\n      // When inline is false, return a promise that resolves when the background run finishes\n      return await new Promise<IssueSectionKey[]>((resolve, reject) => {\n        setImmediate(() => {\n          const runner = async () => {\n            try {\n              if (options.runContext) {\n                await withRunContext(options.runContext, runTask)\n              } else {\n                await runTask()\n              }\n              resolve(affectedSections)\n            } catch (error) {\n              reject(error)\n            }\n          }\n          runner().catch((error) => {\n            console.error('[manual-regeneration] Background regeneration failed', error)\n            reject(error)\n          })\n        })\n      })\n    }\n  } catch (error) {\n    console.error('[manual-regeneration] Failed to start regeneration', error)\n  }\n\n  return affectedSections\n}\n\n/**\n * Get user-friendly status message based on insight status\n */\nexport function getStatusMessage(status: 'fresh' | 'stale' | 'missing' | 'generating', lastGenerated: Date | null): {\n  message: string\n  tone: 'positive' | 'neutral' | 'info'\n} {\n  switch (status) {\n    case 'fresh':\n      if (lastGenerated) {\n        const hoursAgo = Math.floor((Date.now() - lastGenerated.getTime()) / (1000 * 60 * 60))\n        if (hoursAgo < 1) {\n          return { message: 'Fresh insights based on your latest data', tone: 'positive' }\n        } else if (hoursAgo < 24) {\n          return { message: `No changes detected since ${hoursAgo}h ago`, tone: 'neutral' }\n        } else {\n          const daysAgo = Math.floor(hoursAgo / 24)\n          return { message: `No changes detected since ${daysAgo}d ago`, tone: 'neutral' }\n        }\n      }\n      return { message: 'Current insights ready', tone: 'positive' }\n\n    case 'generating':\n      return { message: 'Updating based on your recent changes...', tone: 'info' }\n\n    case 'stale':\n      return { message: 'Updating insights based on your recent changes...', tone: 'info' }\n\n    case 'missing':\n      return { message: 'Generating your personalized insights...', tone: 'info' }\n\n    default:\n      return { message: 'Insights available', tone: 'neutral' }\n  }\n}\n","truncated":false,"size":20908},{"path":"lib/metered-openai.ts","content":"import OpenAI from 'openai';\nimport { costCentsForTokens, estimateTokensFromText } from './cost-meter';\nimport { reportCriticalError } from '@/lib/error-reporter';\n\ntype CreateParams = Parameters<OpenAI['chat']['completions']['create']>[0];\n\nexport type CompletionWithCost<T = any> = {\n  completion: T;\n  costCents: number;\n  promptTokens: number;\n  completionTokens: number;\n};\n\n/**\n * Non-streaming chat completion that returns calculated cost in cents.\n * Callers can then charge the wallet accordingly.\n */\nexport async function chatCompletionWithCost(\n  openai: OpenAI,\n  params: CreateParams\n): Promise<CompletionWithCost<OpenAI.Chat.Completions.ChatCompletion>> {\n  try {\n    const completion = await openai.chat.completions.create({\n      ...params,\n      stream: false,\n    } as any);\n\n    // Try to use official usage first; if absent, fall back to a rough estimate.\n    const usage = (completion as any).usage || {};\n    const model = (completion as any).model || (params as any).model || 'gpt-4o';\n    const promptTokens = Number(usage?.prompt_tokens || 0);\n    const completionTokens = Number(usage?.completion_tokens || 0);\n\n    let costCents = 0;\n    if (promptTokens > 0 || completionTokens > 0) {\n      costCents = costCentsForTokens(model, { promptTokens, completionTokens });\n    } else {\n      // Fallback: estimate from message text and max_tokens\n      const promptText = extractPromptText(params.messages);\n      const maxTokens =\n        Number((params as any).max_tokens) ||\n        Number((params as any).max_completion_tokens) ||\n        0;\n      const expectedOutputChars = Math.max(0, maxTokens * 4);\n      costCents = costCentsForTokens(model, {\n        promptTokens: estimateTokensFromText(promptText),\n        completionTokens: Math.ceil(expectedOutputChars / 4),\n      });\n    }\n\n    return {\n      completion,\n      costCents,\n      promptTokens,\n      completionTokens,\n    };\n  } catch (error) {\n    const model = String((params as any).model || 'unknown')\n    const maxTokens =\n      Number((params as any).max_tokens) ||\n      Number((params as any).max_completion_tokens) ||\n      0\n    reportCriticalError({\n      source: 'openai.chat.completions',\n      error,\n      details: {\n        model,\n        maxTokens,\n      },\n    })\n    throw error\n  }\n}\n\nfunction extractPromptText(messages: any[]): string {\n  try {\n    return (messages || [])\n      .map((m) => {\n        if (!m?.content) return '';\n        if (typeof m.content === 'string') return m.content;\n        if (Array.isArray(m.content)) {\n          return m.content\n            .map((p: any) => (typeof p?.text === 'string' ? p.text : ''))\n            .join('\\n');\n        }\n        return '';\n      })\n      .join('\\n');\n  } catch {\n    return '';\n  }\n}\n\n\n\n\n\n\n\n","truncated":false,"size":2762},{"path":"lib/openai-billing.ts","content":"import { openaiCostCentsForTokens } from './cost-meter'\n\ntype UsageTokenTotals = {\n  promptTokens: number\n  completionTokens: number\n  totalTokens: number\n}\n\nexport type BillingWindow = {\n  startDate: string\n  endDate: string\n  totalUsageCents: number | null\n  costUsd: number | null\n  tokenTotals?: UsageTokenTotals | null\n  source: 'usage' | 'costs' | 'billing_fallback' | 'missing_key' | 'error'\n  usingFallback: boolean\n  fetchedAt: string\n  error?: string | null\n}\n\nconst toNumber = (value: any): number => {\n  const n = Number(value)\n  return Number.isFinite(n) ? n : 0\n}\n\nconst hasValue = (value: any) => value !== undefined && value !== null\n\nconst parseUsdAmount = (value: any): number | null => {\n  if (value === undefined || value === null) return null\n  if (typeof value === 'number' && Number.isFinite(value)) return value\n  if (typeof value === 'string') {\n    const trimmed = value.trim()\n    if (!trimmed) return null\n    // OpenAI cost export sometimes uses stringified numerics like \"0E-6176\".\n    const n = Number(trimmed)\n    return Number.isFinite(n) ? n : null\n  }\n  return null\n}\n\nconst dateToUnixStartUtc = (yyyyMmDd: string): number => {\n  const d = new Date(`${yyyyMmDd}T00:00:00Z`)\n  return Math.floor(d.getTime() / 1000)\n}\n\nconst addDaysIso = (yyyyMmDd: string, days: number): string => {\n  const d = new Date(`${yyyyMmDd}T00:00:00Z`)\n  d.setUTCDate(d.getUTCDate() + days)\n  return d.toISOString().slice(0, 10)\n}\n\nfunction summarizeUsageList(body: any): { usageCents: number | null; tokens?: UsageTokenTotals | null } {\n  if (!body) return { usageCents: null, tokens: null }\n\n  const directCents = hasValue(body.total_usage) ? toNumber(body.total_usage) : null\n\n  let promptTokens = 0\n  let completionTokens = 0\n  let tokenSeen = false\n\n  if (Array.isArray(body.data)) {\n    for (const item of body.data) {\n      const p = toNumber(\n        item?.prompt_tokens ??\n          item?.input_tokens ??\n          item?.n_prompt_tokens ??\n          item?.usage?.prompt_tokens ??\n          0\n      )\n      const c = toNumber(\n        item?.completion_tokens ??\n          item?.output_tokens ??\n          item?.n_completion_tokens ??\n          item?.usage?.completion_tokens ??\n          0\n      )\n      if (p || c) tokenSeen = true\n      promptTokens += p\n      completionTokens += c\n    }\n  }\n\n  const tokens =\n    tokenSeen || directCents !== null\n      ? {\n          promptTokens,\n          completionTokens,\n          totalTokens: promptTokens + completionTokens,\n        }\n      : null\n\n  return {\n    usageCents: directCents,\n    tokens,\n  }\n}\n\nexport async function fetchOpenAIUsageTotals(args: { startDate: string; endDate: string }): Promise<BillingWindow> {\n  const startDate = args.startDate\n  const endDate = args.endDate\n  const fetchedAt = new Date().toISOString()\n  const apiKey = process.env.OPENAI_API_KEY\n  const projectId = process.env.OPENAI_PROJECT_ID || process.env.OPENAI_PROJECT\n  const orgId = process.env.OPENAI_ORG_ID || process.env.OPENAI_ORGANIZATION || process.env.OPENAI_ORG\n\n  if (!apiKey) {\n    return {\n      startDate,\n      endDate,\n      totalUsageCents: null,\n      costUsd: null,\n      source: 'missing_key',\n      usingFallback: true,\n      fetchedAt,\n      error: 'OPENAI_API_KEY is not set',\n    }\n  }\n\n  const headers = {\n    Authorization: `Bearer ${apiKey}`,\n  }\n  if (orgId) {\n    ;(headers as any)['OpenAI-Organization'] = orgId\n  }\n\n  const headerVariants: Record<string, string>[] = projectId\n    ? [headers, { ...headers, 'OpenAI-Project': projectId }]\n    : [headers]\n\n  const errors: string[] = []\n\n  // Helper: try a direct call\n  const tryCall = async (label: string, url: string, source: 'usage' | 'billing_fallback', usingFallback: boolean) => {\n    for (const hv of headerVariants) {\n      try {\n        const resp = await fetch(url, { headers: hv, method: 'GET' })\n        const body = await resp.json().catch(() => ({}))\n        if (!resp.ok) {\n          const msg = body?.error?.message || resp.statusText || `${label} failed`\n          errors.push(`${label}: ${msg} (status ${resp.status})`)\n          continue\n        }\n        const parsed = source === 'usage' ? summarizeUsageList(body) : { usageCents: body?.total_usage ?? null, tokens: null }\n        const cents =\n          parsed.usageCents !== null\n            ? toNumber(parsed.usageCents)\n            : hasValue(body.total_usage)\n            ? toNumber(body.total_usage)\n            : null\n        if (cents !== null) {\n          return {\n            startDate,\n            endDate,\n            totalUsageCents: cents,\n            costUsd: cents / 100,\n            tokenTotals: parsed.tokens || null,\n            source,\n            usingFallback,\n            fetchedAt,\n            error: errors.length ? errors[errors.length - 1] : null,\n          }\n        }\n        errors.push(`${label} returned no total_usage`)\n      } catch (err: any) {\n        errors.push(`${label} exception: ${err?.message || 'unknown'}`)\n      }\n    }\n    return null\n  }\n\n  // Prefer the newer org costs endpoint (matches OpenAI dashboard \"Export ‚Üí Cost data\").\n  // Use an inclusive end by querying until endDate+1 at 00:00Z.\n  const tryFetchOrgCosts = async (): Promise<BillingWindow | null> => {\n    const startTime = dateToUnixStartUtc(startDate)\n    const endTime = dateToUnixStartUtc(addDaysIso(endDate, 1))\n    const urls = [\n      `https://api.openai.com/v1/organization/costs?start_time=${startTime}&end_time=${endTime}&bucket_width=1d`,\n      `https://api.openai.com/v1/organization/costs?start_time=${startTime}&end_time=${endTime}&bucket_width=1d&group_by=project_id`,\n      `https://api.openai.com/v1/organization/costs?start_time=${startTime}&end_time=${endTime}&bucket_width=1d&group_by[]=project_id`,\n    ]\n\n    for (const url of urls) {\n      for (const hv of headerVariants) {\n        try {\n          const resp = await fetch(url, { headers: hv, method: 'GET' })\n          const body = await resp.json().catch(() => ({}))\n          if (!resp.ok) {\n            const msg = body?.error?.message || resp.statusText || `org_costs failed`\n            errors.push(`org_costs: ${msg} (status ${resp.status})`)\n            continue\n          }\n\n          const buckets = Array.isArray(body?.data) ? body.data : []\n          let sumUsd = 0\n          let sawAny = false\n\n          for (const bucket of buckets) {\n            const results = Array.isArray(bucket?.results) ? bucket.results : []\n            for (const r of results) {\n              if (projectId && typeof r?.project_id === 'string' && r.project_id !== projectId) continue\n              const usd = parseUsdAmount(r?.amount?.value)\n              if (usd === null) continue\n              sumUsd += usd\n              sawAny = true\n            }\n          }\n\n          if (!sawAny) {\n            errors.push('org_costs returned no usable cost buckets')\n            continue\n          }\n\n          const totalUsageCents = Math.round(sumUsd * 100)\n          return {\n            startDate,\n            endDate,\n            totalUsageCents,\n            costUsd: totalUsageCents / 100,\n            tokenTotals: null,\n            source: 'costs',\n            usingFallback: false,\n            fetchedAt,\n            error: errors.length ? errors[errors.length - 1] : null,\n          }\n        } catch (err: any) {\n          errors.push(`org_costs exception: ${err?.message || 'unknown'}`)\n        }\n      }\n    }\n    return null\n  }\n\n  const costs = await tryFetchOrgCosts()\n  if (costs) return costs\n\n  // OpenAI's vendor billing endpoints under /dashboard/* now require a browser session\n  // and will 401 for API keys. Also, many usage endpoints reject start/end and only\n  // accept a single `date` param. Avoid noisy multi-request fallbacks (rate limits).\n  const usageSingle = await tryCall('usage_single', `https://api.openai.com/v1/usage?date=${endDate}`, 'usage', false)\n  if (usageSingle) return usageSingle\n\n  errors.push('OpenAI usage totals unavailable for this account; falling back to Helfi logs + rate card estimates.')\n\n  // If everything failed, return error\n  return {\n    startDate,\n    endDate,\n    totalUsageCents: null,\n    costUsd: null,\n    tokenTotals: null,\n    source: 'error',\n    usingFallback: true,\n    fetchedAt,\n    error: errors.join(' | ') || 'OpenAI billing fetch failed',\n  }\n}\n\n// Helper to compute cost at OpenAI rate card for a batch of tokens.\nexport function computeCostCentsFromTokens(model: string, promptTokens: number, completionTokens: number): number {\n  return openaiCostCentsForTokens(model || 'gpt-4o', {\n    promptTokens,\n    completionTokens,\n  })\n}\n","truncated":false,"size":8591},{"path":"lib/owner-notifications.ts","content":"import { prisma } from '@/lib/prisma'\nimport webpush from 'web-push'\nimport { normalizeSubscriptionList, removeSubscriptionsByEndpoint, sendToSubscriptions } from '@/lib/push-subscriptions'\n\n/**\n * Owner Notification System\n * Sends push notifications to the app owner when important events occur:\n * - New user signups\n * - Subscription purchases\n * - Credit purchases\n * \n * Uses the same web-push system as check-in reminders.\n * Owner must subscribe to push notifications first via their account.\n */\n\ninterface NotificationOptions {\n  event: 'signup' | 'subscription' | 'credit_purchase'\n  userEmail: string\n  userName?: string\n  amount?: number // in cents\n  currency?: string\n  planName?: string\n  creditAmount?: number\n  additionalInfo?: string\n}\n\n/**\n * Get owner's user ID from email (checks both User and AdminUser tables)\n */\nasync function getOwnerUserId(): Promise<string | null> {\n  const ownerEmail = process.env.OWNER_EMAIL\n  if (!ownerEmail) {\n    console.log('üì± Owner email not configured (set OWNER_EMAIL environment variable)')\n    return null\n  }\n\n  try {\n    // First check AdminUser table (for admin panel users)\n    const adminUser = await prisma.adminUser.findUnique({\n      where: { email: ownerEmail.toLowerCase() },\n      select: { id: true }\n    })\n    \n    if (adminUser) {\n      // For admin users, we need to find their corresponding User account\n      // or create a mapping. For now, let's check if there's a User with same email\n      const regularUser = await prisma.user.findUnique({\n        where: { email: ownerEmail.toLowerCase() },\n        select: { id: true }\n      })\n      return regularUser?.id || null\n    }\n\n    // Fallback to regular User table\n    const owner = await prisma.user.findUnique({\n      where: { email: ownerEmail.toLowerCase() },\n      select: { id: true }\n    })\n    return owner?.id || null\n  } catch (error) {\n    console.error('‚ùå Failed to find owner user:', error)\n    return null\n  }\n}\n\n/**\n * Get owner's push subscription from database\n */\nasync function getOwnerSubscription(): Promise<{ userId: string; subscription: any } | null> {\n  const ownerUserId = await getOwnerUserId()\n  if (!ownerUserId) {\n    return null\n  }\n\n  try {\n    // Ensure table exists\n    // await prisma.$executeRawUnsafe(`\n    //   CREATE TABLE IF NOT EXISTS PushSubscriptions (\n    //     userId TEXT PRIMARY KEY,\n    //     subscription JSONB NOT NULL\n    //   )\n    // `)\n\n    const rows: Array<{ subscription: any }> = await prisma.$queryRawUnsafe(\n      `SELECT subscription FROM PushSubscriptions WHERE userId = $1`,\n      ownerUserId\n    )\n\n    if (!rows.length) {\n      console.log('üì± Owner has not subscribed to push notifications yet')\n      return null\n    }\n\n    return { userId: ownerUserId, subscription: rows[0].subscription }\n  } catch (error) {\n    console.error('‚ùå Failed to get owner subscription:', error)\n    return null\n  }\n}\n\n/**\n * Format amount in cents to currency string\n */\nfunction formatAmount(cents: number, currency: string = 'USD'): string {\n  const amount = cents / 100\n  return new Intl.NumberFormat('en-US', {\n    style: 'currency',\n    currency: currency,\n  }).format(amount)\n}\n\n/**\n * Generate notification payload based on event type\n */\nfunction generateNotificationPayload(options: NotificationOptions): { title: string; body: string; url: string } {\n  const { event, userEmail, userName, amount, currency, planName, creditAmount } = options\n  const displayName = userName || userEmail.split('@')[0]\n\n  switch (event) {\n    case 'signup': {\n      return {\n        title: 'üéâ New User Signup',\n        body: `${displayName} just signed up!`,\n        url: '/admin-panel'\n      }\n    }\n\n    case 'subscription': {\n      const amountStr = amount ? formatAmount(amount, currency) : 'N/A'\n      const planStr = planName || 'Premium'\n      return {\n        title: 'üí∞ New Subscription',\n        body: `${displayName} purchased ${planStr} (${amountStr})`,\n        url: '/admin-panel'\n      }\n    }\n\n    case 'credit_purchase': {\n      const amountStr = amount ? formatAmount(amount, currency) : 'N/A'\n      const creditsStr = creditAmount ? `${creditAmount} credits` : 'credits'\n      return {\n        title: 'üí≥ Credit Purchase',\n        body: `${displayName} bought ${creditsStr} (${amountStr})`,\n        url: '/admin-panel'\n      }\n    }\n  }\n}\n\n/**\n * Send push notification to owner\n * This function is non-blocking and won't throw errors\n */\nexport async function notifyOwner(options: NotificationOptions): Promise<void> {\n  try {\n    // 1) Attempt to deliver via Upstash QStash (same infra used for reminders)\n    //    This gives us retries and decouples from the request that triggered the event.\n    const qstashToken = process.env.QSTASH_TOKEN || ''\n    const schedulerSecret = process.env.SCHEDULER_SECRET || ''\n    let base =\n      process.env.PUBLIC_BASE_URL ||\n      (process.env.VERCEL_URL ? `https://${process.env.VERCEL_URL}` : '') ||\n      process.env.NEXT_PUBLIC_APP_URL ||\n      ''\n    if (base) {\n      base = base.trim()\n      if (base && !/^https?:\\/\\//i.test(base)) {\n        base = `https://${base}`\n      }\n      base = base.replace(/\\/+$/, '')\n    }\n    if (qstashToken && base) {\n      try {\n        const callbackUrl = `${base}/api/push/owner`\n        const headers: Record<string, string> = {\n          Authorization: `Bearer ${qstashToken}`,\n          'Content-Type': 'application/json',\n        }\n        if (schedulerSecret) {\n          headers['Upstash-Forward-Authorization'] = `Bearer ${schedulerSecret}`\n        }\n        const res = await fetch(`https://qstash.upstash.io/v2/publish/${callbackUrl}`, {\n          method: 'POST',\n          headers,\n          body: JSON.stringify(options),\n        })\n        // If QStash accepted the message, we can return early and let it handle retries/delivery\n        if (res.ok) {\n          // Log enqueue\n          try {\n            // await prisma.$executeRawUnsafe(`\n            //   CREATE TABLE IF NOT EXISTS OwnerPushLog (\n            //     createdAt TIMESTAMP NOT NULL DEFAULT NOW(),\n            //     event TEXT,\n            //     userEmail TEXT,\n            //     status TEXT,\n            //     info TEXT\n            //   )\n            // `)\n            await prisma.$executeRawUnsafe(\n              `INSERT INTO OwnerPushLog (event, userEmail, status, info) VALUES ($1, $2, $3, $4)`,\n              options.event,\n              options.userEmail,\n              'enqueued_qstash',\n              null\n            )\n          } catch {}\n          console.log(`üì¢ [OWNER NOTIFICATION] Enqueued via QStash: ${options.event}`)\n          return\n        } else {\n          const text = await res.text().catch(() => '')\n          console.warn('[OWNER NOTIFICATION] QStash publish failed, falling back to direct push:', res.status, text.slice(0, 200))\n        }\n      } catch (e) {\n        console.warn('[OWNER NOTIFICATION] QStash publish error, falling back to direct push')\n      }\n    }\n\n    // 2) Fallback: direct web-push delivery (same as reminders use under the hood)\n    const publicKey = process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY || ''\n    const privateKey = process.env.VAPID_PRIVATE_KEY || ''\n    \n    if (!publicKey || !privateKey) {\n      console.log('üì± VAPID keys not configured - push notifications disabled')\n      return\n    }\n\n    const subscriptionInfo = await getOwnerSubscription()\n    if (!subscriptionInfo) {\n      // Silently fail - owner hasn't subscribed yet\n      return\n    }\n    const subscriptions = normalizeSubscriptionList(subscriptionInfo.subscription)\n    if (!subscriptions.length) {\n      return\n    }\n\n    webpush.setVapidDetails('mailto:support@helfi.ai', publicKey, privateKey)\n\n    const payload = generateNotificationPayload(options)\n    const payloadJson = JSON.stringify(payload)\n\n    // Send notification (don't await to avoid blocking)\n    sendToSubscriptions(subscriptions, (sub) => webpush.sendNotification(sub, payloadJson)).then(async (result) => {\n      if (result.goneEndpoints.length) {\n        const remaining = removeSubscriptionsByEndpoint(subscriptions, result.goneEndpoints)\n        await prisma.$executeRawUnsafe(\n          `UPDATE PushSubscriptions SET subscription = $2::jsonb, updatedAt = NOW() WHERE userId = $1`,\n          subscriptionInfo.userId,\n          JSON.stringify(remaining)\n        ).catch(() => {})\n      }\n      if (!result.sent) {\n        throw new Error('owner_push_failed')\n      }\n      try {\n        // await prisma.$executeRawUnsafe(`\n        //   CREATE TABLE IF NOT EXISTS OwnerPushLog (\n        //     createdAt TIMESTAMP NOT NULL DEFAULT NOW(),\n        //     event TEXT,\n        //     userEmail TEXT,\n        //     status TEXT,\n        //     info TEXT\n        //   )\n        // `)\n        await prisma.$executeRawUnsafe(\n          `INSERT INTO OwnerPushLog (event, userEmail, status, info) VALUES ($1, $2, $3, $4)`,\n          options.event,\n          options.userEmail,\n          'sent_direct',\n          null\n        )\n      } catch {}\n    }).catch((error: any) => {\n      console.error('‚ùå [OWNER PUSH] Failed to send:', error?.body || error?.message || error)\n      try {\n        prisma.$executeRawUnsafe(\n          `INSERT INTO OwnerPushLog (event, userEmail, status, info) VALUES ($1, $2, $3, $4)`,\n          options.event,\n          options.userEmail,\n          'error_direct',\n          String(error?.body || error?.message || error).slice(0, 500)\n        ).catch(() => {})\n      } catch {}\n      // If subscription is invalid, we could optionally remove it here\n      // But for now, just log the error\n    })\n\n    console.log(`üì¢ [OWNER NOTIFICATION] Queued ${options.event} push notification`)\n  } catch (error) {\n    // Never throw - notifications are non-critical\n    console.error('‚ùå [OWNER NOTIFICATION] Failed to queue notification:', error)\n  }\n}\n","truncated":false,"size":9838},{"path":"lib/partner-outreach-seed.ts","content":"export type PartnerOutreachSeedEntry = {\n  name: string\n  email: string\n  company: string\n  region?: string\n  notes?: string\n  sourceUrl?: string\n}\n\nexport const partnerOutreachSeed: PartnerOutreachSeedEntry[] = [\n  {\n    name: 'PartnerHub Support',\n    email: 'partnerhub@woolworths.com.au',\n    company: 'Woolworths Group',\n    region: 'AU',\n    notes: 'Supplier onboarding / NPC support',\n    sourceUrl: 'https://gs1au.org/services/data-and-content/national-product-catalogue/supplier-onboarding/woolworths-npc'\n  },\n  {\n    name: 'NPC Customer Support',\n    email: 'npccustomersupport@gs1au.org',\n    company: 'GS1 Australia (NPC)',\n    region: 'AU',\n    notes: 'National Product Catalogue support',\n    sourceUrl: 'https://gs1au.org/services/data-and-content/national-product-catalogue/supplier-onboarding/woolworths-npc'\n  },\n  {\n    name: 'Customer Services (Suppliers)',\n    email: 'customer.service@metcashfg.com',\n    company: 'Metcash / IGA',\n    region: 'AU',\n    notes: 'Supplier enquiries',\n    sourceUrl: 'https://www.metcash.com/contact/'\n  },\n  {\n    name: 'General Support',\n    email: 'info@gs1us.org',\n    company: 'GS1 US',\n    region: 'US',\n    notes: 'GS1 US contact',\n    sourceUrl: 'https://www.gs1us.org/who-we-are/contact-us'\n  },\n  {\n    name: 'Business Development',\n    email: 'businessdevelopment@gs1us.org',\n    company: 'GS1 US Data Hub',\n    region: 'US',\n    notes: 'Data Hub View/Use inquiries',\n    sourceUrl: 'https://www.gs1us.org/lp/data-hub-search-verify/confirmation'\n  },\n  {\n    name: 'API Support',\n    email: 'api@edamam.com',\n    company: 'Edamam',\n    region: 'US',\n    notes: 'Food Database API support',\n    sourceUrl: 'https://developer.edamam.com/faq'\n  },\n  {\n    name: 'Contact',\n    email: 'contact@openfoodfacts.org',\n    company: 'Open Food Facts',\n    region: 'Global',\n    notes: 'Open data contact',\n    sourceUrl: 'https://world.openfoodfacts.org/contact'\n  }\n]\n","truncated":false,"size":1923},{"path":"lib/pdf-processor.ts","content":"/**\n * PDF processing utilities for lab reports\n * Handles password-protected PDFs, text extraction, and lab value parsing\n * Uses pdfjs-dist with server-side configuration\n */\n\n// For server-side, we need to use a different approach\n// pdfjs-dist has issues with DOMMatrix in Node.js, so we'll use pdf-parse as fallback\n// or configure pdfjs-dist to work without DOM APIs\n\nlet pdfjsLib: any;\nlet getDocument: any;\nlet PDFDocumentProxy: any;\n\n// Dynamic import to handle server-side vs client-side\nif (typeof window === 'undefined') {\n  // Server-side: Use pdfjs-dist without worker (synchronous mode)\n  // This avoids DOMMatrix issues\n  const pdfjs = require('pdfjs-dist/legacy/build/pdf.mjs');\n  pdfjsLib = pdfjs;\n  getDocument = pdfjs.getDocument;\n  \n  // Disable worker for server-side (use synchronous rendering)\n  pdfjsLib.GlobalWorkerOptions.workerSrc = '';\n} else {\n  // Client-side: Use standard pdfjs-dist\n  pdfjsLib = require('pdfjs-dist');\n  getDocument = pdfjsLib.getDocument;\n  pdfjsLib.GlobalWorkerOptions.workerSrc = `//cdnjs.cloudflare.com/ajax/libs/pdf.js/${pdfjsLib.version}/pdf.worker.min.js`;\n}\n\n// Type definitions\nexport interface LabValue {\n  analyteName: string;\n  value: string;\n  unit?: string;\n  referenceRange?: string;\n  collectionDate?: string;\n  accessionNumber?: string;\n  laboratoryName?: string;\n}\n\nexport interface PDFProcessingResult {\n  text: string;\n  labValues: LabValue[];\n  pageCount: number;\n}\n\nexport type PDFDocumentProxyType = any;\n\n/**\n * Load and decrypt password-protected PDF\n */\nexport async function loadPDF(\n  pdfBuffer: Buffer,\n  password?: string\n): Promise<PDFDocumentProxyType> {\n  const loadingTask = getDocument({\n    data: pdfBuffer,\n    password: password,\n    useWorkerFetch: false, // Disable worker fetch for server-side\n    isEvalSupported: false, // Disable eval for security\n    verbosity: 0, // Reduce logging\n  });\n\n  try {\n    const pdf = await loadingTask.promise;\n    return pdf;\n  } catch (error: any) {\n    if (error.name === 'PasswordException') {\n      throw new Error('PDF password incorrect or required');\n    }\n    throw new Error(`Failed to load PDF: ${error.message}`);\n  }\n}\n\n/**\n * Extract text from PDF\n */\nexport async function extractTextFromPDF(pdf: PDFDocumentProxyType): Promise<string> {\n  let fullText = '';\n  const numPages = pdf.numPages;\n\n  for (let pageNum = 1; pageNum <= numPages; pageNum++) {\n    const page = await pdf.getPage(pageNum);\n    const textContent = await page.getTextContent();\n    \n    // Combine text items with proper spacing\n    const pageText = textContent.items\n      .map((item: any) => item.str)\n      .join(' ');\n    \n    fullText += pageText + '\\n\\n';\n  }\n\n  return fullText.trim();\n}\n\n/**\n * Parse lab values from extracted text\n * Uses pattern matching to identify common lab test formats\n */\nexport function parseLabValues(text: string): LabValue[] {\n  const labValues: LabValue[] = [];\n  \n  // Common patterns for lab results\n  // Format: Test Name | Value | Unit | Reference Range\n  // Example: \"Glucose | 95 | mg/dL | 70-100\"\n  \n  const lines = text.split('\\n');\n  let currentLabName = '';\n  let currentLabDate: string | undefined;\n  let currentAccession: string | undefined;\n  let currentLabName_full: string | undefined;\n  \n  // Try to extract lab name and date from header\n  for (const line of lines.slice(0, 20)) {\n    // Look for date patterns\n    const dateMatch = line.match(/(\\d{1,2}[\\/\\-]\\d{1,2}[\\/\\-]\\d{2,4})/);\n    if (dateMatch && !currentLabDate) {\n      currentLabDate = dateMatch[1];\n    }\n    \n    // Look for accession numbers\n    const accessionMatch = line.match(/accession[:\\s]+([A-Z0-9\\-]+)/i);\n    if (accessionMatch && !currentAccession) {\n      currentAccession = accessionMatch[1];\n    }\n    \n    // Look for lab name\n    const labNameMatch = line.match(/([A-Z][A-Z\\s&]+(?:LABORATORY|LAB|DIAGNOSTICS|MEDICAL))/i);\n    if (labNameMatch && !currentLabName_full) {\n      currentLabName_full = labNameMatch[1].trim();\n    }\n  }\n  \n  // Parse test results\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i].trim();\n    if (!line) continue;\n    \n    // Pattern 1: Test Name | Value | Unit | Range\n    const pipePattern = /^([A-Z][A-Za-z\\s]+?)\\s*\\|\\s*([\\d.]+)\\s*\\|\\s*([A-Za-z\\/%]+)\\s*\\|\\s*([\\d.\\-\\s<>]+)$/;\n    const pipeMatch = line.match(pipePattern);\n    \n    if (pipeMatch) {\n      labValues.push({\n        analyteName: pipeMatch[1].trim(),\n        value: pipeMatch[2].trim(),\n        unit: pipeMatch[3].trim(),\n        referenceRange: pipeMatch[4].trim(),\n        collectionDate: currentLabDate,\n        accessionNumber: currentAccession,\n        laboratoryName: currentLabName_full,\n      });\n      continue;\n    }\n    \n    // Pattern 2: Test Name: Value Unit (Range)\n    const colonPattern = /^([A-Z][A-Za-z\\s]+?):\\s*([\\d.]+)\\s*([A-Za-z\\/%]+)\\s*\\(([\\d.\\-\\s<>]+)\\)$/;\n    const colonMatch = line.match(colonPattern);\n    \n    if (colonMatch) {\n      labValues.push({\n        analyteName: colonMatch[1].trim(),\n        value: colonMatch[2].trim(),\n        unit: colonMatch[3].trim(),\n        referenceRange: colonMatch[4].trim(),\n        collectionDate: currentLabDate,\n        accessionNumber: currentAccession,\n        laboratoryName: currentLabName_full,\n      });\n      continue;\n    }\n    \n    // Pattern 3: Test Name Value Unit Range (tab or multiple spaces)\n    const tabPattern = /^([A-Z][A-Za-z\\s]+?)\\s{2,}([\\d.]+)\\s+([A-Za-z\\/%]+)\\s+([\\d.\\-\\s<>]+)$/;\n    const tabMatch = line.match(tabPattern);\n    \n    if (tabMatch) {\n      labValues.push({\n        analyteName: tabMatch[1].trim(),\n        value: tabMatch[2].trim(),\n        unit: tabMatch[3].trim(),\n        referenceRange: tabMatch[4].trim(),\n        collectionDate: currentLabDate,\n        accessionNumber: currentAccession,\n        laboratoryName: currentLabName_full,\n      });\n      continue;\n    }\n    \n    // Pattern 4: Common test names followed by value\n    const commonTests = [\n      'Glucose', 'Cholesterol', 'HDL', 'LDL', 'Triglycerides',\n      'Hemoglobin', 'Hematocrit', 'WBC', 'RBC', 'Platelets',\n      'Sodium', 'Potassium', 'Creatinine', 'BUN', 'ALT', 'AST',\n      'TSH', 'T4', 'T3', 'Vitamin D', 'B12', 'Folate',\n    ];\n    \n    for (const testName of commonTests) {\n      const testPattern = new RegExp(`^${testName}[:\\s]+([\\d.]+)\\\\s*([A-Za-z\\/%]+)?`, 'i');\n      const testMatch = line.match(testPattern);\n      \n      if (testMatch) {\n        labValues.push({\n          analyteName: testName,\n          value: testMatch[1].trim(),\n          unit: testMatch[2]?.trim(),\n          collectionDate: currentLabDate,\n          accessionNumber: currentAccession,\n          laboratoryName: currentLabName_full,\n        });\n        break;\n      }\n    }\n  }\n  \n  // If no structured data found, try to extract any number-value pairs\n  if (labValues.length === 0) {\n    // Fallback: look for any pattern that might be a lab value\n    const fallbackPattern = /([A-Z][A-Za-z\\s]{2,30}?)[:\\s]+([\\d.]+)\\s*([A-Za-z\\/%]+)?/g;\n    let match;\n    \n    while ((match = fallbackPattern.exec(text)) !== null) {\n      const testName = match[1].trim();\n      // Skip if it looks like a date or other non-test value\n      if (testName.length > 3 && testName.length < 50 && !testName.match(/^\\d/)) {\n        labValues.push({\n          analyteName: testName,\n          value: match[2].trim(),\n          unit: match[3]?.trim(),\n          collectionDate: currentLabDate,\n          accessionNumber: currentAccession,\n          laboratoryName: currentLabName_full,\n        });\n      }\n    }\n  }\n  \n  return labValues;\n}\n\n/**\n * Process PDF: decrypt, extract text, and parse lab values\n */\nexport async function processPDF(\n  pdfBuffer: Buffer,\n  password?: string\n): Promise<PDFProcessingResult> {\n  // Load PDF (with password if provided)\n  const pdf = await loadPDF(pdfBuffer, password);\n  const pageCount = pdf.numPages;\n  \n  // Extract text\n  const text = await extractTextFromPDF(pdf);\n  \n  // Parse lab values\n  const labValues = parseLabValues(text);\n  \n  return {\n    text,\n    labValues,\n    pageCount,\n  };\n}\n\n","truncated":false,"size":8042},{"path":"lib/prisma.ts","content":"import { PrismaClient } from '@prisma/client'\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined\n}\n\nexport const prisma = globalForPrisma.prisma ?? new PrismaClient({\n  log: process.env.NODE_ENV === 'development' ? ['error', 'warn'] : ['error'],\n})\n\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma\n\n// Disconnect on process termination\nif (process.env.NODE_ENV === 'production') {\n  process.on('beforeExit', async () => {\n    await prisma.$disconnect()\n  })\n} ","truncated":false,"size":523},{"path":"lib/push-subscriptions.ts","content":"export type PushSubscriptionRecord = Record<string, any>\n\nexport function getSubscriptionEndpoint(subscription: PushSubscriptionRecord | null | undefined): string | null {\n  if (!subscription || typeof subscription !== 'object') return null\n  const endpoint = subscription.endpoint\n  return typeof endpoint === 'string' && endpoint.length > 0 ? endpoint : null\n}\n\nexport function normalizeSubscriptionList(raw: unknown): PushSubscriptionRecord[] {\n  const list = Array.isArray(raw) ? raw : raw ? [raw] : []\n  return list.filter((item) => item && typeof item === 'object') as PushSubscriptionRecord[]\n}\n\nexport function dedupeSubscriptions(list: PushSubscriptionRecord[]): PushSubscriptionRecord[] {\n  const seen = new Set<string>()\n  const out: PushSubscriptionRecord[] = []\n\n  for (const sub of list) {\n    const endpoint = getSubscriptionEndpoint(sub)\n    const key = endpoint || JSON.stringify(sub)\n    if (seen.has(key)) continue\n    seen.add(key)\n    out.push(sub)\n  }\n\n  return out\n}\n\nexport function mergeSubscriptionList(existingRaw: unknown, incoming: unknown): PushSubscriptionRecord[] {\n  const existing = normalizeSubscriptionList(existingRaw)\n  const next = [...existing]\n  if (incoming && typeof incoming === 'object') {\n    next.push(incoming as PushSubscriptionRecord)\n  }\n  return dedupeSubscriptions(next)\n}\n\nexport function removeSubscriptionsByEndpoint(\n  list: PushSubscriptionRecord[],\n  endpointsToRemove: string[],\n): PushSubscriptionRecord[] {\n  if (!endpointsToRemove.length) return list\n  const removeSet = new Set(endpointsToRemove)\n  return list.filter((sub) => {\n    const endpoint = getSubscriptionEndpoint(sub)\n    return !endpoint || !removeSet.has(endpoint)\n  })\n}\n\nexport type PushSendResult = {\n  sent: number\n  errors: Array<{ endpoint: string | null; message: string; statusCode?: number }>\n  goneEndpoints: string[]\n}\n\nexport async function sendToSubscriptions(\n  subscriptions: PushSubscriptionRecord[],\n  sendFn: (subscription: PushSubscriptionRecord) => Promise<unknown>,\n): Promise<PushSendResult> {\n  const results = await Promise.allSettled(subscriptions.map((sub) => sendFn(sub)))\n  const errors: Array<{ endpoint: string | null; message: string; statusCode?: number }> = []\n  const goneEndpoints: string[] = []\n  let sent = 0\n\n  results.forEach((result, index) => {\n    const subscription = subscriptions[index]\n    if (result.status === 'fulfilled') {\n      sent += 1\n      return\n    }\n    const error: any = result.reason\n    const statusCode = error?.statusCode || error?.status\n    const message = String(error?.body || error?.message || error || 'push_error')\n    const endpoint = getSubscriptionEndpoint(subscription)\n    errors.push({ endpoint, message, statusCode })\n    if (statusCode === 404 || statusCode === 410) {\n      if (endpoint) goneEndpoints.push(endpoint)\n    }\n  })\n\n  return { sent, errors, goneEndpoints }\n}\n","truncated":false,"size":2879},{"path":"lib/qstash.ts","content":"import { prisma } from '@/lib/prisma'\nimport { randomUUID } from 'crypto'\n\n/**\n * Compute minutes from now (UTC clock) until the next occurrence of HH:MM in the given IANA timezone.\n * We avoid heavy tz libs by comparing only local HH:MM within the zone, then applying the delta to Date.now().\n */\nexport function minutesUntilNext(timeHHMM: string, timeZone: string): number {\n  const now = new Date()\n  const fmt = new Intl.DateTimeFormat('en-GB', {\n    timeZone,\n    hour: '2-digit',\n    minute: '2-digit',\n    hour12: false,\n  })\n  const parts = fmt.formatToParts(now)\n  const hh = parseInt(parts.find((p) => p.type === 'hour')?.value || '0', 10)\n  const mm = parseInt(parts.find((p) => p.type === 'minute')?.value || '0', 10)\n  const nowMins = hh * 60 + mm\n\n  const [tH, tM] = timeHHMM.split(':').map((v) => parseInt(v, 10))\n  const targetMins = (tH % 24) * 60 + (tM % 60)\n\n  let delta = (targetMins - nowMins) % 1440\n  if (delta < 0) delta += 1440\n  if (delta === 0) delta = 1440 // schedule next day if exact same minute\n  return delta\n}\n\n/**\n * Schedule a QStash callback to our /api/push/dispatch endpoint.\n * Requires: QSTASH_TOKEN, and base URL derivable from PUBLIC_BASE_URL or VERCEL_URL.\n */\ntype ScheduleLogRecord = {\n  userId: string\n  reminderTime: string\n  timezone: string\n  deltaMinutes: number\n  notBeforeEpochSeconds: number | null\n  scheduled: boolean\n  httpStatus?: number | null\n  reason?: string\n  responseSnippet?: string | null\n  callbackUrl?: string | null\n}\n\nasync function logScheduleAttempt(entry: ScheduleLogRecord) {\n  try {\n    // await prisma.$executeRawUnsafe(`\n    //   CREATE TABLE IF NOT EXISTS QstashScheduleLog (\n    //     id TEXT PRIMARY KEY,\n    //     createdAt TIMESTAMP NOT NULL DEFAULT NOW(),\n    //     userId TEXT,\n    //     reminderTime TEXT,\n    //     timezone TEXT,\n    //     deltaMinutes INTEGER,\n    //     notBeforeEpochSeconds BIGINT,\n    //     scheduled BOOLEAN NOT NULL,\n    //     httpStatus INTEGER,\n    //     reason TEXT,\n    //     responseSnippet TEXT,\n    //     callbackUrl TEXT\n    //   )\n    // `)\n    // await prisma.$executeRawUnsafe(`ALTER TABLE QstashScheduleLog ADD COLUMN IF NOT EXISTS callbackUrl TEXT`).catch(\n    //   () => {}\n    // )\n    // await prisma.$executeRawUnsafe(\n    //   `ALTER TABLE QstashScheduleLog ADD COLUMN IF NOT EXISTS responseSnippet TEXT`\n    // ).catch(() => {})\n    // await prisma.$executeRawUnsafe(`ALTER TABLE QstashScheduleLog ADD COLUMN IF NOT EXISTS reason TEXT`).catch(\n    //   () => {}\n    // )\n    // await prisma.$executeRawUnsafe(`ALTER TABLE QstashScheduleLog ADD COLUMN IF NOT EXISTS httpStatus INTEGER`).catch(\n    //   () => {}\n    // )\n    // await prisma.$executeRawUnsafe(\n    //   `ALTER TABLE QstashScheduleLog ADD COLUMN IF NOT EXISTS notBeforeEpochSeconds BIGINT`\n    // ).catch(() => {})\n    // await prisma.$executeRawUnsafe(`ALTER TABLE QstashScheduleLog ADD COLUMN IF NOT EXISTS deltaMinutes INTEGER`).catch(\n    //   () => {}\n    // )\n    // await prisma.$executeRawUnsafe(`ALTER TABLE QstashScheduleLog ADD COLUMN IF NOT EXISTS scheduled BOOLEAN`).catch(\n    //   () => {}\n    // )\n\n    await prisma.$queryRawUnsafe(\n      `INSERT INTO QstashScheduleLog (\n        id,\n        createdAt,\n        userId,\n        reminderTime,\n        timezone,\n        deltaMinutes,\n        notBeforeEpochSeconds,\n        scheduled,\n        httpStatus,\n        reason,\n        responseSnippet,\n        callbackUrl\n      ) VALUES ($1, NOW(), $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)`,\n      randomUUID(),\n      entry.userId,\n      entry.reminderTime,\n      entry.timezone,\n      entry.deltaMinutes,\n      entry.notBeforeEpochSeconds,\n      entry.scheduled,\n      entry.httpStatus ?? null,\n      entry.reason ?? null,\n      entry.responseSnippet ?? null,\n      entry.callbackUrl ?? null\n    )\n  } catch (error) {\n    console.error('[QSTASH_LOG] failed to persist schedule attempt', error)\n  }\n}\n\ntype ScheduleTarget = {\n  userId: string,\n  timeHHMM: string,\n  timeZone: string\n  callbackPath: string\n}\n\nasync function scheduleWithQStash(\n  target: ScheduleTarget\n): Promise<{ scheduled: boolean; reason?: string; status?: number; responseBody?: string }> {\n  const { userId, timeHHMM, timeZone, callbackPath } = target\n  const token = process.env.QSTASH_TOKEN || ''\n  const schedulerSecret = process.env.SCHEDULER_SECRET || ''\n  const deltaMinutes = minutesUntilNext(timeHHMM, timeZone)\n  const notBeforeEpochSeconds = Math.floor((Date.now() + deltaMinutes * 60_000) / 1000)\n\n  if (!token) {\n    await logScheduleAttempt({\n      userId,\n      reminderTime: timeHHMM,\n      timezone: timeZone,\n      deltaMinutes,\n      notBeforeEpochSeconds: null,\n      scheduled: false,\n      reason: 'missing_qstash_token',\n      callbackUrl: null,\n    })\n    return { scheduled: false, reason: 'missing_qstash_token' }\n  }\n\n  let base =\n    process.env.PUBLIC_BASE_URL ||\n    (process.env.VERCEL_URL ? `https://${process.env.VERCEL_URL}` : '')\n  if (base) {\n    base = base.trim()\n    if (base && !/^https?:\\/\\//i.test(base)) {\n      base = `https://${base}`\n    }\n    // Remove any trailing slash to avoid double slashes in callback\n    base = base.replace(/\\/+$/, '')\n  }\n  if (!base) {\n    await logScheduleAttempt({\n      userId,\n      reminderTime: timeHHMM,\n      timezone: timeZone,\n      deltaMinutes,\n      notBeforeEpochSeconds: null,\n      scheduled: false,\n      reason: 'missing_base_url',\n      callbackUrl: null,\n    })\n    return { scheduled: false, reason: 'missing_base_url' }\n  }\n\n  const normalizedPath = callbackPath.startsWith('/')\n    ? callbackPath\n    : `/${callbackPath}`\n  const callbackUrl = `${base}${normalizedPath}`\n  const url = `https://qstash.upstash.io/v2/publish/${callbackUrl}`\n\n  const body = JSON.stringify({ userId, reminderTime: timeHHMM, timezone: timeZone })\n  let responseBody = ''\n  let status: number | undefined\n\n  try {\n    const headers: Record<string, string> = {\n      Authorization: `Bearer ${token}`,\n      'Content-Type': 'application/json',\n      'Upstash-Not-Before': String(notBeforeEpochSeconds),\n    }\n    if (schedulerSecret) {\n      headers['Upstash-Forward-Authorization'] = `Bearer ${schedulerSecret}`\n    }\n    const res = await fetch(url, {\n      method: 'POST',\n      headers,\n      body,\n    })\n\n    status = res.status\n    responseBody = await res.text()\n\n    if (!res.ok) {\n      const reason = `qstash_http_${res.status}`\n      await logScheduleAttempt({\n        userId,\n        reminderTime: timeHHMM,\n        timezone: timeZone,\n        deltaMinutes,\n        notBeforeEpochSeconds,\n        scheduled: false,\n        httpStatus: res.status,\n        reason,\n        responseSnippet: responseBody.slice(0, 500),\n        callbackUrl,\n      })\n      return { scheduled: false, reason, status: res.status, responseBody }\n    }\n\n    await logScheduleAttempt({\n      userId,\n      reminderTime: timeHHMM,\n      timezone: timeZone,\n      deltaMinutes,\n      notBeforeEpochSeconds,\n      scheduled: true,\n      httpStatus: res.status,\n      responseSnippet: responseBody.slice(0, 500),\n      callbackUrl,\n    })\n    return { scheduled: true, status: res.status, responseBody }\n  } catch (error: any) {\n    const reason = error?.message ? `fetch_error:${error.message}` : 'fetch_error'\n    await logScheduleAttempt({\n      userId,\n      reminderTime: timeHHMM,\n      timezone: timeZone,\n      deltaMinutes,\n      notBeforeEpochSeconds,\n      scheduled: false,\n      reason,\n      callbackUrl,\n      responseSnippet: (error?.stack || String(error)).slice(0, 500),\n    })\n    return { scheduled: false, reason, status, responseBody }\n  }\n}\n\nexport async function scheduleReminderWithQStash(\n  userId: string,\n  timeHHMM: string,\n  timeZone: string\n): Promise<{ scheduled: boolean; reason?: string; status?: number; responseBody?: string }> {\n  return scheduleWithQStash({\n    userId,\n    timeHHMM,\n    timeZone,\n    callbackPath: '/api/push/dispatch',\n  })\n}\n\nexport async function scheduleMoodReminderWithQStash(\n  userId: string,\n  timeHHMM: string,\n  timeZone: string\n): Promise<{ scheduled: boolean; reason?: string; status?: number; responseBody?: string }> {\n  return scheduleWithQStash({\n    userId,\n    timeHHMM,\n    timeZone,\n    callbackPath: '/api/mood/dispatch',\n  })\n}\n\nexport async function scheduleHealthTipWithQStash(\n  userId: string,\n  timeHHMM: string,\n  timeZone: string\n): Promise<{ scheduled: boolean; reason?: string; status?: number; responseBody?: string }> {\n  return scheduleWithQStash({\n    userId,\n    timeHHMM,\n    timeZone,\n    callbackPath: '/api/push/health-tips/dispatch',\n  })\n}\n\nexport async function publishWithQStash(\n  callbackPath: string,\n  payload: unknown\n): Promise<{ ok: boolean; reason?: string; status?: number; responseBody?: string; callbackUrl?: string }> {\n  const token = process.env.QSTASH_TOKEN || ''\n  const schedulerSecret = process.env.SCHEDULER_SECRET || ''\n  if (!token) return { ok: false, reason: 'missing_qstash_token' }\n\n  let base =\n    process.env.PUBLIC_BASE_URL ||\n    (process.env.VERCEL_URL ? `https://${process.env.VERCEL_URL}` : '')\n  if (base) {\n    base = base.trim()\n    if (base && !/^https?:\\/\\//i.test(base)) base = `https://${base}`\n    base = base.replace(/\\/+$/, '')\n  }\n  if (!base) return { ok: false, reason: 'missing_base_url' }\n\n  const normalizedPath = callbackPath.startsWith('/') ? callbackPath : `/${callbackPath}`\n  const callbackUrl = `${base}${normalizedPath}`\n  const url = `https://qstash.upstash.io/v2/publish/${callbackUrl}`\n\n  try {\n    const headers: Record<string, string> = {\n      Authorization: `Bearer ${token}`,\n      'Content-Type': 'application/json',\n    }\n    if (schedulerSecret) {\n      headers['Upstash-Forward-Authorization'] = `Bearer ${schedulerSecret}`\n    }\n    const res = await fetch(url, {\n      method: 'POST',\n      headers,\n      body: JSON.stringify(payload ?? {}),\n    })\n    const responseBody = await res.text()\n    if (!res.ok) return { ok: false, status: res.status, responseBody, callbackUrl, reason: `qstash_http_${res.status}` }\n    return { ok: true, status: res.status, responseBody, callbackUrl }\n  } catch (error: any) {\n    return { ok: false, reason: error?.message || 'fetch_error', responseBody: (error?.stack || String(error)).slice(0, 500), callbackUrl }\n  }\n}\n\n/**\n * Schedule all active reminders for a user based on frequency (1-3).\n */\nexport async function scheduleAllActiveReminders(\n  userId: string,\n  settings: { time1: string; time2: string; time3: string; timezone: string; frequency: number }\n) {\n  const { time1, time2, time3, timezone, frequency } = settings\n  const reminders: string[] = []\n  if (frequency >= 1) reminders.push(time1)\n  if (frequency >= 2) reminders.push(time2)\n  if (frequency >= 3) reminders.push(time3)\n\n  const tasks = reminders.map((reminderTime) =>\n    scheduleReminderWithQStash(userId, reminderTime, timezone).then((result) => ({\n      reminderTime,\n      ...result,\n    }))\n  )\n\n  try {\n    return await Promise.all(tasks)\n  } catch (error) {\n    console.error('[QSTASH] scheduleAllActiveReminders encountered an error', error)\n    return []\n  }\n}\n\nexport async function scheduleAllMoodReminders(\n  userId: string,\n  settings: { time1: string; time2: string; time3: string; timezone: string; frequency: number }\n) {\n  const { time1, time2, time3, timezone, frequency } = settings\n  const reminders: string[] = []\n  if (frequency >= 1) reminders.push(time1)\n  if (frequency >= 2) reminders.push(time2)\n  if (frequency >= 3) reminders.push(time3)\n\n  const tasks = reminders.map((reminderTime) =>\n    scheduleMoodReminderWithQStash(userId, reminderTime, timezone).then((result) => ({\n      reminderTime,\n      ...result,\n    }))\n  )\n\n  try {\n    return await Promise.all(tasks)\n  } catch (error) {\n    console.error('[QSTASH] scheduleAllMoodReminders encountered an error', error)\n    return []\n  }\n}\n","truncated":false,"size":11843},{"path":"lib/rate-limit.ts","content":"import { prisma } from '@/lib/prisma'\n\nconst buckets = new Map<string, number[]>()\nlet rateLimitTableReady = false\nlet rateLimitInitPromise: Promise<void> | null = null\nlet lastCleanupAt = 0\nconst CLEANUP_INTERVAL_MS = 5 * 60 * 1000\nconst RETENTION_MS = 24 * 60 * 60 * 1000\n\nexport type RateLimitResult = {\n  allowed: boolean\n  retryAfterMs: number\n}\n\nconst ensureRateLimitTable = async () => {\n  if (rateLimitTableReady) return\n  if (rateLimitInitPromise) {\n    await rateLimitInitPromise\n    return\n  }\n  rateLimitInitPromise = prisma.$executeRawUnsafe(`\n    CREATE TABLE IF NOT EXISTS \"RateLimitBucket\" (\n      \"scope\" TEXT NOT NULL,\n      \"rateKey\" TEXT NOT NULL,\n      \"windowStart\" BIGINT NOT NULL,\n      \"count\" INTEGER NOT NULL DEFAULT 0,\n      \"updatedAt\" TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n      PRIMARY KEY (\"scope\", \"rateKey\", \"windowStart\")\n    );\n    CREATE INDEX IF NOT EXISTS \"RateLimitBucket_updatedAt_idx\" ON \"RateLimitBucket\" (\"updatedAt\");\n  `)\n    .then(() => {\n      rateLimitTableReady = true\n    })\n    .catch((error) => {\n      console.error('Rate limit table init failed:', error)\n    })\n  await rateLimitInitPromise\n}\n\nconst consumeRateLimitMemory = (\n  scope: string,\n  key: string,\n  limit: number,\n  windowMs: number\n): RateLimitResult => {\n  const now = Date.now()\n  const bucketKey = `${scope}:${key}`\n  const existing = buckets.get(bucketKey) || []\n  const recent = existing.filter((ts) => now - ts < windowMs)\n\n  if (recent.length >= limit) {\n    const oldest = recent[0]\n    const retryAfterMs = windowMs - (now - oldest)\n    buckets.set(bucketKey, recent)\n    return { allowed: false, retryAfterMs }\n  }\n\n  recent.push(now)\n  buckets.set(bucketKey, recent)\n  return { allowed: true, retryAfterMs: 0 }\n}\n\n/**\n * Durable rate limiter backed by the database.\n * Falls back to in-memory checks if the database is unavailable.\n */\nexport async function consumeRateLimit(\n  scope: string,\n  key: string,\n  limit: number,\n  windowMs: number\n): Promise<RateLimitResult> {\n  const now = Date.now()\n  try {\n    await ensureRateLimitTable()\n\n    const windowStart = Math.floor(now / windowMs) * windowMs\n    const rows = await prisma.$queryRaw<{ count: number }[]>`\n      INSERT INTO \"RateLimitBucket\" (\"scope\", \"rateKey\", \"windowStart\", \"count\", \"updatedAt\")\n      VALUES (${scope}, ${key}, ${windowStart}, 1, NOW())\n      ON CONFLICT (\"scope\", \"rateKey\", \"windowStart\")\n      DO UPDATE SET \"count\" = \"RateLimitBucket\".\"count\" + 1, \"updatedAt\" = NOW()\n      RETURNING \"count\"\n    `\n    const rawCount = rows?.[0]?.count ?? 1\n    const count = typeof rawCount === 'bigint' ? Number(rawCount) : Number(rawCount)\n    if (count > limit) {\n      const retryAfterMs = Math.max(0, windowStart + windowMs - now)\n      return { allowed: false, retryAfterMs }\n    }\n\n    if (now - lastCleanupAt > CLEANUP_INTERVAL_MS) {\n      lastCleanupAt = now\n      const cutoff = now - RETENTION_MS\n      await prisma.$executeRawUnsafe(\n        'DELETE FROM \"RateLimitBucket\" WHERE \"windowStart\" < $1',\n        cutoff\n      )\n    }\n\n    return { allowed: true, retryAfterMs: 0 }\n  } catch (error) {\n    console.error('Rate limit fallback to memory:', error)\n    return consumeRateLimitMemory(scope, key, limit, windowMs)\n  }\n}\n","truncated":false,"size":3231},{"path":"lib/run-context.ts","content":"import { AsyncLocalStorage } from 'node:async_hooks'\n\nexport type RunContext = {\n  runId?: string | null\n  feature?: string | null\n  meta?: {\n    userId?: string | null\n    changeTypes?: string[]\n    sections?: string[]\n    phase?: 'quick' | 'full'\n  }\n}\n\nconst runContextStore = new AsyncLocalStorage<RunContext>()\nlet fallbackContext: RunContext | undefined\n\n/**\n * Run a function with a scoped run context (e.g., insights regeneration runId).\n * The context is available to downstream logging via getRunContext.\n */\nexport function withRunContext<T>(context: RunContext, fn: () => Promise<T> | T): Promise<T> | T {\n  fallbackContext = context\n  try {\n    return runContextStore.run(context, fn as any)\n  } finally {\n    fallbackContext = undefined\n  }\n}\n\nexport function getRunContext(): RunContext | undefined {\n  return runContextStore.getStore() ?? fallbackContext\n}\n","truncated":false,"size":873},{"path":"lib/scheduler-auth.ts","content":"import { NextRequest } from 'next/server'\n\nexport function isSchedulerAuthorized(req: NextRequest): boolean {\n  const expected = process.env.SCHEDULER_SECRET || ''\n  const authHeader = req.headers.get('authorization') || ''\n  if (expected) {\n    return authHeader === `Bearer ${expected}`\n  }\n\n  if (process.env.QSTASH_REQUIRE_SIGNATURE) {\n    const sig = req.headers.get('upstash-signature')\n    if (sig) return true\n  }\n\n  return false\n}\n","truncated":false,"size":440},{"path":"lib/server-call-tracker.ts","content":"import { prisma } from '@/lib/prisma'\nimport crypto from 'crypto'\n\ntype ServerCallKind = 'analysis' | 'credit_status' | 'feature_usage' | 'other'\n\nlet ensured = false\n\nasync function ensureServerCallLogTable() {\n  await prisma.$executeRawUnsafe(`\n    CREATE TABLE IF NOT EXISTS \"ServerCallLog\" (\n      id TEXT PRIMARY KEY,\n      \"createdAt\" TIMESTAMP NOT NULL DEFAULT NOW(),\n      feature TEXT NOT NULL,\n      endpoint TEXT NOT NULL,\n      kind TEXT NOT NULL\n    )\n  `)\n\n  await prisma.$executeRawUnsafe(`\n    CREATE INDEX IF NOT EXISTS \"ServerCallLog_createdAt_idx\" ON \"ServerCallLog\" (\"createdAt\")\n  `)\n\n  await prisma.$executeRawUnsafe(`\n    CREATE INDEX IF NOT EXISTS \"ServerCallLog_feature_idx\" ON \"ServerCallLog\" (feature)\n  `)\n\n  await prisma.$executeRawUnsafe(`\n    CREATE INDEX IF NOT EXISTS \"ServerCallLog_kind_idx\" ON \"ServerCallLog\" (kind)\n  `)\n}\n\nexport async function logServerCall(options: {\n  feature: string\n  endpoint: string\n  kind: ServerCallKind\n}) {\n  const feature = String(options.feature || '').trim()\n  if (!feature) return\n  try {\n    if (!ensured) {\n      await ensureServerCallLogTable()\n      ensured = true\n    }\n    const id = crypto.randomUUID()\n    await prisma.$executeRawUnsafe(\n      `INSERT INTO \"ServerCallLog\" (id, feature, endpoint, kind) VALUES ($1, $2, $3, $4)`,\n      id,\n      feature,\n      options.endpoint,\n      options.kind\n    )\n  } catch (error) {\n    console.error('‚ùå Failed to log server call:', error)\n  }\n}\n","truncated":false,"size":1465},{"path":"lib/session-revocation.ts","content":"import { prisma } from '@/lib/prisma'\n\nlet ensured = false\n\nasync function ensureSessionRevocationTable() {\n  await prisma.$executeRawUnsafe(`\n    CREATE TABLE IF NOT EXISTS \"UserSessionRevocation\" (\n      \"userId\" TEXT PRIMARY KEY,\n      \"revokedAt\" TIMESTAMP NOT NULL,\n      \"updatedAt\" TIMESTAMP NOT NULL DEFAULT NOW()\n    )\n  `)\n}\n\nexport async function getSessionRevokedAt(userId: string): Promise<Date | null> {\n  if (!userId) return null\n  try {\n    if (!ensured) {\n      await ensureSessionRevocationTable()\n      ensured = true\n    }\n    const rows = await prisma.$queryRawUnsafe<Array<{ revokedAt: Date }>>(\n      `SELECT \"revokedAt\" FROM \"UserSessionRevocation\" WHERE \"userId\" = $1`,\n      userId\n    )\n    return rows[0]?.revokedAt ? new Date(rows[0].revokedAt) : null\n  } catch (error) {\n    console.error('‚ùå Failed to load session revocation:', error)\n    return null\n  }\n}\n\nexport async function revokeUserSessions(userId: string): Promise<Date | null> {\n  if (!userId) return null\n  const now = new Date()\n  try {\n    if (!ensured) {\n      await ensureSessionRevocationTable()\n      ensured = true\n    }\n    await prisma.$executeRawUnsafe(\n      `INSERT INTO \"UserSessionRevocation\" (\"userId\", \"revokedAt\")\n       VALUES ($1, $2)\n       ON CONFLICT (\"userId\") DO UPDATE SET \"revokedAt\" = EXCLUDED.\"revokedAt\", \"updatedAt\" = NOW()`,\n      userId,\n      now\n    )\n    return now\n  } catch (error) {\n    console.error('‚ùå Failed to revoke user sessions:', error)\n    return null\n  }\n}\n","truncated":false,"size":1501},{"path":"lib/session.ts","content":"import { prisma } from '@/lib/prisma'\nimport { NextRequest } from 'next/server'\nimport crypto from 'crypto'\n\n// Custom session interface\nexport interface CustomSession {\n  id: string\n  userId: string\n  email: string\n  name?: string | null\n  image?: string | null\n  expiresAt: Date\n}\n\n// Generate a secure session token\nexport function generateSessionToken(): string {\n  return crypto.randomBytes(32).toString('hex')\n}\n\n// Create a new session in database\nexport async function createSession(email: string, name?: string, image?: string): Promise<string> {\n  const sessionToken = generateSessionToken()\n  const expiresAt = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000) // 30 days\n  \n  try {\n    // Find or create user\n    let user = await prisma.user.findUnique({\n      where: { email }\n    })\n    \n    if (!user) {\n      user = await prisma.user.create({\n        data: {\n          email,\n          name: name || email.split('@')[0],\n          image: image || null,\n        }\n      })\n    }\n    \n    // Delete any existing sessions for this user (optional - for single session per user)\n    await prisma.session.deleteMany({\n      where: { userId: user.id }\n    })\n    \n    // Create new session\n    await prisma.session.create({\n      data: {\n        sessionToken,\n        userId: user.id,\n        expires: expiresAt\n      }\n    })\n    \n    console.log('Custom session created for:', email, 'Token:', sessionToken.substring(0, 8) + '...')\n    return sessionToken\n    \n  } catch (error) {\n    console.error('Error creating custom session:', error)\n    throw error\n  }\n}\n\n// Get session from database\nexport async function getSession(request: NextRequest): Promise<CustomSession | null> {\n  try {\n    // Get session token from cookie or Authorization header\n    const cookies = request.headers.get('cookie') || ''\n    const sessionToken = extractSessionToken(cookies) || \n                        request.headers.get('authorization')?.replace('Bearer ', '')\n    \n    if (!sessionToken) {\n      console.log('No session token found in request')\n      return null\n    }\n    \n    console.log('Looking for session with token:', sessionToken.substring(0, 8) + '...')\n    \n    // Find session in database\n    const session = await prisma.session.findUnique({\n      where: { sessionToken },\n      include: {\n        user: true\n      }\n    })\n    \n    if (!session) {\n      console.log('Session not found in database')\n      return null\n    }\n    \n    // Check if expired\n    if (session.expires < new Date()) {\n      console.log('Session expired, deleting')\n      await prisma.session.delete({\n        where: { sessionToken }\n      })\n      return null\n    }\n    \n    console.log('Valid session found for user:', session.user.email)\n    \n    return {\n      id: session.id,\n      userId: session.userId,\n      email: session.user.email,\n      name: session.user.name,\n      image: session.user.image,\n      expiresAt: session.expires\n    }\n    \n  } catch (error) {\n    console.error('Error getting custom session:', error)\n    return null\n  }\n}\n\n// Extract session token from cookie string\nfunction extractSessionToken(cookieString: string): string | null {\n  // Look for our custom session cookie\n  const match = cookieString.match(/helfi-session=([^;]+)/)\n  if (match) {\n    return match[1]\n  }\n  \n  // Also check for NextAuth session token as fallback\n  const nextAuthMatch = cookieString.match(/next-auth\\.session-token=([^;]+)/)\n  if (nextAuthMatch) {\n    return nextAuthMatch[1]\n  }\n  \n  return null\n}\n\n// Delete session\nexport async function deleteSession(sessionToken: string): Promise<void> {\n  try {\n    await prisma.session.delete({\n      where: { sessionToken }\n    })\n    console.log('Session deleted:', sessionToken.substring(0, 8) + '...')\n  } catch (error) {\n    console.error('Error deleting session:', error)\n  }\n}\n\n// Clean up expired sessions (utility function)\nexport async function cleanupExpiredSessions(): Promise<void> {\n  try {\n    const result = await prisma.session.deleteMany({\n      where: {\n        expires: {\n          lt: new Date()\n        }\n      }\n    })\n    console.log('Cleaned up', result.count, 'expired sessions')\n  } catch (error) {\n    console.error('Error cleaning up sessions:', error)\n  }\n} ","truncated":false,"size":4227},{"path":"lib/signed-file.ts","content":"import jwt from 'jsonwebtoken'\n\nconst SIGNING_SECRET = (() => {\n  const secret =\n    process.env.FILE_URL_SIGNING_SECRET ||\n    process.env.NEXTAUTH_SECRET ||\n    process.env.JWT_SECRET\n\n  if (!secret) {\n    throw new Error('FILE_URL_SIGNING_SECRET or NEXTAUTH_SECRET is required')\n  }\n\n  return secret\n})()\n\nexport type SignedFilePayload = {\n  fileId: string\n  userId: string\n  usage: 'MEDICAL_IMAGE' | 'LAB_REPORT'\n}\n\nexport function createSignedFileToken(payload: SignedFilePayload, expiresInSeconds = 600): string {\n  return jwt.sign(payload, SIGNING_SECRET, { expiresIn: expiresInSeconds })\n}\n\nexport function verifySignedFileToken(token: string): SignedFilePayload | null {\n  try {\n    const decoded = jwt.verify(token, SIGNING_SECRET) as SignedFilePayload\n    if (!decoded?.fileId || !decoded?.userId || !decoded?.usage) {\n      return null\n    }\n    return decoded\n  } catch {\n    return null\n  }\n}\n","truncated":false,"size":907},{"path":"lib/subscription-utils.ts","content":"export type SubscriptionLike = {\n  plan?: string | null\n  endDate?: Date | string | null\n}\n\nexport function isSubscriptionActive(subscription: SubscriptionLike | null | undefined, now = new Date()): boolean {\n  if (!subscription?.plan) return false\n  const endDate = subscription.endDate ? new Date(subscription.endDate) : null\n  if (!endDate || Number.isNaN(endDate.getTime())) return true\n  return endDate.getTime() > now.getTime()\n}\n","truncated":false,"size":436},{"path":"lib/support-automation.ts","content":"import OpenAI from 'openai'\nimport crypto from 'crypto'\nimport { Resend } from 'resend'\nimport { prisma } from '@/lib/prisma'\nimport { TicketCategory, TicketPriority } from '@prisma/client'\nimport { runChatCompletionWithLogging } from '@/lib/ai-usage-logger'\nimport { getEmailFooter } from '@/lib/email-footer'\nimport { buildSupportCodeContext } from '@/lib/support-code-search'\n\nconst SUPPORT_AI_MODEL = process.env.SUPPORT_AI_MODEL || 'gpt-4o-mini'\nconst SUPPORT_COPY_EMAIL = 'support@helfi.ai'\nconst SUPPORT_VERIFICATION_TTL_MINUTES = 15\nconst SUPPORT_AGENT_NAME = 'Maya'\nconst SUPPORT_AGENT_ROLE = 'Helfi Support'\nconst SYSTEM_IDENTITY_MARKER = '[SYSTEM] Identity verified'\nconst SYSTEM_TRANSCRIPT_MARKER = '[SYSTEM] Transcript emailed'\nconst SYSTEM_INTERNAL_NOTES_MARKER = '[SYSTEM] Internal notes'\nconst ATTACHMENTS_MARKER = '[[ATTACHMENTS]]'\n\ntype SupportAiResult = {\n  customerReply: string\n  shouldEscalate: boolean\n  escalationReason?: string\n  needsIdentityCheck?: boolean\n  needsMoreInfo?: boolean\n  requestedInfo?: string[]\n  internalNotes?: string\n  suggestedCategory?: string\n  suggestedPriority?: string\n}\n\ntype SupportAutomationInput = {\n  ticketId: string\n  latestUserMessage?: string | null\n  source?: 'app_ticket' | 'app_reply' | 'email_ticket' | 'email_reply' | 'web_ticket' | 'web_chat' | 'admin_reply'\n}\n\nfunction getOpenAIClient(): OpenAI | null {\n  if (!process.env.OPENAI_API_KEY) return null\n  return new OpenAI({ apiKey: process.env.OPENAI_API_KEY })\n}\n\nfunction getResendClient(): Resend | null {\n  if (!process.env.RESEND_API_KEY) return null\n  return new Resend(process.env.RESEND_API_KEY)\n}\n\nfunction escapeHtml(input: string): string {\n  return input\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#39;')\n}\n\ntype SupportAttachment = {\n  name: string\n  url: string\n  type?: string\n  size?: number\n}\n\nfunction splitAttachmentsFromMessage(message: string): { text: string; attachments: SupportAttachment[] } {\n  const markerIndex = message.indexOf(ATTACHMENTS_MARKER)\n  if (markerIndex === -1) {\n    return { text: message, attachments: [] }\n  }\n\n  const text = message.slice(0, markerIndex).trim()\n  const raw = message.slice(markerIndex + ATTACHMENTS_MARKER.length).trim()\n  if (!raw) {\n    return { text, attachments: [] }\n  }\n\n  try {\n    const parsed = JSON.parse(raw)\n    const attachments = Array.isArray(parsed)\n      ? parsed.map((item) => ({\n          name: String(item?.name || ''),\n          url: String(item?.url || ''),\n          type: item?.type ? String(item.type) : undefined,\n          size: typeof item?.size === 'number' ? item.size : undefined,\n        })).filter((item) => item.name && item.url)\n      : []\n    return { text, attachments }\n  } catch {\n    return { text: message, attachments: [] }\n  }\n}\n\nfunction stripHtml(input: string): string {\n  return input.replace(/<[^>]*>/g, ' ').replace(/\\s+/g, ' ').trim()\n}\n\nfunction extractVerificationCode(message: string): string | null {\n  const match = message.match(/\\b(\\d{6})\\b/)\n  return match ? match[1] : null\n}\n\nfunction verificationIdentifier(ticketId: string, userEmail: string): string {\n  return `support:${ticketId}:${userEmail.toLowerCase()}`\n}\n\nfunction verificationTokenHash(ticketId: string, code: string): string {\n  return crypto.createHash('sha256').update(`${ticketId}:${code}`).digest('hex')\n}\n\nfunction isIdentityVerified(responses: Array<{ message: string; isAdminResponse: boolean }>): boolean {\n  return responses.some((r) => r.isAdminResponse && r.message?.startsWith(SYSTEM_IDENTITY_MARKER))\n}\n\nfunction buildSupportSystemPrompt(): string {\n  return [\n    `You are ${SUPPORT_AGENT_NAME}, a careful and friendly support agent for ${SUPPORT_AGENT_ROLE}.`,\n    'Your goal is to troubleshoot app issues, ask for missing details, and keep the user safe.',\n    '',\n    'Rules:',\n    '- Use plain English. Keep replies short, warm, and helpful.',\n    '- Start with a brief greeting only if this is your first reply in the conversation; otherwise, skip the greeting and continue naturally.',\n    '- Focus on app troubleshooting, not medical advice.',\n    '- Do not claim hardware or device integrations that are not currently supported.',\n    '- If asked about Apple devices or Apple Watch, explain they are not supported in the web app and are planned for the future native apps.',\n    '- Never mention code or internal details in the customer reply.',\n    '- Never ask for passwords, payment card numbers, or full security answers.',\n    '- Do not claim you made account changes. Only provide guidance and request verification when needed.',\n    '- If the issue involves account access, billing, subscription changes, email change, password change, or deleting data, you MUST require identity verification.',\n    '- If verification is pending, ask the user to reply with the 6-digit code we emailed them.',\n    '- For troubleshooting, ask for steps to reproduce, device type, OS version, browser/app version, and screenshots when relevant.',\n    '- If a bug is likely, tell the user we are investigating and provide clear internal notes for the team.',\n    '- Use the product facts below when answering questions about trials, pricing, credits, or features.',\n    '- If you are not sure about a detail, say you will confirm and loop in the team.',\n    `- Sign off with \"${SUPPORT_AGENT_NAME} from ${SUPPORT_AGENT_ROLE}\".`,\n    '',\n    supportProductFacts(),\n    '',\n    'Output strict JSON only with these fields:',\n    '{ \"customerReply\": string, \"shouldEscalate\": boolean, \"escalationReason\": string, \"needsIdentityCheck\": boolean, \"needsMoreInfo\": boolean, \"requestedInfo\": string[], \"internalNotes\": string, \"suggestedCategory\": string, \"suggestedPriority\": string }',\n    'Do not include markdown or code fences.',\n    '',\n    'The internalNotes field is for the team only and may mention likely code areas.',\n    'Never mention internalNotes or code paths in the customerReply.',\n  ].join('\\n')\n}\n\nfunction supportCodeMap(): string {\n  return [\n    'CODE MAP (for internal notes only):',\n    '- Auth / login: app/api/auth/*, app/auth/*, lib/auth.ts',\n    '- Support tickets: app/support/page.tsx, app/api/admin/tickets/route.ts, app/api/tickets/webhook/route.ts, prisma/schema.prisma (SupportTicket)',\n    '- Billing / subscriptions: app/api/billing/*, app/billing/*, stripe docs',\n    '- AI chats: app/api/chat/voice/route.ts, lib/metered-openai.ts, lib/ai-usage-logger.ts',\n    '- Food logging: app/food/*, app/api/food-*',\n    '- Medical images: app/medical-images/*, app/api/medical-images/*',\n    '- Symptoms: app/symptoms/*, app/api/analyze-symptoms/*',\n    '- Insights: app/insights/*, lib/insights/*',\n    '- Push notifications: app/api/push/*, lib/push/*',\n  ].join('\\n')\n}\n\nfunction supportProductFacts(): string {\n  return [\n    'PRODUCT FACTS:',\n    '- No free trial. New users get multiple free uses of AI features before needing credits or a subscription.',\n    '- Free AI uses on signup: 5 food photo analyses, 2 symptom analyses, 2 medical image analyses, 2 supplement/medication interaction analyses.',\n    '- Extra free uses on signup: 1 full health intake analysis, 3 insights updates.',\n    '- Free chats on signup: 2 symptom follow-up chats, 2 medical image follow-up chats, 2 insights chats, 2 voice chats.',\n    '- Free re-analyses on signup: 2 food re-analyses, 2 interaction re-analyses.',\n    '- Non-AI features remain free for all users.',\n    '- Premium plan: $20/month includes 30 daily AI food analyses, 30 reanalysis credits per day, 30 medical image analyses per day, advanced insights, priority support, and export capabilities.',\n    '- Credit packs: $5 for 100 credits or $10 for 150 credits. Credits do not expire and can be used for any analysis.',\n    '- Helfi is a web app that works in the browser on mobile and desktop; no download is required.',\n    '- Device integrations: Fitbit is available now. Garmin Connect is in evaluation and may be temporarily unavailable until production approval is granted.',\n    '- Apple Watch, Apple Health, Samsung Health, Oura Ring, and Google Fit are not supported yet. These are planned for future iOS/Android apps.',\n  ].join('\\n')\n}\n\nfunction buildSupportUserPrompt(input: {\n  ticket: any\n  latestMessage: string\n  latestAttachments: SupportAttachment[]\n  identityVerified: boolean\n  verificationPending: boolean\n  verificationJustCompleted: boolean\n  hasPriorSupportReply: boolean\n  codeContext: string\n  conversation: string\n}): string {\n  const ticket = input.ticket\n  return [\n    `Ticket ID: ${ticket.id}`,\n    `Subject: ${ticket.subject || 'Support request'}`,\n    `Category: ${ticket.category}`,\n    `Priority: ${ticket.priority}`,\n    `Status: ${ticket.status}`,\n    `User Email: ${ticket.userEmail}`,\n    `User Name: ${ticket.userName || 'Not provided'}`,\n    '',\n    `Identity verified: ${input.identityVerified ? 'yes' : 'no'}`,\n    `Verification pending: ${input.verificationPending ? 'yes' : 'no'}`,\n    `Verification just completed: ${input.verificationJustCompleted ? 'yes' : 'no'}`,\n    `Has prior support reply: ${input.hasPriorSupportReply ? 'yes' : 'no'}`,\n    '',\n    'Latest user message:',\n    input.latestMessage || '(no new message)',\n    input.latestAttachments.length > 0 ? `Attachments: ${input.latestAttachments.map((a) => `${a.name} (${a.type || 'file'})`).join(', ')}` : '',\n    '',\n    input.codeContext ? `Code context:\\n${input.codeContext}` : 'Code context: (none)',\n    '',\n    'Conversation history:',\n    input.conversation || '(none)',\n    '',\n    supportProductFacts(),\n    '',\n    supportCodeMap(),\n  ].join('\\n')\n}\n\nfunction safeParseSupportJson(text: string): SupportAiResult | null {\n  try {\n    const parsed = JSON.parse(text)\n    if (!parsed || typeof parsed.customerReply !== 'string') return null\n    return {\n      customerReply: String(parsed.customerReply || '').trim(),\n      shouldEscalate: Boolean(parsed.shouldEscalate),\n      escalationReason: parsed.escalationReason ? String(parsed.escalationReason) : '',\n      needsIdentityCheck: Boolean(parsed.needsIdentityCheck),\n      needsMoreInfo: Boolean(parsed.needsMoreInfo),\n      requestedInfo: Array.isArray(parsed.requestedInfo) ? parsed.requestedInfo.map(String) : [],\n      internalNotes: parsed.internalNotes ? String(parsed.internalNotes) : '',\n      suggestedCategory: parsed.suggestedCategory ? String(parsed.suggestedCategory) : '',\n      suggestedPriority: parsed.suggestedPriority ? String(parsed.suggestedPriority) : '',\n    }\n  } catch {\n    const start = text.indexOf('{')\n    const end = text.lastIndexOf('}')\n    if (start !== -1 && end !== -1 && end > start) {\n      try {\n        const parsed = JSON.parse(text.slice(start, end + 1))\n        if (!parsed || typeof parsed.customerReply !== 'string') return null\n        return {\n          customerReply: String(parsed.customerReply || '').trim(),\n          shouldEscalate: Boolean(parsed.shouldEscalate),\n          escalationReason: parsed.escalationReason ? String(parsed.escalationReason) : '',\n          needsIdentityCheck: Boolean(parsed.needsIdentityCheck),\n          needsMoreInfo: Boolean(parsed.needsMoreInfo),\n          requestedInfo: Array.isArray(parsed.requestedInfo) ? parsed.requestedInfo.map(String) : [],\n          internalNotes: parsed.internalNotes ? String(parsed.internalNotes) : '',\n          suggestedCategory: parsed.suggestedCategory ? String(parsed.suggestedCategory) : '',\n          suggestedPriority: parsed.suggestedPriority ? String(parsed.suggestedPriority) : '',\n        }\n      } catch {\n        return null\n      }\n    }\n    return null\n  }\n}\n\nfunction buildConversationHistory(ticket: any): string {\n  const lines: string[] = []\n  if (ticket.message) {\n    const parsed = splitAttachmentsFromMessage(String(ticket.message))\n    const base = stripHtml(parsed.text)\n    lines.push(`Customer: ${base}`)\n    if (parsed.attachments.length > 0) {\n      lines.push(`Attachments: ${parsed.attachments.map((a) => `${a.name} (${a.type || 'file'})`).join(', ')}`)\n    }\n  }\n  const responses = Array.isArray(ticket.responses) ? ticket.responses : []\n  for (const response of responses) {\n    const parsed = splitAttachmentsFromMessage(String(response.message || ''))\n    const text = stripHtml(parsed.text)\n    if (!text) continue\n    if (text.startsWith('[SYSTEM]')) continue\n    lines.push(`${response.isAdminResponse ? 'Support' : 'Customer'}: ${text}`)\n    if (parsed.attachments.length > 0) {\n      lines.push(`Attachments: ${parsed.attachments.map((a) => `${a.name} (${a.type || 'file'})`).join(', ')}`)\n    }\n  }\n  return lines.slice(-12).join('\\n')\n}\n\nfunction collectInternalNotes(ticket: any): string[] {\n  const responses = Array.isArray(ticket.responses) ? ticket.responses : []\n  return responses\n    .map((response: any) => String(response.message || ''))\n    .filter((message) => message.startsWith(SYSTEM_INTERNAL_NOTES_MARKER))\n    .map((message) => message.replace(SYSTEM_INTERNAL_NOTES_MARKER, '').trim())\n    .filter(Boolean)\n}\n\nasync function hasPendingVerification(ticketId: string, userEmail: string): Promise<boolean> {\n  const identifier = verificationIdentifier(ticketId, userEmail)\n  const pending = await prisma.verificationToken.findFirst({\n    where: {\n      identifier,\n      expires: { gt: new Date() },\n    },\n  })\n  return Boolean(pending)\n}\n\nasync function consumeVerificationCode(ticketId: string, userEmail: string, code: string): Promise<boolean> {\n  const identifier = verificationIdentifier(ticketId, userEmail)\n  const tokenHash = verificationTokenHash(ticketId, code)\n  const token = await prisma.verificationToken.findFirst({\n    where: {\n      identifier,\n      token: tokenHash,\n      expires: { gt: new Date() },\n    },\n  })\n  if (!token) return false\n\n  await prisma.verificationToken.delete({\n    where: { identifier_token: { identifier, token: tokenHash } },\n  })\n\n  await prisma.ticketResponse.create({\n    data: {\n      ticketId,\n      message: `${SYSTEM_IDENTITY_MARKER} (${new Date().toISOString()})`,\n      isAdminResponse: true,\n      adminId: null,\n    },\n  })\n\n  return true\n}\n\nasync function ensureVerificationCode(ticketId: string, userEmail: string): Promise<boolean> {\n  const identifier = verificationIdentifier(ticketId, userEmail)\n  const existing = await prisma.verificationToken.findFirst({\n    where: {\n      identifier,\n      expires: { gt: new Date() },\n    },\n  })\n  if (existing) return true\n\n  const code = String(Math.floor(100000 + Math.random() * 900000))\n  const tokenHash = verificationTokenHash(ticketId, code)\n  const expires = new Date(Date.now() + SUPPORT_VERIFICATION_TTL_MINUTES * 60 * 1000)\n\n  await prisma.verificationToken.deleteMany({ where: { identifier } })\n  await prisma.verificationToken.create({\n    data: { identifier, token: tokenHash, expires },\n  })\n\n  const resend = getResendClient()\n  if (!resend) return false\n\n  const html = `\n    <div style=\"font-family: 'Segoe UI', Arial, sans-serif; max-width: 600px; margin: 0 auto; color: #333; background: #f8fafc;\">\n      <div style=\"background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; padding: 40px 30px; text-align: center; border-radius: 12px 12px 0 0;\">\n        <h1 style=\"margin: 0; font-size: 32px; font-weight: bold; letter-spacing: -0.5px;\">Helfi</h1>\n        <p style=\"margin: 12px 0 0 0; opacity: 0.95; font-size: 16px;\">Support Verification</p>\n      </div>\n      <div style=\"padding: 40px 30px; background: white; border-radius: 0 0 12px 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);\">\n        <p style=\"margin: 0 0 20px 0; line-height: 1.7; font-size: 16px; color: #4b5563;\">\n          Please confirm it is really you. Use this 6-digit code to continue your support request:\n        </p>\n        <div style=\"background: #f0f9ff; border: 1px solid #0ea5e9; border-radius: 10px; padding: 16px; text-align: center; margin: 24px 0;\">\n          <span style=\"font-size: 28px; letter-spacing: 4px; font-weight: 700; color: #0c4a6e;\">${code}</span>\n        </div>\n        <p style=\"margin: 0; font-size: 14px; color: #6b7280;\">\n          This code expires in ${SUPPORT_VERIFICATION_TTL_MINUTES} minutes.\n        </p>\n        ${getEmailFooter({ recipientEmail: userEmail, emailType: 'support', reasonText: 'This verification keeps your account safe.' })}\n      </div>\n    </div>\n  `\n\n  await resend.emails.send({\n    from: 'Helfi Support <support@helfi.ai>',\n    to: userEmail,\n    subject: 'Your Helfi support verification code',\n    html,\n  })\n\n  return true\n}\n\nfunction buildSupportResponseHtml(options: {\n  subject: string\n  message: string\n  internalNotes?: string\n  isCopy?: boolean\n  ticketId?: string\n  latestUserMessage?: string\n}): string {\n  const safeMessage = escapeHtml(options.message)\n  const internalNotes = options.internalNotes ? escapeHtml(options.internalNotes) : ''\n  const latestUserMessage = options.latestUserMessage ? escapeHtml(options.latestUserMessage) : ''\n  const latestUserBlock = options.isCopy && latestUserMessage\n    ? `\n      <div style=\"background: #f3f4f6; border-radius: 8px; padding: 16px; margin: 16px 0;\">\n        <p style=\"margin: 0 0 8px 0; color: #374151; font-weight: 600; font-size: 14px;\">Latest Customer Message</p>\n        <div style=\"white-space: pre-wrap; color: #4b5563; font-size: 14px;\">${latestUserMessage}</div>\n      </div>\n    `\n    : ''\n  const internalBlock = options.isCopy && internalNotes\n    ? `\n      <div style=\"background: #fff7ed; border: 1px solid #fdba74; border-radius: 8px; padding: 16px; margin: 24px 0;\">\n        <p style=\"margin: 0 0 8px 0; color: #9a3412; font-weight: 600; font-size: 14px;\">Internal Notes (AI)</p>\n        <div style=\"white-space: pre-wrap; color: #7c2d12; font-size: 14px;\">${internalNotes}</div>\n      </div>\n    `\n    : ''\n\n  const ticketMeta = options.isCopy && options.ticketId\n    ? `<p style=\"margin: 0 0 12px 0; font-size: 13px; color: #6b7280;\">Ticket ID: ${options.ticketId}</p>`\n    : ''\n\n  return `\n    <div style=\"font-family: 'Segoe UI', Arial, sans-serif; max-width: 600px; margin: 0 auto; color: #333; background: #f8fafc;\">\n      <div style=\"background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; padding: 40px 30px; text-align: center; border-radius: 12px 12px 0 0;\">\n        <h1 style=\"margin: 0; font-size: 32px; font-weight: bold; letter-spacing: -0.5px;\">Helfi</h1>\n        <p style=\"margin: 12px 0 0 0; opacity: 0.95; font-size: 16px;\">Support Team Response</p>\n      </div>\n      <div style=\"padding: 40px 30px; background: white; border-radius: 0 0 12px 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);\">\n        <h2 style=\"margin: 0 0 20px 0; color: #374151; font-size: 24px;\">Response to your support request</h2>\n        <div style=\"background: #f0f9ff; border: 1px solid #0ea5e9; border-radius: 8px; padding: 16px; margin: 20px 0;\">\n          <p style=\"margin: 0; color: #0c4a6e; font-size: 14px;\">\n            <strong>Regarding:</strong> ${escapeHtml(options.subject)}\n          </p>\n        </div>\n        ${ticketMeta}\n        ${latestUserBlock}\n        <div style=\"background: #f9fafb; border-radius: 8px; padding: 20px; margin: 30px 0;\">\n          <h3 style=\"margin: 0 0 15px 0; color: #374151;\">Our Response:</h3>\n          <div style=\"line-height: 1.7; font-size: 16px; color: #4b5563; white-space: pre-wrap;\">${safeMessage}</div>\n        </div>\n        ${internalBlock}\n        <div style=\"background: #ecfdf5; border: 1px solid #10b981; border-radius: 8px; padding: 16px; margin: 30px 0;\">\n          <p style=\"margin: 0; color: #065f46; font-size: 14px;\">\n            <strong>Need more help?</strong> Reply to this email and we will continue the conversation.\n          </p>\n        </div>\n        <div style=\"margin-top: 40px; padding-top: 30px; border-top: 1px solid #e5e7eb; font-size: 14px; color: #6b7280; text-align: center;\">\n          <p style=\"margin: 0 0 16px 0; font-size: 16px; color: #374151;\"><strong>Best regards,<br>Helfi Support Team</strong></p>\n          <p style=\"margin: 20px 0 0 0; font-size: 14px;\">\n            <a href=\"https://helfi.ai\" style=\"color: #10b981; text-decoration: none; font-weight: 500;\">helfi.ai</a> |\n            <a href=\"mailto:support@helfi.ai\" style=\"color: #10b981; text-decoration: none; font-weight: 500;\">support@helfi.ai</a>\n          </p>\n        </div>\n      </div>\n    </div>\n  `\n}\n\nasync function sendSupportResponseEmail(options: {\n  ticket: any\n  message: string\n  internalNotes?: string\n  latestUserMessage?: string\n  sendUserEmail?: boolean\n  sendSupportCopy?: boolean\n}) {\n  const resend = getResendClient()\n  if (!resend) return\n\n  const subject = options.ticket.subject || 'Support request'\n  const userEmail = options.ticket.userEmail\n  const copyEmail = SUPPORT_COPY_EMAIL\n  const sendUserEmail = options.sendUserEmail ?? true\n  const sendSupportCopy = options.sendSupportCopy ?? false\n\n  if (sendUserEmail) {\n    await resend.emails.send({\n      from: 'Helfi Support <support@helfi.ai>',\n      to: userEmail,\n      subject: `Re: ${subject}`,\n      html: buildSupportResponseHtml({ subject, message: options.message }),\n    })\n  }\n\n  if (sendSupportCopy && copyEmail && userEmail.toLowerCase() !== copyEmail.toLowerCase()) {\n    await resend.emails.send({\n      from: 'Helfi Support <support@helfi.ai>',\n      to: copyEmail,\n      subject: `Copy: Re: ${subject}`,\n      html: buildSupportResponseHtml({\n        subject,\n        message: options.message,\n        internalNotes: options.internalNotes || '',\n        isCopy: true,\n        ticketId: options.ticket.id,\n        latestUserMessage: options.latestUserMessage || '',\n      }),\n    })\n  }\n}\n\nasync function sendEscalationNotice(options: {\n  ticket: any\n  internalNotes?: string\n  reason?: string\n}) {\n  const resend = getResendClient()\n  if (!resend) return\n\n  const subject = `Escalation needed: ${options.ticket.subject || 'Support request'}`\n  const html = `\n    <div style=\"font-family: Arial, sans-serif; line-height: 1.5; color: #111827;\">\n      <h2 style=\"margin: 0 0 12px 0;\">Support escalation needed</h2>\n      <p style=\"margin: 0 0 6px 0;\"><strong>Ticket ID:</strong> ${options.ticket.id}</p>\n      <p style=\"margin: 0 0 6px 0;\"><strong>User:</strong> ${options.ticket.userEmail}</p>\n      <p style=\"margin: 0 0 12px 0;\"><strong>Subject:</strong> ${escapeHtml(options.ticket.subject || 'Support request')}</p>\n      ${options.reason ? `<p style=\"margin: 0 0 12px 0;\"><strong>Reason:</strong> ${escapeHtml(options.reason)}</p>` : ''}\n      ${options.internalNotes ? `<pre style=\"background:#f3f4f6; padding:12px; border-radius:8px; font-size:12px; white-space:pre-wrap;\">${escapeHtml(options.internalNotes)}</pre>` : ''}\n      ${getEmailFooter({\n        recipientEmail: SUPPORT_COPY_EMAIL,\n        emailType: 'admin',\n        reasonText: 'This is an automated escalation alert from the Helfi support system.',\n      })}\n    </div>\n  `\n\n  await resend.emails.send({\n    from: 'Helfi Alerts <support@helfi.ai>',\n    to: SUPPORT_COPY_EMAIL,\n    subject,\n    html,\n  })\n}\n\ntype TranscriptEntry = {\n  author: string\n  message: string\n  attachments: SupportAttachment[]\n}\n\nfunction buildTranscriptEntries(ticket: any): TranscriptEntry[] {\n  const entries: TranscriptEntry[] = []\n  if (ticket.message) {\n    const parsed = splitAttachmentsFromMessage(String(ticket.message))\n    entries.push({\n      author: `Customer (${ticket.userEmail})`,\n      message: parsed.text,\n      attachments: parsed.attachments,\n    })\n  }\n\n  const responses = Array.isArray(ticket.responses) ? ticket.responses : []\n  responses.forEach((response: any) => {\n    const parsed = splitAttachmentsFromMessage(String(response.message || ''))\n    if (!parsed.text) return\n    if (parsed.text.startsWith('[SYSTEM]')) return\n    const author = response.isAdminResponse ? `${SUPPORT_AGENT_NAME} (AI)` : 'Customer'\n    entries.push({\n      author,\n      message: parsed.text,\n      attachments: parsed.attachments,\n    })\n  })\n\n  return entries\n}\n\nfunction buildTranscriptHtml(options: { ticket: any; transcript: string }): string {\n  const subject = escapeHtml(options.ticket.subject || 'Support request')\n  const entries = buildTranscriptEntries(options.ticket)\n  const internalNotes = collectInternalNotes(options.ticket)\n  const transcriptHtml = entries\n    .map((entry) => {\n      const safeMessage = escapeHtml(entry.message).replace(/\\n/g, '<br />')\n      const attachmentsHtml = entry.attachments.length\n        ? `\n          <div style=\"margin-top: 6px; font-size: 12px; color: #6b7280;\">\n            ${entry.attachments\n              .map((att) => {\n                const name = escapeHtml(att.name)\n                const type = escapeHtml(att.type || 'file')\n                const url = escapeHtml(att.url)\n                return `<div>Attachment: <a href=\"${url}\" target=\"_blank\" rel=\"noreferrer\">${name}</a> (${type})</div>`\n              })\n              .join('')}\n          </div>\n        `\n        : ''\n      return `\n        <div style=\"margin: 0 0 16px 0;\">\n          <div style=\"font-size: 13px; color: #111827; margin-bottom: 4px;\">\n            <strong>${escapeHtml(entry.author)}</strong>\n          </div>\n          <div style=\"font-size: 13px; color: #374151;\">${safeMessage}</div>\n          ${attachmentsHtml}\n        </div>\n      `\n    })\n    .join('')\n  return `\n    <div style=\"font-family: Arial, sans-serif; line-height: 1.5; color: #111827;\">\n      <h2 style=\"margin: 0 0 12px 0;\">Support chat transcript</h2>\n      <p style=\"margin: 0 0 6px 0;\"><strong>Ticket ID:</strong> ${options.ticket.id}</p>\n      <p style=\"margin: 0 0 6px 0;\"><strong>User:</strong> ${options.ticket.userEmail}</p>\n      <p style=\"margin: 0 0 16px 0;\"><strong>Subject:</strong> ${subject}</p>\n      <div style=\"background:#f3f4f6; padding:12px; border-radius:8px;\">\n        ${transcriptHtml || '<div style=\"font-size: 13px; color: #6b7280;\">No messages recorded.</div>'}\n      </div>\n      ${internalNotes.length > 0 ? `\n        <div style=\"margin-top: 18px;\">\n          <h3 style=\"margin: 0 0 8px 0; font-size: 14px;\">AI internal notes</h3>\n          <pre style=\"background:#111827; color:#f9fafb; padding:12px; border-radius:8px; font-size:12px; white-space:pre-wrap;\">${escapeHtml(internalNotes.join('\\n\\n'))}</pre>\n        </div>\n      ` : ''}\n      ${getEmailFooter({\n        recipientEmail: SUPPORT_COPY_EMAIL,\n        emailType: 'admin',\n        reasonText: 'Transcript sent after the support chat ended.',\n      })}\n    </div>\n  `\n}\n\nexport async function sendSupportTranscriptEmail(ticketId: string) {\n  const resend = getResendClient()\n  if (!resend) return\n\n  const ticket = await prisma.supportTicket.findUnique({\n    where: { id: ticketId },\n    include: { responses: { orderBy: { createdAt: 'asc' } } },\n  })\n  if (!ticket) return\n  const alreadySent = ticket.responses?.some((response) => response.isAdminResponse && response.message?.startsWith(SYSTEM_TRANSCRIPT_MARKER))\n  if (alreadySent) return\n\n  const transcript = ''\n  await resend.emails.send({\n    from: 'Helfi Support <support@helfi.ai>',\n    to: SUPPORT_COPY_EMAIL,\n    subject: `Support transcript: ${ticket.subject || 'Support request'}`,\n    html: buildTranscriptHtml({ ticket, transcript }),\n  })\n\n  await prisma.ticketResponse.create({\n    data: {\n      ticketId,\n      message: `${SYSTEM_TRANSCRIPT_MARKER} (${new Date().toISOString()})`,\n      isAdminResponse: true,\n      adminId: null,\n    },\n  })\n}\n\nexport function buildSupportFeedbackPrompt(userName?: string | null) {\n  const name = userName?.trim() ? userName.trim().split(' ')[0] : 'there'\n  return [\n    `Thanks ${name} ‚Äî I‚Äôm glad we could help.`,\n    'If you have a moment, could you rate your support experience and leave a quick comment? It helps us improve.',\n    `\\n${SUPPORT_AGENT_NAME} from ${SUPPORT_AGENT_ROLE}`,\n  ].join('\\n')\n}\n\nexport async function sendSupportFeedbackEmail(options: {\n  ticketId: string\n  rating: number\n  comment?: string\n}) {\n  const resend = getResendClient()\n  if (!resend) return\n\n  const ticket = await prisma.supportTicket.findUnique({\n    where: { id: options.ticketId },\n  })\n  if (!ticket) return\n\n  const comment = options.comment?.trim() ? escapeHtml(options.comment.trim()) : 'No comment provided.'\n  const html = `\n    <div style=\"font-family: Arial, sans-serif; line-height: 1.5; color: #111827;\">\n      <h2 style=\"margin: 0 0 12px 0;\">Support feedback received</h2>\n      <p style=\"margin: 0 0 6px 0;\"><strong>Ticket ID:</strong> ${ticket.id}</p>\n      <p style=\"margin: 0 0 6px 0;\"><strong>User:</strong> ${ticket.userEmail}</p>\n      <p style=\"margin: 0 0 6px 0;\"><strong>Rating:</strong> ${options.rating}/5</p>\n      <p style=\"margin: 12px 0 0 0;\"><strong>Comment:</strong></p>\n      <p style=\"margin: 6px 0 0 0;\">${comment}</p>\n      ${getEmailFooter({\n        recipientEmail: SUPPORT_COPY_EMAIL,\n        emailType: 'admin',\n        reasonText: 'Support feedback submitted after a chat ended.',\n      })}\n    </div>\n  `\n\n  await resend.emails.send({\n    from: 'Helfi Support <support@helfi.ai>',\n    to: SUPPORT_COPY_EMAIL,\n    subject: `Support feedback: ${ticket.subject || 'Support request'}`,\n    html,\n  })\n}\n\nfunction fallbackSupportReply(): SupportAiResult {\n  return {\n    customerReply: 'Thanks for reaching out. I am unable to access the support assistant right now. I have flagged your request for a human review and will follow up as soon as possible.',\n    shouldEscalate: true,\n    escalationReason: 'AI unavailable',\n    needsIdentityCheck: false,\n    needsMoreInfo: true,\n    requestedInfo: [],\n    internalNotes: 'OpenAI client unavailable or response parse failed.',\n    suggestedCategory: '',\n    suggestedPriority: '',\n  }\n}\n\nexport async function processSupportTicketAutoReply(input: SupportAutomationInput) {\n  const ticket = await prisma.supportTicket.findUnique({\n    where: { id: input.ticketId },\n    include: {\n      responses: { orderBy: { createdAt: 'asc' } },\n      user: { select: { id: true, email: true, name: true } },\n    },\n  })\n\n  if (!ticket) return\n  if (!ticket.userEmail) return\n\n  const rawLatest = String(input.latestUserMessage || ticket.message || '').trim()\n  const parsedLatest = splitAttachmentsFromMessage(rawLatest)\n  let latestMessage = stripHtml(parsedLatest.text)\n  const rawLatestMessage = latestMessage\n\n  let identityVerified = isIdentityVerified(ticket.responses || []) || Boolean(ticket.userId)\n  let verificationPending = await hasPendingVerification(ticket.id, ticket.userEmail)\n  let verificationJustCompleted = false\n\n  const code = latestMessage ? extractVerificationCode(latestMessage) : null\n  if (code) {\n    const verified = await consumeVerificationCode(ticket.id, ticket.userEmail, code)\n    if (verified) {\n      identityVerified = true\n      verificationJustCompleted = true\n      verificationPending = false\n      latestMessage = latestMessage.replace(code, '').trim()\n      if (!latestMessage) {\n        latestMessage = 'User provided the verification code.'\n      }\n    }\n  }\n\n  const conversation = buildConversationHistory(ticket)\n  const hasPriorSupportReply = (ticket.responses || []).some((response: any) => {\n    const message = String(response.message || '')\n    return response.isAdminResponse && !message.startsWith('[SYSTEM]') && !message.startsWith('[FEEDBACK]')\n  })\n  const openai = getOpenAIClient()\n  let aiResult: SupportAiResult\n\n  if (!openai) {\n    aiResult = fallbackSupportReply()\n  } else {\n    const systemPrompt = buildSupportSystemPrompt()\n    const codeContext = buildSupportCodeContext([ticket.subject, latestMessage].filter(Boolean).join(' '))\n    const userPrompt = buildSupportUserPrompt({\n      ticket,\n      latestMessage,\n      latestAttachments: parsedLatest.attachments,\n      identityVerified,\n      verificationPending,\n      verificationJustCompleted,\n      hasPriorSupportReply,\n      codeContext,\n      conversation,\n    })\n\n    const completion = await runChatCompletionWithLogging(\n      openai,\n      {\n        model: SUPPORT_AI_MODEL,\n        messages: [\n          { role: 'system', content: systemPrompt },\n          { role: 'user', content: userPrompt },\n        ],\n        temperature: 0.2,\n        max_tokens: 500,\n      },\n      {\n        feature: 'support:ai',\n        userId: ticket.userId || ticket.user?.id || null,\n        userLabel: ticket.userEmail,\n      },\n      {\n        callDetail: input.source ? `source:${input.source}` : undefined,\n      }\n    )\n\n    const rawText = completion?.choices?.[0]?.message?.content || ''\n    aiResult = safeParseSupportJson(rawText) || fallbackSupportReply()\n  }\n\n  if (aiResult.needsIdentityCheck && !identityVerified) {\n    const sent = await ensureVerificationCode(ticket.id, ticket.userEmail)\n    const needsCodeReminder = !aiResult.customerReply.toLowerCase().includes('code')\n    if (sent && needsCodeReminder) {\n      aiResult.customerReply = `${aiResult.customerReply}\\n\\nFor security, we sent a 6-digit verification code to your email. Please reply with that code to continue.`\n    }\n    if (!sent) {\n      aiResult.customerReply = `${aiResult.customerReply}\\n\\nFor security, please log in to your Helfi account and continue this request from the in-app support chat so we can verify you.`\n    }\n  }\n\n  if (!aiResult.customerReply) {\n    aiResult = fallbackSupportReply()\n  }\n\n  if (aiResult.suggestedCategory && aiResult.suggestedCategory !== ticket.category) {\n    const allowedCategories: TicketCategory[] = ['GENERAL', 'TECHNICAL', 'BILLING', 'ACCOUNT', 'FEATURE_REQUEST', 'BUG_REPORT', 'EMAIL']\n    if (allowedCategories.includes(aiResult.suggestedCategory as TicketCategory)) {\n      await prisma.supportTicket.update({\n        where: { id: ticket.id },\n        data: { category: aiResult.suggestedCategory as TicketCategory },\n      })\n    }\n  }\n\n  if (aiResult.suggestedPriority && aiResult.suggestedPriority !== ticket.priority) {\n    const allowedPriorities: TicketPriority[] = ['LOW', 'MEDIUM', 'HIGH', 'URGENT']\n    if (allowedPriorities.includes(aiResult.suggestedPriority as TicketPriority)) {\n      await prisma.supportTicket.update({\n        where: { id: ticket.id },\n        data: { priority: aiResult.suggestedPriority as TicketPriority },\n      })\n    }\n  }\n\n  await prisma.ticketResponse.create({\n    data: {\n      ticketId: ticket.id,\n      message: aiResult.customerReply,\n      isAdminResponse: true,\n      adminId: null,\n    },\n  })\n\n  const internalNotes = aiResult.internalNotes?.trim()\n  if (internalNotes) {\n    const trimmedNotes = internalNotes.length > 1800 ? `${internalNotes.slice(0, 1800)}...` : internalNotes\n    await prisma.ticketResponse.create({\n      data: {\n        ticketId: ticket.id,\n        message: `${SYSTEM_INTERNAL_NOTES_MARKER} ${trimmedNotes}`,\n        isAdminResponse: true,\n        adminId: null,\n      },\n    })\n  }\n\n  await prisma.supportTicket.update({\n    where: { id: ticket.id },\n    data: {\n      status: aiResult.shouldEscalate ? 'IN_PROGRESS' : 'RESPONDED',\n      updatedAt: new Date(),\n    },\n  })\n\n  const isEmailChannel =\n    input.source === 'email_reply' ||\n    input.source === 'email_ticket' ||\n    input.source === 'web_ticket'\n  if (isEmailChannel) {\n    await sendSupportResponseEmail({\n      ticket,\n      message: aiResult.customerReply,\n      internalNotes: aiResult.internalNotes || '',\n      latestUserMessage: rawLatestMessage,\n      sendUserEmail: true,\n      sendSupportCopy: false,\n    })\n  }\n\n  if (aiResult.shouldEscalate) {\n    await sendEscalationNotice({\n      ticket,\n      internalNotes: aiResult.internalNotes || '',\n      reason: aiResult.escalationReason || 'Needs human review',\n    })\n  }\n\n  console.log('‚úÖ [SUPPORT AI] Auto-reply sent', {\n    ticketId: ticket.id,\n    source: input.source || 'unknown',\n    identityVerified,\n    verificationPending,\n    latestMessage: rawLatestMessage.slice(0, 120),\n  })\n}\n","truncated":false,"size":35784},{"path":"lib/support-code-search.ts","content":"import supportCodeIndex from '@/data/support-code-index.json'\n\ntype SupportCodeIndexEntry = {\n  path: string\n  content: string\n  truncated?: boolean\n  size?: number\n}\n\nconst STOPWORDS = new Set([\n  'the',\n  'and',\n  'for',\n  'with',\n  'that',\n  'this',\n  'from',\n  'your',\n  'you',\n  'are',\n  'not',\n  'have',\n  'has',\n  'was',\n  'were',\n  'what',\n  'when',\n  'where',\n  'why',\n  'how',\n  'can',\n  'cant',\n  'cannot',\n  'help',\n  'issue',\n  'problem',\n  'error',\n  'support',\n  'ticket',\n  'chat',\n  'app',\n  'site',\n  'page',\n  'user',\n])\n\nconst MAX_SNIPPETS = 3\nconst MAX_SNIPPET_CHARS = 900\n\nfunction extractKeywords(text: string): string[] {\n  return text\n    .toLowerCase()\n    .replace(/[^a-z0-9_\\- ]/g, ' ')\n    .split(/\\s+/)\n    .map((word) => word.trim())\n    .filter((word) => word.length > 3 && !STOPWORDS.has(word))\n    .slice(0, 8)\n}\n\nfunction scoreEntry(entry: SupportCodeIndexEntry, keywords: string[]): number {\n  const path = entry.path.toLowerCase()\n  const content = entry.content.toLowerCase()\n  let score = 0\n  keywords.forEach((keyword) => {\n    if (path.includes(keyword)) score += 3\n    if (content.includes(keyword)) score += 1\n  })\n  return score\n}\n\nfunction buildSnippet(entry: SupportCodeIndexEntry, keywords: string[]): string {\n  const content = entry.content\n  const lower = content.toLowerCase()\n  let index = -1\n  for (const keyword of keywords) {\n    index = lower.indexOf(keyword)\n    if (index !== -1) break\n  }\n  let snippet = ''\n  if (index === -1) {\n    snippet = content.slice(0, MAX_SNIPPET_CHARS)\n  } else {\n    const start = Math.max(0, index - 320)\n    const end = Math.min(content.length, index + 520)\n    snippet = content.slice(start, end)\n    if (start > 0) snippet = `...${snippet}`\n    if (end < content.length) snippet = `${snippet}...`\n  }\n  return snippet.length > MAX_SNIPPET_CHARS ? `${snippet.slice(0, MAX_SNIPPET_CHARS)}...` : snippet\n}\n\nexport function buildSupportCodeContext(message: string): string {\n  const keywords = extractKeywords(message)\n  if (keywords.length === 0) return ''\n\n  const entries = (supportCodeIndex as { entries?: SupportCodeIndexEntry[] }).entries || []\n  const scored = entries\n    .map((entry) => ({ entry, score: scoreEntry(entry, keywords) }))\n    .filter((item) => item.score > 0)\n    .sort((a, b) => b.score - a.score)\n    .slice(0, MAX_SNIPPETS)\n\n  if (scored.length === 0) return ''\n\n  const lines = ['Relevant code snippets (read-only, internal only):']\n  scored.forEach(({ entry }) => {\n    const snippet = buildSnippet(entry, keywords)\n    lines.push(`- ${entry.path}${entry.truncated ? ' (truncated)' : ''}`)\n    lines.push(snippet)\n  })\n\n  return lines.join('\\n')\n}\n","truncated":false,"size":2663},{"path":"lib/talk-to-ai-chat-store.ts","content":"import { prisma } from '@/lib/prisma'\n\nlet tablesEnsured = false\n\nexport async function ensureTalkToAITables(): Promise<void> {\n  if (tablesEnsured) return\n  try {\n    await prisma.$executeRawUnsafe(\n      'CREATE TABLE IF NOT EXISTS \"TalkToAIChatThread\" (\"id\" TEXT PRIMARY KEY, \"userId\" TEXT NOT NULL, \"title\" TEXT, \"createdAt\" TIMESTAMPTZ NOT NULL DEFAULT NOW(), \"updatedAt\" TIMESTAMPTZ NOT NULL DEFAULT NOW())'\n    )\n    await prisma.$executeRawUnsafe(\n      'CREATE TABLE IF NOT EXISTS \"TalkToAIChatMessage\" (\"id\" TEXT PRIMARY KEY, \"threadId\" TEXT NOT NULL, \"role\" TEXT NOT NULL, \"content\" TEXT NOT NULL, \"tokenCount\" INTEGER NULL, \"createdAt\" TIMESTAMPTZ NOT NULL DEFAULT NOW(), CONSTRAINT \"TalkToAIChatMessage_threadId_fkey\" FOREIGN KEY (\"threadId\") REFERENCES \"TalkToAIChatThread\"(\"id\") ON DELETE CASCADE)'\n    )\n    await prisma.$executeRawUnsafe(\n      'CREATE INDEX IF NOT EXISTS \"TalkToAIChatMessage_threadId_createdAt_idx\" ON \"TalkToAIChatMessage\" (\"threadId\", \"createdAt\")'\n    )\n    await prisma.$executeRawUnsafe(\n      'CREATE INDEX IF NOT EXISTS \"TalkToAIChatThread_userId_idx\" ON \"TalkToAIChatThread\" (\"userId\")'\n    )\n    tablesEnsured = true\n  } catch (error) {\n    console.error('[talk-to-ai] Failed to ensure tables', error)\n  }\n}\n\nfunction uuid(): string {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n    const r = (Math.random() * 16) | 0\n    const v = c === 'x' ? r : (r & 0x3) | 0x8\n    return v.toString(16)\n  })\n}\n\nexport type ChatThread = { id: string; title: string | null; createdAt: string; updatedAt: string }\n\nexport async function listThreads(userId: string): Promise<ChatThread[]> {\n  await ensureTalkToAITables()\n  const rows: Array<{ id: string; title: string | null; createdAt: Date; updatedAt: Date }> = await prisma.$queryRawUnsafe(\n    'SELECT \"id\",\"title\",\"createdAt\",\"updatedAt\" FROM \"TalkToAIChatThread\" WHERE \"userId\" = $1 ORDER BY \"updatedAt\" DESC LIMIT 50',\n    userId\n  )\n  return rows.map((r) => ({ id: r.id, title: r.title, createdAt: r.createdAt.toISOString(), updatedAt: r.updatedAt.toISOString() }))\n}\n\nexport async function createThread(userId: string, title?: string): Promise<{ id: string }> {\n  await ensureTalkToAITables()\n  const id = uuid()\n  await prisma.$executeRawUnsafe(\n    'INSERT INTO \"TalkToAIChatThread\" (\"id\",\"userId\",\"title\") VALUES ($1,$2,$3)',\n    id,\n    userId,\n    title || null\n  )\n  return { id }\n}\n\nexport async function updateThreadTitle(threadId: string, title: string): Promise<void> {\n  await ensureTalkToAITables()\n  await prisma.$executeRawUnsafe(\n    'UPDATE \"TalkToAIChatThread\" SET \"title\" = $1, \"updatedAt\" = NOW() WHERE \"id\" = $2',\n    title,\n    threadId\n  )\n}\n\nexport async function deleteThread(threadId: string): Promise<void> {\n  await ensureTalkToAITables()\n  await prisma.$executeRawUnsafe('DELETE FROM \"TalkToAIChatThread\" WHERE \"id\" = $1', threadId)\n}\n\nexport type ChatMessage = { id: string; role: 'user' | 'assistant'; content: string; createdAt: string }\n\nexport async function listMessages(threadId: string, limit = 40): Promise<ChatMessage[]> {\n  await ensureTalkToAITables()\n  const rows: Array<{ id: string; role: string; content: string; createdAt: Date }> = await prisma.$queryRawUnsafe(\n    'SELECT \"id\",\"role\",\"content\",\"createdAt\" FROM \"TalkToAIChatMessage\" WHERE \"threadId\" = $1 ORDER BY \"createdAt\" ASC LIMIT $2',\n    threadId,\n    Math.max(1, Math.min(200, limit))\n  )\n  return rows.map((r) => ({ id: r.id, role: r.role as 'user' | 'assistant', content: r.content, createdAt: r.createdAt.toISOString() }))\n}\n\nexport async function appendMessage(threadId: string, role: 'user' | 'assistant', content: string, tokenCount?: number): Promise<string> {\n  await ensureTalkToAITables()\n  const id = uuid()\n  await prisma.$executeRawUnsafe(\n    'INSERT INTO \"TalkToAIChatMessage\" (\"id\",\"threadId\",\"role\",\"content\",\"tokenCount\") VALUES ($1,$2,$3,$4,$5)',\n    id,\n    threadId,\n    role,\n    content,\n    tokenCount ?? null\n  )\n  await prisma.$executeRawUnsafe('UPDATE \"TalkToAIChatThread\" SET \"updatedAt\" = NOW() WHERE \"id\" = $1', threadId)\n  return id\n}\n\n","truncated":false,"size":4092},{"path":"lib/vision-usage-logger.ts","content":"import fs from 'fs'\nimport path from 'path'\n\nexport type VisionUsageEntry = {\n  timestamp: number\n  scanId?: string | null\n  feature: string\n  userId?: string | null\n  userLabel?: string | null\n  model: string\n  promptTokens: number\n  completionTokens: number\n  costCents: number\n  imageWidth: number | null\n  imageHeight: number | null\n  imageBytes: number | null\n  imageMime: string | null\n  endpoint?: string | null\n  detail?: string | null\n}\n\nconst GLOBAL_KEY = '__helfiVisionUsage__'\nconst LOG_DIR = path.join(process.cwd(), 'openai-usage')\nconst LOG_FILE = path.join(LOG_DIR, 'vision-usage.log')\nconst DEFAULT_DISK_LIMIT = 1000\n\nfunction getStore(): VisionUsageEntry[] {\n  const globalAny = globalThis as any\n  if (!globalAny[GLOBAL_KEY]) {\n    globalAny[GLOBAL_KEY] = []\n  }\n  return globalAny[GLOBAL_KEY]\n}\n\nexport function logVisionUsage(entry: VisionUsageEntry) {\n  const store = getStore()\n  store.push(entry)\n\n  try {\n    fs.mkdirSync(LOG_DIR, { recursive: true })\n    fs.appendFileSync(LOG_FILE, JSON.stringify(entry) + '\\n', 'utf8')\n  } catch (err) {\n    console.warn('[vision-usage] failed to persist log entry', err)\n  }\n}\n\nexport function getVisionUsageSummary(entries?: VisionUsageEntry[]) {\n  const data = (entries && entries.length > 0 ? entries : getStore()).slice()\n  const grouped: Record<\n    string,\n    {\n      count: number\n      tokens: number\n      promptTokens: number\n      completionTokens: number\n      costCents: number\n      avgResolution: string\n      maxWidth: number | null\n      maxHeight: number | null\n      models: Record<string, number>\n    }\n  > = {}\n\n  data.forEach((row) => {\n    const key = row.feature || 'unknown'\n    if (!grouped[key]) {\n      grouped[key] = {\n        count: 0,\n        tokens: 0,\n        promptTokens: 0,\n        completionTokens: 0,\n        costCents: 0,\n        avgResolution: '',\n        maxWidth: null,\n        maxHeight: null,\n        models: {},\n      }\n    }\n    const bucket = grouped[key]\n    bucket.count += 1\n    bucket.promptTokens += Number(row.promptTokens || 0)\n    bucket.completionTokens += Number(row.completionTokens || 0)\n    bucket.tokens = bucket.promptTokens + bucket.completionTokens\n    bucket.costCents += Number(row.costCents || 0)\n    if (row.model) {\n      bucket.models[row.model] = (bucket.models[row.model] || 0) + 1\n    }\n    if (row.imageWidth && row.imageHeight) {\n      bucket.maxWidth = bucket.maxWidth ? Math.max(bucket.maxWidth, row.imageWidth) : row.imageWidth\n      bucket.maxHeight = bucket.maxHeight ? Math.max(bucket.maxHeight, row.imageHeight) : row.imageHeight\n    }\n  })\n\n  Object.keys(grouped).forEach((key) => {\n    const b = grouped[key]\n    if (b.maxWidth && b.maxHeight) {\n      b.avgResolution = `${b.maxWidth}x${b.maxHeight} (max observed)`\n    } else {\n      b.avgResolution = 'n/a'\n    }\n  })\n\n  return grouped\n}\n\nexport function printVisionUsageSummary(entries?: VisionUsageEntry[]) {\n  const summary = getVisionUsageSummary(entries)\n  const rows = Object.entries(summary)\n  if (rows.length === 0) {\n    console.log('[vision-usage] No entries logged yet.')\n    return\n  }\n\n  console.log('\\n=== Vision Usage by Feature ===')\n  rows.forEach(([feature, stats]) => {\n    console.log(\n      `- ${feature}: ${stats.count} call(s), tokens p/c: ${stats.promptTokens}/${stats.completionTokens} (total ${stats.tokens}), cost: ${(stats.costCents / 100).toFixed(\n        2\n      )} USD, resolution: ${stats.avgResolution}`\n    )\n  })\n  console.log('=== End Vision Usage ===\\n')\n}\n\nexport function loadVisionUsageFromDisk(limit: number = DEFAULT_DISK_LIMIT): VisionUsageEntry[] {\n  try {\n    if (!fs.existsSync(LOG_FILE)) return []\n    const lines = fs.readFileSync(LOG_FILE, 'utf8').split('\\n').filter(Boolean)\n    const slice = lines.slice(-Math.max(1, limit))\n    const entries: VisionUsageEntry[] = []\n    for (const line of slice) {\n      try {\n        const parsed = JSON.parse(line)\n        entries.push(parsed)\n      } catch {\n        // skip malformed\n      }\n    }\n    return entries\n  } catch (err) {\n    console.warn('[vision-usage] failed to read log file', err)\n    return []\n  }\n}\n\nexport function buildVisionUsageAnalytics(entries?: VisionUsageEntry[]) {\n  const data = (entries && entries.length ? entries : getStore()).slice()\n  const featureSummary: Record<\n    string,\n    {\n      count: number\n      promptTokens: number\n      completionTokens: number\n      costCents: number\n      models: Record<string, number>\n      maxWidth: number | null\n      maxHeight: number | null\n    }\n  > = {}\n\n  const userSummary: Record<\n    string,\n    {\n      label: string\n      count: number\n      promptTokens: number\n      completionTokens: number\n      costCents: number\n      features: Record<string, number>\n    }\n  > = {}\n\n  const trendByDay: Record<string, { costCents: number; calls: number }> = {}\n\n  let monthCostCents = 0\n  let monthPromptTokens = 0\n  let monthCompletionTokens = 0\n  const now = new Date()\n  const monthStart = new Date(now.getFullYear(), now.getMonth(), 1).getTime()\n\n  data.forEach((row) => {\n    // Feature aggregation\n    const fKey = row.feature || 'unknown'\n    if (!featureSummary[fKey]) {\n      featureSummary[fKey] = {\n        count: 0,\n        promptTokens: 0,\n        completionTokens: 0,\n        costCents: 0,\n        models: {},\n        maxWidth: null,\n        maxHeight: null,\n      }\n    }\n    const f = featureSummary[fKey]\n    f.count += 1\n    f.promptTokens += Number(row.promptTokens || 0)\n    f.completionTokens += Number(row.completionTokens || 0)\n    f.costCents += Number(row.costCents || 0)\n    if (row.model) {\n      f.models[row.model] = (f.models[row.model] || 0) + 1\n    }\n    if (row.imageWidth && row.imageHeight) {\n      f.maxWidth = f.maxWidth ? Math.max(f.maxWidth, row.imageWidth) : row.imageWidth\n      f.maxHeight = f.maxHeight ? Math.max(f.maxHeight, row.imageHeight) : row.imageHeight\n    }\n\n    // User aggregation\n    const userKey = row.userId || row.userLabel || 'unknown'\n    const userLabel = row.userLabel || row.userId || 'unknown'\n    if (!userSummary[userKey]) {\n      userSummary[userKey] = {\n        label: userLabel,\n        count: 0,\n        promptTokens: 0,\n        completionTokens: 0,\n        costCents: 0,\n        features: {},\n      }\n    }\n    const u = userSummary[userKey]\n    u.count += 1\n    u.promptTokens += Number(row.promptTokens || 0)\n    u.completionTokens += Number(row.completionTokens || 0)\n    u.costCents += Number(row.costCents || 0)\n    u.features[fKey] = (u.features[fKey] || 0) + 1\n\n    // Trend by day\n    const day = new Date(Number(row.timestamp || Date.now())).toISOString().slice(0, 10)\n    if (!trendByDay[day]) {\n      trendByDay[day] = { costCents: 0, calls: 0 }\n    }\n    trendByDay[day].costCents += Number(row.costCents || 0)\n    trendByDay[day].calls += 1\n\n    // Month-to-date\n    if (Number(row.timestamp) >= monthStart) {\n      monthCostCents += Number(row.costCents || 0)\n      monthPromptTokens += Number(row.promptTokens || 0)\n      monthCompletionTokens += Number(row.completionTokens || 0)\n    }\n  })\n\n  const trend = Object.entries(trendByDay)\n    .map(([day, v]) => ({ day, costCents: v.costCents, calls: v.calls }))\n    .sort((a, b) => a.day.localeCompare(b.day))\n\n  const scans = data\n    .slice()\n    .sort((a, b) => Number(b.timestamp) - Number(a.timestamp))\n    .map((row) => ({\n      ...row,\n      tokens: Number(row.promptTokens || 0) + Number(row.completionTokens || 0),\n      costUsd: Number(row.costCents || 0) / 100,\n      timestampIso: new Date(Number(row.timestamp || Date.now())).toISOString(),\n    }))\n\n  const totals = {\n    totalCalls: data.length,\n    totalCostCents: data.reduce((acc, r) => acc + Number(r.costCents || 0), 0),\n    totalPromptTokens: data.reduce((acc, r) => acc + Number(r.promptTokens || 0), 0),\n    totalCompletionTokens: data.reduce((acc, r) => acc + Number(r.completionTokens || 0), 0),\n    monthCostCents,\n    monthPromptTokens,\n    monthCompletionTokens,\n  }\n\n  return { featureSummary, userSummary, trend, scans, totals }\n}\n","truncated":false,"size":8011},{"path":"middleware.ts","content":"import { NextResponse } from 'next/server'\nimport type { NextRequest } from 'next/server'\nimport { getToken } from 'next-auth/jwt'\n\nconst ADMIN_GATE_COOKIE_MAX_AGE = 30 * 24 * 60 * 60 // 30 days\n\nexport async function middleware(request: NextRequest) {\n  // Preview-staging should always skip the admin gate to avoid iOS logout loops\n  const skipAdminGate = true\n\n  // Skip middleware for static files and API routes that don't need auth\n  if (\n    request.nextUrl.pathname.startsWith('/_next') ||\n    request.nextUrl.pathname.startsWith('/api') ||\n    request.nextUrl.pathname.includes('.')\n  ) {\n    return NextResponse.next()\n  }\n\n  try {\n    // Get the session token from the request\n    const token = await getToken({ \n      req: request, \n      secret: process.env.NEXTAUTH_SECRET || 'helfi-secret-key-production-2024',\n      // Use a stable encryption key to prevent session invalidation\n      cookieName: process.env.NODE_ENV === 'production' \n        ? '__Secure-next-auth.session-token' \n        : 'next-auth.session-token'\n    })\n\n    // If we have a valid token, preserve it by adding stability headers\n    if (token) {\n      // PWA guard rail: signed-in Home Screen opens must skip login/marketing.\n      // If you touch this, read GUARD_RAILS.md (PWA Home Screen / Entry Path).\n      if (request.nextUrl.pathname === '/auth/signin' || request.nextUrl.pathname === '/') {\n        const redirectUrl = request.nextUrl.clone()\n        redirectUrl.pathname = '/pwa-entry'\n        return NextResponse.redirect(redirectUrl)\n      }\n\n      const response = NextResponse.next()\n\n      // Refresh admin gate cookie so testers aren't booted back to the gate page\n      response.cookies.set('passed_admin_gate', '1', {\n        httpOnly: false,\n        maxAge: ADMIN_GATE_COOKIE_MAX_AGE,\n        path: '/',\n        sameSite: 'lax',\n        secure: request.nextUrl.protocol === 'https:'\n      })\n      \n      // Add headers to prevent session invalidation during deployments\n      response.headers.set('X-Session-Preserved', 'true')\n      response.headers.set('Cache-Control', 'no-cache, no-store, must-revalidate')\n      \n      return response\n    }\n  } catch (error) {\n    console.error('Middleware session check error:', error)\n    // Continue without session preservation if there's an error\n  }\n\n  // Gate sign-in routes behind /healthapp admin check\n  const pathname = request.nextUrl.pathname\n  if (skipAdminGate && pathname === '/healthapp') {\n    const url = request.nextUrl.clone()\n    url.pathname = '/auth/signin'\n    return NextResponse.redirect(url)\n  }\n  // Never allow direct access to the temporary staging sign-in page\n  if (pathname === '/staging-signin') {\n    const url = request.nextUrl.clone()\n    url.pathname = '/healthapp'\n    return NextResponse.redirect(url)\n  }\n  const needsAdminGate = pathname === '/auth/signin'\n  if (skipAdminGate && needsAdminGate) {\n    return NextResponse.next()\n  }\n  const hasPassedGate = request.cookies.get('passed_admin_gate')?.value === '1'\n  if (needsAdminGate && !hasPassedGate) {\n    const url = request.nextUrl.clone()\n    url.pathname = '/healthapp'\n    return NextResponse.redirect(url)\n  }\n\n  return NextResponse.next()\n}\n\nexport const config = {\n  matcher: [\n    /*\n     * Match all request paths except for the ones starting with:\n     * - api (API routes)\n     * - _next/static (static files)\n     * - _next/image (image optimization files)\n     * - favicon.ico (favicon file)\n     */\n    '/((?!api|_next/static|_next/image|favicon.ico).*)',\n  ],\n}\n","truncated":false,"size":3518},{"path":"next.config.js","content":"module.exports = {\n  images: {\n    domains: ['res.cloudinary.com', 'lh3.googleusercontent.com', 'blob.vercel-storage.com'],\n    remotePatterns: [\n      {\n        protocol: 'https',\n        hostname: '**.public.blob.vercel-storage.com',\n      },\n      {\n        protocol: 'https',\n        hostname: '**.blob.vercel-storage.com',\n      },\n    ],\n  },\n  // Session preservation during development and deployment\n  experimental: {\n    serverComponentsExternalPackages: ['prisma'],\n    // Improve session stability during hot reloads\n    esmExternals: 'loose',\n  },\n  // Prevent session invalidation during hot reloads and deployments\n  onDemandEntries: {\n    maxInactiveAge: 25 * 1000,\n    pagesBufferLength: 2,\n  },\n  // Fast refresh configuration with session preservation\n  webpack: (config, { dev, isServer }) => {\n    if (dev) {\n      config.watchOptions = {\n        poll: 1000,\n        aggregateTimeout: 300,\n      }\n    }\n    \n    // Prevent session invalidation during builds\n    if (!isServer) {\n      config.resolve.fallback = {\n        ...config.resolve.fallback,\n        fs: false,\n        net: false,\n        tls: false,\n      }\n    }\n    \n    return config\n  },\n  // Stable environment variables to prevent session invalidation\n  env: {\n    NEXTAUTH_URL: process.env.NEXTAUTH_URL,\n    NEXTAUTH_SECRET: process.env.NEXTAUTH_SECRET,\n    GOOGLE_CLIENT_ID: process.env.GOOGLE_CLIENT_ID,\n    GOOGLE_CLIENT_SECRET: process.env.GOOGLE_CLIENT_SECRET,\n    CLOUDINARY_CLOUD_NAME: process.env.CLOUDINARY_CLOUD_NAME,\n    CLOUDINARY_API_KEY: process.env.CLOUDINARY_API_KEY,\n    CLOUDINARY_API_SECRET: process.env.CLOUDINARY_API_SECRET,\n    CLOUDINARY_URL: process.env.CLOUDINARY_URL,\n    NEXT_PUBLIC_CHECKINS_ENABLED: process.env.NEXT_PUBLIC_CHECKINS_ENABLED || 'false',\n    NEXT_PUBLIC_INSIGHTS_ENABLED: process.env.NEXT_PUBLIC_INSIGHTS_ENABLED || 'false',\n    NEXT_PUBLIC_REPORTS_ENABLED: process.env.NEXT_PUBLIC_REPORTS_ENABLED || 'false',\n    NEXT_PUBLIC_INSIGHTS_CHAT: process.env.NEXT_PUBLIC_INSIGHTS_CHAT || 'true',\n  },\n  // Add headers to improve session stability\n  async headers() {\n    return [\n      {\n        source: '/api/auth/:path*',\n        headers: [\n          {\n            key: 'Cache-Control',\n            value: 'no-store, max-age=0',\n          },\n        ],\n      },\n    ]\n  },\n}\n","truncated":false,"size":2301},{"path":"package.json","content":"{\n  \"name\": \"helfi\",\n  \"version\": \"0.1.0\",\n  \"private\": true,\n  \"engines\": {\n    \"node\": \"22.x\"\n  },\n  \"scripts\": {\n    \"dev\": \"next dev\",\n    \"prebuild\": \"node scripts/protect-regions.js\",\n    \"build\": \"prisma generate && next build\",\n    \"start\": \"next start\",\n    \"lint\": \"next lint\",\n    \"postinstall\": \"prisma generate\",\n    \"test:food-normalization\": \"TS_NODE_TRANSPILE_ONLY=1 TS_NODE_COMPILER_OPTIONS='{\\\"module\\\":\\\"commonjs\\\",\\\"moduleResolution\\\":\\\"node\\\"}' ts-node scripts/food-normalization-check.ts\",\n    \"seed:exercise-types\": \"TS_NODE_TRANSPILE_ONLY=1 TS_NODE_COMPILER_OPTIONS='{\\\"module\\\":\\\"commonjs\\\",\\\"moduleResolution\\\":\\\"node\\\"}' ts-node scripts/seed-exercise-types.ts\"\n  },\n  \"dependencies\": {\n    \"@aws-sdk/client-kms\": \"^3.927.0\",\n    \"@aws-sdk/client-s3\": \"^3.927.0\",\n    \"@aws-sdk/s3-presigned-post\": \"^3.927.0\",\n    \"@aws-sdk/s3-request-presigner\": \"^3.927.0\",\n    \"@headlessui/react\": \"^1.7.18\",\n    \"@heroicons/react\": \"^2.1.1\",\n    \"@prisma/client\": \"^5.9.1\",\n    \"@tailwindcss/forms\": \"^0.5.7\",\n    \"@types/bcrypt\": \"^5.0.2\",\n    \"@types/jsonwebtoken\": \"^9.0.10\",\n    \"@types/qrcode\": \"^1.5.6\",\n    \"@vercel/blob\": \"^2.0.0\",\n    \"@zxing/browser\": \"^0.1.5\",\n    \"@zxing/library\": \"^0.21.3\",\n    \"axios\": \"^1.6.7\",\n    \"bcrypt\": \"^6.0.0\",\n    \"bcryptjs\": \"^3.0.2\",\n    \"chart.js\": \"^4.4.1\",\n    \"chartjs-adapter-date-fns\": \"^3.0.0\",\n    \"cloudinary\": \"^2.7.0\",\n    \"crypto\": \"^1.0.1\",\n    \"date-fns\": \"^3.3.1\",\n    \"html5-qrcode\": \"^2.3.8\",\n    \"jsonwebtoken\": \"^9.0.2\",\n    \"next\": \"14.1.0\",\n    \"next-auth\": \"^4.24.5\",\n    \"oauth-1.0a\": \"^2.2.6\",\n    \"openai\": \"^5.7.0\",\n    \"otplib\": \"^12.0.1\",\n    \"pdf-lib\": \"^1.17.1\",\n    \"pdfjs-dist\": \"^5.4.394\",\n    \"playwright\": \"^1.53.2\",\n    \"qrcode\": \"^1.5.4\",\n    \"react\": \"^18.2.0\",\n    \"react-chartjs-2\": \"^5.2.0\",\n    \"react-dom\": \"^18.2.0\",\n    \"react-hook-form\": \"^7.50.1\",\n    \"resend\": \"^4.6.0\",\n    \"stripe\": \"^16.12.0\",\n    \"tailwindcss\": \"^3.4.1\",\n    \"twilio\": \"^5.10.5\",\n    \"typescript\": \"^5.3.3\",\n    \"web-push\": \"^3.6.7\",\n    \"zod\": \"^3.22.4\"\n  },\n  \"devDependencies\": {\n    \"@types/bcryptjs\": \"^2.4.6\",\n    \"@types/node\": \"^20.11.16\",\n    \"@types/react\": \"^18.2.52\",\n    \"@types/react-dom\": \"^18.2.18\",\n    \"autoprefixer\": \"^10.4.17\",\n    \"eslint\": \"^8.56.0\",\n    \"eslint-config-next\": \"14.1.0\",\n    \"postcss\": \"^8.4.33\",\n    \"prisma\": \"^5.9.1\",\n    \"ts-node\": \"^10.9.2\"\n  }\n}\n","truncated":false,"size":2366},{"path":"prisma/schema.prisma","content":"generator client {\n  provider = \"prisma-client-js\"\n}\n\ndatasource db {\n  provider = \"postgresql\"\n  url      = env(\"DATABASE_URL\")\n}\n\nmodel User {\n  id                     String    @id @default(cuid())\n  email                  String    @unique\n  passwordHash           String?\n  emailVerified          DateTime?\n  name                   String?\n  image                  String?\n  gender                 Gender?\n  weight                 Float?\n  height                 Float?\n  bodyType               BodyType?\n  exerciseFrequency      String?\n  exerciseTypes          String[]\n  termsAccepted          Boolean   @default(false)\n  // Credit system fields\n  dailyAnalysisCredits   Int       @default(3) // Free: 3, Premium: 30\n  additionalCredits      Int       @default(0) // Purchased credits that don't expire\n  lastAnalysisResetDate  DateTime? // Track daily reset\n  lastMonthlyResetDate   DateTime? // Track monthly reset for monthly quotas\n  totalAnalysisCount     Int       @default(0) // Lifetime usage counter\n  dailyAnalysisUsed      Int       @default(0) // Used today\n  // Wallet-based metering (Cursor-style)\n  walletMonthlyUsedCents Int       @default(0) // Amount used this month in cents\n  walletMonthlyResetAt   DateTime? // Last time monthly wallet was reset\n\n  // Feature-specific credit tracking\n  dailyFoodAnalysisUsed          Int @default(0) // Food analysis credits used today\n  dailyFoodReanalysisUsed        Int @default(0) // Food re-analysis used today\n  dailyMedicalAnalysisUsed       Int @default(0) // Medical image analyses used today\n  dailyInteractionAnalysisUsed   Int @default(0) // Interaction analysis credits used today\n  totalFoodAnalysisCount         Int @default(0) // Lifetime food analysis count\n  totalInteractionAnalysisCount  Int @default(0) // Lifetime interaction analysis count\n  monthlyInteractionAnalysisUsed Int @default(0) // Monthly interactions used (premium)\n\n  // Monthly per-feature usage tracking (resets monthly)\n  monthlySymptomAnalysisUsed      Int @default(0) // Symptom analyses used this month\n  monthlyFoodAnalysisUsed         Int @default(0) // Food analyses used this month\n  monthlyMedicalImageAnalysisUsed Int @default(0) // Medical image analyses used this month\n  monthlyInsightsGenerationUsed   Int @default(0) // Insights generations used this month\n\n  // Free credits tracking (granted once on signup)\n  freeFoodAnalysisRemaining       Int @default(5) // 5 free food image analyses\n  freeSymptomAnalysisRemaining    Int @default(2) // 2 free symptom analyses\n  freeMedicalAnalysisRemaining    Int @default(2) // 2 free medical image analyses\n  freeInteractionAnalysisRemaining Int @default(2) // 2 free supplement/medication interaction analyses\n  freeHealthIntakeRemaining       Int @default(1) // 1 free full health intake analysis (on page 11 complete)\n  freeInsightsUpdateRemaining     Int @default(3) // 3 free insights updates (when changing health setup)\n  freeSymptomChatRemaining        Int @default(0) // Free symptom follow-up chats (granted on signup)\n  freeMedicalChatRemaining        Int @default(0) // Free medical image follow-up chats (granted on signup)\n  freeInsightsChatRemaining       Int @default(0) // Free insights chats (granted on signup)\n  freeVoiceChatRemaining          Int @default(0) // Free voice chat uses (granted on signup)\n  freeFoodReanalysisRemaining     Int @default(0) // Free food re-analyses (granted on signup)\n  freeInteractionReanalysisRemaining Int @default(0) // Free interaction re-analyses (granted on signup)\n\n  createdAt           DateTime              @default(now())\n  updatedAt           DateTime              @updatedAt\n  accounts            Account[]\n  sessions            Session[]\n  healthGoals         HealthGoal[]\n  supplements         Supplement[]\n  medications         Medication[]\n  healthLogs          HealthLog[]\n  foodLogs            FoodLog[]\n  exerciseLogs        ExerciseLog[]\n  exerciseEntries     ExerciseEntry[]\n  subscription        Subscription?\n  affiliate           Affiliate?             @relation(\"AffiliateUser\")\n  affiliateApplications AffiliateApplication[] @relation(\"AffiliateApplicationUser\")\n  affiliateReferral   AffiliateReferral?     @relation(\"AffiliateReferredUser\")\n  affiliateConversions AffiliateConversion[] @relation(\"AffiliateConvertedUser\")\n  supportTickets      SupportTicket[]\n  interactionAnalyses InteractionAnalysis[]\n  symptomAnalyses     SymptomAnalysis[]\n  creditTopUps        CreditTopUp[]\n  fitbitData          FitbitData[]\n  garminRequestTokens GarminRequestToken[]\n  garminWebhookLogs   GarminWebhookLog[]\n  foodAnalysisFeedback FoodAnalysisFeedback[]\n  medicalImageAnalyses MedicalImageAnalysis[]\n\n  // File relationships (PHASE 2 addition)\n  uploadedFiles File[] @relation(\"UploadedFiles\")\n  profileImages File[] @relation(\"ProfileImages\")\n\n  // Lab report relationships\n  reports        Report[]\n  consentRecords ConsentRecord[]\n}\n\nmodel Account {\n  id                String  @id @default(cuid())\n  userId            String\n  type              String\n  provider          String\n  providerAccountId String\n  refresh_token     String?\n  access_token      String?\n  expires_at        Int?\n  token_type        String?\n  scope             String?\n  id_token          String?\n  session_state     String?\n  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  @@unique([provider, providerAccountId])\n}\n\nmodel Session {\n  id           String   @id @default(cuid())\n  sessionToken String   @unique\n  userId       String\n  expires      DateTime\n  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)\n}\n\nmodel VerificationToken {\n  identifier String\n  token      String   @unique\n  expires    DateTime\n\n  @@unique([identifier, token])\n}\n\nmodel PasswordResetToken {\n  id        String   @id @default(cuid())\n  email     String\n  tokenHash String   @unique\n  expires   DateTime\n  createdAt DateTime @default(now())\n\n  @@index([email])\n}\n\nmodel HealthGoal {\n  id            String      @id @default(cuid())\n  userId        String\n  name          String\n  category      String\n  currentRating Int\n  createdAt     DateTime    @default(now())\n  updatedAt     DateTime    @updatedAt\n  user          User        @relation(fields: [userId], references: [id], onDelete: Cascade)\n  healthLogs    HealthLog[]\n}\n\nmodel Supplement {\n  id        String   @id @default(cuid())\n  userId    String\n  name      String\n  dosage    String\n  timing    String[]\n  imageUrl  String?\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  // File relationships (PHASE 2 addition)\n  images File[] @relation(\"SupplementImages\")\n}\n\nmodel Medication {\n  id        String   @id @default(cuid())\n  userId    String\n  name      String\n  dosage    String\n  timing    String[]\n  imageUrl  String?\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  // File relationships (PHASE 2 addition)\n  images File[] @relation(\"MedicationImages\")\n}\n\nmodel HealthLog {\n  id        String     @id @default(cuid())\n  userId    String\n  goalId    String\n  rating    Int\n  notes     String?\n  createdAt DateTime   @default(now())\n  goal      HealthGoal @relation(fields: [goalId], references: [id], onDelete: Cascade)\n  user      User       @relation(fields: [userId], references: [id], onDelete: Cascade)\n}\n\nmodel FoodLog {\n  id          String   @id @default(cuid())\n  userId      String\n  name        String\n  imageUrl    String?\n  description String?\n  nutrients   Json?\n  items       Json?      // Structured ingredient list for robust card editing\n  localDate   String?    // Local calendar date (YYYY-MM-DD) to avoid timezone drift in history\n  meal        String?    // Normalized meal category (breakfast, lunch, dinner, snacks, uncategorized)\n  category    String?    // Optional original category label for compatibility\n  createdAt   DateTime @default(now())\n  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  // File relationships (PHASE 2 addition)\n  images File[] @relation(\"FoodLogImages\")\n}\n\nmodel BarcodeProduct {\n  id               String   @id @default(cuid())\n  barcode          String   @unique\n  name             String\n  brand            String?\n  servingSize      String?\n  calories         Float?\n  proteinG         Float?\n  carbsG           Float?\n  fatG             Float?\n  fiberG           Float?\n  sugarG           Float?\n  quantityG        Float?\n  piecesPerServing Float?\n  source           String?\n  reportCount      Int      @default(0)\n  lastReportedAt   DateTime?\n  createdById      String?\n  updatedById      String?\n  createdAt        DateTime @default(now())\n  updatedAt        DateTime @updatedAt\n\n  @@index([barcode])\n}\n\nmodel ExerciseLog {\n  id        String   @id @default(cuid())\n  userId    String\n  type      String\n  duration  Int\n  intensity String?\n  notes     String?\n  createdAt DateTime @default(now())\n  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)\n}\n\n// Food Diary Exercise - MET catalog\nmodel ExerciseType {\n  id        Int      @id @default(autoincrement())\n  name      String\n  category  String\n  met       Float\n  intensity String?\n  isCustom  Boolean  @default(false)\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n\n  entries ExerciseEntry[]\n\n  @@unique([name, category])\n  @@index([name])\n}\n\n// Food Diary Exercise - per-user daily entries (manual or synced)\nmodel ExerciseEntry {\n  id              String         @id @default(cuid())\n  userId          String\n  localDate       String         // Local calendar date (YYYY-MM-DD) to avoid timezone drift\n  startTime       DateTime?\n  durationMinutes Int\n  distanceKm      Float?\n  source          ExerciseSource\n  deviceId        String?\n  exerciseTypeId  Int?\n  label           String\n  met             Float\n  calories        Float\n  rawPayload      Json?\n  createdAt       DateTime       @default(now())\n  updatedAt       DateTime       @updatedAt\n\n  user         User          @relation(fields: [userId], references: [id], onDelete: Cascade)\n  exerciseType ExerciseType? @relation(fields: [exerciseTypeId], references: [id])\n\n  @@index([userId, localDate])\n  @@unique([userId, source, deviceId])\n}\n\nenum ExerciseSource {\n  MANUAL\n  FITBIT\n  GARMIN\n}\n\nmodel AIUsageEvent {\n  id                String    @id @default(cuid())\n  createdAt         DateTime  @default(now())\n  feature           String\n  userId            String?\n  userLabel         String?\n  scanId            String?\n  model             String\n  promptTokens      Int       @default(0)\n  completionTokens  Int       @default(0)\n  totalTokens       Int       @default(0)\n  costCents         Int       @default(0)\n  imageWidth        Int?\n  imageHeight       Int?\n  imageBytes        Int?\n  imageMime         String?\n  endpoint          String?\n  success           Boolean   @default(true)\n  errorMessage      String?\n  detail            String?\n  runId             String?\n\n  @@index([runId])\n}\n\nmodel FoodAnalysisFeedback {\n  id              String   @id @default(cuid())\n  createdAt       DateTime @default(now())\n  userId          String\n  scanId          String?\n  analysisMode    String?\n  analysisHint    String?\n  scope           String\n  rating          Int\n  reasons         Json?\n  comment         String?\n  itemIndex       Int?\n  itemName        String?\n  itemServingSize String?\n  itemBrand       String?\n\n  user User @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  @@index([userId])\n  @@index([scanId])\n}\n\n// Fitbit Data Sync - stores synced data from Fitbit API\nmodel FitbitData {\n  id        String   @id @default(cuid())\n  userId    String\n  date      DateTime @db.Date // Date of the data (YYYY-MM-DD)\n  dataType  String // 'steps', 'heartrate', 'sleep', 'weight', 'activity'\n  value     Json // Flexible JSON storage for different data types\n  syncedAt  DateTime @default(now())\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  @@unique([userId, date, dataType])\n  @@index([userId, date])\n  @@index([userId, dataType])\n}\n\n// Garmin OAuth handshake request tokens (short-lived)\nmodel GarminRequestToken {\n  id               String   @id @default(cuid())\n  userId           String\n  oauthToken       String   @unique\n  oauthTokenSecret String\n  createdAt        DateTime @default(now())\n  expiresAt        DateTime?\n  user             User     @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  @@index([userId])\n}\n\n// Raw Garmin webhook payloads for auditing/debugging\nmodel GarminWebhookLog {\n  id         String   @id @default(cuid())\n  userId     String?\n  oauthToken String?\n  dataType   String?\n  payload    Json\n  receivedAt DateTime @default(now())\n  user       User?    @relation(fields: [userId], references: [id], onDelete: SetNull)\n\n  @@index([oauthToken])\n  @@index([userId])\n}\n\nmodel Subscription {\n  id                  String    @id @default(cuid())\n  userId              String    @unique\n  plan                Plan      @default(PREMIUM)\n  monthlyPriceCents   Int? // Track subscription tier: 2000 ($20), 3000 ($30), 5000 ($50)\n  stripeSubscriptionId String? // Stripe subscription ID for managing Stripe subscriptions\n  startDate           DateTime  @default(now())\n  endDate             DateTime?\n  user                User      @relation(fields: [userId], references: [id], onDelete: Cascade)\n}\n\n// Affiliate program\nmodel AffiliateApplication {\n  id              String                     @id @default(cuid())\n  userId          String?\n  email           String\n  name            String\n  website         String?\n  primaryChannel  String?\n  primaryChannelOther String?\n  audienceSize    String?\n  termsVersion    String?\n  termsAcceptedAt DateTime?\n  promotionMethod String\n  notes           String?\n\n  // Automated screening inputs\n  ip        String?\n  userAgent String?\n  country   String?\n  region    String?\n  city      String?\n\n  // AI screening outputs\n  riskLevel      AffiliateRiskLevel?\n  recommendation AffiliateRecommendation?\n  aiReasoning    String?\n  aiRawJson      Json?\n\n  status           AffiliateApplicationStatus @default(PENDING_REVIEW)\n  autoApproved     Boolean                   @default(false)\n  reviewedAt       DateTime?\n  reviewedByAdminId String?\n\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n\n  user       User?      @relation(\"AffiliateApplicationUser\", fields: [userId], references: [id], onDelete: SetNull)\n  reviewedBy AdminUser? @relation(\"AffiliateApplicationReviewedBy\", fields: [reviewedByAdminId], references: [id], onDelete: SetNull)\n  affiliate  Affiliate?\n\n  @@index([status, createdAt])\n  @@index([userId])\n}\n\nmodel Affiliate {\n  id            String          @id @default(cuid())\n  userId        String          @unique\n  applicationId String?         @unique\n  code          String          @unique\n  status        AffiliateStatus @default(ACTIVE)\n\n  stripeConnectAccountId        String?  @unique\n  stripeConnectDetailsSubmitted Boolean  @default(false)\n  stripeConnectChargesEnabled   Boolean  @default(false)\n  stripeConnectPayoutsEnabled   Boolean  @default(false)\n  stripeConnectOnboardedAt      DateTime?\n\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n\n  user        User                  @relation(\"AffiliateUser\", fields: [userId], references: [id], onDelete: Cascade)\n  application AffiliateApplication? @relation(fields: [applicationId], references: [id], onDelete: SetNull)\n  clicks      AffiliateClick[]\n  referrals   AffiliateReferral[]\n  conversions AffiliateConversion[]\n  commissions AffiliateCommission[]\n  payouts     AffiliatePayout[]\n\n  @@index([status])\n}\n\nmodel AffiliateClick {\n  id              String   @id @default(cuid())\n  affiliateId     String\n  visitorId       String\n  createdAt       DateTime @default(now())\n\n  ip              String?\n  userAgent       String?\n  referer         String?\n  landingPath     String?\n  destinationPath String?\n  country         String?\n  region          String?\n  city            String?\n\n  affiliate   Affiliate            @relation(fields: [affiliateId], references: [id], onDelete: Cascade)\n  referrals   AffiliateReferral[]\n  conversions AffiliateConversion[]\n\n  @@index([affiliateId, createdAt])\n  @@index([affiliateId, visitorId])\n  @@index([createdAt])\n}\n\nmodel AffiliateReferral {\n  id             String   @id @default(cuid())\n  affiliateId    String\n  clickId        String?\n  referredUserId String   @unique\n  createdAt      DateTime @default(now())\n\n  affiliate    Affiliate      @relation(fields: [affiliateId], references: [id], onDelete: Cascade)\n  click        AffiliateClick? @relation(fields: [clickId], references: [id], onDelete: SetNull)\n  referredUser User           @relation(\"AffiliateReferredUser\", fields: [referredUserId], references: [id], onDelete: Cascade)\n\n  @@index([affiliateId, createdAt])\n}\n\nmodel AffiliateConversion {\n  id                     String                  @id @default(cuid())\n  affiliateId             String\n  clickId                 String?\n  referredUserId          String?\n  type                   AffiliateConversionType\n\n  stripeEventId            String  @unique\n  stripeCheckoutSessionId  String? @unique\n  stripePaymentIntentId    String?\n  stripeChargeId           String? @unique\n  stripeInvoiceId          String?\n\n  currency          String\n  amountGrossCents  Int\n  stripeFeeCents    Int\n  amountNetCents    Int\n  occurredAt        DateTime\n  createdAt         DateTime @default(now())\n\n  affiliate   Affiliate      @relation(fields: [affiliateId], references: [id], onDelete: Cascade)\n  click       AffiliateClick? @relation(fields: [clickId], references: [id], onDelete: SetNull)\n  referredUser User?         @relation(\"AffiliateConvertedUser\", fields: [referredUserId], references: [id], onDelete: SetNull)\n  commission  AffiliateCommission?\n\n  @@index([affiliateId, occurredAt])\n  @@index([type, occurredAt])\n}\n\nmodel AffiliateCommission {\n  id             String                   @id @default(cuid())\n  affiliateId    String\n  conversionId   String                   @unique\n  status         AffiliateCommissionStatus @default(PENDING)\n\n  currency        String\n  netRevenueCents Int\n  commissionCents Int\n\n  payableAt DateTime\n  paidAt    DateTime?\n  payoutId  String?\n\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n\n  affiliate  Affiliate           @relation(fields: [affiliateId], references: [id], onDelete: Cascade)\n  conversion AffiliateConversion @relation(fields: [conversionId], references: [id], onDelete: Cascade)\n  payout     AffiliatePayout?    @relation(fields: [payoutId], references: [id], onDelete: SetNull)\n\n  @@index([affiliateId, status])\n  @@index([status, payableAt])\n}\n\nmodel AffiliatePayoutRun {\n  id               String                   @id @default(cuid())\n  createdByAdminId  String?\n  currency          String\n  periodStart       DateTime\n  periodEnd         DateTime\n  runAt             DateTime                 @default(now())\n  status            AffiliatePayoutRunStatus\n  totalCents        Int                      @default(0)\n  transferCount     Int                      @default(0)\n  note              String?\n  createdAt         DateTime                 @default(now())\n\n  createdBy AdminUser?       @relation(\"AffiliatePayoutRunCreatedBy\", fields: [createdByAdminId], references: [id], onDelete: SetNull)\n  payouts   AffiliatePayout[]\n\n  @@index([runAt])\n}\n\nmodel AffiliatePayout {\n  id              String   @id @default(cuid())\n  payoutRunId     String\n  affiliateId     String\n  currency        String\n  amountCents     Int\n  stripeTransferId String  @unique\n  createdAt       DateTime @default(now())\n\n  payoutRun   AffiliatePayoutRun   @relation(fields: [payoutRunId], references: [id], onDelete: Cascade)\n  affiliate   Affiliate           @relation(fields: [affiliateId], references: [id], onDelete: Cascade)\n  commissions AffiliateCommission[]\n\n  @@index([affiliateId, createdAt])\n  @@index([payoutRunId])\n}\n\n// Monetary credit top-ups valid for up to 12 months, consumed FIFO\nmodel CreditTopUp {\n  id          String   @id @default(cuid())\n  userId      String\n  amountCents Int\n  usedCents   Int      @default(0)\n  purchasedAt DateTime @default(now())\n  expiresAt   DateTime\n  source      String? // e.g., Stripe session id or admin note\n  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  @@index([userId, expiresAt])\n}\n\nenum Gender {\n  MALE\n  FEMALE\n}\n\nenum BodyType {\n  ECTOMORPH\n  MESOMORPH\n  ENDOMORPH\n}\n\nenum Plan {\n  PREMIUM\n}\n\nenum AffiliateStatus {\n  ACTIVE\n  SUSPENDED\n}\n\nenum AffiliateApplicationStatus {\n  PENDING_REVIEW\n  APPROVED\n  REJECTED\n}\n\nenum AffiliateRiskLevel {\n  LOW\n  MEDIUM\n  HIGH\n}\n\nenum AffiliateRecommendation {\n  AUTO_APPROVE\n  MANUAL_REVIEW\n}\n\nenum AffiliateConversionType {\n  SUBSCRIPTION_INITIAL\n  TOPUP\n}\n\nenum AffiliateCommissionStatus {\n  PENDING\n  VOIDED\n  PAID\n}\n\nenum AffiliatePayoutRunStatus {\n  SUCCEEDED\n  FAILED\n}\n\nmodel Waitlist {\n  id           String   @id @default(cuid())\n  email        String   @unique\n  name         String\n  unsubscribed Boolean  @default(false)\n  createdAt    DateTime @default(now())\n  updatedAt    DateTime @updatedAt\n}\n\nmodel PartnerOutreachContact {\n  id           String   @id @default(cuid())\n  name         String\n  email        String?  @unique\n  company      String\n  region       String?\n  notes        String?\n  sourceUrl    String?\n  unsubscribed Boolean  @default(false)\n  createdAt    DateTime @default(now())\n  updatedAt    DateTime @updatedAt\n}\n\nmodel AdminUser {\n  id        String    @id @default(cuid())\n  email     String    @unique\n  password  String // Hashed password\n  totpSecret String?\n  totpEnabled Boolean @default(false)\n  name      String\n  role      AdminRole @default(ADMIN)\n  isActive  Boolean   @default(true)\n  lastLogin DateTime?\n  createdAt DateTime  @default(now())\n  updatedAt DateTime  @updatedAt\n  createdBy String? // ID of admin who created this user\n\n  // Support ticket relations\n  assignedTickets SupportTicket[]  @relation(\"AssignedTickets\")\n  ticketResponses TicketResponse[] @relation(\"TicketResponses\")\n  reviewedAffiliateApplications AffiliateApplication[] @relation(\"AffiliateApplicationReviewedBy\")\n  affiliatePayoutRuns          AffiliatePayoutRun[]    @relation(\"AffiliatePayoutRunCreatedBy\")\n}\n\nenum AdminRole {\n  SUPER_ADMIN\n  ADMIN\n  MODERATOR\n}\n\nmodel AdminQrLogin {\n  token     String   @id\n  status    String\n  adminId   String?\n  email     String?\n  expiresAt DateTime\n  createdAt DateTime @default(now())\n  approvedAt DateTime?\n\n  @@index([status])\n  @@index([expiresAt])\n}\n\nmodel EmailTemplate {\n  id        String        @id @default(cuid())\n  name      String // Display name (e.g., \"Welcome New Users\")\n  category  EmailCategory @default(MARKETING)\n  subject   String // Email subject line\n  content   String // Email body content\n  isActive  Boolean       @default(true)\n  isBuiltIn Boolean       @default(false) // True for system templates, false for custom\n  createdBy String? // Admin user ID who created it\n  createdAt DateTime      @default(now())\n  updatedAt DateTime      @updatedAt\n}\n\nenum EmailCategory {\n  ONBOARDING\n  MARKETING\n  SUPPORT\n  ANNOUNCEMENTS\n  RETENTION\n  CUSTOM\n}\n\nmodel SupportTicket {\n  id                String         @id @default(cuid())\n  subject           String\n  message           String\n  userEmail         String\n  userName          String?\n  userId            String? // Optional link to registered user\n  status            TicketStatus   @default(OPEN)\n  priority          TicketPriority @default(MEDIUM)\n  category          TicketCategory @default(GENERAL)\n  externalMessageId String? // For email threading\n  assignedAdminId   String?\n  createdAt         DateTime       @default(now())\n  updatedAt         DateTime       @updatedAt\n\n  // Relations\n  user          User?            @relation(fields: [userId], references: [id], onDelete: SetNull)\n  assignedAdmin AdminUser?       @relation(\"AssignedTickets\", fields: [assignedAdminId], references: [id], onDelete: SetNull)\n  responses     TicketResponse[]\n}\n\nmodel TicketResponse {\n  id              String   @id @default(cuid())\n  ticketId        String\n  message         String\n  isAdminResponse Boolean  @default(false)\n  adminId         String? // If admin response\n  userEmail       String? // If user response (for non-registered users)\n  createdAt       DateTime @default(now())\n\n  // Relations\n  ticket SupportTicket @relation(fields: [ticketId], references: [id], onDelete: Cascade)\n  admin  AdminUser?    @relation(\"TicketResponses\", fields: [adminId], references: [id], onDelete: SetNull)\n}\n\nenum TicketStatus {\n  OPEN\n  IN_PROGRESS\n  AWAITING_RESPONSE\n  RESPONDED\n  RESOLVED\n  CLOSED\n}\n\nenum TicketPriority {\n  LOW\n  MEDIUM\n  HIGH\n  URGENT\n}\n\nenum TicketCategory {\n  GENERAL\n  TECHNICAL\n  BILLING\n  ACCOUNT\n  FEATURE_REQUEST\n  BUG_REPORT\n  EMAIL\n}\n\n// File Management System - PHASE 2 ADDITION\nmodel File {\n  id            String    @id @default(cuid())\n  originalName  String // Original filename from user\n  fileName      String // Processed filename\n  fileSize      Int // File size in bytes\n  mimeType      String // File MIME type (image/jpeg, etc.)\n  cloudinaryId  String // Cloudinary public_id\n  cloudinaryUrl String // Full Cloudinary URL\n  secureUrl     String // Secure HTTPS Cloudinary URL\n  uploadedById  String // User who uploaded it\n  fileType      FileType  @default(IMAGE)\n  usage         FileUsage @default(OTHER)\n  metadata      Json? // Additional file metadata\n  isPublic      Boolean   @default(false)\n  createdAt     DateTime  @default(now())\n  updatedAt     DateTime  @updatedAt\n\n  // Relations\n  uploadedBy User @relation(\"UploadedFiles\", fields: [uploadedById], references: [id], onDelete: Cascade)\n\n  // Optional relationships to existing models (for future use)\n  profileUsers    User[]       @relation(\"ProfileImages\")\n  supplementFiles Supplement[] @relation(\"SupplementImages\")\n  medicationFiles Medication[] @relation(\"MedicationImages\")\n  foodLogFiles    FoodLog[]    @relation(\"FoodLogImages\")\n  medicalImageAnalyses MedicalImageAnalysis[]\n}\n\nenum FileType {\n  IMAGE\n  DOCUMENT\n  VIDEO\n  AUDIO\n  OTHER\n}\n\nenum FileUsage {\n  PROFILE_IMAGE\n  FOOD_PHOTO\n  SUPPLEMENT_IMAGE\n  MEDICATION_IMAGE\n  MEDICAL_IMAGE\n  DOCUMENT\n  OTHER\n}\n\nmodel MedicalImageAnalysis {\n  id           String   @id @default(cuid())\n  userId       String\n  imageFileId  String?\n  summary      String?\n  analysisText String?\n  analysisData Json?\n  createdAt    DateTime @default(now())\n  updatedAt    DateTime @updatedAt\n\n  user      User  @relation(fields: [userId], references: [id], onDelete: Cascade)\n  imageFile File? @relation(fields: [imageFileId], references: [id], onDelete: SetNull)\n\n  @@index([userId, createdAt])\n}\n\nmodel InteractionAnalysis {\n  id                  String   @id @default(cuid())\n  userId              String\n  analysisName        String // User-friendly name for the analysis\n  overallRisk         String // low, medium, high\n  supplementCount     Int      @default(0)\n  medicationCount     Int      @default(0)\n  analysisData        Json // Full analysis results (interactions, recommendations, etc.)\n  supplementsAnalyzed Json // Array of supplements that were analyzed\n  medicationsAnalyzed Json // Array of medications that were analyzed\n  createdAt           DateTime @default(now())\n  updatedAt           DateTime @updatedAt\n\n  // Relations\n  user User @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  @@index([userId, createdAt])\n}\n\nmodel SymptomAnalysis {\n  id           String   @id @default(cuid())\n  userId       String\n  symptoms     Json\n  duration     String?\n  notes        String?\n  summary      String?\n  analysisText String?\n  analysisData Json?\n  createdAt    DateTime @default(now())\n  updatedAt    DateTime @updatedAt\n\n  user User @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  @@index([userId, createdAt])\n}\n\n// PDF Lab Report Intake & Encryption System\nmodel Report {\n  id                    String       @id @default(cuid())\n  userId                String\n  originalFileName      String // Original filename from user\n  s3Key                 String // Blob pathname (stored in s3Key field for compatibility)\n  fileSize              Int // File size in bytes\n  mimeType              String       @default(\"application/pdf\")\n  status                ReportStatus @default(PENDING)\n  isPasswordProtected   Boolean      @default(false)\n  passwordHash          String? // Ephemeral hash (not the actual password) - only for verification attempts\n  retainOriginal        Boolean      @default(false) // User consent to retain original PDF\n  originalDeletedAt     DateTime? // When original was deleted\n  processingStartedAt   DateTime?\n  processingCompletedAt DateTime?\n  processingError       String? // Error message if processing failed\n  consentRecordId       String // Link to consent record\n  metadata              Json? // Store blob URL and other metadata\n  createdAt             DateTime     @default(now())\n  updatedAt             DateTime     @updatedAt\n\n  // Relations\n  user          User          @relation(fields: [userId], references: [id], onDelete: Cascade)\n  consentRecord ConsentRecord @relation(fields: [consentRecordId], references: [id], onDelete: Cascade)\n  labResults    LabResult[]\n  auditEvents   AuditEvent[]\n\n  @@index([userId, createdAt])\n  @@index([status])\n  @@index([consentRecordId])\n}\n\nmodel LabResult {\n  id                       String   @id @default(cuid())\n  reportId                 String\n  // All sensitive fields are encrypted with AES-256-GCM\n  analyteNameEncrypted     String // AES-256-GCM encrypted analyte name (e.g., \"Glucose\", \"Cholesterol\")\n  valueEncrypted           String // AES-256-GCM encrypted test value\n  unitEncrypted            String? // AES-256-GCM encrypted unit of measurement\n  referenceRangeEncrypted  String? // AES-256-GCM encrypted normal range\n  collectionDateEncrypted  String? // AES-256-GCM encrypted date (ISO string)\n  accessionNumberEncrypted String? // AES-256-GCM encrypted lab accession number\n  laboratoryNameEncrypted  String? // AES-256-GCM encrypted lab name\n  dataKeyEncrypted         String // KMS-wrapped data encryption key (envelope encryption)\n  createdAt                DateTime @default(now())\n  updatedAt                DateTime @updatedAt\n\n  // Relations\n  report Report @relation(fields: [reportId], references: [id], onDelete: Cascade)\n\n  @@index([reportId])\n}\n\nmodel ConsentRecord {\n  id                String      @id @default(cuid())\n  userId            String\n  consentType       ConsentType @default(PDF_DECRYPTION)\n  consentText       String // Full text of consent shown to user\n  decryptionConsent Boolean // Required: User authorized PDF decryption\n  passwordConsent   Boolean // Required: User authorized password use (ephemeral)\n  retentionConsent  Boolean     @default(false) // Optional: User chose to retain original PDF\n  ipAddress         String? // User's IP at time of consent\n  userAgent         String? // User's browser/device info\n  consentedAt       DateTime    @default(now())\n\n  // Relations\n  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)\n  reports Report[]\n\n  @@index([userId, consentedAt])\n}\n\nenum ConsentType {\n  PDF_DECRYPTION\n  DATA_PROCESSING\n  DATA_RETENTION\n}\n\nmodel AuditEvent {\n  id               String         @id @default(cuid())\n  reportId         String?\n  userId           String\n  eventType        AuditEventType\n  eventDescription String // Human-readable description\n  metadata         Json? // Additional event data (redacted of sensitive info)\n  ipAddress        String?\n  userAgent        String?\n  createdAt        DateTime       @default(now())\n\n  // Relations\n  report Report? @relation(fields: [reportId], references: [id], onDelete: SetNull)\n\n  @@index([userId, createdAt])\n  @@index([reportId])\n  @@index([eventType, createdAt])\n}\n\nenum AuditEventType {\n  CONSENT_GRANTED\n  CONSENT_WITHDRAWN\n  PDF_UPLOADED\n  PDF_PROCESSING_STARTED\n  PDF_PROCESSING_COMPLETED\n  PDF_PROCESSING_FAILED\n  PDF_DECRYPTED\n  LAB_DATA_EXTRACTED\n  LAB_DATA_ENCRYPTED\n  ORIGINAL_DELETED\n  DATA_ACCESSED\n  DATA_DELETED\n}\n\nenum ReportStatus {\n  PENDING // Uploaded, awaiting processing\n  PROCESSING // Currently being processed\n  COMPLETED // Successfully processed\n  FAILED // Processing failed\n  DECRYPTION_FAILED // Password incorrect or PDF corrupted\n}\n","truncated":false,"size":32743}]}