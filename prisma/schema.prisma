generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                     String    @id @default(cuid())
  email                  String    @unique
  passwordHash           String?
  emailVerified          DateTime?
  name                   String?
  image                  String?
  gender                 Gender?
  weight                 Float?
  height                 Float?
  bodyType               BodyType?
  exerciseFrequency      String?
  exerciseTypes          String[]
  termsAccepted          Boolean   @default(false)
  // Credit system fields
  dailyAnalysisCredits   Int       @default(3) // Free: 3, Premium: 30
  additionalCredits      Int       @default(0) // Purchased credits that don't expire
  lastAnalysisResetDate  DateTime? // Track daily reset
  lastMonthlyResetDate   DateTime? // Track monthly reset for monthly quotas
  totalAnalysisCount     Int       @default(0) // Lifetime usage counter
  dailyAnalysisUsed      Int       @default(0) // Used today
  // Wallet-based metering (Cursor-style)
  walletMonthlyUsedCents Int       @default(0) // Amount used this month in cents
  walletMonthlyResetAt   DateTime? // Last time monthly wallet was reset

  // Feature-specific credit tracking
  dailyFoodAnalysisUsed          Int @default(0) // Food analysis credits used today
  dailyFoodReanalysisUsed        Int @default(0) // Food re-analysis used today
  dailyMedicalAnalysisUsed       Int @default(0) // Medical image analyses used today
  dailyInteractionAnalysisUsed   Int @default(0) // Interaction analysis credits used today
  totalFoodAnalysisCount         Int @default(0) // Lifetime food analysis count
  totalInteractionAnalysisCount  Int @default(0) // Lifetime interaction analysis count
  monthlyInteractionAnalysisUsed Int @default(0) // Monthly interactions used (premium)

  // Monthly per-feature usage tracking (resets monthly)
  monthlySymptomAnalysisUsed      Int @default(0) // Symptom analyses used this month
  monthlyFoodAnalysisUsed         Int @default(0) // Food analyses used this month
  monthlyMedicalImageAnalysisUsed Int @default(0) // Medical image analyses used this month
  monthlyInsightsGenerationUsed   Int @default(0) // Insights generations used this month

  // Free credits tracking (granted once on signup)
  freeFoodAnalysisRemaining       Int @default(5) // 5 free food image analyses
  freeSymptomAnalysisRemaining    Int @default(2) // 2 free symptom analyses
  freeMedicalAnalysisRemaining    Int @default(2) // 2 free medical image analyses
  freeInteractionAnalysisRemaining Int @default(2) // 2 free supplement/medication interaction analyses
  freeHealthIntakeRemaining       Int @default(1) // 1 free full health intake analysis (on page 11 complete)
  freeInsightsUpdateRemaining     Int @default(3) // 3 free insights updates (when changing health setup)
  freeSymptomChatRemaining        Int @default(0) // Free symptom follow-up chats (granted on signup)
  freeMedicalChatRemaining        Int @default(0) // Free medical image follow-up chats (granted on signup)
  freeInsightsChatRemaining       Int @default(0) // Free insights chats (granted on signup)
  freeVoiceChatRemaining          Int @default(0) // Free voice chat uses (granted on signup)
  freeFoodReanalysisRemaining     Int @default(0) // Free food re-analyses (granted on signup)
  freeInteractionReanalysisRemaining Int @default(0) // Free interaction re-analyses (granted on signup)

  createdAt           DateTime              @default(now())
  updatedAt           DateTime              @updatedAt
  accounts            Account[]
  sessions            Session[]
  healthGoals         HealthGoal[]
  supplements         Supplement[]
  medications         Medication[]
  healthLogs          HealthLog[]
  foodLogs            FoodLog[]
  waterLogs           WaterLog[]
  exerciseLogs        ExerciseLog[]
  exerciseEntries     ExerciseEntry[]
  subscription        Subscription?
  affiliate           Affiliate?             @relation("AffiliateUser")
  affiliateApplications AffiliateApplication[] @relation("AffiliateApplicationUser")
  affiliateReferral   AffiliateReferral?     @relation("AffiliateReferredUser")
  affiliateConversions AffiliateConversion[] @relation("AffiliateConvertedUser")
  practitionerAccount PractitionerAccount?
  supportTickets      SupportTicket[]
  interactionAnalyses InteractionAnalysis[]
  symptomAnalyses     SymptomAnalysis[]
  creditTopUps        CreditTopUp[]
  fitbitData          FitbitData[]
  garminRequestTokens GarminRequestToken[]
  garminWebhookLogs   GarminWebhookLog[]
  foodAnalysisFeedback FoodAnalysisFeedback[]
  medicalImageAnalyses MedicalImageAnalysis[]

  // File relationships (PHASE 2 addition)
  uploadedFiles File[] @relation("UploadedFiles")
  profileImages File[] @relation("ProfileImages")

  // Lab report relationships
  reports        Report[]
  consentRecords ConsentRecord[]
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model PasswordResetToken {
  id        String   @id @default(cuid())
  email     String
  tokenHash String   @unique
  expires   DateTime
  createdAt DateTime @default(now())

  @@index([email])
}

model HealthGoal {
  id            String      @id @default(cuid())
  userId        String
  name          String
  category      String
  currentRating Int
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  user          User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  healthLogs    HealthLog[]
}

model Supplement {
  id        String   @id @default(cuid())
  userId    String
  name      String
  dosage    String
  timing    String[]
  imageUrl  String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // File relationships (PHASE 2 addition)
  images File[] @relation("SupplementImages")
}

model Medication {
  id        String   @id @default(cuid())
  userId    String
  name      String
  dosage    String
  timing    String[]
  imageUrl  String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // File relationships (PHASE 2 addition)
  images File[] @relation("MedicationImages")
}

model HealthLog {
  id        String     @id @default(cuid())
  userId    String
  goalId    String
  rating    Int
  notes     String?
  createdAt DateTime   @default(now())
  goal      HealthGoal @relation(fields: [goalId], references: [id], onDelete: Cascade)
  user      User       @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model FoodLog {
  id          String   @id @default(cuid())
  userId      String
  name        String
  imageUrl    String?
  description String?
  nutrients   Json?
  items       Json?      // Structured ingredient list for robust card editing
  localDate   String?    // Local calendar date (YYYY-MM-DD) to avoid timezone drift in history
  meal        String?    // Normalized meal category (breakfast, lunch, dinner, snacks, uncategorized)
  category    String?    // Optional original category label for compatibility
  createdAt   DateTime @default(now())
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // File relationships (PHASE 2 addition)
  images File[] @relation("FoodLogImages")
}

model WaterLog {
  id        String   @id @default(cuid())
  userId    String
  amount    Float
  unit      String
  amountMl  Float
  label     String?
  category  String?
  localDate String
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, localDate])
  @@index([userId, createdAt])
}

model BarcodeProduct {
  id               String   @id @default(cuid())
  barcode          String   @unique
  name             String
  brand            String?
  servingSize      String?
  calories         Float?
  proteinG         Float?
  carbsG           Float?
  fatG             Float?
  fiberG           Float?
  sugarG           Float?
  quantityG        Float?
  piecesPerServing Float?
  source           String?
  reportCount      Int      @default(0)
  lastReportedAt   DateTime?
  createdById      String?
  updatedById      String?
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  @@index([barcode])
}

model FoodLibraryItem {
  id          String   @id @default(cuid())
  source      String
  fdcId       Int?
  gtinUpc     String?
  name        String
  brand       String?
  servingSize String?
  calories    Float?
  proteinG    Float?
  carbsG      Float?
  fatG        Float?
  fiberG      Float?
  sugarG      Float?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([name])
  @@index([brand])
  @@index([gtinUpc])
  @@index([source])
  @@unique([source, fdcId])
}

model ExerciseLog {
  id        String   @id @default(cuid())
  userId    String
  type      String
  duration  Int
  intensity String?
  notes     String?
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// Food Diary Exercise - MET catalog
model ExerciseType {
  id        Int      @id @default(autoincrement())
  name      String
  category  String
  met       Float
  intensity String?
  isCustom  Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  entries ExerciseEntry[]

  @@unique([name, category])
  @@index([name])
}

// Food Diary Exercise - per-user daily entries (manual or synced)
model ExerciseEntry {
  id              String         @id @default(cuid())
  userId          String
  localDate       String         // Local calendar date (YYYY-MM-DD) to avoid timezone drift
  startTime       DateTime?
  durationMinutes Int
  distanceKm      Float?
  source          ExerciseSource
  deviceId        String?
  exerciseTypeId  Int?
  label           String
  met             Float
  calories        Float
  rawPayload      Json?
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt

  user         User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  exerciseType ExerciseType? @relation(fields: [exerciseTypeId], references: [id])

  @@index([userId, localDate])
  @@unique([userId, source, deviceId])
}

enum ExerciseSource {
  MANUAL
  FITBIT
  GARMIN
}

model AIUsageEvent {
  id                String    @id @default(cuid())
  createdAt         DateTime  @default(now())
  feature           String
  userId            String?
  userLabel         String?
  scanId            String?
  model             String
  promptTokens      Int       @default(0)
  completionTokens  Int       @default(0)
  totalTokens       Int       @default(0)
  costCents         Int       @default(0)
  imageWidth        Int?
  imageHeight       Int?
  imageBytes        Int?
  imageMime         String?
  endpoint          String?
  success           Boolean   @default(true)
  errorMessage      String?
  detail            String?
  runId             String?

  @@index([runId])
}

model FoodAnalysisFeedback {
  id              String   @id @default(cuid())
  createdAt       DateTime @default(now())
  userId          String
  scanId          String?
  analysisMode    String?
  analysisHint    String?
  scope           String
  rating          Int
  reasons         Json?
  comment         String?
  itemIndex       Int?
  itemName        String?
  itemServingSize String?
  itemBrand       String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([scanId])
}

// Fitbit Data Sync - stores synced data from Fitbit API
model FitbitData {
  id        String   @id @default(cuid())
  userId    String
  date      DateTime @db.Date // Date of the data (YYYY-MM-DD)
  dataType  String // 'steps', 'heartrate', 'sleep', 'weight', 'activity'
  value     Json // Flexible JSON storage for different data types
  syncedAt  DateTime @default(now())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, date, dataType])
  @@index([userId, date])
  @@index([userId, dataType])
}

// Garmin OAuth handshake request tokens (short-lived)
model GarminRequestToken {
  id               String   @id @default(cuid())
  userId           String
  oauthToken       String   @unique
  oauthTokenSecret String
  createdAt        DateTime @default(now())
  expiresAt        DateTime?
  user             User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

// Raw Garmin webhook payloads for auditing/debugging
model GarminWebhookLog {
  id         String   @id @default(cuid())
  userId     String?
  oauthToken String?
  dataType   String?
  payload    Json
  receivedAt DateTime @default(now())
  user       User?    @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([oauthToken])
  @@index([userId])
}

model Subscription {
  id                  String    @id @default(cuid())
  userId              String    @unique
  plan                Plan      @default(PREMIUM)
  monthlyPriceCents   Int? // Track subscription tier: 2000 ($20), 3000 ($30), 5000 ($50)
  stripeSubscriptionId String? // Stripe subscription ID for managing Stripe subscriptions
  startDate           DateTime  @default(now())
  endDate             DateTime?
  user                User      @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// Affiliate program
model AffiliateApplication {
  id              String                     @id @default(cuid())
  userId          String?
  email           String
  name            String
  website         String?
  primaryChannel  String?
  primaryChannelOther String?
  audienceSize    String?
  termsVersion    String?
  termsAcceptedAt DateTime?
  promotionMethod String
  notes           String?

  // Automated screening inputs
  ip        String?
  userAgent String?
  country   String?
  region    String?
  city      String?

  // AI screening outputs
  riskLevel      AffiliateRiskLevel?
  recommendation AffiliateRecommendation?
  aiReasoning    String?
  aiRawJson      Json?

  status           AffiliateApplicationStatus @default(PENDING_REVIEW)
  autoApproved     Boolean                   @default(false)
  reviewedAt       DateTime?
  reviewedByAdminId String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user       User?      @relation("AffiliateApplicationUser", fields: [userId], references: [id], onDelete: SetNull)
  reviewedBy AdminUser? @relation("AffiliateApplicationReviewedBy", fields: [reviewedByAdminId], references: [id], onDelete: SetNull)
  affiliate  Affiliate?

  @@index([status, createdAt])
  @@index([userId])
}

model Affiliate {
  id            String          @id @default(cuid())
  userId        String          @unique
  applicationId String?         @unique
  code          String          @unique
  status        AffiliateStatus @default(ACTIVE)

  stripeConnectAccountId        String?  @unique
  stripeConnectDetailsSubmitted Boolean  @default(false)
  stripeConnectChargesEnabled   Boolean  @default(false)
  stripeConnectPayoutsEnabled   Boolean  @default(false)
  stripeConnectOnboardedAt      DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user        User                  @relation("AffiliateUser", fields: [userId], references: [id], onDelete: Cascade)
  application AffiliateApplication? @relation(fields: [applicationId], references: [id], onDelete: SetNull)
  clicks      AffiliateClick[]
  referrals   AffiliateReferral[]
  conversions AffiliateConversion[]
  commissions AffiliateCommission[]
  payouts     AffiliatePayout[]

  @@index([status])
}

model AffiliateClick {
  id              String   @id @default(cuid())
  affiliateId     String
  visitorId       String
  createdAt       DateTime @default(now())

  ip              String?
  userAgent       String?
  referer         String?
  landingPath     String?
  destinationPath String?
  country         String?
  region          String?
  city            String?

  affiliate   Affiliate            @relation(fields: [affiliateId], references: [id], onDelete: Cascade)
  referrals   AffiliateReferral[]
  conversions AffiliateConversion[]

  @@index([affiliateId, createdAt])
  @@index([affiliateId, visitorId])
  @@index([createdAt])
}

model AffiliateReferral {
  id             String   @id @default(cuid())
  affiliateId    String
  clickId        String?
  referredUserId String   @unique
  createdAt      DateTime @default(now())

  affiliate    Affiliate      @relation(fields: [affiliateId], references: [id], onDelete: Cascade)
  click        AffiliateClick? @relation(fields: [clickId], references: [id], onDelete: SetNull)
  referredUser User           @relation("AffiliateReferredUser", fields: [referredUserId], references: [id], onDelete: Cascade)

  @@index([affiliateId, createdAt])
}

model AffiliateConversion {
  id                     String                  @id @default(cuid())
  affiliateId             String
  clickId                 String?
  referredUserId          String?
  type                   AffiliateConversionType

  stripeEventId            String  @unique
  stripeCheckoutSessionId  String? @unique
  stripePaymentIntentId    String?
  stripeChargeId           String? @unique
  stripeInvoiceId          String?

  currency          String
  amountGrossCents  Int
  stripeFeeCents    Int
  amountNetCents    Int
  occurredAt        DateTime
  createdAt         DateTime @default(now())

  affiliate   Affiliate      @relation(fields: [affiliateId], references: [id], onDelete: Cascade)
  click       AffiliateClick? @relation(fields: [clickId], references: [id], onDelete: SetNull)
  referredUser User?         @relation("AffiliateConvertedUser", fields: [referredUserId], references: [id], onDelete: SetNull)
  commission  AffiliateCommission?

  @@index([affiliateId, occurredAt])
  @@index([type, occurredAt])
}

model AffiliateCommission {
  id             String                   @id @default(cuid())
  affiliateId    String
  conversionId   String                   @unique
  status         AffiliateCommissionStatus @default(PENDING)

  currency        String
  netRevenueCents Int
  commissionCents Int

  payableAt DateTime
  paidAt    DateTime?
  payoutId  String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  affiliate  Affiliate           @relation(fields: [affiliateId], references: [id], onDelete: Cascade)
  conversion AffiliateConversion @relation(fields: [conversionId], references: [id], onDelete: Cascade)
  payout     AffiliatePayout?    @relation(fields: [payoutId], references: [id], onDelete: SetNull)

  @@index([affiliateId, status])
  @@index([status, payableAt])
}

model AffiliatePayoutRun {
  id               String                   @id @default(cuid())
  createdByAdminId  String?
  currency          String
  periodStart       DateTime
  periodEnd         DateTime
  runAt             DateTime                 @default(now())
  status            AffiliatePayoutRunStatus
  totalCents        Int                      @default(0)
  transferCount     Int                      @default(0)
  note              String?
  createdAt         DateTime                 @default(now())

  createdBy AdminUser?       @relation("AffiliatePayoutRunCreatedBy", fields: [createdByAdminId], references: [id], onDelete: SetNull)
  payouts   AffiliatePayout[]

  @@index([runAt])
}

model AffiliatePayout {
  id              String   @id @default(cuid())
  payoutRunId     String
  affiliateId     String
  currency        String
  amountCents     Int
  stripeTransferId String  @unique
  createdAt       DateTime @default(now())

  payoutRun   AffiliatePayoutRun   @relation(fields: [payoutRunId], references: [id], onDelete: Cascade)
  affiliate   Affiliate           @relation(fields: [affiliateId], references: [id], onDelete: Cascade)
  commissions AffiliateCommission[]

  @@index([affiliateId, createdAt])
  @@index([payoutRunId])
}

model PractitionerAccount {
  id           String   @id @default(cuid())
  userId       String   @unique
  contactEmail String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user     User                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  listings PractitionerListing[]
  emailLogs PractitionerEmailLog[]
}

model PractitionerCategory {
  id        String   @id @default(cuid())
  name      String
  slug      String   @unique
  parentId  String?
  synonyms  String[] @default([])
  sortOrder Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  parent      PractitionerCategory?  @relation("PractitionerCategoryHierarchy", fields: [parentId], references: [id], onDelete: SetNull)
  children    PractitionerCategory[] @relation("PractitionerCategoryHierarchy")
  listings    PractitionerListing[]  @relation("PractitionerListingCategory")
  subListings PractitionerListing[]  @relation("PractitionerListingSubcategory")
  boosts      PractitionerBoostPurchase[]

  @@index([parentId])
  @@index([sortOrder])
}

model PractitionerListing {
  id                    String                         @id @default(cuid())
  practitionerAccountId String
  displayName           String
  slug                  String                         @unique
  categoryId            String
  subcategoryId         String?
  tags                  String[]                       @default([])
  description           String?
  phone                 String?
  websiteUrl            String?
  emailPublic           String?
  businessRegistrationNumber String?
  addressLine1          String?
  addressLine2          String?
  suburbCity            String?
  stateRegion           String?
  postcode              String?
  country               String?
  lat                   Float?
  lng                   Float?
  serviceType           PractitionerServiceType        @default(IN_PERSON)
  languages             String[]                       @default([])
  hoursJson             Json?
  images                Json?
  status                PractitionerListingStatus      @default(DRAFT)
  visibilityReason      PractitionerVisibilityReason?
  reviewStatus          PractitionerReviewStatus       @default(PENDING)
  reviewNotes           String?
  reviewFlagReason      String?
  reviewDecisionAt      DateTime?
  reviewedByAdminId     String?
  aiRiskLevel           PractitionerAiRiskLevel?
  aiReasoning           String?
  aiRawJson             Json?
  createdAt             DateTime                       @default(now())
  updatedAt             DateTime                       @updatedAt

  practitionerAccount PractitionerAccount            @relation(fields: [practitionerAccountId], references: [id], onDelete: Cascade)
  category            PractitionerCategory           @relation("PractitionerListingCategory", fields: [categoryId], references: [id], onDelete: Restrict)
  subcategory         PractitionerCategory?          @relation("PractitionerListingSubcategory", fields: [subcategoryId], references: [id], onDelete: SetNull)
  reviewedBy          AdminUser?                     @relation("PractitionerListingReviewedBy", fields: [reviewedByAdminId], references: [id], onDelete: SetNull)
  subscription        PractitionerListingSubscription?
  boosts              PractitionerBoostPurchase[]
  emailLogs           PractitionerEmailLog[]
  moderationLogs      PractitionerModerationLog[]

  @@index([practitionerAccountId])
  @@index([categoryId])
  @@index([subcategoryId])
  @@index([status])
  @@index([reviewStatus])
  @@index([createdAt])
}

model PractitionerListingSubscription {
  id                     String                          @id @default(cuid())
  listingId              String                          @unique
  provider               PractitionerSubscriptionProvider @default(STRIPE)
  providerCustomerId     String?
  providerSubscriptionId String?
  plan                   PractitionerSubscriptionPlan     @default(LISTING_4_95)
  trialStartAt           DateTime?
  trialEndAt             DateTime?
  currentPeriodStart     DateTime?
  currentPeriodEnd       DateTime?
  status                 PractitionerSubscriptionStatus   @default(TRIALING)
  cancelAtPeriodEnd      Boolean                         @default(false)
  createdAt              DateTime                        @default(now())
  updatedAt              DateTime                        @updatedAt

  listing PractitionerListing @relation(fields: [listingId], references: [id], onDelete: Cascade)

  @@index([status])
  @@index([currentPeriodEnd])
}

model PractitionerBoostPurchase {
  id                        String                    @id @default(cuid())
  listingId                 String
  categoryId                String
  geoKey                    String
  radiusTier                PractitionerRadiusTier
  startsAt                  DateTime
  endsAt                    DateTime
  status                    PractitionerBoostStatus   @default(ACTIVE)
  priceCents                Int
  currency                  String
  pausedAt                  DateTime?
  remainingSeconds          Int?
  providerCheckoutSessionId String?
  providerPaymentIntentId   String?
  createdAt                 DateTime                  @default(now())

  listing  PractitionerListing  @relation(fields: [listingId], references: [id], onDelete: Cascade)
  category PractitionerCategory @relation(fields: [categoryId], references: [id], onDelete: Restrict)

  @@index([listingId])
  @@index([categoryId])
  @@index([status])
  @@index([geoKey])
  @@index([startsAt, endsAt])
}

model PractitionerBoostRotationState {
  id                   String   @id @default(cuid())
  bucketKey            String   @unique
  lastServedListingId  String?
  lastServedAt         DateTime?
  updatedAt            DateTime @updatedAt
}

model PractitionerEmailLog {
  id                    String                  @id @default(cuid())
  practitionerAccountId String?
  listingId             String?
  type                  PractitionerEmailType
  toEmail               String
  sentAt                DateTime
  metadata              Json?
  createdAt             DateTime                @default(now())

  practitionerAccount PractitionerAccount? @relation(fields: [practitionerAccountId], references: [id], onDelete: SetNull)
  listing              PractitionerListing? @relation(fields: [listingId], references: [id], onDelete: Cascade)

  @@index([listingId])
  @@index([type])
  @@index([sentAt])
}

model PractitionerModerationLog {
  id          String                      @id @default(cuid())
  adminUserId String?
  listingId   String
  action      PractitionerModerationAction
  reason      String?
  createdAt   DateTime                    @default(now())

  adminUser AdminUser?            @relation(fields: [adminUserId], references: [id], onDelete: SetNull)
  listing   PractitionerListing  @relation(fields: [listingId], references: [id], onDelete: Cascade)

  @@index([listingId])
  @@index([adminUserId])
  @@index([createdAt])
}

// Monetary credit top-ups valid for up to 12 months, consumed FIFO
model CreditTopUp {
  id          String   @id @default(cuid())
  userId      String
  amountCents Int
  usedCents   Int      @default(0)
  purchasedAt DateTime @default(now())
  expiresAt   DateTime
  source      String? // e.g., Stripe session id or admin note
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, expiresAt])
}

enum Gender {
  MALE
  FEMALE
}

enum BodyType {
  ECTOMORPH
  MESOMORPH
  ENDOMORPH
}

enum Plan {
  PREMIUM
}

enum AffiliateStatus {
  ACTIVE
  SUSPENDED
}

enum AffiliateApplicationStatus {
  PENDING_REVIEW
  APPROVED
  REJECTED
}

enum AffiliateRiskLevel {
  LOW
  MEDIUM
  HIGH
}

enum AffiliateRecommendation {
  AUTO_APPROVE
  MANUAL_REVIEW
}

enum AffiliateConversionType {
  SUBSCRIPTION_INITIAL
  TOPUP
}

enum AffiliateCommissionStatus {
  PENDING
  VOIDED
  PAID
}

enum AffiliatePayoutRunStatus {
  SUCCEEDED
  FAILED
}

enum PractitionerServiceType {
  IN_PERSON
  TELEHEALTH
  BOTH
}

enum PractitionerListingStatus {
  DRAFT
  PENDING_REVIEW
  ACTIVE
  HIDDEN
  SUSPENDED
  REJECTED
  DELETED
}

enum PractitionerVisibilityReason {
  TRIAL_ACTIVE
  SUB_ACTIVE
  SUB_LAPSED
  ADMIN_HIDDEN
  PAYMENT_FAILED
  POLICY
  AI_REVIEW_PENDING
  AI_FLAGGED
  REJECTED
}

enum PractitionerReviewStatus {
  PENDING
  APPROVED
  FLAGGED
  REJECTED
}

enum PractitionerAiRiskLevel {
  LOW
  MEDIUM
  HIGH
}

enum PractitionerSubscriptionProvider {
  STRIPE
}

enum PractitionerSubscriptionPlan {
  LISTING_4_95
}

enum PractitionerSubscriptionStatus {
  TRIALING
  ACTIVE
  PAST_DUE
  CANCELED
  INCOMPLETE
  EXPIRED
}

enum PractitionerBoostStatus {
  ACTIVE
  PAUSED
  EXPIRED
  CANCELED
}

enum PractitionerRadiusTier {
  R5
  R10
  R25
  R50
}

enum PractitionerEmailType {
  TRIAL_14D
  TRIAL_7D
  TRIAL_1D
  TRIAL_ENDED
  SUB_FAILED
  SUB_CANCELED
  BOOST_PURCHASED
  WEEKLY_REENGAGE
  LISTING_SUBMITTED
  LISTING_APPROVED
  LISTING_FLAGGED
  LISTING_REJECTED
  LISTING_ACTIVATED
}

enum PractitionerModerationAction {
  APPROVE
  HIDE
  SUSPEND
  UNSUSPEND
  EDIT
  DELETE
  REJECT
}

model Waitlist {
  id           String   @id @default(cuid())
  email        String   @unique
  name         String
  unsubscribed Boolean  @default(false)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
}

model PartnerOutreachContact {
  id           String   @id @default(cuid())
  name         String
  email        String?  @unique
  company      String
  region       String?
  notes        String?
  sourceUrl    String?
  unsubscribed Boolean  @default(false)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
}

model AdminUser {
  id        String    @id @default(cuid())
  email     String    @unique
  password  String // Hashed password
  totpSecret String?
  totpEnabled Boolean @default(false)
  name      String
  role      AdminRole @default(ADMIN)
  isActive  Boolean   @default(true)
  lastLogin DateTime?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  createdBy String? // ID of admin who created this user

  // Support ticket relations
  assignedTickets SupportTicket[]  @relation("AssignedTickets")
  ticketResponses TicketResponse[] @relation("TicketResponses")
  reviewedAffiliateApplications AffiliateApplication[] @relation("AffiliateApplicationReviewedBy")
  affiliatePayoutRuns          AffiliatePayoutRun[]    @relation("AffiliatePayoutRunCreatedBy")
  reviewedPractitionerListings PractitionerListing[] @relation("PractitionerListingReviewedBy")
  practitionerModerationLogs   PractitionerModerationLog[]
}

enum AdminRole {
  SUPER_ADMIN
  ADMIN
  MODERATOR
}

model AdminQrLogin {
  token     String   @id
  status    String
  adminId   String?
  email     String?
  expiresAt DateTime
  createdAt DateTime @default(now())
  approvedAt DateTime?

  @@index([status])
  @@index([expiresAt])
}

model EmailTemplate {
  id        String        @id @default(cuid())
  name      String // Display name (e.g., "Welcome New Users")
  category  EmailCategory @default(MARKETING)
  subject   String // Email subject line
  content   String // Email body content
  isActive  Boolean       @default(true)
  isBuiltIn Boolean       @default(false) // True for system templates, false for custom
  createdBy String? // Admin user ID who created it
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt
}

enum EmailCategory {
  ONBOARDING
  MARKETING
  SUPPORT
  ANNOUNCEMENTS
  RETENTION
  CUSTOM
}

model SupportTicket {
  id                String         @id @default(cuid())
  subject           String
  message           String
  userEmail         String
  userName          String?
  userId            String? // Optional link to registered user
  status            TicketStatus   @default(OPEN)
  priority          TicketPriority @default(MEDIUM)
  category          TicketCategory @default(GENERAL)
  externalMessageId String? // For email threading
  assignedAdminId   String?
  createdAt         DateTime       @default(now())
  updatedAt         DateTime       @updatedAt

  // Relations
  user          User?            @relation(fields: [userId], references: [id], onDelete: SetNull)
  assignedAdmin AdminUser?       @relation("AssignedTickets", fields: [assignedAdminId], references: [id], onDelete: SetNull)
  responses     TicketResponse[]
}

model TicketResponse {
  id              String   @id @default(cuid())
  ticketId        String
  message         String
  isAdminResponse Boolean  @default(false)
  adminId         String? // If admin response
  userEmail       String? // If user response (for non-registered users)
  createdAt       DateTime @default(now())

  // Relations
  ticket SupportTicket @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  admin  AdminUser?    @relation("TicketResponses", fields: [adminId], references: [id], onDelete: SetNull)
}

enum TicketStatus {
  OPEN
  IN_PROGRESS
  AWAITING_RESPONSE
  RESPONDED
  RESOLVED
  CLOSED
}

enum TicketPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum TicketCategory {
  GENERAL
  TECHNICAL
  BILLING
  ACCOUNT
  FEATURE_REQUEST
  BUG_REPORT
  EMAIL
}

// File Management System - PHASE 2 ADDITION
model File {
  id            String    @id @default(cuid())
  originalName  String // Original filename from user
  fileName      String // Processed filename
  fileSize      Int // File size in bytes
  mimeType      String // File MIME type (image/jpeg, etc.)
  cloudinaryId  String // Cloudinary public_id
  cloudinaryUrl String // Full Cloudinary URL
  secureUrl     String // Secure HTTPS Cloudinary URL
  uploadedById  String // User who uploaded it
  fileType      FileType  @default(IMAGE)
  usage         FileUsage @default(OTHER)
  metadata      Json? // Additional file metadata
  isPublic      Boolean   @default(false)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations
  uploadedBy User @relation("UploadedFiles", fields: [uploadedById], references: [id], onDelete: Cascade)

  // Optional relationships to existing models (for future use)
  profileUsers    User[]       @relation("ProfileImages")
  supplementFiles Supplement[] @relation("SupplementImages")
  medicationFiles Medication[] @relation("MedicationImages")
  foodLogFiles    FoodLog[]    @relation("FoodLogImages")
  medicalImageAnalyses MedicalImageAnalysis[]
}

enum FileType {
  IMAGE
  DOCUMENT
  VIDEO
  AUDIO
  OTHER
}

enum FileUsage {
  PROFILE_IMAGE
  FOOD_PHOTO
  SUPPLEMENT_IMAGE
  MEDICATION_IMAGE
  MEDICAL_IMAGE
  DOCUMENT
  OTHER
}

model MedicalImageAnalysis {
  id           String   @id @default(cuid())
  userId       String
  imageFileId  String?
  summary      String?
  analysisText String?
  analysisData Json?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user      User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  imageFile File? @relation(fields: [imageFileId], references: [id], onDelete: SetNull)

  @@index([userId, createdAt])
}

model InteractionAnalysis {
  id                  String   @id @default(cuid())
  userId              String
  analysisName        String // User-friendly name for the analysis
  overallRisk         String // low, medium, high
  supplementCount     Int      @default(0)
  medicationCount     Int      @default(0)
  analysisData        Json // Full analysis results (interactions, recommendations, etc.)
  supplementsAnalyzed Json // Array of supplements that were analyzed
  medicationsAnalyzed Json // Array of medications that were analyzed
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
}

model SymptomAnalysis {
  id           String   @id @default(cuid())
  userId       String
  symptoms     Json
  duration     String?
  notes        String?
  summary      String?
  analysisText String?
  analysisData Json?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
}

// PDF Lab Report Intake & Encryption System
model Report {
  id                    String       @id @default(cuid())
  userId                String
  originalFileName      String // Original filename from user
  s3Key                 String // Blob pathname (stored in s3Key field for compatibility)
  fileSize              Int // File size in bytes
  mimeType              String       @default("application/pdf")
  status                ReportStatus @default(PENDING)
  isPasswordProtected   Boolean      @default(false)
  passwordHash          String? // Ephemeral hash (not the actual password) - only for verification attempts
  retainOriginal        Boolean      @default(false) // User consent to retain original PDF
  originalDeletedAt     DateTime? // When original was deleted
  processingStartedAt   DateTime?
  processingCompletedAt DateTime?
  processingError       String? // Error message if processing failed
  consentRecordId       String // Link to consent record
  metadata              Json? // Store blob URL and other metadata
  createdAt             DateTime     @default(now())
  updatedAt             DateTime     @updatedAt

  // Relations
  user          User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  consentRecord ConsentRecord @relation(fields: [consentRecordId], references: [id], onDelete: Cascade)
  labResults    LabResult[]
  auditEvents   AuditEvent[]

  @@index([userId, createdAt])
  @@index([status])
  @@index([consentRecordId])
}

model LabResult {
  id                       String   @id @default(cuid())
  reportId                 String
  // All sensitive fields are encrypted with AES-256-GCM
  analyteNameEncrypted     String // AES-256-GCM encrypted analyte name (e.g., "Glucose", "Cholesterol")
  valueEncrypted           String // AES-256-GCM encrypted test value
  unitEncrypted            String? // AES-256-GCM encrypted unit of measurement
  referenceRangeEncrypted  String? // AES-256-GCM encrypted normal range
  collectionDateEncrypted  String? // AES-256-GCM encrypted date (ISO string)
  accessionNumberEncrypted String? // AES-256-GCM encrypted lab accession number
  laboratoryNameEncrypted  String? // AES-256-GCM encrypted lab name
  dataKeyEncrypted         String // KMS-wrapped data encryption key (envelope encryption)
  createdAt                DateTime @default(now())
  updatedAt                DateTime @updatedAt

  // Relations
  report Report @relation(fields: [reportId], references: [id], onDelete: Cascade)

  @@index([reportId])
}

model ConsentRecord {
  id                String      @id @default(cuid())
  userId            String
  consentType       ConsentType @default(PDF_DECRYPTION)
  consentText       String // Full text of consent shown to user
  decryptionConsent Boolean // Required: User authorized PDF decryption
  passwordConsent   Boolean // Required: User authorized password use (ephemeral)
  retentionConsent  Boolean     @default(false) // Optional: User chose to retain original PDF
  ipAddress         String? // User's IP at time of consent
  userAgent         String? // User's browser/device info
  consentedAt       DateTime    @default(now())

  // Relations
  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  reports Report[]

  @@index([userId, consentedAt])
}

enum ConsentType {
  PDF_DECRYPTION
  DATA_PROCESSING
  DATA_RETENTION
}

model AuditEvent {
  id               String         @id @default(cuid())
  reportId         String?
  userId           String
  eventType        AuditEventType
  eventDescription String // Human-readable description
  metadata         Json? // Additional event data (redacted of sensitive info)
  ipAddress        String?
  userAgent        String?
  createdAt        DateTime       @default(now())

  // Relations
  report Report? @relation(fields: [reportId], references: [id], onDelete: SetNull)

  @@index([userId, createdAt])
  @@index([reportId])
  @@index([eventType, createdAt])
}

enum AuditEventType {
  CONSENT_GRANTED
  CONSENT_WITHDRAWN
  PDF_UPLOADED
  PDF_PROCESSING_STARTED
  PDF_PROCESSING_COMPLETED
  PDF_PROCESSING_FAILED
  PDF_DECRYPTED
  LAB_DATA_EXTRACTED
  LAB_DATA_ENCRYPTED
  ORIGINAL_DELETED
  DATA_ACCESSED
  DATA_DELETED
}

enum ReportStatus {
  PENDING // Uploaded, awaiting processing
  PROCESSING // Currently being processed
  COMPLETED // Successfully processed
  FAILED // Processing failed
  DECRYPTION_FAILED // Password incorrect or PDF corrupted
}
